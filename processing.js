(() => {
  var __defProp = Object.defineProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

  // src/Helpers/virtEquals.js
  function virtEquals(obj, other) {
    if (obj === null || other === null) {
      return obj === null && other === null;
    }
    if (typeof obj === "string") {
      return obj === other;
    }
    if (typeof obj !== "object") {
      return obj === other;
    }
    if (obj.equals instanceof Function) {
      return obj.equals(other);
    }
    return obj === other;
  }

  // src/Helpers/virtHashCode.js
  function virtHashCode(obj, undef) {
    if (typeof obj === "string") {
      var hash = 0;
      for (var i = 0; i < obj.length; ++i) {
        hash = hash * 31 + obj.charCodeAt(i) & 4294967295;
      }
      return hash;
    }
    if (typeof obj !== "object") {
      return obj & 4294967295;
    }
    if (obj.hashCode instanceof Function) {
      return obj.hashCode();
    }
    if (obj.$id === undef) {
      obj.$id = Math.floor(Math.random() * 65536) - 32768 << 16 | Math.floor(Math.random() * 65536);
    }
    return obj.$id;
  }

  // src/Helpers/ObjectIterator.js
  function ObjectIterator(obj) {
    if (obj instanceof Array) {
      var index = -1;
      this.hasNext = function() {
        return ++index < obj.length;
      };
      this.next = function() {
        return obj[index];
      };
    } else if (obj.iterator instanceof Function) {
      return obj.iterator();
    } else {
      throw "Unable to iterate: " + obj;
    }
  }

  // src/Helpers/PConstants.js
  var PConstants2 = {
    X: 0,
    Y: 1,
    Z: 2,
    R: 3,
    G: 4,
    B: 5,
    A: 6,
    U: 7,
    V: 8,
    NX: 9,
    NY: 10,
    NZ: 11,
    EDGE: 12,
    // Stroke
    SR: 13,
    SG: 14,
    SB: 15,
    SA: 16,
    SW: 17,
    // Transformations (2D and 3D)
    TX: 18,
    TY: 19,
    TZ: 20,
    VX: 21,
    VY: 22,
    VZ: 23,
    VW: 24,
    // Material properties
    AR: 25,
    AG: 26,
    AB: 27,
    DR: 3,
    DG: 4,
    DB: 5,
    DA: 6,
    SPR: 28,
    SPG: 29,
    SPB: 30,
    SHINE: 31,
    ER: 32,
    EG: 33,
    EB: 34,
    BEEN_LIT: 35,
    VERTEX_FIELD_COUNT: 36,
    // Renderers
    P2D: 1,
    JAVA2D: 1,
    WEBGL: 2,
    P3D: 2,
    OPENGL: 2,
    PDF: 0,
    DXF: 0,
    // Platform IDs
    OTHER: 0,
    WINDOWS: 1,
    MAXOSX: 2,
    LINUX: 3,
    EPSILON: 1e-4,
    MAX_FLOAT: 34028235e31,
    MIN_FLOAT: -34028235e31,
    MAX_INT: 2147483647,
    MIN_INT: -2147483648,
    PI: Math.PI,
    TWO_PI: 2 * Math.PI,
    TAU: 2 * Math.PI,
    HALF_PI: Math.PI / 2,
    THIRD_PI: Math.PI / 3,
    QUARTER_PI: Math.PI / 4,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    WHITESPACE: " 	\n\r\f\xA0",
    // Color modes
    RGB: 1,
    ARGB: 2,
    HSB: 3,
    ALPHA: 4,
    CMYK: 5,
    // Image file types
    TIFF: 0,
    TARGA: 1,
    JPEG: 2,
    GIF: 3,
    // Filter/convert types
    BLUR: 11,
    GRAY: 12,
    INVERT: 13,
    OPAQUE: 14,
    POSTERIZE: 15,
    THRESHOLD: 16,
    ERODE: 17,
    DILATE: 18,
    // Blend modes
    REPLACE: 0,
    BLEND: 1 << 0,
    ADD: 1 << 1,
    SUBTRACT: 1 << 2,
    LIGHTEST: 1 << 3,
    DARKEST: 1 << 4,
    DIFFERENCE: 1 << 5,
    EXCLUSION: 1 << 6,
    MULTIPLY: 1 << 7,
    SCREEN: 1 << 8,
    OVERLAY: 1 << 9,
    HARD_LIGHT: 1 << 10,
    SOFT_LIGHT: 1 << 11,
    DODGE: 1 << 12,
    BURN: 1 << 13,
    // Color component bit masks
    ALPHA_MASK: 4278190080,
    RED_MASK: 16711680,
    GREEN_MASK: 65280,
    BLUE_MASK: 255,
    // Projection matrices
    CUSTOM: 0,
    ORTHOGRAPHIC: 2,
    PERSPECTIVE: 3,
    // Shapes
    POINT: 2,
    POINTS: 2,
    LINE: 4,
    LINES: 4,
    TRIANGLE: 8,
    TRIANGLES: 9,
    TRIANGLE_STRIP: 10,
    TRIANGLE_FAN: 11,
    QUAD: 16,
    QUADS: 16,
    QUAD_STRIP: 17,
    POLYGON: 20,
    PATH: 21,
    RECT: 30,
    ELLIPSE: 31,
    ARC: 32,
    SPHERE: 40,
    BOX: 41,
    // Arc drawing modes
    //OPEN:          1, // shared with Shape closing modes   
    CHORD: 2,
    PIE: 3,
    GROUP: 0,
    PRIMITIVE: 1,
    //PATH:         21, // shared with Shape PATH
    GEOMETRY: 3,
    // Shape Vertex
    VERTEX: 0,
    BEZIER_VERTEX: 1,
    CURVE_VERTEX: 2,
    BREAK: 3,
    CLOSESHAPE: 4,
    // Shape closing modes
    OPEN: 1,
    CLOSE: 2,
    // Shape drawing modes
    CORNER: 0,
    // Draw mode convention to use (x, y) to (width, height)
    CORNERS: 1,
    // Draw mode convention to use (x1, y1) to (x2, y2) coordinates
    RADIUS: 2,
    // Draw mode from the center, and using the radius
    CENTER_RADIUS: 2,
    // Deprecated! Use RADIUS instead
    CENTER: 3,
    // Draw from the center, using second pair of values as the diameter
    DIAMETER: 3,
    // Synonym for the CENTER constant. Draw from the center
    CENTER_DIAMETER: 3,
    // Deprecated! Use DIAMETER instead
    // Text vertical alignment modes
    BASELINE: 0,
    // Default vertical alignment for text placement
    TOP: 101,
    // Align text to the top
    BOTTOM: 102,
    // Align text from the bottom, using the baseline
    // UV Texture coordinate modes
    NORMAL: 1,
    NORMALIZED: 1,
    IMAGE: 2,
    // Text placement modes
    MODEL: 4,
    SHAPE: 5,
    // Stroke modes
    SQUARE: "butt",
    ROUND: "round",
    PROJECT: "square",
    MITER: "miter",
    BEVEL: "bevel",
    // Lighting modes
    AMBIENT: 0,
    DIRECTIONAL: 1,
    //POINT:     2, Shared with Shape constant
    SPOT: 3,
    // Key constants
    // Both key and keyCode will be equal to these values
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 10,
    RETURN: 13,
    ESC: 27,
    DELETE: 127,
    CODED: 65535,
    // p.key will be CODED and p.keyCode will be this value
    SHIFT: 16,
    CONTROL: 17,
    ALT: 18,
    CAPSLK: 20,
    PGUP: 33,
    PGDN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUMLK: 144,
    META: 157,
    INSERT: 155,
    // Cursor types
    ARROW: "default",
    CROSS: "crosshair",
    HAND: "pointer",
    MOVE: "move",
    TEXT: "text",
    WAIT: "wait",
    NOCURSOR: "url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto",
    // Hints
    DISABLE_OPENGL_2X_SMOOTH: 1,
    ENABLE_OPENGL_2X_SMOOTH: -1,
    ENABLE_OPENGL_4X_SMOOTH: 2,
    ENABLE_NATIVE_FONTS: 3,
    DISABLE_DEPTH_TEST: 4,
    ENABLE_DEPTH_TEST: -4,
    ENABLE_DEPTH_SORT: 5,
    DISABLE_DEPTH_SORT: -5,
    DISABLE_OPENGL_ERROR_REPORT: 6,
    ENABLE_OPENGL_ERROR_REPORT: -6,
    ENABLE_ACCURATE_TEXTURES: 7,
    DISABLE_ACCURATE_TEXTURES: -7,
    HINT_COUNT: 10,
    // PJS defined constants
    SINCOS_LENGTH: 720,
    // every half degree
    PRECISIONB: 15,
    // fixed point precision is limited to 15 bits!!
    PRECISIONF: 1 << 15,
    PREC_MAXVAL: (1 << 15) - 1,
    PREC_ALPHA_SHIFT: 24 - 15,
    PREC_RED_SHIFT: 16 - 15,
    NORMAL_MODE_AUTO: 0,
    NORMAL_MODE_SHAPE: 1,
    NORMAL_MODE_VERTEX: 2,
    MAX_LIGHTS: 8
  };
  var PConstants_default = PConstants2;

  // src/Objects/ArrayList.js
  function HashMap(options) {
    var virtHashCode2 = options.virtHashCode, virtEquals2 = options.virtEquals;
    function Iterator(array) {
      var index = -1;
      this.hasNext = function() {
        return index + 1 < array.length;
      };
      this.next = function() {
        return array[++index];
      };
      this.remove = function() {
        array.splice(index--, 1);
      };
    }
    function ArrayList(a) {
      var array = [];
      if (a && a.toArray) {
        array = a.toArray();
      }
      this.get = function(i) {
        return array[i];
      };
      this.contains = function(item) {
        return this.indexOf(item) > -1;
      };
      this.indexOf = function(item) {
        for (var i = 0, len = array.length; i < len; ++i) {
          if (virtEquals2(item, array[i])) {
            return i;
          }
        }
        return -1;
      };
      this.lastIndexOf = function(item) {
        for (var i = array.length - 1; i >= 0; --i) {
          if (virtEquals2(item, array[i])) {
            return i;
          }
        }
        return -1;
      };
      this.add = function() {
        if (arguments.length === 1) {
          array.push(arguments[0]);
        } else if (arguments.length === 2) {
          var arg0 = arguments[0];
          if (typeof arg0 === "number") {
            if (arg0 >= 0 && arg0 <= array.length) {
              array.splice(arg0, 0, arguments[1]);
            } else {
              throw arg0 + " is not a valid index";
            }
          } else {
            throw typeof arg0 + " is not a number";
          }
        } else {
          throw "Please use the proper number of parameters.";
        }
      };
      this.addAll = function(arg1, arg2) {
        var it;
        if (typeof arg1 === "number") {
          if (arg1 < 0 || arg1 > array.length) {
            throw "Index out of bounds for addAll: " + arg1 + " greater or equal than " + array.length;
          }
          it = new ObjectIterator(arg2);
          while (it.hasNext()) {
            array.splice(arg1++, 0, it.next());
          }
        } else {
          it = new ObjectIterator(arg1);
          while (it.hasNext()) {
            array.push(it.next());
          }
        }
      };
      this.set = function() {
        if (arguments.length === 2) {
          var arg0 = arguments[0];
          if (typeof arg0 === "number") {
            if (arg0 >= 0 && arg0 < array.length) {
              array.splice(arg0, 1, arguments[1]);
            } else {
              throw arg0 + " is not a valid index.";
            }
          } else {
            throw typeof arg0 + " is not a number";
          }
        } else {
          throw "Please use the proper number of parameters.";
        }
      };
      this.size = function() {
        return array.length;
      };
      this.clear = function() {
        array.length = 0;
      };
      this.remove = function(item) {
        if (typeof item === "number") {
          return array.splice(item, 1)[0];
        }
        item = this.indexOf(item);
        if (item > -1) {
          array.splice(item, 1);
          return true;
        }
        return false;
      };
      this.removeAll = function(c) {
        var i, x, item, newList = new ArrayList();
        newList.addAll(this);
        this.clear();
        for (i = 0, x = 0; i < newList.size(); i++) {
          item = newList.get(i);
          if (!c.contains(item)) {
            this.add(x++, item);
          }
        }
        if (this.size() < newList.size()) {
          return true;
        }
        return false;
      };
      this.isEmpty = function() {
        return !array.length;
      };
      this.clone = function() {
        return new ArrayList(this);
      };
      this.toArray = function() {
        return array.slice(0);
      };
      this.iterator = function() {
        return new Iterator(array);
      };
    }
    return ArrayList;
  }
  var ArrayList_default = HashMap;

  // src/Objects/HashMap.js
  function HashMap2(options) {
    var virtHashCode2 = options.virtHashCode, virtEquals2 = options.virtEquals;
    function HashMap3() {
      if (arguments.length === 1 && arguments[0] instanceof HashMap3) {
        return arguments[0].clone();
      }
      var initialCapacity = arguments.length > 0 ? arguments[0] : 16;
      var loadFactor = arguments.length > 1 ? arguments[1] : 0.75;
      var buckets = [];
      buckets.length = initialCapacity;
      var count = 0;
      var hashMap = this;
      function getBucketIndex(key) {
        var index = virtHashCode2(key) % buckets.length;
        return index < 0 ? buckets.length + index : index;
      }
      function ensureLoad() {
        if (count <= loadFactor * buckets.length) {
          return;
        }
        var allEntries = [];
        for (var i = 0; i < buckets.length; ++i) {
          if (buckets[i] !== void 0) {
            allEntries = allEntries.concat(buckets[i]);
          }
        }
        var newBucketsLength = buckets.length * 2;
        buckets = [];
        buckets.length = newBucketsLength;
        for (var j = 0; j < allEntries.length; ++j) {
          var index = getBucketIndex(allEntries[j].key);
          var bucket = buckets[index];
          if (bucket === void 0) {
            buckets[index] = bucket = [];
          }
          bucket.push(allEntries[j]);
        }
      }
      function Iterator(conversion, removeItem) {
        var bucketIndex = 0;
        var itemIndex = -1;
        var endOfBuckets = false;
        var currentItem;
        function findNext() {
          while (!endOfBuckets) {
            ++itemIndex;
            if (bucketIndex >= buckets.length) {
              endOfBuckets = true;
            } else if (buckets[bucketIndex] === void 0 || itemIndex >= buckets[bucketIndex].length) {
              itemIndex = -1;
              ++bucketIndex;
            } else {
              return;
            }
          }
        }
        this.hasNext = function() {
          return !endOfBuckets;
        };
        this.next = function() {
          currentItem = conversion(buckets[bucketIndex][itemIndex]);
          findNext();
          return currentItem;
        };
        this.remove = function() {
          if (currentItem !== void 0) {
            removeItem(currentItem);
            --itemIndex;
            findNext();
          }
        };
        findNext();
      }
      function Set(conversion, isIn, removeItem) {
        this.clear = function() {
          hashMap.clear();
        };
        this.contains = function(o) {
          return isIn(o);
        };
        this.containsAll = function(o) {
          var it = o.iterator();
          while (it.hasNext()) {
            if (!this.contains(it.next())) {
              return false;
            }
          }
          return true;
        };
        this.isEmpty = function() {
          return hashMap.isEmpty();
        };
        this.iterator = function() {
          return new Iterator(conversion, removeItem);
        };
        this.remove = function(o) {
          if (this.contains(o)) {
            removeItem(o);
            return true;
          }
          return false;
        };
        this.removeAll = function(c) {
          var it = c.iterator();
          var changed = false;
          while (it.hasNext()) {
            var item = it.next();
            if (this.contains(item)) {
              removeItem(item);
              changed = true;
            }
          }
          return true;
        };
        this.retainAll = function(c) {
          var it = this.iterator();
          var toRemove = [];
          while (it.hasNext()) {
            var entry = it.next();
            if (!c.contains(entry)) {
              toRemove.push(entry);
            }
          }
          for (var i = 0; i < toRemove.length; ++i) {
            removeItem(toRemove[i]);
          }
          return toRemove.length > 0;
        };
        this.size = function() {
          return hashMap.size();
        };
        this.toArray = function() {
          var result = [];
          var it = this.iterator();
          while (it.hasNext()) {
            result.push(it.next());
          }
          return result;
        };
      }
      function Entry(pair) {
        this._isIn = function(map) {
          return map === hashMap && pair.removed === void 0;
        };
        this.equals = function(o) {
          return virtEquals2(pair.key, o.getKey());
        };
        this.getKey = function() {
          return pair.key;
        };
        this.getValue = function() {
          return pair.value;
        };
        this.hashCode = function(o) {
          return virtHashCode2(pair.key);
        };
        this.setValue = function(value) {
          var old = pair.value;
          pair.value = value;
          return old;
        };
      }
      this.clear = function() {
        count = 0;
        buckets = [];
        buckets.length = initialCapacity;
      };
      this.clone = function() {
        var map = new HashMap3();
        map.putAll(this);
        return map;
      };
      this.containsKey = function(key) {
        var index = getBucketIndex(key);
        var bucket = buckets[index];
        if (bucket === void 0) {
          return false;
        }
        for (var i = 0; i < bucket.length; ++i) {
          if (virtEquals2(bucket[i].key, key)) {
            return true;
          }
        }
        return false;
      };
      this.containsValue = function(value) {
        for (var i = 0; i < buckets.length; ++i) {
          var bucket = buckets[i];
          if (bucket === void 0) {
            continue;
          }
          for (var j = 0; j < bucket.length; ++j) {
            if (virtEquals2(bucket[j].value, value)) {
              return true;
            }
          }
        }
        return false;
      };
      this.entrySet = function() {
        return new Set(
          function(pair) {
            return new Entry(pair);
          },
          function(pair) {
            return pair instanceof Entry && pair._isIn(hashMap);
          },
          function(pair) {
            return hashMap.remove(pair.getKey());
          }
        );
      };
      this.get = function(key) {
        var index = getBucketIndex(key);
        var bucket = buckets[index];
        if (bucket === void 0) {
          return null;
        }
        for (var i = 0; i < bucket.length; ++i) {
          if (virtEquals2(bucket[i].key, key)) {
            return bucket[i].value;
          }
        }
        return null;
      };
      this.isEmpty = function() {
        return count === 0;
      };
      this.keySet = function() {
        return new Set(
          // get key from pair
          function(pair) {
            return pair.key;
          },
          // is-in test
          function(key) {
            return hashMap.containsKey(key);
          },
          // remove from hashmap by key
          function(key) {
            return hashMap.remove(key);
          }
        );
      };
      this.values = function() {
        return new Set(
          // get value from pair
          function(pair) {
            return pair.value;
          },
          // is-in test
          function(value) {
            return hashMap.containsValue(value);
          },
          // remove from hashmap by value
          function(value) {
            return hashMap.removeByValue(value);
          }
        );
      };
      this.put = function(key, value) {
        var index = getBucketIndex(key);
        var bucket = buckets[index];
        if (bucket === void 0) {
          ++count;
          buckets[index] = [{
            key,
            value
          }];
          ensureLoad();
          return null;
        }
        for (var i = 0; i < bucket.length; ++i) {
          if (virtEquals2(bucket[i].key, key)) {
            var previous = bucket[i].value;
            bucket[i].value = value;
            return previous;
          }
        }
        ++count;
        bucket.push({
          key,
          value
        });
        ensureLoad();
        return null;
      };
      this.putAll = function(m) {
        var it = m.entrySet().iterator();
        while (it.hasNext()) {
          var entry = it.next();
          this.put(entry.getKey(), entry.getValue());
        }
      };
      this.remove = function(key) {
        var index = getBucketIndex(key);
        var bucket = buckets[index];
        if (bucket === void 0) {
          return null;
        }
        for (var i = 0; i < bucket.length; ++i) {
          if (virtEquals2(bucket[i].key, key)) {
            --count;
            var previous = bucket[i].value;
            bucket[i].removed = true;
            if (bucket.length > 1) {
              bucket.splice(i, 1);
            } else {
              buckets[index] = void 0;
            }
            return previous;
          }
        }
        return null;
      };
      this.removeByValue = function(value) {
        var bucket, i, ilen, pair;
        for (bucket in buckets) {
          if (buckets.hasOwnProperty(bucket)) {
            for (i = 0, ilen = buckets[bucket].length; i < ilen; i++) {
              pair = buckets[bucket][i];
              if (pair.value === value) {
                buckets[bucket].splice(i, 1);
                return true;
              }
            }
          }
        }
        return false;
      };
      this.size = function() {
        return count;
      };
    }
    return HashMap3;
  }
  var HashMap_default = HashMap2;

  // src/Objects/PVector.js
  function PVector2(options, undef) {
    var PConstants3 = options.PConstants;
    function PVector3(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    }
    PVector3.fromAngle = function(angle, v) {
      if (v === undef || v === null) {
        v = new PVector3();
      }
      v.x = Math.cos(angle);
      v.y = Math.sin(angle);
      return v;
    };
    PVector3.random2D = function(v) {
      return PVector3.fromAngle(Math.random() * PConstants3.TWO_PI, v);
    };
    PVector3.random3D = function(v) {
      var angle = Math.random() * PConstants3.TWO_PI;
      var vz = Math.random() * 2 - 1;
      var mult = Math.sqrt(1 - vz * vz);
      var vx = mult * Math.cos(angle);
      var vy = mult * Math.sin(angle);
      if (v === undef || v === null) {
        v = new PVector3(vx, vy, vz);
      } else {
        v.set(vx, vy, vz);
      }
      return v;
    };
    PVector3.dist = function(v1, v2) {
      return v1.dist(v2);
    };
    PVector3.dot = function(v1, v2) {
      return v1.dot(v2);
    };
    PVector3.cross = function(v1, v2) {
      return v1.cross(v2);
    };
    PVector3.sub = function(v1, v2) {
      return new PVector3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    };
    PVector3.angleBetween = function(v1, v2) {
      return Math.acos(v1.dot(v2) / Math.sqrt(v1.magSq() * v2.magSq()));
    };
    PVector3.lerp = function(v1, v2, amt) {
      var retval = new PVector3(v1.x, v1.y, v1.z);
      retval.lerp(v2, amt);
      return retval;
    };
    PVector3.prototype = {
      set: function(v, y, z) {
        if (arguments.length === 1) {
          this.set(
            v.x || v[0] || 0,
            v.y || v[1] || 0,
            v.z || v[2] || 0
          );
        } else {
          this.x = v;
          this.y = y;
          this.z = z;
        }
      },
      get: function() {
        return new PVector3(this.x, this.y, this.z);
      },
      mag: function() {
        var x = this.x, y = this.y, z = this.z;
        return Math.sqrt(x * x + y * y + z * z);
      },
      magSq: function() {
        var x = this.x, y = this.y, z = this.z;
        return x * x + y * y + z * z;
      },
      setMag: function(v_or_len, len) {
        if (len === undef) {
          len = v_or_len;
          this.normalize();
          this.mult(len);
        } else {
          var v = v_or_len;
          v.normalize();
          v.mult(len);
          return v;
        }
      },
      add: function(v, y, z) {
        if (arguments.length === 1) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
        } else if (arguments.length === 2) {
          this.x += v;
          this.y += y;
        } else {
          this.x += v;
          this.y += y;
          this.z += z;
        }
      },
      sub: function(v, y, z) {
        if (arguments.length === 1) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
        } else if (arguments.length === 2) {
          this.x -= v;
          this.y -= y;
        } else {
          this.x -= v;
          this.y -= y;
          this.z -= z;
        }
      },
      mult: function(v) {
        if (typeof v === "number") {
          this.x *= v;
          this.y *= v;
          this.z *= v;
        } else {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
        }
      },
      div: function(v) {
        if (typeof v === "number") {
          this.x /= v;
          this.y /= v;
          this.z /= v;
        } else {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;
        }
      },
      rotate: function(angle) {
        var prev_x = this.x;
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.x = c * this.x - s * this.y;
        this.y = s * prev_x + c * this.y;
      },
      dist: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      },
      dot: function(v, y, z) {
        if (arguments.length === 1) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        return this.x * v + this.y * y + this.z * z;
      },
      cross: function(v) {
        var x = this.x, y = this.y, z = this.z;
        return new PVector3(
          y * v.z - v.y * z,
          z * v.x - v.z * x,
          x * v.y - v.x * y
        );
      },
      lerp: function(v_or_x, amt_or_y, z, amt) {
        var lerp_val = function(start, stop, amt2) {
          return start + (stop - start) * amt2;
        };
        var x, y;
        if (arguments.length === 2) {
          amt = amt_or_y;
          x = v_or_x.x;
          y = v_or_x.y;
          z = v_or_x.z;
        } else {
          x = v_or_x;
          y = amt_or_y;
        }
        this.x = lerp_val(this.x, x, amt);
        this.y = lerp_val(this.y, y, amt);
        this.z = lerp_val(this.z, z, amt);
      },
      normalize: function() {
        var m = this.mag();
        if (m > 0) {
          this.div(m);
        }
      },
      limit: function(high) {
        if (this.mag() > high) {
          this.normalize();
          this.mult(high);
        }
      },
      heading: function() {
        return -Math.atan2(-this.y, this.x);
      },
      heading2D: function() {
        return this.heading();
      },
      toString: function() {
        return "[" + this.x + ", " + this.y + ", " + this.z + "]";
      },
      array: function() {
        return [this.x, this.y, this.z];
      }
    };
    function createPVectorMethod(method2) {
      return function(v1, v2) {
        var v = v1.get();
        v[method2](v2);
        return v;
      };
    }
    for (var method in PVector3.prototype) {
      if (PVector3.prototype.hasOwnProperty(method) && !PVector3.hasOwnProperty(method)) {
        PVector3[method] = createPVectorMethod(method);
      }
    }
    return PVector3;
  }
  var PVector_default = PVector2;

  // src/Objects/PFont.js
  function PFont2(options, undef) {
    var window2 = options.Browser.window, document2 = options.Browser.document, noop = options.noop;
    function computeFontMetrics(pfont) {
      var emQuad = 250, correctionFactor = pfont.size / emQuad, canvas = document2.createElement("canvas");
      canvas.width = 2 * emQuad;
      canvas.height = 2 * emQuad;
      canvas.style.opacity = 0;
      var cfmFont = pfont.getCSSDefinition(emQuad + "px", "normal"), ctx = canvas.getContext("2d");
      ctx.font = cfmFont;
      var protrusions = "dbflkhyjqpg";
      canvas.width = ctx.measureText(protrusions).width;
      ctx.font = cfmFont;
      var leadDiv = document2.createElement("div");
      leadDiv.style.position = "absolute";
      leadDiv.style.opacity = 0;
      leadDiv.style.fontFamily = '"' + pfont.name + '"';
      leadDiv.style.fontSize = emQuad + "px";
      leadDiv.innerHTML = protrusions + "<br/>" + protrusions;
      document2.body.appendChild(leadDiv);
      var w = canvas.width, h = canvas.height, baseline = h / 2;
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "black";
      ctx.fillText(protrusions, 0, baseline);
      var pixelData = ctx.getImageData(0, 0, w, h).data;
      var i = 0, w4 = w * 4, len = pixelData.length;
      while (++i < len && pixelData[i] === 255) {
        noop();
      }
      var ascent = Math.round(i / w4);
      i = len - 1;
      while (--i > 0 && pixelData[i] === 255) {
        noop();
      }
      var descent = Math.round(i / w4);
      pfont.ascent = correctionFactor * (baseline - ascent);
      pfont.descent = correctionFactor * (descent - baseline);
      if (document2.defaultView.getComputedStyle) {
        var leadDivHeight = document2.defaultView.getComputedStyle(leadDiv, null).getPropertyValue("height");
        leadDivHeight = correctionFactor * leadDivHeight.replace("px", "");
        if (leadDivHeight >= pfont.size * 2) {
          pfont.leading = Math.round(leadDivHeight / 2);
        }
      }
      document2.body.removeChild(leadDiv);
      if (pfont.caching) {
        return ctx;
      }
    }
    function PFont3(name, size) {
      if (name === undef) {
        name = "";
      }
      this.name = name;
      if (size === undef) {
        size = 0;
      }
      this.size = size;
      this.glyph = false;
      this.ascent = 0;
      this.descent = 0;
      this.leading = 1.2 * size;
      var illegalIndicator = name.indexOf(" Italic Bold");
      if (illegalIndicator !== -1) {
        name = name.substring(0, illegalIndicator);
      }
      this.style = "normal";
      var italicsIndicator = name.indexOf(" Italic");
      if (italicsIndicator !== -1) {
        name = name.substring(0, italicsIndicator);
        this.style = "italic";
      }
      this.weight = "normal";
      var boldIndicator = name.indexOf(" Bold");
      if (boldIndicator !== -1) {
        name = name.substring(0, boldIndicator);
        this.weight = "bold";
      }
      this.family = "sans-serif";
      if (name !== undef) {
        switch (name) {
          case "sans-serif":
          case "serif":
          case "monospace":
          case "fantasy":
          case "cursive":
            this.family = name;
            break;
          default:
            this.family = '"' + name + '", sans-serif';
            break;
        }
      }
      this.context2d = computeFontMetrics(this);
      this.css = this.getCSSDefinition();
      if (this.context2d) {
        this.context2d.font = this.css;
      }
    }
    PFont3.prototype.caching = true;
    PFont3.prototype.getCSSDefinition = function(fontSize, lineHeight) {
      if (fontSize === undef) {
        fontSize = this.size + "px";
      }
      if (lineHeight === undef) {
        lineHeight = this.leading + "px";
      }
      var components = [this.style, "normal", this.weight, fontSize + "/" + lineHeight, this.family];
      return components.join(" ");
    };
    PFont3.prototype.measureTextWidth = function(string) {
      return this.context2d.measureText(string).width;
    };
    PFont3.prototype.measureTextWidthFallback = function(string) {
      var canvas = document2.createElement("canvas"), ctx = canvas.getContext("2d");
      ctx.font = this.css;
      return ctx.measureText(string).width;
    };
    PFont3.PFontCache = { length: 0 };
    PFont3.get = function(fontName, fontSize) {
      fontSize = (fontSize * 10 + 0.5 | 0) / 10;
      var cache = PFont3.PFontCache, idx = fontName + "/" + fontSize;
      if (!cache[idx]) {
        cache[idx] = new PFont3(fontName, fontSize);
        cache.length++;
        if (cache.length === 50) {
          PFont3.prototype.measureTextWidth = PFont3.prototype.measureTextWidthFallback;
          PFont3.prototype.caching = false;
          var entry;
          for (entry in cache) {
            if (entry !== "length") {
              cache[entry].context2d = null;
            }
          }
          return new PFont3(fontName, fontSize);
        }
        if (cache.length === 400) {
          PFont3.PFontCache = {};
          PFont3.get = PFont3.getFallback;
          return new PFont3(fontName, fontSize);
        }
      }
      return cache[idx];
    };
    PFont3.getFallback = function(fontName, fontSize) {
      return new PFont3(fontName, fontSize);
    };
    PFont3.list = function() {
      return ["sans-serif", "serif", "monospace", "fantasy", "cursive"];
    };
    PFont3.preloading = {
      // template element used to compare font sizes
      template: {},
      // indicates whether or not the reference tiny font has been loaded
      initialized: false,
      // load the reference tiny font via a css @font-face rule
      initialize: function() {
        var generateTinyFont = function() {
          var encoded = "#E3KAI2wAgT1MvMg7Eo3VmNtYX7ABi3CxnbHlm7Abw3kaGVhZ7ACs3OGhoZWE7A53CRobXR47AY3AGbG9jYQ7G03Bm1heH7ABC3CBuYW1l7Ae3AgcG9zd7AI3AE#B3AQ2kgTY18PPPUACwAg3ALSRoo3#yld0xg32QAB77#E777773B#E3C#I#Q77773E#Q7777777772CMAIw7AB77732B#M#Q3wAB#g3B#E#E2BB//82BB////w#B7#gAEg3E77x2B32B#E#Q#MTcBAQ32gAe#M#QQJ#E32M#QQJ#I#g32Q77#";
          var expand = function(input) {
            return "AAAAAAAA".substr(~~input ? 7 - input : 6);
          };
          return encoded.replace(/[#237]/g, expand);
        };
        var fontface = document2.createElement("style");
        fontface.setAttribute("type", "text/css");
        fontface.innerHTML = `@font-face {
  font-family: "PjsEmptyFont";
  src: url('data:application/x-font-ttf;base64,` + generateTinyFont() + "')\n       format('truetype');\n}";
        document2.head.appendChild(fontface);
        var element = document2.createElement("span");
        element.style.cssText = 'position: absolute; top: -1000; left: 0; opacity: 0; font-family: "PjsEmptyFont", fantasy;';
        element.innerHTML = "AAAAAAAA";
        document2.body.appendChild(element);
        this.template = element;
        this.initialized = true;
      },
      // Shorthand function to get the computed width for an element.
      getElementWidth: function(element) {
        return document2.defaultView.getComputedStyle(element, "").getPropertyValue("width");
      },
      // time taken so far in attempting to load a font
      timeAttempted: 0,
      // returns false if no fonts are pending load, or true otherwise.
      pending: function(intervallength) {
        if (!this.initialized) {
          this.initialize();
        }
        var element, computedWidthFont, computedWidthRef = this.getElementWidth(this.template);
        for (var i = 0; i < this.fontList.length; i++) {
          element = this.fontList[i];
          computedWidthFont = this.getElementWidth(element);
          if (this.timeAttempted < 4e3 && computedWidthFont === computedWidthRef) {
            this.timeAttempted += intervallength;
            return true;
          } else {
            document2.body.removeChild(element);
            this.fontList.splice(i--, 1);
            this.timeAttempted = 0;
          }
        }
        if (this.fontList.length === 0) {
          return false;
        }
        return true;
      },
      // fontList contains elements to compare font sizes against a template
      fontList: [],
      // addedList contains the fontnames of all the fonts loaded via @font-face
      addedList: {},
      // adds a font to the font cache
      // creates an element using the font, to start loading the font,
      // and compare against a default font to see if the custom font is loaded
      add: function(fontSrc) {
        if (!this.initialized) {
          this.initialize();
        }
        var fontName = typeof fontSrc === "object" ? fontSrc.fontFace : fontSrc, fontUrl = typeof fontSrc === "object" ? fontSrc.url : fontSrc;
        if (this.addedList[fontName]) {
          return;
        }
        var style = document2.createElement("style");
        style.setAttribute("type", "text/css");
        style.innerHTML = "@font-face{\n  font-family: '" + fontName + "';\n  src:  url('" + fontUrl + "');\n}\n";
        document2.head.appendChild(style);
        this.addedList[fontName] = true;
        var element = document2.createElement("span");
        element.style.cssText = "position: absolute; top: 0; left: 0; opacity: 0;";
        element.style.fontFamily = '"' + fontName + '", "PjsEmptyFont", fantasy';
        element.innerHTML = "AAAAAAAA";
        document2.body.appendChild(element);
        this.fontList.push(element);
      }
    };
    return PFont3;
  }
  var PFont_default = PFont2;

  // src/Objects/Char.js
  function buildChar(charMap, undef) {
    var Char2 = function(chr) {
      if (typeof chr === "string" && chr.length === 1) {
        this.code = chr.charCodeAt(0);
      } else if (typeof chr === "number") {
        this.code = chr;
      } else if (chr instanceof Char2) {
        this.code = chr;
      } else {
        this.code = NaN;
      }
      return charMap[this.code] === undef ? charMap[this.code] = this : charMap[this.code];
    };
    Char2.prototype.toString = function() {
      return String.fromCharCode(this.code);
    };
    Char2.prototype.valueOf = function() {
      return this.code;
    };
    return Char2;
  }
  var Char = buildChar({}, void 0);
  var Char_default = Char;

  // src/Objects/XMLAttribute.js
  function XMLAttribute_default() {
    var XMLAttribute = function(fname, n, nameSpace, v, t2) {
      this.fullName = fname || "";
      this.name = n || "";
      this.namespace = nameSpace || "";
      this.value = v;
      this.type = t2;
    };
    XMLAttribute.prototype = {
      /**
       * @member XMLAttribute
       * The getName() function returns the short name of the attribute
       *
       * @return {String} the short name of the attribute
       */
      getName: function() {
        return this.name;
      },
      /**
       * @member XMLAttribute
       * The getFullName() function returns the full name of the attribute
       *
       * @return {String} the full name of the attribute
       */
      getFullName: function() {
        return this.fullName;
      },
      /**
       * @member XMLAttribute
       * The getNamespace() function returns the namespace of the attribute
       *
       * @return {String} the namespace of the attribute
       */
      getNamespace: function() {
        return this.namespace;
      },
      /**
       * @member XMLAttribute
       * The getValue() function returns the value of the attribute
       *
       * @return {String} the value of the attribute
       */
      getValue: function() {
        return this.value;
      },
      /**
       * @member XMLAttribute
       * The getValue() function returns the type of the attribute
       *
       * @return {String} the type of the attribute
       */
      getType: function() {
        return this.type;
      },
      /**
       * @member XMLAttribute
       * The setValue() function sets the value of the attribute
       *
       * @param {String} newval the new value
       */
      setValue: function(newval) {
        this.value = newval;
      }
    };
    return XMLAttribute;
  }

  // src/Objects/XMLElement.js
  function XMLElement_default(options, undef) {
    var Browser2 = options.Browser, ajax = Browser2.ajax, window2 = Browser2.window, XMLHttpRequest2 = window2.XMLHttpRequest, DOMParser = window2.DOMParser, XMLAttribute = options.XMLAttribute;
    var XMLElement = function(selector, uri, sysid, line) {
      this.attributes = [];
      this.children = [];
      this.fullName = null;
      this.name = null;
      this.namespace = "";
      this.content = null;
      this.parent = null;
      this.lineNr = "";
      this.systemID = "";
      this.type = "ELEMENT";
      if (selector) {
        if (typeof selector === "string") {
          if (uri === undef && selector.indexOf("<") > -1) {
            this.parse(selector);
          } else {
            this.fullName = selector;
            this.namespace = uri;
            this.systemId = sysid;
            this.lineNr = line;
          }
        } else {
          this.parse(uri, true);
        }
      }
    };
    XMLElement.prototype = {
      /**
       * @member XMLElement
       * The parse() function retrieves the file via ajax() and uses DOMParser()
       * parseFromString method to make an XML document
       * @addon
       *
       * @param {String} filename name of the XML/SVG file to load
       *
       * @throws ExceptionType Error loading document
       *
       * @see XMLElement#parseChildrenRecursive
       */
      parse: function(textstring, stringIsURI) {
        var xmlDoc;
        try {
          if (stringIsURI) {
            textstring = ajax(textstring);
          }
          xmlDoc = new DOMParser().parseFromString(textstring, "text/xml");
          var elements = xmlDoc.documentElement;
          if (elements) {
            this.parseChildrenRecursive(null, elements);
          } else {
            throw "Error loading document";
          }
          return this;
        } catch (e) {
          throw e;
        }
      },
      /**
       * @member XMLElement
       * Internal helper function for parse().
       * Loops through the
       * @addon
       *
       * @param {XMLElement} parent                      the parent node
       * @param {XML document childNodes} elementpath    the remaining nodes that need parsing
       *
       * @return {XMLElement} the new element and its children elements
       */
      parseChildrenRecursive: function(parent, elementpath) {
        var xmlelement, xmlattribute, tmpattrib, l2, m, child;
        if (!parent) {
          this.fullName = elementpath.localName;
          this.name = elementpath.nodeName;
          xmlelement = this;
        } else {
          xmlelement = new XMLElement(elementpath.nodeName);
          xmlelement.parent = parent;
        }
        if (elementpath.nodeType === 3 && elementpath.textContent !== "") {
          return this.createPCDataElement(elementpath.textContent);
        }
        if (elementpath.nodeType === 4) {
          return this.createCDataElement(elementpath.textContent);
        }
        if (elementpath.attributes) {
          for (l2 = 0, m = elementpath.attributes.length; l2 < m; l2++) {
            tmpattrib = elementpath.attributes[l2];
            xmlattribute = new XMLAttribute(
              tmpattrib.getname,
              tmpattrib.nodeName,
              tmpattrib.namespaceURI,
              tmpattrib.nodeValue,
              tmpattrib.nodeType
            );
            xmlelement.attributes.push(xmlattribute);
          }
        }
        if (elementpath.childNodes) {
          for (l2 = 0, m = elementpath.childNodes.length; l2 < m; l2++) {
            var node = elementpath.childNodes[l2];
            child = xmlelement.parseChildrenRecursive(xmlelement, node);
            if (child !== null) {
              xmlelement.children.push(child);
            }
          }
        }
        return xmlelement;
      },
      /**
       * @member XMLElement
       * The createElement() function Creates an empty element
       *
       * @param {String} fullName   the full name of the element
       * @param {String} namespace  the namespace URI
       * @param {String} systemID   the system ID of the XML data where the element starts
       * @param {int} lineNr    the line in the XML data where the element starts
       */
      createElement: function(fullname, namespaceuri, sysid, line) {
        if (sysid === undef) {
          return new XMLElement(fullname, namespaceuri);
        }
        return new XMLElement(fullname, namespaceuri, sysid, line);
      },
      /**
       * @member XMLElement
       * The createPCDataElement() function creates an element to be used for #PCDATA content.
       * Because Processing discards whitespace TEXT nodes, this method will not build an element
       * if the passed content is empty after trimming for whitespace.
       *
       * @return {XMLElement} new "pcdata" XMLElement, or null if content consists only of whitespace
       */
      createPCDataElement: function(content, isCDATA) {
        if (content.replace(/^\s+$/g, "") === "") {
          return null;
        }
        var pcdata = new XMLElement();
        pcdata.type = "TEXT";
        pcdata.content = content;
        return pcdata;
      },
      /**
       * @member XMLElement
       * The createCDataElement() function creates an element to be used for CDATA content.
       *
       * @return {XMLElement} new "cdata" XMLElement, or null if content consists only of whitespace
       */
      createCDataElement: function(content) {
        var cdata = this.createPCDataElement(content);
        if (cdata === null) {
          return null;
        }
        cdata.type = "CDATA";
        var htmlentities = { "<": "&lt;", ">": "&gt;", "'": "&apos;", '"': "&quot;" }, entity;
        for (entity in htmlentities) {
          if (!Object.hasOwnProperty(htmlentities, entity)) {
            content = content.replace(new RegExp(entity, "g"), htmlentities[entity]);
          }
        }
        cdata.cdata = content;
        return cdata;
      },
      /**
       * @member XMLElement
       * The hasAttribute() function returns whether an attribute exists
       *
       * @param {String} name      name of the attribute
       * @param {String} namespace the namespace URI of the attribute
       *
       * @return {boolean} true if the attribute exists
       */
      hasAttribute: function() {
        if (arguments.length === 1) {
          return this.getAttribute(arguments[0]) !== null;
        }
        if (arguments.length === 2) {
          return this.getAttribute(arguments[0], arguments[1]) !== null;
        }
      },
      /**
       * @member XMLElement
       * The equals() function checks to see if the XMLElement being passed in equals another XMLElement
       *
       * @param {XMLElement} rawElement the element to compare to
       *
       * @return {boolean} true if the element equals another element
       */
      equals: function(other) {
        if (!(other instanceof XMLElement)) {
          return false;
        }
        var i, j;
        if (this.fullName !== other.fullName) {
          return false;
        }
        if (this.attributes.length !== other.getAttributeCount()) {
          return false;
        }
        if (this.attributes.length !== other.attributes.length) {
          return false;
        }
        var attr_name, attr_ns, attr_value, attr_type, attr_other;
        for (i = 0, j = this.attributes.length; i < j; i++) {
          attr_name = this.attributes[i].getName();
          attr_ns = this.attributes[i].getNamespace();
          attr_other = other.findAttribute(attr_name, attr_ns);
          if (attr_other === null) {
            return false;
          }
          if (this.attributes[i].getValue() !== attr_other.getValue()) {
            return false;
          }
          if (this.attributes[i].getType() !== attr_other.getType()) {
            return false;
          }
        }
        if (this.children.length !== other.getChildCount()) {
          return false;
        }
        if (this.children.length > 0) {
          var child1, child2;
          for (i = 0, j = this.children.length; i < j; i++) {
            child1 = this.getChild(i);
            child2 = other.getChild(i);
            if (!child1.equals(child2)) {
              return false;
            }
          }
          return true;
        }
        return this.content === other.content;
      },
      /**
       * @member XMLElement
       * The getContent() function returns the content of an element. If there is no such content, null is returned
       *
       * @return {String} the (possibly null) content
       */
      getContent: function() {
        if (this.type === "TEXT" || this.type === "CDATA") {
          return this.content;
        }
        var children = this.children;
        if (children.length === 1 && (children[0].type === "TEXT" || children[0].type === "CDATA")) {
          return children[0].content;
        }
        return null;
      },
      /**
       * @member XMLElement
       * The getAttribute() function returns the value of an attribute
       *
       * @param {String} name         the non-null full name of the attribute
       * @param {String} namespace    the namespace URI, which may be null
       * @param {String} defaultValue the default value of the attribute
       *
       * @return {String} the value, or defaultValue if the attribute does not exist
       */
      getAttribute: function() {
        var attribute;
        if (arguments.length === 2) {
          attribute = this.findAttribute(arguments[0]);
          if (attribute) {
            return attribute.getValue();
          }
          return arguments[1];
        } else if (arguments.length === 1) {
          attribute = this.findAttribute(arguments[0]);
          if (attribute) {
            return attribute.getValue();
          }
          return null;
        } else if (arguments.length === 3) {
          attribute = this.findAttribute(arguments[0], arguments[1]);
          if (attribute) {
            return attribute.getValue();
          }
          return arguments[2];
        }
      },
      /**
       * @member XMLElement
       * The getStringAttribute() function returns the string attribute of the element
       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.
       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.
       *
       * @param name         the name of the attribute
       * @param defaultValue value returned if the attribute is not found
       *
       * @return {String} the value, or defaultValue if the attribute does not exist
       */
      getStringAttribute: function() {
        if (arguments.length === 1) {
          return this.getAttribute(arguments[0]);
        }
        if (arguments.length === 2) {
          return this.getAttribute(arguments[0], arguments[1]);
        }
        return this.getAttribute(arguments[0], arguments[1], arguments[2]);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic String
       * attribute getter. This may only take one argument.
       */
      getString: function(attributeName) {
        return this.getStringAttribute(attributeName);
      },
      /**
       * @member XMLElement
       * The getFloatAttribute() function returns the float attribute of the element.
       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.
       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.
       *
       * @param name         the name of the attribute
       * @param defaultValue value returned if the attribute is not found
       *
       * @return {float} the value, or defaultValue if the attribute does not exist
       */
      getFloatAttribute: function() {
        if (arguments.length === 1) {
          return parseFloat(this.getAttribute(arguments[0], 0));
        }
        if (arguments.length === 2) {
          return this.getAttribute(arguments[0], arguments[1]);
        }
        return this.getAttribute(arguments[0], arguments[1], arguments[2]);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic float
       * attribute getter. This may only take one argument.
       */
      getFloat: function(attributeName) {
        return this.getFloatAttribute(attributeName);
      },
      /**
       * @member XMLElement
       * The getIntAttribute() function returns the integer attribute of the element.
       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.
       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.
       *
       * @param name         the name of the attribute
       * @param defaultValue value returned if the attribute is not found
       *
       * @return {int} the value, or defaultValue if the attribute does not exist
       */
      getIntAttribute: function() {
        if (arguments.length === 1) {
          return this.getAttribute(arguments[0], 0);
        }
        if (arguments.length === 2) {
          return this.getAttribute(arguments[0], arguments[1]);
        }
        return this.getAttribute(arguments[0], arguments[1], arguments[2]);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic int
       * attribute getter. This may only take one argument.
       */
      getInt: function(attributeName) {
        return this.getIntAttribute(attributeName);
      },
      /**
       * @member XMLElement
       * The hasChildren() function returns whether the element has children.
       *
       * @return {boolean} true if the element has children.
       */
      hasChildren: function() {
        return this.children.length > 0;
      },
      /**
       * @member XMLElement
       * The addChild() function adds a child element
       *
       * @param {XMLElement} child the non-null child to add.
       */
      addChild: function(child) {
        if (child !== null) {
          child.parent = this;
          this.children.push(child);
        }
      },
      /**
       * @member XMLElement
       * The insertChild() function inserts a child element at the index provided
       *
       * @param {XMLElement} child  the non-null child to add.
       * @param {int} index     where to put the child.
       */
      insertChild: function(child, index) {
        if (child) {
          if (child.getLocalName() === null && !this.hasChildren()) {
            var lastChild = this.children[this.children.length - 1];
            if (lastChild.getLocalName() === null) {
              lastChild.setContent(lastChild.getContent() + child.getContent());
              return;
            }
          }
          child.parent = this;
          this.children.splice(index, 0, child);
        }
      },
      /**
       * @member XMLElement
       * The getChild() returns the child XMLElement as specified by the <b>index</b> parameter.
       * The value of the <b>index</b> parameter must be less than the total number of children to avoid going out of the array storing the child elements.
       * When the <b>path</b> parameter is specified, then it will return all children that match that path. The path is a series of elements and sub-elements, separated by slashes.
       *
       * @param {int} index     where to put the child.
       * @param {String} path       path to a particular element
       *
       * @return {XMLElement} the element
       */
      getChild: function(selector) {
        if (typeof selector === "number") {
          return this.children[selector];
        }
        if (selector.indexOf("/") !== -1) {
          return this.getChildRecursive(selector.split("/"), 0);
        }
        var kid, kidName;
        for (var i = 0, j = this.getChildCount(); i < j; i++) {
          kid = this.getChild(i);
          kidName = kid.getName();
          if (kidName !== null && kidName === selector) {
            return kid;
          }
        }
        return null;
      },
      /**
       * @member XMLElement
       * The getChildren() returns all of the children as an XMLElement array.
       * When the <b>path</b> parameter is specified, then it will return all children that match that path.
       * The path is a series of elements and sub-elements, separated by slashes.
       *
       * @param {String} path       element name or path/to/element
       *
       * @return {XMLElement} array of child elements that match
       *
       * @see XMLElement#getChildCount()
       * @see XMLElement#getChild()
       */
      getChildren: function() {
        if (arguments.length === 1) {
          if (typeof arguments[0] === "number") {
            return this.getChild(arguments[0]);
          }
          if (arguments[0].indexOf("/") !== -1) {
            return this.getChildrenRecursive(arguments[0].split("/"), 0);
          }
          var matches = [];
          var kid, kidName;
          for (var i = 0, j = this.getChildCount(); i < j; i++) {
            kid = this.getChild(i);
            kidName = kid.getName();
            if (kidName !== null && kidName === arguments[0]) {
              matches.push(kid);
            }
          }
          return matches;
        }
        return this.children;
      },
      /**
       * @member XMLElement
       * The getChildCount() returns the number of children for the element.
       *
       * @return {int} the count
       *
       * @see XMLElement#getChild()
       * @see XMLElement#getChildren()
       */
      getChildCount: function() {
        return this.children.length;
      },
      /**
       * @member XMLElement
       * Internal helper function for getChild().
       *
       * @param {String[]} items   result of splitting the query on slashes
       * @param {int} offset   where in the items[] array we're currently looking
       *
       * @return {XMLElement} matching element or null if no match
       */
      getChildRecursive: function(items, offset) {
        if (offset === items.length) {
          return this;
        }
        var kid, kidName, matchName = items[offset];
        for (var i = 0, j = this.getChildCount(); i < j; i++) {
          kid = this.getChild(i);
          kidName = kid.getName();
          if (kidName !== null && kidName === matchName) {
            return kid.getChildRecursive(items, offset + 1);
          }
        }
        return null;
      },
      /**
       * @member XMLElement
       * Internal helper function for getChildren().
       *
       * @param {String[]} items   result of splitting the query on slashes
       * @param {int} offset   where in the items[] array we're currently looking
       *
       * @return {XMLElement[]} matching elements or empty array if no match
       */
      getChildrenRecursive: function(items, offset) {
        if (offset === items.length - 1) {
          return this.getChildren(items[offset]);
        }
        var matches = this.getChildren(items[offset]);
        var kidMatches = [];
        for (var i = 0; i < matches.length; i++) {
          kidMatches = kidMatches.concat(matches[i].getChildrenRecursive(items, offset + 1));
        }
        return kidMatches;
      },
      /**
       * @member XMLElement
       * The isLeaf() function returns whether the element is a leaf element.
       *
       * @return {boolean} true if the element has no children.
       */
      isLeaf: function() {
        return !this.hasChildren();
      },
      /**
       * @member XMLElement
       * The listChildren() function put the names of all children into an array. Same as looping through
       * each child and calling getName() on each XMLElement.
       *
       * @return {String[]} a list of element names.
       */
      listChildren: function() {
        var arr = [];
        for (var i = 0, j = this.children.length; i < j; i++) {
          arr.push(this.getChild(i).getName());
        }
        return arr;
      },
      /**
       * @member XMLElement
       * The removeAttribute() function removes an attribute
       *
       * @param {String} name        the non-null name of the attribute.
       * @param {String} namespace   the namespace URI of the attribute, which may be null.
       */
      removeAttribute: function(name, namespace) {
        this.namespace = namespace || "";
        for (var i = 0, j = this.attributes.length; i < j; i++) {
          if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {
            this.attributes.splice(i, 1);
            break;
          }
        }
      },
      /**
       * @member XMLElement
       * The removeChild() removes a child element.
       *
       * @param {XMLElement} child      the the non-null child to be renoved
       */
      removeChild: function(child) {
        if (child) {
          for (var i = 0, j = this.children.length; i < j; i++) {
            if (this.children[i].equals(child)) {
              this.children.splice(i, 1);
              break;
            }
          }
        }
      },
      /**
       * @member XMLElement
       * The removeChildAtIndex() removes the child located at a certain index
       *
       * @param {int} index      the index of the child, where the first child has index 0
       */
      removeChildAtIndex: function(index) {
        if (this.children.length > index) {
          this.children.splice(index, 1);
        }
      },
      /**
       * @member XMLElement
       * The findAttribute() function searches an attribute
       *
       * @param {String} name        fullName the non-null full name of the attribute
       * @param {String} namespace   the name space, which may be null
       *
       * @return {XMLAttribute} the attribute, or null if the attribute does not exist.
       */
      findAttribute: function(name, namespace) {
        this.namespace = namespace || "";
        for (var i = 0, j = this.attributes.length; i < j; i++) {
          if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {
            return this.attributes[i];
          }
        }
        return null;
      },
      /**
       * @member XMLElement
       * The setAttribute() function sets an attribute.
       *
       * @param {String} name        the non-null full name of the attribute
       * @param {String} namespace   the non-null value of the attribute
       */
      setAttribute: function() {
        var attr;
        if (arguments.length === 3) {
          var index = arguments[0].indexOf(":");
          var name = arguments[0].substring(index + 1);
          attr = this.findAttribute(name, arguments[1]);
          if (attr) {
            attr.setValue(arguments[2]);
          } else {
            attr = new XMLAttribute(arguments[0], name, arguments[1], arguments[2], "CDATA");
            this.attributes.push(attr);
          }
        } else {
          attr = this.findAttribute(arguments[0]);
          if (attr) {
            attr.setValue(arguments[1]);
          } else {
            attr = new XMLAttribute(arguments[0], arguments[0], null, arguments[1], "CDATA");
            this.attributes.push(attr);
          }
        }
      },
      /**
       * Processing 1.5 XML API wrapper for the generic String
       * attribute setter. This must take two arguments.
       */
      setString: function(attribute, value) {
        this.setAttribute(attribute, value);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic int
       * attribute setter. This must take two arguments.
       */
      setInt: function(attribute, value) {
        this.setAttribute(attribute, value);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic float
       * attribute setter. This must take two arguments.
       */
      setFloat: function(attribute, value) {
        this.setAttribute(attribute, value);
      },
      /**
       * @member XMLElement
       * The setContent() function sets the #PCDATA content. It is an error to call this method with a
       * non-null value if there are child objects.
       *
       * @param {String} content     the (possibly null) content
       */
      setContent: function(content) {
        if (this.children.length > 0) {
          Processing.debug("Tried to set content for XMLElement with children");
        }
        this.content = content;
      },
      /**
       * @member XMLElement
       * The setName() function sets the full name. This method also sets the short name and clears the
       * namespace URI.
       *
       * @param {String} name        the non-null name
       * @param {String} namespace   the namespace URI, which may be null.
       */
      setName: function() {
        if (arguments.length === 1) {
          this.name = arguments[0];
          this.fullName = arguments[0];
          this.namespace = null;
        } else {
          var index = arguments[0].indexOf(":");
          if (arguments[1] === null || index < 0) {
            this.name = arguments[0];
          } else {
            this.name = arguments[0].substring(index + 1);
          }
          this.fullName = arguments[0];
          this.namespace = arguments[1];
        }
      },
      /**
       * @member XMLElement
       * The getName() function returns the full name (i.e. the name including an eventual namespace
       * prefix) of the element.
       *
       * @return {String} the name, or null if the element only contains #PCDATA.
       */
      getName: function() {
        return this.fullName;
      },
      /**
       * @member XMLElement
       * The getLocalName() function returns the local name (i.e. the name excluding an eventual namespace
       * prefix) of the element.
       *
       * @return {String} the name, or null if the element only contains #PCDATA.
       */
      getLocalName: function() {
        return this.name;
      },
      /**
       * @member XMLElement
       * The getAttributeCount() function returns the number of attributes for the node
       * that this XMLElement represents.
       *
       * @return {int} the number of attributes in this XMLElement
       */
      getAttributeCount: function() {
        return this.attributes.length;
      },
      /**
       * @member XMLElement
       * The toString() function returns the XML definition of an XMLElement.
       *
       * @return {String} the XML definition of this XMLElement
       */
      toString: function() {
        if (this.type === "TEXT") {
          return this.content || "";
        }
        if (this.type === "CDATA") {
          return this.cdata || "";
        }
        var tagstring = this.fullName;
        var xmlstring = "<" + tagstring;
        var a, c;
        for (a = 0; a < this.attributes.length; a++) {
          var attr = this.attributes[a];
          xmlstring += " " + attr.getName() + '="' + attr.getValue() + '"';
        }
        if (this.children.length === 0) {
          if (this.content === "" || this.content === null || this.content === void 0) {
            xmlstring += "/>";
          } else {
            xmlstring += ">" + this.content + "</" + tagstring + ">";
          }
        } else {
          xmlstring += ">";
          for (c = 0; c < this.children.length; c++) {
            xmlstring += this.children[c].toString();
          }
          xmlstring += "</" + tagstring + ">";
        }
        return xmlstring;
      }
    };
    XMLElement.parse = function(xmlstring) {
      var element = new XMLElement();
      element.parse(xmlstring);
      return element;
    };
    return XMLElement;
  }

  // src/Objects/PMatrix2D.js
  function PMatrix2D(options, undef) {
    var p = options.p;
    var PMatrix2D2 = function() {
      if (arguments.length === 0) {
        this.reset();
      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
        this.set(arguments[0].array());
      } else if (arguments.length === 6) {
        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
      }
    };
    PMatrix2D2.prototype = {
      /**
       * @member PMatrix2D
       * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.
       *
       * @param {PMatrix2D} matrix    the matrix to set this matrix to
       * @param {float[]} elements    an array of elements to set this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the third element of the matrix
       * @param {float} m10           the fourth element of the matrix
       * @param {float} m11           the fith element of the matrix
       * @param {float} m12           the sixth element of the matrix
       */
      set: function() {
        if (arguments.length === 6) {
          var a = arguments;
          this.set([
            a[0],
            a[1],
            a[2],
            a[3],
            a[4],
            a[5]
          ]);
        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
          this.elements = arguments[0].array();
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          this.elements = arguments[0].slice();
        }
      },
      /**
       * @member PMatrix2D
       * The get() function returns a copy of this PMatrix2D.
       *
       * @return {PMatrix2D} a copy of this PMatrix2D
       */
      get: function() {
        var outgoing = new PMatrix2D2();
        outgoing.set(this.elements);
        return outgoing;
      },
      /**
       * @member PMatrix2D
       * The reset() function sets this PMatrix2D to the identity matrix.
       */
      reset: function() {
        this.set([1, 0, 0, 0, 1, 0]);
      },
      /**
       * @member PMatrix2D
       * The array() function returns a copy of the element values.
       * @addon
       *
       * @return {float[]} returns a copy of the element values
       */
      array: function array() {
        return this.elements.slice();
      },
      /**
       * @member PMatrix2D
       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.
       *
       * @param {float} tx  the x-axis coordinate to move to
       * @param {float} ty  the y-axis coordinate to move to
       */
      translate: function(tx, ty) {
        this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];
        this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];
      },
      /**
       * @member PMatrix2D
       * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.
       *
       * @param {float} tx  the x-axis coordinate to move to
       * @param {float} ty  the y-axis coordinate to move to
       */
      invTranslate: function(tx, ty) {
        this.translate(-tx, -ty);
      },
      /**
      * @member PMatrix2D
      * The transpose() function is not used in processingjs.
      */
      transpose: function() {
      },
      /**
       * @member PMatrix2D
       * The mult() function multiplied this matrix.
       * If two array elements are passed in the function will multiply a two element vector against this matrix.
       * If target is null or not length four, a new float array will be returned.
       * The values for vec and target can be the same (though that's less efficient).
       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.
       *
       * @param {PVector} source, target  the PVectors used to multiply this matrix
       * @param {float[]} source, target  the arrays used to multiply this matrix
       *
       * @return {PVector|float[]} returns a PVector or an array representing the new matrix
       */
      mult: function(source2, target) {
        var x, y;
        if (source2 instanceof PVector) {
          x = source2.x;
          y = source2.y;
          if (!target) {
            target = new PVector();
          }
        } else if (source2 instanceof Array) {
          x = source2[0];
          y = source2[1];
          if (!target) {
            target = [];
          }
        }
        if (target instanceof Array) {
          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];
          target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];
        } else if (target instanceof PVector) {
          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];
          target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];
          target.z = 0;
        }
        return target;
      },
      /**
       * @member PMatrix2D
       * The multX() function calculates the x component of a vector from a transformation.
       *
       * @param {float} x the x component of the vector being transformed
       * @param {float} y the y component of the vector being transformed
       *
       * @return {float} returnes the result of the calculation
       */
      multX: function(x, y) {
        return x * this.elements[0] + y * this.elements[1] + this.elements[2];
      },
      /**
       * @member PMatrix2D
       * The multY() function calculates the y component of a vector from a transformation.
       *
       * @param {float} x the x component of the vector being transformed
       * @param {float} y the y component of the vector being transformed
       *
       * @return {float} returnes the result of the calculation
       */
      multY: function(x, y) {
        return x * this.elements[3] + y * this.elements[4] + this.elements[5];
      },
      /**
       * @member PMatrix2D
       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      skewX: function(angle) {
        this.apply(1, 0, 1, angle, 0, 0);
      },
      /**
       * @member PMatrix2D
       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      skewY: function(angle) {
        this.apply(1, 0, 1, 0, angle, 0);
      },
      /**
       * @member PMatrix2D
       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      shearX: function(angle) {
        this.apply(1, 0, 1, Math.tan(angle), 0, 0);
      },
      /**
       * @member PMatrix2D
       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      shearY: function(angle) {
        this.apply(1, 0, 1, 0, Math.tan(angle), 0);
      },
      /**
       * @member PMatrix2D
       * The determinant() function calvculates the determinant of this matrix.
       *
       * @return {float} the determinant of the matrix
       */
      determinant: function() {
        return this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3];
      },
      /**
       * @member PMatrix2D
       * The invert() function inverts this matrix
       *
       * @return {boolean} true if successful
       */
      invert: function() {
        var d = this.determinant();
        if (Math.abs(d) > PConstants.MIN_INT) {
          var old00 = this.elements[0];
          var old01 = this.elements[1];
          var old02 = this.elements[2];
          var old10 = this.elements[3];
          var old11 = this.elements[4];
          var old12 = this.elements[5];
          this.elements[0] = old11 / d;
          this.elements[3] = -old10 / d;
          this.elements[1] = -old01 / d;
          this.elements[4] = old00 / d;
          this.elements[2] = (old01 * old12 - old11 * old02) / d;
          this.elements[5] = (old10 * old02 - old00 * old12) / d;
          return true;
        }
        return false;
      },
      /**
       * @member PMatrix2D
       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.
       * This is equivalent to a two parameter call.
       *
       * @param {float} sx  the amount to scale on the x-axis
       * @param {float} sy  the amount to scale on the y-axis
       */
      scale: function(sx, sy) {
        if (sx && sy === undef) {
          sy = sx;
        }
        if (sx && sy) {
          this.elements[0] *= sx;
          this.elements[1] *= sy;
          this.elements[3] *= sx;
          this.elements[4] *= sy;
        }
      },
      /**
       * @member PMatrix2D
       * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.
       * This is equivalent to a two parameter call.
       *
       * @param {float} sx  the amount to scale on the x-axis
       * @param {float} sy  the amount to scale on the y-axis
       */
      invScale: function(sx, sy) {
        if (sx && !sy) {
          sy = sx;
        }
        this.scale(1 / sx, 1 / sy);
      },
      /**
       * @member PMatrix2D
       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.
       *
       * @param {PMatrix2D} matrix    the matrix to apply this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the third element of the matrix
       * @param {float} m10           the fourth element of the matrix
       * @param {float} m11           the fith element of the matrix
       * @param {float} m12           the sixth element of the matrix
       */
      apply: function() {
        var source2;
        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
          source2 = arguments[0].array();
        } else if (arguments.length === 6) {
          source2 = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          source2 = arguments[0];
        }
        var result = [
          0,
          0,
          this.elements[2],
          0,
          0,
          this.elements[5]
        ];
        var e = 0;
        for (var row = 0; row < 2; row++) {
          for (var col = 0; col < 3; col++, e++) {
            result[e] += this.elements[row * 3 + 0] * source2[col + 0] + this.elements[row * 3 + 1] * source2[col + 3];
          }
        }
        this.elements = result.slice();
      },
      /**
       * @member PMatrix2D
       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.
       *
       * @param {PMatrix2D} matrix    the matrix to apply this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the third element of the matrix
       * @param {float} m10           the fourth element of the matrix
       * @param {float} m11           the fith element of the matrix
       * @param {float} m12           the sixth element of the matrix
       */
      preApply: function() {
        var source2;
        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
          source2 = arguments[0].array();
        } else if (arguments.length === 6) {
          source2 = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          source2 = arguments[0];
        }
        var result = [
          0,
          0,
          source2[2],
          0,
          0,
          source2[5]
        ];
        result[2] = source2[2] + this.elements[2] * source2[0] + this.elements[5] * source2[1];
        result[5] = source2[5] + this.elements[2] * source2[3] + this.elements[5] * source2[4];
        result[0] = this.elements[0] * source2[0] + this.elements[3] * source2[1];
        result[3] = this.elements[0] * source2[3] + this.elements[3] * source2[4];
        result[1] = this.elements[1] * source2[0] + this.elements[4] * source2[1];
        result[4] = this.elements[1] * source2[3] + this.elements[4] * source2[4];
        this.elements = result.slice();
      },
      /**
       * @member PMatrix2D
       * The rotate() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotate: function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var temp1 = this.elements[0];
        var temp2 = this.elements[1];
        this.elements[0] = c * temp1 + s * temp2;
        this.elements[1] = -s * temp1 + c * temp2;
        temp1 = this.elements[3];
        temp2 = this.elements[4];
        this.elements[3] = c * temp1 + s * temp2;
        this.elements[4] = -s * temp1 + c * temp2;
      },
      /**
       * @member PMatrix2D
       * The rotateZ() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotateZ: function(angle) {
        this.rotate(angle);
      },
      /**
       * @member PMatrix2D
       * The invRotateZ() function rotates the matrix in opposite direction.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      invRotateZ: function(angle) {
        this.rotateZ(angle - Math.PI);
      },
      /**
       * @member PMatrix2D
       * The print() function prints out the elements of this matrix
       */
      print: function() {
        var digits = printMatrixHelper(this.elements);
        var output = "" + p.nfs(this.elements[0], digits, 4) + " " + p.nfs(this.elements[1], digits, 4) + " " + p.nfs(this.elements[2], digits, 4) + "\n" + p.nfs(this.elements[3], digits, 4) + " " + p.nfs(this.elements[4], digits, 4) + " " + p.nfs(this.elements[5], digits, 4) + "\n\n";
        p.println(output);
      }
    };
    return PMatrix2D2;
  }
  var PMatrix2D_default = PMatrix2D;

  // src/Objects/PMatrix3D.js
  function PMatrix3D(options, undef) {
    var p = options.p;
    var PMatrix3D2 = function() {
      this.reset();
    };
    PMatrix3D2.prototype = {
      /**
       * @member PMatrix2D
       * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.
       *
       * @param {PMatrix3D} matrix    the initial matrix to set to
       * @param {float[]} elements    an array of elements to set this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the second element of the matrix
       * @param {float} m02           the third element of the matrix
       * @param {float} m03           the fourth element of the matrix
       * @param {float} m10           the fifth element of the matrix
       * @param {float} m11           the sixth element of the matrix
       * @param {float} m12           the seventh element of the matrix
       * @param {float} m13           the eight element of the matrix
       * @param {float} m20           the nineth element of the matrix
       * @param {float} m21           the tenth element of the matrix
       * @param {float} m22           the eleventh element of the matrix
       * @param {float} m23           the twelveth element of the matrix
       * @param {float} m30           the thirteenth element of the matrix
       * @param {float} m31           the fourtheenth element of the matrix
       * @param {float} m32           the fivetheenth element of the matrix
       * @param {float} m33           the sixteenth element of the matrix
       */
      set: function() {
        if (arguments.length === 16) {
          this.elements = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
          this.elements = arguments[0].array();
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          this.elements = arguments[0].slice();
        }
      },
      /**
       * @member PMatrix3D
       * The get() function returns a copy of this PMatrix3D.
       *
       * @return {PMatrix3D} a copy of this PMatrix3D
       */
      get: function() {
        var outgoing = new PMatrix3D2();
        outgoing.set(this.elements);
        return outgoing;
      },
      /**
       * @member PMatrix3D
       * The reset() function sets this PMatrix3D to the identity matrix.
       */
      reset: function() {
        this.elements = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      },
      /**
       * @member PMatrix3D
       * The array() function returns a copy of the element values.
       * @addon
       *
       * @return {float[]} returns a copy of the element values
       */
      array: function array() {
        return this.elements.slice();
      },
      /**
       * @member PMatrix3D
       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.
       *
       * @param {float} tx  the x-axis coordinate to move to
       * @param {float} ty  the y-axis coordinate to move to
       * @param {float} tz  the z-axis coordinate to move to
       */
      translate: function(tx, ty, tz) {
        if (tz === undef) {
          tz = 0;
        }
        this.elements[3] += tx * this.elements[0] + ty * this.elements[1] + tz * this.elements[2];
        this.elements[7] += tx * this.elements[4] + ty * this.elements[5] + tz * this.elements[6];
        this.elements[11] += tx * this.elements[8] + ty * this.elements[9] + tz * this.elements[10];
        this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];
      },
      /**
       * @member PMatrix3D
       * The transpose() function transpose this matrix.
       */
      transpose: function() {
        var temp = this.elements[4];
        this.elements[4] = this.elements[1];
        this.elements[1] = temp;
        temp = this.elements[8];
        this.elements[8] = this.elements[2];
        this.elements[2] = temp;
        temp = this.elements[6];
        this.elements[6] = this.elements[9];
        this.elements[9] = temp;
        temp = this.elements[3];
        this.elements[3] = this.elements[12];
        this.elements[12] = temp;
        temp = this.elements[7];
        this.elements[7] = this.elements[13];
        this.elements[13] = temp;
        temp = this.elements[11];
        this.elements[11] = this.elements[14];
        this.elements[14] = temp;
      },
      /**
       * @member PMatrix3D
       * The mult() function multiplied this matrix.
       * If two array elements are passed in the function will multiply a two element vector against this matrix.
       * If target is null or not length four, a new float array will be returned.
       * The values for vec and target can be the same (though that's less efficient).
       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.
       *
       * @param {PVector} source, target  the PVectors used to multiply this matrix
       * @param {float[]} source, target  the arrays used to multiply this matrix
       *
       * @return {PVector|float[]} returns a PVector or an array representing the new matrix
       */
      mult: function(source2, target) {
        var x, y, z, w;
        if (source2 instanceof PVector) {
          x = source2.x;
          y = source2.y;
          z = source2.z;
          w = 1;
          if (!target) {
            target = new PVector();
          }
        } else if (source2 instanceof Array) {
          x = source2[0];
          y = source2[1];
          z = source2[2];
          w = source2[3] || 1;
          if (!target || target.length !== 3 && target.length !== 4) {
            target = [0, 0, 0];
          }
        }
        if (target instanceof Array) {
          if (target.length === 3) {
            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
          } else if (target.length === 4) {
            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;
            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;
            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;
            target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;
          }
        }
        if (target instanceof PVector) {
          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
          target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
          target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
        }
        return target;
      },
      /**
       * @member PMatrix3D
       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.
       *
       * @param {PMatrix3D} matrix    the matrix to apply this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the second element of the matrix
       * @param {float} m02           the third element of the matrix
       * @param {float} m03           the fourth element of the matrix
       * @param {float} m10           the fifth element of the matrix
       * @param {float} m11           the sixth element of the matrix
       * @param {float} m12           the seventh element of the matrix
       * @param {float} m13           the eight element of the matrix
       * @param {float} m20           the nineth element of the matrix
       * @param {float} m21           the tenth element of the matrix
       * @param {float} m22           the eleventh element of the matrix
       * @param {float} m23           the twelveth element of the matrix
       * @param {float} m30           the thirteenth element of the matrix
       * @param {float} m31           the fourtheenth element of the matrix
       * @param {float} m32           the fivetheenth element of the matrix
       * @param {float} m33           the sixteenth element of the matrix
       */
      preApply: function() {
        var source2;
        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
          source2 = arguments[0].array();
        } else if (arguments.length === 16) {
          source2 = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          source2 = arguments[0];
        }
        var result = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        var e = 0;
        for (var row = 0; row < 4; row++) {
          for (var col = 0; col < 4; col++, e++) {
            result[e] += this.elements[col + 0] * source2[row * 4 + 0] + this.elements[col + 4] * source2[row * 4 + 1] + this.elements[col + 8] * source2[row * 4 + 2] + this.elements[col + 12] * source2[row * 4 + 3];
          }
        }
        this.elements = result.slice();
      },
      /**
       * @member PMatrix3D
       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.
       *
       * @param {PMatrix3D} matrix    the matrix to apply this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the second element of the matrix
       * @param {float} m02           the third element of the matrix
       * @param {float} m03           the fourth element of the matrix
       * @param {float} m10           the fifth element of the matrix
       * @param {float} m11           the sixth element of the matrix
       * @param {float} m12           the seventh element of the matrix
       * @param {float} m13           the eight element of the matrix
       * @param {float} m20           the nineth element of the matrix
       * @param {float} m21           the tenth element of the matrix
       * @param {float} m22           the eleventh element of the matrix
       * @param {float} m23           the twelveth element of the matrix
       * @param {float} m30           the thirteenth element of the matrix
       * @param {float} m31           the fourtheenth element of the matrix
       * @param {float} m32           the fivetheenth element of the matrix
       * @param {float} m33           the sixteenth element of the matrix
       */
      apply: function() {
        var source2;
        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
          source2 = arguments[0].array();
        } else if (arguments.length === 16) {
          source2 = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          source2 = arguments[0];
        }
        var result = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        var e = 0;
        for (var row = 0; row < 4; row++) {
          for (var col = 0; col < 4; col++, e++) {
            result[e] += this.elements[row * 4 + 0] * source2[col + 0] + this.elements[row * 4 + 1] * source2[col + 4] + this.elements[row * 4 + 2] * source2[col + 8] + this.elements[row * 4 + 3] * source2[col + 12];
          }
        }
        this.elements = result.slice();
      },
      /**
       * @member PMatrix3D
       * The rotate() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotate: function(angle, v0, v1, v2) {
        if (!v1) {
          this.rotateZ(angle);
        } else {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var t2 = 1 - c;
          this.apply(
            t2 * v0 * v0 + c,
            t2 * v0 * v1 - s * v2,
            t2 * v0 * v2 + s * v1,
            0,
            t2 * v0 * v1 + s * v2,
            t2 * v1 * v1 + c,
            t2 * v1 * v2 - s * v0,
            0,
            t2 * v0 * v2 - s * v1,
            t2 * v1 * v2 + s * v0,
            t2 * v2 * v2 + c,
            0,
            0,
            0,
            0,
            1
          );
        }
      },
      /**
       * @member PMatrix3D
       * The invApply() function applies the inverted matrix to this matrix.
       *
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the second element of the matrix
       * @param {float} m02           the third element of the matrix
       * @param {float} m03           the fourth element of the matrix
       * @param {float} m10           the fifth element of the matrix
       * @param {float} m11           the sixth element of the matrix
       * @param {float} m12           the seventh element of the matrix
       * @param {float} m13           the eight element of the matrix
       * @param {float} m20           the nineth element of the matrix
       * @param {float} m21           the tenth element of the matrix
       * @param {float} m22           the eleventh element of the matrix
       * @param {float} m23           the twelveth element of the matrix
       * @param {float} m30           the thirteenth element of the matrix
       * @param {float} m31           the fourtheenth element of the matrix
       * @param {float} m32           the fivetheenth element of the matrix
       * @param {float} m33           the sixteenth element of the matrix
       *
       * @return {boolean} returns true if the operation was successful.
       */
      invApply: function() {
        if (inverseCopy === undef) {
          inverseCopy = new PMatrix3D2();
        }
        var a = arguments;
        inverseCopy.set(
          a[0],
          a[1],
          a[2],
          a[3],
          a[4],
          a[5],
          a[6],
          a[7],
          a[8],
          a[9],
          a[10],
          a[11],
          a[12],
          a[13],
          a[14],
          a[15]
        );
        if (!inverseCopy.invert()) {
          return false;
        }
        this.preApply(inverseCopy);
        return true;
      },
      /**
       * @member PMatrix3D
       * The rotateZ() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotateX: function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);
      },
      /**
       * @member PMatrix3D
       * The rotateY() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotateY: function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);
      },
      /**
       * @member PMatrix3D
       * The rotateZ() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotateZ: function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      },
      /**
       * @member PMatrix3D
       * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.
       * This is equivalent to a three parameter call.
       *
       * @param {float} sx  the amount to scale on the x-axis
       * @param {float} sy  the amount to scale on the y-axis
       * @param {float} sz  the amount to scale on the z-axis
       */
      scale: function(sx, sy, sz) {
        if (sx && sy === undef && sz === undef) {
          sy = sz = sx;
        } else if (sx && sy && sz === undef) {
          sz = 1;
        }
        if (sx && sy && sz) {
          this.elements[0] *= sx;
          this.elements[1] *= sy;
          this.elements[2] *= sz;
          this.elements[4] *= sx;
          this.elements[5] *= sy;
          this.elements[6] *= sz;
          this.elements[8] *= sx;
          this.elements[9] *= sy;
          this.elements[10] *= sz;
          this.elements[12] *= sx;
          this.elements[13] *= sy;
          this.elements[14] *= sz;
        }
      },
      /**
       * @member PMatrix3D
       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      skewX: function(angle) {
        var t2 = Math.tan(angle);
        this.apply(1, t2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      /**
       * @member PMatrix3D
       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      skewY: function(angle) {
        var t2 = Math.tan(angle);
        this.apply(1, 0, 0, 0, t2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      /**
       * @member PMatrix3D
       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of shear specified in radians
       */
      shearX: function(angle) {
        var t2 = Math.tan(angle);
        this.apply(1, t2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      /**
       * @member PMatrix3D
       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of shear specified in radians
       */
      shearY: function(angle) {
        var t2 = Math.tan(angle);
        this.apply(1, 0, 0, 0, t2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      multX: function(x, y, z, w) {
        if (!z) {
          return this.elements[0] * x + this.elements[1] * y + this.elements[3];
        }
        if (!w) {
          return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
        }
        return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;
      },
      multY: function(x, y, z, w) {
        if (!z) {
          return this.elements[4] * x + this.elements[5] * y + this.elements[7];
        }
        if (!w) {
          return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
        }
        return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;
      },
      multZ: function(x, y, z, w) {
        if (!w) {
          return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
        }
        return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;
      },
      multW: function(x, y, z, w) {
        if (!w) {
          return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];
        }
        return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;
      },
      /**
       * @member PMatrix3D
       * The invert() function inverts this matrix
       *
       * @return {boolean} true if successful
       */
      invert: function() {
        var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];
        var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];
        var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];
        var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];
        var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];
        var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];
        var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];
        var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];
        var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];
        var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];
        var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];
        var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];
        var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;
        if (Math.abs(fDet) <= 1e-9) {
          return false;
        }
        var kInv = [];
        kInv[0] = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;
        kInv[4] = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;
        kInv[8] = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;
        kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;
        kInv[1] = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;
        kInv[5] = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;
        kInv[9] = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;
        kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;
        kInv[2] = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;
        kInv[6] = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;
        kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;
        kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;
        kInv[3] = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;
        kInv[7] = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;
        kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;
        kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;
        var fInvDet = 1 / fDet;
        kInv[0] *= fInvDet;
        kInv[1] *= fInvDet;
        kInv[2] *= fInvDet;
        kInv[3] *= fInvDet;
        kInv[4] *= fInvDet;
        kInv[5] *= fInvDet;
        kInv[6] *= fInvDet;
        kInv[7] *= fInvDet;
        kInv[8] *= fInvDet;
        kInv[9] *= fInvDet;
        kInv[10] *= fInvDet;
        kInv[11] *= fInvDet;
        kInv[12] *= fInvDet;
        kInv[13] *= fInvDet;
        kInv[14] *= fInvDet;
        kInv[15] *= fInvDet;
        this.elements = kInv.slice();
        return true;
      },
      toString: function() {
        var str = "";
        for (var i = 0; i < 15; i++) {
          str += this.elements[i] + ", ";
        }
        str += this.elements[15];
        return str;
      },
      /**
       * @member PMatrix3D
       * The print() function prints out the elements of this matrix
       */
      print: function() {
        var digits = printMatrixHelper(this.elements);
        var output = "" + p.nfs(this.elements[0], digits, 4) + " " + p.nfs(this.elements[1], digits, 4) + " " + p.nfs(this.elements[2], digits, 4) + " " + p.nfs(this.elements[3], digits, 4) + "\n" + p.nfs(this.elements[4], digits, 4) + " " + p.nfs(this.elements[5], digits, 4) + " " + p.nfs(this.elements[6], digits, 4) + " " + p.nfs(this.elements[7], digits, 4) + "\n" + p.nfs(this.elements[8], digits, 4) + " " + p.nfs(this.elements[9], digits, 4) + " " + p.nfs(this.elements[10], digits, 4) + " " + p.nfs(this.elements[11], digits, 4) + "\n" + p.nfs(this.elements[12], digits, 4) + " " + p.nfs(this.elements[13], digits, 4) + " " + p.nfs(this.elements[14], digits, 4) + " " + p.nfs(this.elements[15], digits, 4) + "\n\n";
        p.println(output);
      },
      invTranslate: function(tx, ty, tz) {
        this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);
      },
      invRotateX: function(angle) {
        var c = Math.cos(-angle);
        var s = Math.sin(-angle);
        this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);
      },
      invRotateY: function(angle) {
        var c = Math.cos(-angle);
        var s = Math.sin(-angle);
        this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);
      },
      invRotateZ: function(angle) {
        var c = Math.cos(-angle);
        var s = Math.sin(-angle);
        this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      },
      invScale: function(x, y, z) {
        this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);
      }
    };
    return PMatrix3D2;
  }
  var PMatrix3D_default = PMatrix3D;

  // src/Objects/PShape.js
  function PShape_default(options) {
    var PConstants3 = options.PConstants, PMatrix2D2 = options.PMatrix2D, PMatrix3D2 = options.PMatrix3D;
    var PShape = function(family) {
      this.family = family || PConstants3.GROUP;
      this.visible = true;
      this.style = true;
      this.children = [];
      this.nameTable = [];
      this.params = [];
      this.name = "";
      this.image = null;
      this.matrix = null;
      this.kind = null;
      this.close = null;
      this.width = null;
      this.height = null;
      this.parent = null;
    };
    PShape.prototype = {
      /**
       * @member PShape
       * The isVisible() function returns a boolean value "true" if the image is set to be visible, "false" if not. This is modified with the <b>setVisible()</b> parameter.
       * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.
       * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.
       *
       * @return {boolean}  returns "true" if the image is set to be visible, "false" if not
       */
      isVisible: function() {
        return this.visible;
      },
      /**
       * @member PShape
       * The setVisible() function sets the shape to be visible or invisible. This is determined by the value of the <b>visible</b> parameter.
       * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.
       * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.
       *
       * @param {boolean} visible "false" makes the shape invisible and "true" makes it visible
       */
      setVisible: function(visible) {
        this.visible = visible;
      },
      /**
       * @member PShape
       * The disableStyle() function disables the shape's style data and uses Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.
       * Overrides this shape's style information and uses PGraphics styles and colors. Identical to ignoreStyles(true). Also disables styles for all child shapes.
       */
      disableStyle: function() {
        this.style = false;
        for (var i = 0, j = this.children.length; i < j; i++) {
          this.children[i].disableStyle();
        }
      },
      /**
       * @member PShape
       * The enableStyle() function enables the shape's style data and ignores Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.
       */
      enableStyle: function() {
        this.style = true;
        for (var i = 0, j = this.children.length; i < j; i++) {
          this.children[i].enableStyle();
        }
      },
      /**
       * @member PShape
       * The getFamily function returns the shape type
       *
       * @return {int} the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY
       */
      getFamily: function() {
        return this.family;
      },
      /**
       * @member PShape
       * The getWidth() function gets the width of the drawing area (not necessarily the shape boundary).
       */
      getWidth: function() {
        return this.width;
      },
      /**
       * @member PShape
       * The getHeight() function gets the height of the drawing area (not necessarily the shape boundary).
       */
      getHeight: function() {
        return this.height;
      },
      /**
       * @member PShape
       * The setName() function sets the name of the shape
       *
       * @param {String} name the name of the shape
       */
      setName: function(name) {
        this.name = name;
      },
      /**
       * @member PShape
       * The getName() function returns the name of the shape
       *
       * @return {String} the name of the shape
       */
      getName: function() {
        return this.name;
      },
      /**
       * @member PShape
       * Called by the following (the shape() command adds the g)
       * PShape s = loadShapes("blah.svg");
       * shape(s);
       */
      draw: function(renderContext) {
        if (!renderContext) {
          throw "render context missing for draw() in PShape";
        }
        if (this.visible) {
          this.pre(renderContext);
          this.drawImpl(renderContext);
          this.post(renderContext);
        }
      },
      /**
       * @member PShape
       * the drawImpl() function draws the SVG document.
       */
      drawImpl: function(renderContext) {
        if (this.family === PConstants3.GROUP) {
          this.drawGroup(renderContext);
        } else if (this.family === PConstants3.PRIMITIVE) {
          this.drawPrimitive(renderContext);
        } else if (this.family === PConstants3.GEOMETRY) {
          this.drawGeometry(renderContext);
        } else if (this.family === PConstants3.PATH) {
          this.drawPath(renderContext);
        }
      },
      /**
       * @member PShape
       * The drawPath() function draws the <path> part of the SVG document.
       */
      drawPath: function(renderContext) {
        var i, j;
        if (this.vertices.length === 0) {
          return;
        }
        renderContext.beginShape();
        if (this.vertexCodes.length === 0) {
          if (this.vertices[0].length === 2) {
            for (i = 0, j = this.vertices.length; i < j; i++) {
              renderContext.vertex(this.vertices[i][0], this.vertices[i][1]);
            }
          } else {
            for (i = 0, j = this.vertices.length; i < j; i++) {
              renderContext.vertex(
                this.vertices[i][0],
                this.vertices[i][1],
                this.vertices[i][2]
              );
            }
          }
        } else {
          var index = 0;
          if (this.vertices[0].length === 2) {
            for (i = 0, j = this.vertexCodes.length; i < j; i++) {
              if (this.vertexCodes[i] === PConstants3.VERTEX) {
                renderContext.vertex(this.vertices[index][0], this.vertices[index][1], this.vertices[index].moveTo);
                renderContext.breakShape = false;
                index++;
              } else if (this.vertexCodes[i] === PConstants3.BEZIER_VERTEX) {
                renderContext.bezierVertex(
                  this.vertices[index + 0][0],
                  this.vertices[index + 0][1],
                  this.vertices[index + 1][0],
                  this.vertices[index + 1][1],
                  this.vertices[index + 2][0],
                  this.vertices[index + 2][1]
                );
                index += 3;
              } else if (this.vertexCodes[i] === PConstants3.CURVE_VERTEX) {
                renderContext.curveVertex(
                  this.vertices[index][0],
                  this.vertices[index][1]
                );
                index++;
              } else if (this.vertexCodes[i] === PConstants3.BREAK) {
                renderContext.breakShape = true;
              }
            }
          } else {
            for (i = 0, j = this.vertexCodes.length; i < j; i++) {
              if (this.vertexCodes[i] === PConstants3.VERTEX) {
                renderContext.vertex(
                  this.vertices[index][0],
                  this.vertices[index][1],
                  this.vertices[index][2]
                );
                if (this.vertices[index].moveTo === true) {
                  vertArray[vertArray.length - 1].moveTo = true;
                } else if (this.vertices[index].moveTo === false) {
                  vertArray[vertArray.length - 1].moveTo = false;
                }
                renderContext.breakShape = false;
              } else if (this.vertexCodes[i] === PConstants3.BEZIER_VERTEX) {
                renderContext.bezierVertex(
                  this.vertices[index + 0][0],
                  this.vertices[index + 0][1],
                  this.vertices[index + 0][2],
                  this.vertices[index + 1][0],
                  this.vertices[index + 1][1],
                  this.vertices[index + 1][2],
                  this.vertices[index + 2][0],
                  this.vertices[index + 2][1],
                  this.vertices[index + 2][2]
                );
                index += 3;
              } else if (this.vertexCodes[i] === PConstants3.CURVE_VERTEX) {
                renderContext.curveVertex(
                  this.vertices[index][0],
                  this.vertices[index][1],
                  this.vertices[index][2]
                );
                index++;
              } else if (this.vertexCodes[i] === PConstants3.BREAK) {
                renderContext.breakShape = true;
              }
            }
          }
        }
        renderContext.endShape(this.close ? PConstants3.CLOSE : PConstants3.OPEN);
      },
      /**
       * @member PShape
       * The drawGeometry() function draws the geometry part of the SVG document.
       */
      drawGeometry: function(renderContext) {
        var i, j;
        renderContext.beginShape(this.kind);
        if (this.style) {
          for (i = 0, j = this.vertices.length; i < j; i++) {
            renderContext.vertex(this.vertices[i]);
          }
        } else {
          for (i = 0, j = this.vertices.length; i < j; i++) {
            var vert = this.vertices[i];
            if (vert[2] === 0) {
              renderContext.vertex(vert[0], vert[1]);
            } else {
              renderContext.vertex(vert[0], vert[1], vert[2]);
            }
          }
        }
        renderContext.endShape();
      },
      /**
       * @member PShape
       * The drawGroup() function draws the <g> part of the SVG document.
       */
      drawGroup: function(renderContext) {
        for (var i = 0, j = this.children.length; i < j; i++) {
          this.children[i].draw(renderContext);
        }
      },
      /**
       * @member PShape
       * The drawPrimitive() function draws SVG document shape elements. These can be point, line, triangle, quad, rect, ellipse, arc, box, or sphere.
       */
      drawPrimitive: function(renderContext) {
        if (this.kind === PConstants3.POINT) {
          renderContext.point(this.params[0], this.params[1]);
        } else if (this.kind === PConstants3.LINE) {
          if (this.params.length === 4) {
            renderContext.line(
              this.params[0],
              this.params[1],
              this.params[2],
              this.params[3]
            );
          } else {
            renderContext.line(
              this.params[0],
              this.params[1],
              this.params[2],
              this.params[3],
              this.params[4],
              this.params[5]
            );
          }
        } else if (this.kind === PConstants3.TRIANGLE) {
          renderContext.triangle(
            this.params[0],
            this.params[1],
            this.params[2],
            this.params[3],
            this.params[4],
            this.params[5]
          );
        } else if (this.kind === PConstants3.QUAD) {
          renderContext.quad(
            this.params[0],
            this.params[1],
            this.params[2],
            this.params[3],
            this.params[4],
            this.params[5],
            this.params[6],
            this.params[7]
          );
        } else if (this.kind === PConstants3.RECT) {
          if (this.image !== null) {
            var imMode = imageModeConvert;
            renderContext.imageMode(PConstants3.CORNER);
            renderContext.image(
              this.image,
              this.params[0],
              this.params[1],
              this.params[2],
              this.params[3]
            );
            imageModeConvert = imMode;
          } else {
            var rcMode = renderContext.curRectMode;
            renderContext.rectMode(PConstants3.CORNER);
            renderContext.rect(
              this.params[0],
              this.params[1],
              this.params[2],
              this.params[3]
            );
            renderContext.curRectMode = rcMode;
          }
        } else if (this.kind === PConstants3.ELLIPSE) {
          var elMode = renderContext.curEllipseMode;
          renderContext.ellipseMode(PConstants3.CORNER);
          renderContext.ellipse(
            this.params[0],
            this.params[1],
            this.params[2],
            this.params[3]
          );
          renderContext.curEllipseMode = elMode;
        } else if (this.kind === PConstants3.ARC) {
          var eMode = curEllipseMode;
          renderContext.ellipseMode(PConstants3.CORNER);
          renderContext.arc(
            this.params[0],
            this.params[1],
            this.params[2],
            this.params[3],
            this.params[4],
            this.params[5]
          );
          curEllipseMode = eMode;
        } else if (this.kind === PConstants3.BOX) {
          if (this.params.length === 1) {
            renderContext.box(this.params[0]);
          } else {
            renderContext.box(this.params[0], this.params[1], this.params[2]);
          }
        } else if (this.kind === PConstants3.SPHERE) {
          renderContext.sphere(this.params[0]);
        }
      },
      /**
       * @member PShape
       * The pre() function performs the preparations before the SVG is drawn. This includes doing transformations and storing previous styles.
       */
      pre: function(renderContext) {
        if (this.matrix) {
          renderContext.pushMatrix();
          renderContext.transform(this.matrix);
        }
        if (this.style) {
          renderContext.pushStyle();
          this.styles(renderContext);
        }
      },
      /**
       * @member PShape
       * The post() function performs the necessary actions after the SVG is drawn. This includes removing transformations and removing added styles.
       */
      post: function(renderContext) {
        if (this.matrix) {
          renderContext.popMatrix();
        }
        if (this.style) {
          renderContext.popStyle();
        }
      },
      /**
       * @member PShape
       * The styles() function changes the Processing's current styles
       */
      styles: function(renderContext) {
        if (this.stroke) {
          renderContext.stroke(this.strokeColor);
          renderContext.strokeWeight(this.strokeWeight);
          renderContext.strokeCap(this.strokeCap);
          renderContext.strokeJoin(this.strokeJoin);
        } else {
          renderContext.noStroke();
        }
        if (this.fill) {
          renderContext.fill(this.fillColor);
        } else {
          renderContext.noFill();
        }
      },
      /**
       * @member PShape
       * The getChild() function extracts a child shape from a parent shape. Specify the name of the shape with the <b>target</b> parameter or the
       * layer position of the shape to get with the <b>index</b> parameter.
       * The shape is returned as a <b>PShape</b> object, or <b>null</b> is returned if there is an error.
       *
       * @param {String} target   the name of the shape to get
       * @param {int} index   the layer position of the shape to get
       *
       * @return {PShape} returns a child element of a shape as a PShape object or null if there is an error
       */
      getChild: function(child) {
        var i, j;
        if (typeof child === "number") {
          return this.children[child];
        }
        var found;
        if (child === "" || this.name === child) {
          return this;
        }
        if (this.nameTable.length > 0) {
          for (i = 0, j = this.nameTable.length; i < j || found; i++) {
            if (this.nameTable[i].getName === child) {
              found = this.nameTable[i];
              break;
            }
          }
          if (found) {
            return found;
          }
        }
        for (i = 0, j = this.children.length; i < j; i++) {
          found = this.children[i].getChild(child);
          if (found) {
            return found;
          }
        }
        return null;
      },
      /**
       * @member PShape
       * The getChildCount() returns the number of children
       *
       * @return {int} returns a count of children
       */
      getChildCount: function() {
        return this.children.length;
      },
      /**
       * @member PShape
       * The addChild() adds a child to the PShape.
       *
       * @param {PShape} child the child to add
       */
      addChild: function(child) {
        this.children.push(child);
        child.parent = this;
        if (child.getName() !== null) {
          this.addName(child.getName(), child);
        }
      },
      /**
       * @member PShape
       * The addName() functions adds a shape to the name lookup table.
       *
       * @param {String} name   the name to be added
       * @param {PShape} shape  the shape
       */
      addName: function(name, shape) {
        if (this.parent !== null) {
          this.parent.addName(name, shape);
        } else {
          this.nameTable.push([name, shape]);
        }
      },
      /**
       * @member PShape
       * The translate() function specifies an amount to displace the shape. The <b>x</b> parameter specifies left/right translation, the <b>y</b> parameter specifies up/down translation, and the <b>z</b> parameter specifies translations toward/away from the screen.
       * Subsequent calls to the method accumulates the effect. For example, calling <b>translate(50, 0)</b> and then <b>translate(20, 0)</b> is the same as <b>translate(70, 0)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>Using this method with the <b>z</b> parameter requires using the P3D or OPENGL parameter in combination with size.
       *
       * @param {int|float} x left/right translation
       * @param {int|float} y up/down translation
       * @param {int|float} z forward/back translation
       *
       * @see PMatrix2D#translate
       * @see PMatrix3D#translate
       */
      translate: function() {
        if (arguments.length === 2) {
          this.checkMatrix(2);
          this.matrix.translate(arguments[0], arguments[1]);
        } else {
          this.checkMatrix(3);
          this.matrix.translate(arguments[0], arguments[1], 0);
        }
      },
      /**
       * @member PShape
       * The checkMatrix() function makes sure that the shape's matrix is 1) not null, and 2) has a matrix
       * that can handle <em>at least</em> the specified number of dimensions.
       *
       * @param {int} dimensions the specified number of dimensions
       */
      checkMatrix: function(dimensions) {
        if (this.matrix === null) {
          if (dimensions === 2) {
            this.matrix = new PMatrix2D2();
          } else {
            this.matrix = new PMatrix3D2();
          }
        } else if (dimensions === 3 && this.matrix instanceof PMatrix2D2) {
          this.matrix = new PMatrix3D2();
        }
      },
      /**
       * @member PShape
       * The rotateX() function rotates a shape around the x-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.
       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.
       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateX(HALF_PI)</b> and then <b>rotateX(HALF_PI)</b> is the same as <b>rotateX(PI)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.
       *
       * @param {float}angle angle of rotation specified in radians
       *
       * @see PMatrix3D#rotateX
       */
      rotateX: function(angle) {
        this.rotate(angle, 1, 0, 0);
      },
      /**
       * @member PShape
       * The rotateY() function rotates a shape around the y-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.
       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.
       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateY(HALF_PI)</b> and then <b>rotateY(HALF_PI)</b> is the same as <b>rotateY(PI)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.
       *
       * @param {float}angle angle of rotation specified in radians
       *
       * @see PMatrix3D#rotateY
       */
      rotateY: function(angle) {
        this.rotate(angle, 0, 1, 0);
      },
      /**
       * @member PShape
       * The rotateZ() function rotates a shape around the z-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.
       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.
       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateZ(HALF_PI)</b> and then <b>rotateZ(HALF_PI)</b> is the same as <b>rotateZ(PI)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.
       *
       * @param {float}angle angle of rotation specified in radians
       *
       * @see PMatrix3D#rotateZ
       */
      rotateZ: function(angle) {
        this.rotate(angle, 0, 0, 1);
      },
      /**
       * @member PShape
       * The rotate() function rotates a shape the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.
       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.
       * Transformations apply to everything that happens after and subsequent calls to the method accumulates the effect.
       * For example, calling <b>rotate(HALF_PI)</b> and then <b>rotate(HALF_PI)</b> is the same as <b>rotate(PI)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * If optional parameters x,y,z are supplied, the rotate is about the point (x, y, z).
       *
       * @param {float}angle  angle of rotation specified in radians
       * @param {float}x      x-coordinate of the point
       * @param {float}y      y-coordinate of the point
       * @param {float}z      z-coordinate of the point
       * @see PMatrix2D#rotate
       * @see PMatrix3D#rotate
       */
      rotate: function() {
        if (arguments.length === 1) {
          this.checkMatrix(2);
          this.matrix.rotate(arguments[0]);
        } else {
          this.checkMatrix(3);
          this.matrix.rotate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3]
          );
        }
      },
      /**
       * @member PShape
       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. Shapes always scale from the relative origin of their bounding box.
       * Scale values are specified as decimal percentages. For example, the method call <b>scale(2.0)</b> increases the dimension of a shape by 200%.
       * Subsequent calls to the method multiply the effect. For example, calling <b>scale(2.0)</b> and then <b>scale(1.5)</b> is the same as <b>scale(3.0)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>Using this fuction with the <b>z</b> parameter requires passing P3D or OPENGL into the size() parameter.
       *
       * @param {float}s      percentage to scale the object
       * @param {float}x      percentage to scale the object in the x-axis
       * @param {float}y      percentage to scale the object in the y-axis
       * @param {float}z      percentage to scale the object in the z-axis
       *
       * @see PMatrix2D#scale
       * @see PMatrix3D#scale
       */
      scale: function() {
        if (arguments.length === 2) {
          this.checkMatrix(2);
          this.matrix.scale(arguments[0], arguments[1]);
        } else if (arguments.length === 3) {
          this.checkMatrix(2);
          this.matrix.scale(arguments[0], arguments[1], arguments[2]);
        } else {
          this.checkMatrix(2);
          this.matrix.scale(arguments[0]);
        }
      },
      /**
       * @member PShape
       * The resetMatrix() function resets the matrix
       *
       * @see PMatrix2D#reset
       * @see PMatrix3D#reset
       */
      resetMatrix: function() {
        this.checkMatrix(2);
        this.matrix.reset();
      },
      /**
       * @member PShape
       * The applyMatrix() function multiplies this matrix by another matrix of type PMatrix3D or PMatrix2D.
       * Individual elements can also be provided
       *
       * @param {PMatrix3D|PMatrix2D} matrix   the matrix to multiply by
       *
       * @see PMatrix2D#apply
       * @see PMatrix3D#apply
       */
      applyMatrix: function(matrix) {
        if (arguments.length === 1) {
          this.applyMatrix(
            matrix.elements[0],
            matrix.elements[1],
            0,
            matrix.elements[2],
            matrix.elements[3],
            matrix.elements[4],
            0,
            matrix.elements[5],
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          );
        } else if (arguments.length === 6) {
          this.checkMatrix(2);
          this.matrix.apply(
            arguments[0],
            arguments[1],
            arguments[2],
            0,
            arguments[3],
            arguments[4],
            arguments[5],
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          );
        } else if (arguments.length === 16) {
          this.checkMatrix(3);
          this.matrix.apply(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5],
            arguments[6],
            arguments[7],
            arguments[8],
            arguments[9],
            arguments[10],
            arguments[11],
            arguments[12],
            arguments[13],
            arguments[14],
            arguments[15]
          );
        }
      }
    };
    return PShape;
  }

  // src/Objects/webcolors.js
  var webcolors_default = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgrey: "#d3d3d3",
    lightgreen: "#90ee90",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370d8",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#d87093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };

  // src/Objects/PShapeSVG.js
  function PShapeSVG(options) {
    var CommonFunctions = options.CommonFunctions();
    var PConstants3 = options.PConstants;
    var PShape = options.PShape;
    var XMLElement = options.XMLElement;
    var colors = options.colors;
    var PShapeSVG2 = function() {
      PShape.call(this);
      if (arguments.length === 1) {
        this.element = arguments[0];
        this.vertexCodes = [];
        this.vertices = [];
        this.opacity = 1;
        this.stroke = false;
        this.strokeColor = PConstants3.ALPHA_MASK;
        this.strokeWeight = 1;
        this.strokeCap = PConstants3.SQUARE;
        this.strokeJoin = PConstants3.MITER;
        this.strokeGradient = null;
        this.strokeGradientPaint = null;
        this.strokeName = null;
        this.strokeOpacity = 1;
        this.fill = true;
        this.fillColor = PConstants3.ALPHA_MASK;
        this.fillGradient = null;
        this.fillGradientPaint = null;
        this.fillName = null;
        this.fillOpacity = 1;
        if (this.element.getName() !== "svg") {
          throw "root is not <svg>, it's <" + this.element.getName() + ">";
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[1] === "string") {
          if (arguments[1].indexOf(".svg") > -1) {
            this.element = new XMLElement(true, arguments[1]);
            this.vertexCodes = [];
            this.vertices = [];
            this.opacity = 1;
            this.stroke = false;
            this.strokeColor = PConstants3.ALPHA_MASK;
            this.strokeWeight = 1;
            this.strokeCap = PConstants3.SQUARE;
            this.strokeJoin = PConstants3.MITER;
            this.strokeGradient = "";
            this.strokeGradientPaint = "";
            this.strokeName = "";
            this.strokeOpacity = 1;
            this.fill = true;
            this.fillColor = PConstants3.ALPHA_MASK;
            this.fillGradient = null;
            this.fillGradientPaint = null;
            this.fillOpacity = 1;
          }
        } else {
          if (arguments[0]) {
            this.element = arguments[1];
            this.vertexCodes = arguments[0].vertexCodes.slice();
            this.vertices = arguments[0].vertices.slice();
            this.stroke = arguments[0].stroke;
            this.strokeColor = arguments[0].strokeColor;
            this.strokeWeight = arguments[0].strokeWeight;
            this.strokeCap = arguments[0].strokeCap;
            this.strokeJoin = arguments[0].strokeJoin;
            this.strokeGradient = arguments[0].strokeGradient;
            this.strokeGradientPaint = arguments[0].strokeGradientPaint;
            this.strokeName = arguments[0].strokeName;
            this.fill = arguments[0].fill;
            this.fillColor = arguments[0].fillColor;
            this.fillGradient = arguments[0].fillGradient;
            this.fillGradientPaint = arguments[0].fillGradientPaint;
            this.fillName = arguments[0].fillName;
            this.strokeOpacity = arguments[0].strokeOpacity;
            this.fillOpacity = arguments[0].fillOpacity;
            this.opacity = arguments[0].opacity;
          }
        }
      }
      this.name = this.element.getStringAttribute("id");
      var displayStr = this.element.getStringAttribute("display", "inline");
      this.visible = displayStr !== "none";
      var str = this.element.getAttribute("transform");
      if (str) {
        this.matrix = this.parseMatrix(str);
      }
      var viewBoxStr = this.element.getStringAttribute("viewBox");
      if (viewBoxStr !== null) {
        var viewBox = viewBoxStr.split(" ");
        this.width = viewBox[2];
        this.height = viewBox[3];
      }
      var unitWidth = this.element.getStringAttribute("width");
      var unitHeight = this.element.getStringAttribute("height");
      if (unitWidth !== null) {
        this.width = this.parseUnitSize(unitWidth);
        this.height = this.parseUnitSize(unitHeight);
      } else {
        if (this.width === 0 || this.height === 0) {
          this.width = 1;
          this.height = 1;
          throw "The width and/or height is not readable in the <svg> tag of this file.";
        }
      }
      this.parseColors(this.element);
      this.parseChildren(this.element);
    };
    PShapeSVG2.prototype = new PShape();
    PShapeSVG2.prototype.parseMatrix = /* @__PURE__ */ function() {
      function getCoords(s) {
        var m = [];
        s.replace(/\((.*?)\)/, /* @__PURE__ */ function() {
          return function(all, params) {
            m = params.replace(/,+/g, " ").split(/\s+/);
          };
        }());
        return m;
      }
      return function(str) {
        this.checkMatrix(2);
        var pieces = [];
        str.replace(/\s*(\w+)\((.*?)\)/g, function(all) {
          pieces.push(CommonFunctions.trim(all));
        });
        if (pieces.length === 0) {
          return null;
        }
        for (var i = 0, j = pieces.length; i < j; i++) {
          var m = getCoords(pieces[i]);
          if (pieces[i].indexOf("matrix") !== -1) {
            this.matrix.set(m[0], m[2], m[4], m[1], m[3], m[5]);
          } else if (pieces[i].indexOf("translate") !== -1) {
            var tx = m[0];
            var ty = m.length === 2 ? m[1] : 0;
            this.matrix.translate(tx, ty);
          } else if (pieces[i].indexOf("scale") !== -1) {
            var sx = m[0];
            var sy = m.length === 2 ? m[1] : m[0];
            this.matrix.scale(sx, sy);
          } else if (pieces[i].indexOf("rotate") !== -1) {
            var angle = m[0];
            if (m.length === 1) {
              this.matrix.rotate(CommonFunctions.radians(angle));
            } else if (m.length === 3) {
              this.matrix.translate(m[1], m[2]);
              this.matrix.rotate(CommonFunctions.radians(m[0]));
              this.matrix.translate(-m[1], -m[2]);
            }
          } else if (pieces[i].indexOf("skewX") !== -1) {
            this.matrix.skewX(parseFloat(m[0]));
          } else if (pieces[i].indexOf("skewY") !== -1) {
            this.matrix.skewY(m[0]);
          } else if (pieces[i].indexOf("shearX") !== -1) {
            this.matrix.shearX(m[0]);
          } else if (pieces[i].indexOf("shearY") !== -1) {
            this.matrix.shearY(m[0]);
          }
        }
        return this.matrix;
      };
    }();
    PShapeSVG2.prototype.parseChildren = function(element) {
      var newelement = element.getChildren();
      var base = new PShape();
      var i, j;
      for (i = 0, j = newelement.length; i < j; i++) {
        var kid = this.parseChild(newelement[i]);
        if (kid) {
          base.addChild(kid);
        }
      }
      for (i = 0, j = base.children.length; i < j; i++) {
        this.children.push(base.children[i]);
      }
    };
    PShapeSVG2.prototype.getName = function() {
      return this.name;
    };
    PShapeSVG2.prototype.parseChild = function(elem) {
      var name = elem.getName();
      var shape;
      if (name === "g") {
        shape = new PShapeSVG2(this, elem);
      } else if (name === "defs") {
        shape = new PShapeSVG2(this, elem);
      } else if (name === "line") {
        shape = new PShapeSVG2(this, elem);
        shape.parseLine();
      } else if (name === "circle") {
        shape = new PShapeSVG2(this, elem);
        shape.parseEllipse(true);
      } else if (name === "ellipse") {
        shape = new PShapeSVG2(this, elem);
        shape.parseEllipse(false);
      } else if (name === "rect") {
        shape = new PShapeSVG2(this, elem);
        shape.parseRect();
      } else if (name === "polygon") {
        shape = new PShapeSVG2(this, elem);
        shape.parsePoly(true);
      } else if (name === "polyline") {
        shape = new PShapeSVG2(this, elem);
        shape.parsePoly(false);
      } else if (name === "path") {
        shape = new PShapeSVG2(this, elem);
        shape.parsePath();
      } else if (name === "radialGradient") {
        unimplemented("PShapeSVG.prototype.parseChild, name = radialGradient");
      } else if (name === "linearGradient") {
        unimplemented("PShapeSVG.prototype.parseChild, name = linearGradient");
      } else if (name === "text") {
        unimplemented("PShapeSVG.prototype.parseChild, name = text");
      } else if (name === "filter") {
        unimplemented("PShapeSVG.prototype.parseChild, name = filter");
      } else if (name === "mask") {
        unimplemented("PShapeSVG.prototype.parseChild, name = mask");
      } else {
      }
      return shape;
    };
    PShapeSVG2.prototype.parsePath = function() {
      this.family = PConstants3.PATH;
      this.kind = 0;
      var pathDataChars = [];
      var c;
      var pathData = CommonFunctions.trim(this.element.getStringAttribute("d").replace(/[\s,]+/g, " "));
      if (pathData === null) {
        return;
      }
      pathData = pathData.split("");
      var cx = 0, cy = 0, ctrlX = 0, ctrlY = 0, ctrlX1 = 0, ctrlX2 = 0, ctrlY1 = 0, ctrlY2 = 0, endX = 0, endY = 0, ppx = 0, ppy = 0, px = 0, py = 0, i = 0, valOf = 0;
      var str = "";
      var tmpArray = [];
      var flag = false;
      var lastInstruction;
      var command;
      var j, k;
      while (i < pathData.length) {
        valOf = pathData[i].charCodeAt(0);
        if (valOf >= 65 && valOf <= 90 || valOf >= 97 && valOf <= 122) {
          j = i;
          i++;
          if (i < pathData.length) {
            tmpArray = [];
            valOf = pathData[i].charCodeAt(0);
            while (!(valOf >= 65 && valOf <= 90 || valOf >= 97 && valOf <= 100 || valOf >= 102 && valOf <= 122) && flag === false) {
              if (valOf === 32) {
                if (str !== "") {
                  tmpArray.push(parseFloat(str));
                  str = "";
                }
                i++;
              } else if (valOf === 45) {
                if (pathData[i - 1].charCodeAt(0) === 101) {
                  str += pathData[i].toString();
                  i++;
                } else {
                  if (str !== "") {
                    tmpArray.push(parseFloat(str));
                  }
                  str = pathData[i].toString();
                  i++;
                }
              } else {
                str += pathData[i].toString();
                i++;
              }
              if (i === pathData.length) {
                flag = true;
              } else {
                valOf = pathData[i].charCodeAt(0);
              }
            }
          }
          if (str !== "") {
            tmpArray.push(parseFloat(str));
            str = "";
          }
          command = pathData[j];
          valOf = command.charCodeAt(0);
          if (valOf === 77) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              cx = tmpArray[0];
              cy = tmpArray[1];
              this.parsePathMoveto(cx, cy);
              if (tmpArray.length > 2) {
                for (j = 2, k = tmpArray.length; j < k; j += 2) {
                  cx = tmpArray[j];
                  cy = tmpArray[j + 1];
                  this.parsePathLineto(cx, cy);
                }
              }
            }
          } else if (valOf === 109) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              cx += tmpArray[0];
              cy += tmpArray[1];
              this.parsePathMoveto(cx, cy);
              if (tmpArray.length > 2) {
                for (j = 2, k = tmpArray.length; j < k; j += 2) {
                  cx += tmpArray[j];
                  cy += tmpArray[j + 1];
                  this.parsePathLineto(cx, cy);
                }
              }
            }
          } else if (valOf === 76) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 2) {
                cx = tmpArray[j];
                cy = tmpArray[j + 1];
                this.parsePathLineto(cx, cy);
              }
            }
          } else if (valOf === 108) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 2) {
                cx += tmpArray[j];
                cy += tmpArray[j + 1];
                this.parsePathLineto(cx, cy);
              }
            }
          } else if (valOf === 72) {
            for (j = 0, k = tmpArray.length; j < k; j++) {
              cx = tmpArray[j];
              this.parsePathLineto(cx, cy);
            }
          } else if (valOf === 104) {
            for (j = 0, k = tmpArray.length; j < k; j++) {
              cx += tmpArray[j];
              this.parsePathLineto(cx, cy);
            }
          } else if (valOf === 86) {
            for (j = 0, k = tmpArray.length; j < k; j++) {
              cy = tmpArray[j];
              this.parsePathLineto(cx, cy);
            }
          } else if (valOf === 118) {
            for (j = 0, k = tmpArray.length; j < k; j++) {
              cy += tmpArray[j];
              this.parsePathLineto(cx, cy);
            }
          } else if (valOf === 67) {
            if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 6) {
                ctrlX1 = tmpArray[j];
                ctrlY1 = tmpArray[j + 1];
                ctrlX2 = tmpArray[j + 2];
                ctrlY2 = tmpArray[j + 3];
                endX = tmpArray[j + 4];
                endY = tmpArray[j + 5];
                this.parsePathCurveto(
                  ctrlX1,
                  ctrlY1,
                  ctrlX2,
                  ctrlY2,
                  endX,
                  endY
                );
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 99) {
            if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 6) {
                ctrlX1 = cx + tmpArray[j];
                ctrlY1 = cy + tmpArray[j + 1];
                ctrlX2 = cx + tmpArray[j + 2];
                ctrlY2 = cy + tmpArray[j + 3];
                endX = cx + tmpArray[j + 4];
                endY = cy + tmpArray[j + 5];
                this.parsePathCurveto(
                  ctrlX1,
                  ctrlY1,
                  ctrlX2,
                  ctrlY2,
                  endX,
                  endY
                );
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 83) {
            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 4) {
                if (lastInstruction.toLowerCase() === "c" || lastInstruction.toLowerCase() === "s") {
                  ppx = this.vertices[this.vertices.length - 2][0];
                  ppy = this.vertices[this.vertices.length - 2][1];
                  px = this.vertices[this.vertices.length - 1][0];
                  py = this.vertices[this.vertices.length - 1][1];
                  ctrlX1 = px + (px - ppx);
                  ctrlY1 = py + (py - ppy);
                } else {
                  ctrlX1 = this.vertices[this.vertices.length - 1][0];
                  ctrlY1 = this.vertices[this.vertices.length - 1][1];
                }
                ctrlX2 = tmpArray[j];
                ctrlY2 = tmpArray[j + 1];
                endX = tmpArray[j + 2];
                endY = tmpArray[j + 3];
                this.parsePathCurveto(
                  ctrlX1,
                  ctrlY1,
                  ctrlX2,
                  ctrlY2,
                  endX,
                  endY
                );
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 115) {
            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 4) {
                if (lastInstruction.toLowerCase() === "c" || lastInstruction.toLowerCase() === "s") {
                  ppx = this.vertices[this.vertices.length - 2][0];
                  ppy = this.vertices[this.vertices.length - 2][1];
                  px = this.vertices[this.vertices.length - 1][0];
                  py = this.vertices[this.vertices.length - 1][1];
                  ctrlX1 = px + (px - ppx);
                  ctrlY1 = py + (py - ppy);
                } else {
                  ctrlX1 = this.vertices[this.vertices.length - 1][0];
                  ctrlY1 = this.vertices[this.vertices.length - 1][1];
                }
                ctrlX2 = cx + tmpArray[j];
                ctrlY2 = cy + tmpArray[j + 1];
                endX = cx + tmpArray[j + 2];
                endY = cy + tmpArray[j + 3];
                this.parsePathCurveto(
                  ctrlX1,
                  ctrlY1,
                  ctrlX2,
                  ctrlY2,
                  endX,
                  endY
                );
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 81) {
            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 4) {
                ctrlX = tmpArray[j];
                ctrlY = tmpArray[j + 1];
                endX = tmpArray[j + 2];
                endY = tmpArray[j + 3];
                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 113) {
            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 4) {
                ctrlX = cx + tmpArray[j];
                ctrlY = cy + tmpArray[j + 1];
                endX = cx + tmpArray[j + 2];
                endY = cy + tmpArray[j + 3];
                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 84) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 2) {
                if (lastInstruction.toLowerCase() === "q" || lastInstruction.toLowerCase() === "t") {
                  ppx = this.vertices[this.vertices.length - 2][0];
                  ppy = this.vertices[this.vertices.length - 2][1];
                  px = this.vertices[this.vertices.length - 1][0];
                  py = this.vertices[this.vertices.length - 1][1];
                  ctrlX = px + (px - ppx);
                  ctrlY = py + (py - ppy);
                } else {
                  ctrlX = cx;
                  ctrlY = cy;
                }
                endX = tmpArray[j];
                endY = tmpArray[j + 1];
                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 116) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 2) {
                if (lastInstruction.toLowerCase() === "q" || lastInstruction.toLowerCase() === "t") {
                  ppx = this.vertices[this.vertices.length - 2][0];
                  ppy = this.vertices[this.vertices.length - 2][1];
                  px = this.vertices[this.vertices.length - 1][0];
                  py = this.vertices[this.vertices.length - 1][1];
                  ctrlX = px + (px - ppx);
                  ctrlY = py + (py - ppy);
                } else {
                  ctrlX = cx;
                  ctrlY = cy;
                }
                endX = cx + tmpArray[j];
                endY = cy + tmpArray[j + 1];
                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 90 || valOf === 122) {
            this.close = true;
          }
          lastInstruction = command.toString();
        } else {
          i++;
        }
      }
    };
    PShapeSVG2.prototype.parsePathQuadto = function(x1, y1, cx, cy, x2, y2) {
      if (this.vertices.length > 0) {
        this.parsePathCode(PConstants3.BEZIER_VERTEX);
        this.parsePathVertex(x1 + (cx - x1) * 2 / 3, y1 + (cy - y1) * 2 / 3);
        this.parsePathVertex(x2 + (cx - x2) * 2 / 3, y2 + (cy - y2) * 2 / 3);
        this.parsePathVertex(x2, y2);
      } else {
        throw "Path must start with M/m";
      }
    };
    PShapeSVG2.prototype.parsePathCurveto = function(x1, y1, x2, y2, x3, y3) {
      if (this.vertices.length > 0) {
        this.parsePathCode(PConstants3.BEZIER_VERTEX);
        this.parsePathVertex(x1, y1);
        this.parsePathVertex(x2, y2);
        this.parsePathVertex(x3, y3);
      } else {
        throw "Path must start with M/m";
      }
    };
    PShapeSVG2.prototype.parsePathLineto = function(px, py) {
      if (this.vertices.length > 0) {
        this.parsePathCode(PConstants3.VERTEX);
        this.parsePathVertex(px, py);
        this.vertices[this.vertices.length - 1].moveTo = false;
      } else {
        throw "Path must start with M/m";
      }
    };
    PShapeSVG2.prototype.parsePathMoveto = function(px, py) {
      if (this.vertices.length > 0) {
        this.parsePathCode(PConstants3.BREAK);
      }
      this.parsePathCode(PConstants3.VERTEX);
      this.parsePathVertex(px, py);
      this.vertices[this.vertices.length - 1].moveTo = true;
    };
    PShapeSVG2.prototype.parsePathVertex = function(x, y) {
      var verts = [];
      verts[0] = x;
      verts[1] = y;
      this.vertices.push(verts);
    };
    PShapeSVG2.prototype.parsePathCode = function(what) {
      this.vertexCodes.push(what);
    };
    PShapeSVG2.prototype.parsePoly = function(val) {
      this.family = PConstants3.PATH;
      this.close = val;
      var pointsAttr = CommonFunctions.trim(this.element.getStringAttribute("points").replace(/[,\s]+/g, " "));
      if (pointsAttr !== null) {
        var pointsBuffer = pointsAttr.split(" ");
        if (pointsBuffer.length % 2 === 0) {
          for (var i = 0, j = pointsBuffer.length; i < j; i++) {
            var verts = [];
            verts[0] = pointsBuffer[i];
            verts[1] = pointsBuffer[++i];
            this.vertices.push(verts);
          }
        } else {
          throw "Error parsing polygon points: odd number of coordinates provided";
        }
      }
    };
    PShapeSVG2.prototype.parseRect = function() {
      this.kind = PConstants3.RECT;
      this.family = PConstants3.PRIMITIVE;
      this.params = [];
      this.params[0] = this.element.getFloatAttribute("x");
      this.params[1] = this.element.getFloatAttribute("y");
      this.params[2] = this.element.getFloatAttribute("width");
      this.params[3] = this.element.getFloatAttribute("height");
      if (this.params[2] < 0 || this.params[3] < 0) {
        throw "svg error: negative width or height found while parsing <rect>";
      }
    };
    PShapeSVG2.prototype.parseEllipse = function(val) {
      this.kind = PConstants3.ELLIPSE;
      this.family = PConstants3.PRIMITIVE;
      this.params = [];
      this.params[0] = this.element.getFloatAttribute("cx") | 0;
      this.params[1] = this.element.getFloatAttribute("cy") | 0;
      var rx, ry;
      if (val) {
        rx = ry = this.element.getFloatAttribute("r");
        if (rx < 0) {
          throw "svg error: negative radius found while parsing <circle>";
        }
      } else {
        rx = this.element.getFloatAttribute("rx");
        ry = this.element.getFloatAttribute("ry");
        if (rx < 0 || ry < 0) {
          throw "svg error: negative x-axis radius or y-axis radius found while parsing <ellipse>";
        }
      }
      this.params[0] -= rx;
      this.params[1] -= ry;
      this.params[2] = rx * 2;
      this.params[3] = ry * 2;
    };
    PShapeSVG2.prototype.parseLine = function() {
      this.kind = PConstants3.LINE;
      this.family = PConstants3.PRIMITIVE;
      this.params = [];
      this.params[0] = this.element.getFloatAttribute("x1");
      this.params[1] = this.element.getFloatAttribute("y1");
      this.params[2] = this.element.getFloatAttribute("x2");
      this.params[3] = this.element.getFloatAttribute("y2");
    };
    PShapeSVG2.prototype.parseColors = function(element) {
      if (element.hasAttribute("opacity")) {
        this.setOpacity(element.getAttribute("opacity"));
      }
      if (element.hasAttribute("stroke")) {
        this.setStroke(element.getAttribute("stroke"));
      }
      if (element.hasAttribute("stroke-width")) {
        this.setStrokeWeight(element.getAttribute("stroke-width"));
      }
      if (element.hasAttribute("stroke-linejoin")) {
        this.setStrokeJoin(element.getAttribute("stroke-linejoin"));
      }
      if (element.hasAttribute("stroke-linecap")) {
        this.setStrokeCap(element.getStringAttribute("stroke-linecap"));
      }
      if (element.hasAttribute("fill")) {
        this.setFill(element.getStringAttribute("fill"));
      }
      if (element.hasAttribute("style")) {
        var styleText = element.getStringAttribute("style");
        var styleTokens = styleText.toString().split(";");
        for (var i = 0, j = styleTokens.length; i < j; i++) {
          var tokens = CommonFunctions.trim(styleTokens[i].split(":"));
          if (tokens[0] === "fill") {
            this.setFill(tokens[1]);
          } else if (tokens[0] === "fill-opacity") {
            this.setFillOpacity(tokens[1]);
          } else if (tokens[0] === "stroke") {
            this.setStroke(tokens[1]);
          } else if (tokens[0] === "stroke-width") {
            this.setStrokeWeight(tokens[1]);
          } else if (tokens[0] === "stroke-linecap") {
            this.setStrokeCap(tokens[1]);
          } else if (tokens[0] === "stroke-linejoin") {
            this.setStrokeJoin(tokens[1]);
          } else if (tokens[0] === "stroke-opacity") {
            this.setStrokeOpacity(tokens[1]);
          } else if (tokens[0] === "opacity") {
            this.setOpacity(tokens[1]);
          }
        }
      }
    };
    PShapeSVG2.prototype.setFillOpacity = function(opacityText) {
      this.fillOpacity = parseFloat(opacityText);
      this.fillColor = this.fillOpacity * 255 << 24 | this.fillColor & 16777215;
    };
    PShapeSVG2.prototype.setFill = function(fillText) {
      var opacityMask = this.fillColor & 4278190080;
      if (fillText === "none") {
        this.fill = false;
      } else if (fillText.indexOf("#") === 0) {
        this.fill = true;
        if (fillText.length === 4) {
          fillText = fillText.replace(/#(.)(.)(.)/, "#$1$1$2$2$3$3");
        }
        this.fillColor = opacityMask | parseInt(fillText.substring(1), 16) & 16777215;
      } else if (fillText.indexOf("rgb") === 0) {
        this.fill = true;
        this.fillColor = opacityMask | this.parseRGB(fillText);
      } else if (fillText.indexOf("url(#") === 0) {
        this.fillName = fillText.substring(5, fillText.length - 1);
      } else if (colors[fillText]) {
        this.fill = true;
        this.fillColor = opacityMask | parseInt(colors[fillText].substring(1), 16) & 16777215;
      }
    };
    PShapeSVG2.prototype.setOpacity = function(opacity) {
      this.strokeColor = parseFloat(opacity) * 255 << 24 | this.strokeColor & 16777215;
      this.fillColor = parseFloat(opacity) * 255 << 24 | this.fillColor & 16777215;
    };
    PShapeSVG2.prototype.setStroke = function(strokeText) {
      var opacityMask = this.strokeColor & 4278190080;
      if (strokeText === "none") {
        this.stroke = false;
      } else if (strokeText.charAt(0) === "#") {
        this.stroke = true;
        if (strokeText.length === 4) {
          strokeText = strokeText.replace(/#(.)(.)(.)/, "#$1$1$2$2$3$3");
        }
        this.strokeColor = opacityMask | parseInt(strokeText.substring(1), 16) & 16777215;
      } else if (strokeText.indexOf("rgb") === 0) {
        this.stroke = true;
        this.strokeColor = opacityMask | this.parseRGB(strokeText);
      } else if (strokeText.indexOf("url(#") === 0) {
        this.strokeName = strokeText.substring(5, strokeText.length - 1);
      } else if (colors[strokeText]) {
        this.stroke = true;
        this.strokeColor = opacityMask | parseInt(colors[strokeText].substring(1), 16) & 16777215;
      }
    };
    PShapeSVG2.prototype.setStrokeWeight = function(weight) {
      this.strokeWeight = this.parseUnitSize(weight);
    };
    PShapeSVG2.prototype.setStrokeJoin = function(linejoin) {
      if (linejoin === "miter") {
        this.strokeJoin = PConstants3.MITER;
      } else if (linejoin === "round") {
        this.strokeJoin = PConstants3.ROUND;
      } else if (linejoin === "bevel") {
        this.strokeJoin = PConstants3.BEVEL;
      }
    };
    PShapeSVG2.prototype.setStrokeCap = function(linecap) {
      if (linecap === "butt") {
        this.strokeCap = PConstants3.SQUARE;
      } else if (linecap === "round") {
        this.strokeCap = PConstants3.ROUND;
      } else if (linecap === "square") {
        this.strokeCap = PConstants3.PROJECT;
      }
    };
    PShapeSVG2.prototype.setStrokeOpacity = function(opacityText) {
      this.strokeOpacity = parseFloat(opacityText);
      this.strokeColor = this.strokeOpacity * 255 << 24 | this.strokeColor & 16777215;
    };
    PShapeSVG2.prototype.parseRGB = function(color) {
      var sub = color.substring(color.indexOf("(") + 1, color.indexOf(")"));
      var values = sub.split(", ");
      return values[0] << 16 | values[1] << 8 | values[2];
    };
    PShapeSVG2.prototype.parseUnitSize = function(text) {
      var len = text.length - 2;
      if (len < 0) {
        return text;
      }
      if (text.indexOf("pt") === len) {
        return parseFloat(text.substring(0, len)) * 1.25;
      }
      if (text.indexOf("pc") === len) {
        return parseFloat(text.substring(0, len)) * 15;
      }
      if (text.indexOf("mm") === len) {
        return parseFloat(text.substring(0, len)) * 3.543307;
      }
      if (text.indexOf("cm") === len) {
        return parseFloat(text.substring(0, len)) * 35.43307;
      }
      if (text.indexOf("in") === len) {
        return parseFloat(text.substring(0, len)) * 90;
      }
      if (text.indexOf("px") === len) {
        return parseFloat(text.substring(0, len));
      }
      return parseFloat(text);
    };
    return PShapeSVG2;
  }
  var PShapeSVG_default = PShapeSVG;

  // src/P5Functions/commonFunctions.js
  function commonFunctions(undef) {
    var CommonFunctions = {
      /**
       * Remove whitespace characters from the beginning and ending
       * of a String or a String array. Works like String.trim() but includes the
       * unicode nbsp character as well. If an array is passed in the function will return a new array not effecting the array passed in.
       *
       * @param {String} str    the string to trim
       * @param {String[]} str  the string array to trim
       *
       * @return {String|String[]} retrurns a string or an array will removed whitespaces
       */
      trim: function(str) {
        if (str instanceof Array) {
          var arr = [];
          for (var i = 0; i < str.length; i++) {
            arr.push(str[i].replace(/^\s*/, "").replace(/\s*$/, "").replace(/\r*$/, ""));
          }
          return arr;
        }
        return str.replace(/^\s*/, "").replace(/\s*$/, "").replace(/\r*$/, "");
      },
      /**
       * Converts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of
       * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,
       * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.
       *
       * @param {int|float} value        an angle in radians
       *
       * @returns {float}
       *
       * @see degrees
       */
      radians: function(aAngle) {
        return aAngle / 180 * Math.PI;
      },
      /**
       * Number-to-String formatting function. Prepends "plus" or "minus" depending
       * on whether the value is positive or negative, respectively, after padding
       * the value with zeroes on the left and right, the number of zeroes used dictated
       * by the values 'leftDigits' and 'rightDigits'. 'value' cannot be an array.
       *
       * @param {int|float} value                 the number to format
       * @param {String} plus                     the prefix for positive numbers
       * @param {String} minus                    the prefix for negative numbers
       * @param {int} left                        number of digits to the left of the decimal point
       * @param {int} right                       number of digits to the right of the decimal point
       * @param {String} group                    string delimited for groups, such as the comma in "1,000"
       *
       * @returns {String or String[]}
       *
       * @see nfCore
       */
      nfCoreScalar: function(value, plus, minus, leftDigits, rightDigits, group) {
        var sign2 = value < 0 ? minus : plus;
        var autoDetectDecimals = rightDigits === 0;
        var rightDigitsOfDefault = rightDigits === undef || rightDigits < 0 ? 0 : rightDigits;
        var absValue = Math.abs(value);
        if (autoDetectDecimals) {
          rightDigitsOfDefault = 1;
          absValue *= 10;
          while (Math.abs(Math.round(absValue) - absValue) > 1e-6 && rightDigitsOfDefault < 7) {
            ++rightDigitsOfDefault;
            absValue *= 10;
          }
        } else if (rightDigitsOfDefault !== 0) {
          absValue *= Math.pow(10, rightDigitsOfDefault);
        }
        var number, doubled = absValue * 2;
        if (Math.floor(absValue) === absValue) {
          number = absValue;
        } else if (Math.floor(doubled) === doubled) {
          var floored = Math.floor(absValue);
          number = floored + floored % 2;
        } else {
          number = Math.round(absValue);
        }
        var buffer = "";
        var totalDigits = leftDigits + rightDigitsOfDefault;
        while (totalDigits > 0 || number > 0) {
          totalDigits--;
          buffer = "" + number % 10 + buffer;
          number = Math.floor(number / 10);
        }
        if (group !== undef) {
          var i = buffer.length - 3 - rightDigitsOfDefault;
          while (i > 0) {
            buffer = buffer.substring(0, i) + group + buffer.substring(i);
            i -= 3;
          }
        }
        if (rightDigitsOfDefault > 0) {
          return sign2 + buffer.substring(0, buffer.length - rightDigitsOfDefault) + "." + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);
        }
        return sign2 + buffer;
      },
      /**
      * Number-to-String formatting function. Prepends "plus" or "minus" depending
      * on whether the value is positive or negative, respectively, after padding
      * the value with zeroes on the left and right, the number of zeroes used dictated
      * by the values 'leftDigits' and 'rightDigits'. 'value' can be an array;
      * if the input is an array, each value in it is formatted separately, and
      * an array with formatted values is returned.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {String} plus                     the prefix for positive numbers
      * @param {String} minus                    the prefix for negative numbers
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      * @param {String} group                    string delimited for groups, such as the comma in "1,000"
      *
      * @returns {String or String[]}
      *
      * @see nfCoreScalar
      */
      nfCore: function(value, plus, minus, leftDigits, rightDigits, group) {
        if (value instanceof Array) {
          var arr = [];
          for (var i = 0, len = value.length; i < len; i++) {
            arr.push(CommonFunctions.nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));
          }
          return arr;
        }
        return CommonFunctions.nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group);
      },
      /**
      * Utility function for formatting numbers into strings. There are two versions, one for
      * formatting floats and one for formatting ints. The values for the digits, left, and
      * right parameters should always be positive integers.
      * As shown in the above example, nf() is used to add zeros to the left and/or right
      * of a number. This is typically for aligning a list of numbers. To remove digits from
      * a floating-point number, use the int(), ceil(), floor(), or round() functions.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      *
      * @returns {String or String[]}
      *
      * @see nfs
      * @see nfp
      * @see nfc
      */
      nf: function(value, leftDigits, rightDigits) {
        return CommonFunctions.nfCore(value, "", "-", leftDigits, rightDigits);
      },
      /**
      * Utility function for formatting numbers into strings. Similar to nf()  but leaves a blank space in front
      * of positive numbers so they align with negative numbers in spite of the minus symbol. There are two
      * versions, one for formatting floats and one for formatting ints. The values for the digits, left,
      * and right parameters should always be positive integers.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      *
      * @returns {String or String[]}
      *
      * @see nf
      * @see nfp
      * @see nfc
      */
      nfs: function(value, leftDigits, rightDigits) {
        return CommonFunctions.nfCore(value, " ", "-", leftDigits, rightDigits);
      },
      /**
      * Utility function for formatting numbers into strings. Similar to nf()  but puts a "+" in front of
      * positive numbers and a "-" in front of negative numbers. There are two versions, one for formatting
      * floats and one for formatting ints. The values for the digits, left, and right parameters should
      * always be positive integers.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      *
      * @returns {String or String[]}
      *
      * @see nfs
      * @see nf
      * @see nfc
      */
      nfp: function(value, leftDigits, rightDigits) {
        return CommonFunctions.nfCore(value, "+", "-", leftDigits, rightDigits);
      },
      /**
      * Utility function for formatting numbers into strings and placing appropriate commas to mark
      * units of 1000. There are two versions, one for formatting ints and one for formatting an array
      * of ints. The value for the digits parameter should always be a positive integer.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      *
      * @returns {String or String[]}
      *
      * @see nf
      * @see nfs
      * @see nfp
      */
      nfc: function(value, rightDigits) {
        return CommonFunctions.nfCore(value, "", "-", 0, rightDigits, ",");
      },
      // used to bind all common functions to "p"
      withCommonFunctions: function withCommonFunctions(p) {
        ["trim", "radians", "nf", "nfs", "nfp", "nfc"].forEach(function(f) {
          p[f] = CommonFunctions[f];
        });
      }
    };
    return CommonFunctions;
  }

  // src/Helpers/defaultScope.js
  function defaultScope_default(options) {
    function DefaultScope() {
    }
    DefaultScope.prototype = options.PConstants;
    var defaultScope2 = new DefaultScope();
    Object.keys(options).forEach(function(prop) {
      defaultScope2[prop] = options[prop];
    });
    defaultScope2.defineProperty = function(obj, name, desc) {
      if ("defineProperty" in Object) {
        Object.defineProperty(obj, name, desc);
      } else {
        if (desc.hasOwnProperty("get")) {
          obj.__defineGetter__(name, desc.get);
        }
        if (desc.hasOwnProperty("set")) {
          obj.__defineSetter__(name, desc.set);
        }
      }
    };
    function overloadBaseClassFunction(object, name, basefn) {
      if (!object.hasOwnProperty(name) || typeof object[name] !== "function") {
        object[name] = basefn;
        return;
      }
      var fn = object[name];
      if ("$overloads" in fn) {
        fn.$defaultOverload = basefn;
        return;
      }
      if (!("$overloads" in basefn) && fn.length === basefn.length) {
        return;
      }
      var overloads, defaultOverload;
      if ("$overloads" in basefn) {
        overloads = basefn.$overloads.slice(0);
        overloads[fn.length] = fn;
        defaultOverload = basefn.$defaultOverload;
      } else {
        overloads = [];
        overloads[basefn.length] = basefn;
        overloads[fn.length] = fn;
        defaultOverload = fn;
      }
      var hubfn = function() {
        var fn2 = hubfn.$overloads[arguments.length] || ("$methodArgsIndex" in hubfn && arguments.length > hubfn.$methodArgsIndex ? hubfn.$overloads[hubfn.$methodArgsIndex] : null) || hubfn.$defaultOverload;
        return fn2.apply(this, arguments);
      };
      hubfn.$overloads = overloads;
      if ("$methodArgsIndex" in basefn) {
        hubfn.$methodArgsIndex = basefn.$methodArgsIndex;
      }
      hubfn.$defaultOverload = defaultOverload;
      Object.defineProperty(hubfn, "name", { value: name, writable: false });
      object[name] = hubfn;
    }
    function extendClass(subClass, baseClass) {
      function extendGetterSetter(propertyName2) {
        defaultScope2.defineProperty(subClass, propertyName2, {
          get: function() {
            return baseClass[propertyName2];
          },
          set: function(v) {
            baseClass[propertyName2] = v;
          },
          enumerable: true
        });
      }
      var properties = [];
      for (var propertyName in baseClass) {
        if (typeof baseClass[propertyName] === "function") {
          overloadBaseClassFunction(subClass, propertyName, baseClass[propertyName]);
        } else if (propertyName.charAt(0) !== "$" && !(propertyName in subClass)) {
          properties.push(propertyName);
        }
      }
      while (properties.length > 0) {
        extendGetterSetter(properties.shift());
      }
      subClass.$super = baseClass;
    }
    defaultScope2.extendClassChain = function(base) {
      var path = [base];
      for (var self2 = base.$upcast; self2; self2 = self2.$upcast) {
        extendClass(self2, base);
        path.push(self2);
        base = self2;
      }
      while (path.length > 0) {
        path.pop().$self = base;
      }
    };
    defaultScope2.extendStaticMembers = function(derived, base) {
      extendClass(derived, base);
    };
    defaultScope2.extendInterfaceMembers = function(derived, base) {
      extendClass(derived, base);
    };
    defaultScope2.addMethod = function(object, name, fn, hasMethodArgs) {
      var existingfn = object[name];
      if (existingfn || hasMethodArgs) {
        var args = fn.length;
        if ("$overloads" in existingfn) {
          existingfn.$overloads[args] = fn;
        } else {
          var hubfn = function() {
            var fn2 = hubfn.$overloads[arguments.length] || ("$methodArgsIndex" in hubfn && arguments.length > hubfn.$methodArgsIndex ? hubfn.$overloads[hubfn.$methodArgsIndex] : null) || hubfn.$defaultOverload;
            return fn2.apply(this, arguments);
          };
          var overloads = [];
          if (existingfn) {
            overloads[existingfn.length] = existingfn;
          }
          overloads[args] = fn;
          hubfn.$overloads = overloads;
          hubfn.$defaultOverload = existingfn || fn;
          if (hasMethodArgs) {
            hubfn.$methodArgsIndex = args;
          }
          Object.defineProperty(hubfn, "name", { value: name, writable: false });
          object[name] = hubfn;
        }
      } else {
        object[name] = fn;
      }
    };
    function isNumericalJavaType(type) {
      if (typeof type !== "string") {
        return false;
      }
      return ["byte", "int", "char", "color", "float", "long", "double"].indexOf(type) !== -1;
    }
    defaultScope2.createJavaArray = function(type, bounds) {
      var result = null, defaultValue = null;
      if (typeof type === "string") {
        if (type === "boolean") {
          defaultValue = false;
        } else if (isNumericalJavaType(type)) {
          defaultValue = 0;
        }
      }
      if (typeof bounds[0] === "number") {
        var itemsCount = 0 | bounds[0];
        if (bounds.length <= 1) {
          result = [];
          result.length = itemsCount;
          for (var i = 0; i < itemsCount; ++i) {
            result[i] = defaultValue;
          }
        } else {
          result = [];
          var newBounds = bounds.slice(1);
          for (var j = 0; j < itemsCount; ++j) {
            result.push(defaultScope2.createJavaArray(type, newBounds));
          }
        }
      }
      return result;
    };
    defaultScope2.defineProperty(
      defaultScope2,
      "screenWidth",
      { get: function() {
        return window.innerWidth;
      } }
    );
    defaultScope2.defineProperty(
      defaultScope2,
      "screenHeight",
      { get: function() {
        return window.innerHeight;
      } }
    );
    return defaultScope2;
  }

  // src/Processing.js
  function Processing2(options, undef) {
    var defaultScope2 = options.defaultScope;
    var extend = options.extend;
    var Browser2 = options.Browser;
    var ajax = Browser2.ajax;
    var navigator2 = Browser2.navigator;
    var window2 = Browser2.window;
    var XMLHttpRequest2 = window2.XMLHttpRequest;
    var document2 = Browser2.document;
    var noop = options.noop;
    var PConstants3 = defaultScope2.PConstants;
    var PFont3 = defaultScope2.PFont;
    var PShapeSVG2 = defaultScope2.PShapeSVG;
    var PVector3 = defaultScope2.PVector;
    var Char2 = defaultScope2.Char;
    var Character = defaultScope2.Char;
    var ObjectIterator2 = defaultScope2.ObjectIterator;
    var XMLElement = defaultScope2.XMLElement;
    var XML = defaultScope2.XML;
    var HTMLCanvasElement = window2.HTMLCanvasElement;
    var HTMLImageElement = window2.HTMLImageElement;
    var localStorage;
    try {
      localStorage = window2.localStorage;
    } catch (e) {
      localStorage = {};
    }
    var isDOMPresent = "document" in this && !("fake" in this.document);
    if (!document2.head) {
      document2.head = document2.getElementsByTagName("head")[0];
    }
    var Float32Array2 = setupTypedArray("Float32Array", "WebGLFloatArray"), Int32Array2 = setupTypedArray("Int32Array", "WebGLIntArray"), Uint16Array2 = setupTypedArray("Uint16Array", "WebGLUnsignedShortArray"), Uint8Array2 = setupTypedArray("Uint8Array", "WebGLUnsignedByteArray");
    function setupTypedArray(name, fallback) {
      if (name in window2) {
        return window2[name];
      }
      if (typeof window2[fallback] === "function") {
        return window2[fallback];
      }
      return function(obj) {
        if (obj instanceof Array) {
          return obj;
        }
        if (typeof obj === "number") {
          var arr = [];
          arr.length = obj;
          return arr;
        }
      };
    }
    if (document2.documentMode >= 9 && !document2.doctype) {
      throw "The doctype directive is missing. The recommended doctype in Internet Explorer is the HTML5 doctype: <!DOCTYPE html>";
    }
    var processingInstances = [];
    var processingInstanceIds = {};
    var addInstance = function(processing) {
      if (processing.externals.canvas.id === undef || !processing.externals.canvas.id.length) {
        processing.externals.canvas.id = "__processing" + processingInstances.length;
      }
      processingInstanceIds[processing.externals.canvas.id] = processingInstances.length;
      processingInstances.push(processing);
    };
    var removeInstance = function(id) {
      processingInstances.splice(processingInstanceIds[id], 1);
      delete processingInstanceIds[id];
    };
    var Processing3 = this.Processing = function(aCanvas, aCode, aFunctions) {
      if (!(this instanceof Processing3)) {
        throw "called Processing constructor as if it were a function: missing 'new'.";
      }
      var curElement = {}, pgraphicsMode = aCanvas === undef && aCode === undef;
      if (pgraphicsMode) {
        curElement = document2.createElement("canvas");
      } else {
        curElement = typeof aCanvas === "string" ? document2.getElementById(aCanvas) : aCanvas;
      }
      if (!("getContext" in curElement)) {
        throw "called Processing constructor without passing canvas element reference or id.";
      }
      function unimplemented2(s) {
        Processing3.debug("Unimplemented - " + s);
      }
      var eventHandlers = [];
      function attachEventHandler(elem, type, fn) {
        if (elem.addEventListener) {
          elem.addEventListener(type, fn, false);
        } else {
          elem.attachEvent("on" + type, fn);
        }
        eventHandlers.push({ elem, type, fn });
      }
      function detachEventHandler2(eventHandler) {
        var elem = eventHandler.elem, type = eventHandler.type, fn = eventHandler.fn;
        if (elem.removeEventListener) {
          elem.removeEventListener(type, fn, false);
        } else if (elem.detachEvent) {
          elem.detachEvent("on" + type, fn);
        }
      }
      function detachEventHandlersByType(element, types) {
        Object.keys(eventHandlers).forEach(function(eventHandler) {
          if (types.indexOf(eventHandler.type) > -1 && eventHandler.elem == element) {
            detachEventHandler2(eventHandler.type);
          }
        });
      }
      function removeFirstArgument(args) {
        return Array.prototype.slice.call(args, 1);
      }
      var p = this;
      p.Char = p.Character = Char2;
      eventHandlers = [];
      extend.withCommonFunctions(p);
      extend.withMath(p);
      extend.withProxyFunctions(p, removeFirstArgument);
      extend.withTouch(p, curElement, attachEventHandler, detachEventHandlersByType, document2, PConstants3);
      if (aFunctions) {
        Object.keys(aFunctions).forEach(function(name) {
          p[name] = aFunctions[name];
        });
      }
      p.externals = {
        canvas: curElement,
        context: undef,
        sketch: undef,
        window: window2
      };
      p.name = "Processing.js Instance";
      p.use3DContext = false;
      p.focused = false;
      p.breakShape = false;
      p.glyphTable = {};
      p.pmouseX = 0;
      p.pmouseY = 0;
      p.mouseX = 0;
      p.mouseY = 0;
      p.mouseButton = 0;
      p.mouseScroll = 0;
      p.mouseClicked = undef;
      p.mouseDragged = undef;
      p.mouseMoved = undef;
      p.mousePressed = undef;
      p.mouseReleased = undef;
      p.mouseScrolled = undef;
      p.mouseOver = undef;
      p.mouseOut = undef;
      p.touchStart = undef;
      p.touchEnd = undef;
      p.touchMove = undef;
      p.touchCancel = undef;
      p.key = undef;
      p.keyCode = undef;
      p.keyPressed = noop;
      p.keyReleased = noop;
      p.keyTyped = noop;
      p.draw = undef;
      p.setup = undef;
      p.__mousePressed = false;
      p.__keyPressed = false;
      p.__frameRate = 60;
      p.frameCount = 0;
      p.width = 100;
      p.height = 100;
      var curContext, curSketch, drawing, doFill = true, fillStyle = [1, 1, 1, 1], currentFillColor = 4294967295, isFillDirty = true, doStroke = true, strokeStyle = [0, 0, 0, 1], currentStrokeColor = 4278190080, isStrokeDirty = true, lineWidth = 1, loopStarted = false, renderSmooth = false, doLoop = true, looping = 0, curRectMode = PConstants3.CORNER, curEllipseMode2 = PConstants3.CENTER, normalX = 0, normalY = 0, normalZ = 0, normalMode = PConstants3.NORMAL_MODE_AUTO, curFrameRate = 60, curMsPerFrame = 1e3 / curFrameRate, curCursor = PConstants3.ARROW, oldCursor = curElement.style.cursor, curShape = PConstants3.POLYGON, curShapeCount = 0, curvePoints = [], curTightness = 0, curveDet = 20, curveInited = false, backgroundObj = -3355444, bezDetail = 20, colorModeA = 255, colorModeX = 255, colorModeY = 255, colorModeZ = 255, pathOpen = false, mouseDragging = false, pmouseXLastFrame = 0, pmouseYLastFrame = 0, curColorMode = PConstants3.RGB, curTint = null, curTint3d = null, getLoaded = false, start = Date.now(), timeSinceLastFPS = start, framesSinceLastFPS = 0, textcanvas, curveBasisMatrix, curveToBezierMatrix, curveDrawMatrix, bezierDrawMatrix, bezierBasisInverse, bezierBasisMatrix, curContextCache = { attributes: {}, locations: {} }, programObject3D, programObject2D, programObjectUnlitShape, boxBuffer, boxNormBuffer, boxOutlineBuffer, rectBuffer, rectNormBuffer, sphereBuffer, lineBuffer, fillBuffer, fillColorBuffer, strokeColorBuffer, pointBuffer, shapeTexVBO, canTex, textTex, curTexture = { width: 0, height: 0 }, curTextureMode = PConstants3.IMAGE, usingTexture = false, textBuffer, textureBuffer, indexBuffer, horizontalTextAlignment = PConstants3.LEFT, verticalTextAlignment = PConstants3.BASELINE, textMode = PConstants3.MODEL, curFontName = "Arial", curTextSize = 12, curTextAscent = 9, curTextDescent = 2, curTextLeading = 14, curTextFont = PFont3.get(curFontName, curTextSize), originalContext, proxyContext = null, isContextReplaced = false, setPixelsCached, maxPixelsCached = 1e3, pressedKeysMap = [], lastPressedKeyCode = null, codedKeys = [
        PConstants3.SHIFT,
        PConstants3.CONTROL,
        PConstants3.ALT,
        PConstants3.CAPSLK,
        PConstants3.PGUP,
        PConstants3.PGDN,
        PConstants3.END,
        PConstants3.HOME,
        PConstants3.LEFT,
        PConstants3.UP,
        PConstants3.RIGHT,
        PConstants3.DOWN,
        PConstants3.NUMLK,
        PConstants3.INSERT,
        PConstants3.F1,
        PConstants3.F2,
        PConstants3.F3,
        PConstants3.F4,
        PConstants3.F5,
        PConstants3.F6,
        PConstants3.F7,
        PConstants3.F8,
        PConstants3.F9,
        PConstants3.F10,
        PConstants3.F11,
        PConstants3.F12,
        PConstants3.META
      ];
      var lightCount = 0;
      var sphereDetailV = 0, sphereDetailU = 0, sphereX = [], sphereY = [], sphereZ = [], sinLUT = new Float32Array2(PConstants3.SINCOS_LENGTH), cosLUT = new Float32Array2(PConstants3.SINCOS_LENGTH), sphereVerts, sphereNorms;
      var cam, cameraInv, modelView, modelViewInv, userMatrixStack, userReverseMatrixStack, inverseCopy2, projection, manipulatingCamera = false, frustumMode = false, cameraFOV = 60 * (Math.PI / 180), cameraX = p.width / 2, cameraY = p.height / 2, cameraZ = cameraY / Math.tan(cameraFOV / 2), cameraNear = cameraZ / 10, cameraFar = cameraZ * 10, cameraAspect = p.width / p.height;
      var vertArray2 = [], curveVertArray = [], curveVertCount = 0, isCurve = false, isBezier = false, firstVert = true;
      var curShapeMode = PConstants3.CORNER;
      var styleArray = [];
      var boxVerts = new Float32Array2([
        0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5
      ]);
      var boxOutlineVerts = new Float32Array2([
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5
      ]);
      var boxNorms = new Float32Array2([
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0
      ]);
      var rectVerts = new Float32Array2([0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0]);
      var rectNorms = new Float32Array2([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
      var vertexShaderSrcUnlitShape = "varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec4 aColor;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;void main(void) {  vFrontColor = aColor;  gl_PointSize = uPointSize;  gl_Position = uProjection * uView * vec4(aVertex, 1.0);}";
      var fragmentShaderSrcUnlitShape = "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 vFrontColor;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  gl_FragColor = vFrontColor;}";
      var vertexShaderSrc2D = "varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec2 aTextureCoord;uniform vec4 uColor;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;varying vec2 vTextureCoord;void main(void) {  gl_PointSize = uPointSize;  vFrontColor = uColor;  gl_Position = uProjection * uView * uModel * vec4(aVertex, 1.0);  vTextureCoord = aTextureCoord;}";
      var fragmentShaderSrc2D = "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 vFrontColor;varying vec2 vTextureCoord;uniform sampler2D uSampler;uniform int uIsDrawingText;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  if(uIsDrawingText == 1){    float alpha = texture2D(uSampler, vTextureCoord).a;    gl_FragColor = vec4(vFrontColor.rgb * alpha, alpha);  }  else{    gl_FragColor = vFrontColor;  }}";
      var webglMaxTempsWorkaround = /Windows/.test(navigator2.userAgent);
      var vertexShaderSrc3D = "varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec3 aNormal;attribute vec4 aColor;attribute vec2 aTexture;varying   vec2 vTexture;uniform vec4 uColor;uniform bool uUsingMat;uniform vec3 uSpecular;uniform vec3 uMaterialEmissive;uniform vec3 uMaterialAmbient;uniform vec3 uMaterialSpecular;uniform float uShininess;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform mat4 uNormalTransform;uniform int uLightCount;uniform vec3 uFalloff;struct Light {  int type;  vec3 color;  vec3 position;  vec3 direction;  float angle;  vec3 halfVector;  float concentration;};uniform Light uLights0;uniform Light uLights1;uniform Light uLights2;uniform Light uLights3;uniform Light uLights4;uniform Light uLights5;uniform Light uLights6;uniform Light uLights7;Light getLight(int index){  if(index == 0) return uLights0;  if(index == 1) return uLights1;  if(index == 2) return uLights2;  if(index == 3) return uLights3;  if(index == 4) return uLights4;  if(index == 5) return uLights5;  if(index == 6) return uLights6;  return uLights7;}void AmbientLight( inout vec3 totalAmbient, in vec3 ecPos, in Light light ) {  float d = length( light.position - ecPos );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  totalAmbient += light.color * attenuation;}void DirectionalLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor = 0.0;  float nDotVP = max(0.0, dot( vertNormal, normalize(-light.position) ));  float nDotVH = max(0.0, dot( vertNormal, normalize(-light.position-normalize(ecPos) )));  if( nDotVP != 0.0 ){    powerFactor = pow( nDotVH, uShininess );  }  col += light.color * nDotVP;  spec += uSpecular * powerFactor;}void PointLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor;   vec3 VP = light.position - ecPos;  float d = length( VP );   VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  float nDotVP = max( 0.0, dot( vertNormal, VP ));  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ));  if( nDotVP == 0.0 ) {    powerFactor = 0.0;  }  else {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void SpotLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float spotAttenuation;  float powerFactor = 0.0;  vec3 VP = light.position - ecPos;  vec3 ldir = normalize( -light.direction );  float d = length( VP );  VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ) );  float spotDot = dot( VP, ldir );" + // If the vertex falls inside the cone
      (webglMaxTempsWorkaround ? (
        // Windows reports max temps error if light.angle is used
        "  spotAttenuation = 1.0; "
      ) : "  if( spotDot > cos( light.angle ) ) {    spotAttenuation = pow( spotDot, light.concentration );  }  else{    spotAttenuation = 0.0;  }  attenuation *= spotAttenuation;") + "  float nDotVP = max( 0.0, dot( vertNormal, VP ) );  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ) );  if( nDotVP != 0.0 ) {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void main(void) {  vec3 finalAmbient = vec3( 0.0 );  vec3 finalDiffuse = vec3( 0.0 );  vec3 finalSpecular = vec3( 0.0 );  vec4 col = uColor;  if ( uColor[0] == -1.0 ){    col = aColor;  }  vec3 norm = normalize(vec3( uNormalTransform * vec4( aNormal, 0.0 ) ));  vec4 ecPos4 = uView * uModel * vec4(aVertex, 1.0);  vec3 ecPos = (vec3(ecPos4))/ecPos4.w;  if( uLightCount == 0 ) {    vFrontColor = col + vec4(uMaterialSpecular, 1.0);  }  else {    for( int i = 0; i < 8; i++ ) {      Light l = getLight(i);      if( i >= uLightCount ){        break;      }      if( l.type == 0 ) {        AmbientLight( finalAmbient, ecPos, l );      }      else if( l.type == 1 ) {        DirectionalLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }      else if( l.type == 2 ) {        PointLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }      else {        SpotLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }    }   if( uUsingMat == false ) {     vFrontColor = vec4(       vec3( col ) * finalAmbient +       vec3( col ) * finalDiffuse +       vec3( col ) * finalSpecular,       col[3] );   }   else{     vFrontColor = vec4(        uMaterialEmissive +        (vec3(col) * uMaterialAmbient * finalAmbient ) +        (vec3(col) * finalDiffuse) +        (uMaterialSpecular * finalSpecular),        col[3] );    }  }  vTexture.xy = aTexture.xy;  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );}";
      var fragmentShaderSrc3D = "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 vFrontColor;uniform sampler2D uSampler;uniform bool uUsingTexture;varying vec2 vTexture;void main(void){  if( uUsingTexture ){    gl_FragColor = vec4(texture2D(uSampler, vTexture.xy)) * vFrontColor;  }  else{    gl_FragColor = vFrontColor;  }}";
      function uniformf(cacheId, programObj, varName, varValue) {
        var varLocation = curContextCache.locations[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getUniformLocation(programObj, varName);
          curContextCache.locations[cacheId] = varLocation;
        }
        if (varLocation !== null) {
          if (varValue.length === 4) {
            curContext.uniform4fv(varLocation, varValue);
          } else if (varValue.length === 3) {
            curContext.uniform3fv(varLocation, varValue);
          } else if (varValue.length === 2) {
            curContext.uniform2fv(varLocation, varValue);
          } else {
            curContext.uniform1f(varLocation, varValue);
          }
        }
      }
      function uniformi(cacheId, programObj, varName, varValue) {
        var varLocation = curContextCache.locations[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getUniformLocation(programObj, varName);
          curContextCache.locations[cacheId] = varLocation;
        }
        if (varLocation !== null) {
          if (varValue.length === 4) {
            curContext.uniform4iv(varLocation, varValue);
          } else if (varValue.length === 3) {
            curContext.uniform3iv(varLocation, varValue);
          } else if (varValue.length === 2) {
            curContext.uniform2iv(varLocation, varValue);
          } else {
            curContext.uniform1i(varLocation, varValue);
          }
        }
      }
      function uniformMatrix(cacheId, programObj, varName, transpose, matrix) {
        var varLocation = curContextCache.locations[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getUniformLocation(programObj, varName);
          curContextCache.locations[cacheId] = varLocation;
        }
        if (varLocation !== -1) {
          if (matrix.length === 16) {
            curContext.uniformMatrix4fv(varLocation, transpose, matrix);
          } else if (matrix.length === 9) {
            curContext.uniformMatrix3fv(varLocation, transpose, matrix);
          } else {
            curContext.uniformMatrix2fv(varLocation, transpose, matrix);
          }
        }
      }
      function vertexAttribPointer(cacheId, programObj, varName, size, VBO) {
        var varLocation = curContextCache.attributes[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getAttribLocation(programObj, varName);
          curContextCache.attributes[cacheId] = varLocation;
        }
        if (varLocation !== -1) {
          curContext.bindBuffer(curContext.ARRAY_BUFFER, VBO);
          curContext.vertexAttribPointer(varLocation, size, curContext.FLOAT, false, 0, 0);
          curContext.enableVertexAttribArray(varLocation);
        }
      }
      function disableVertexAttribPointer(cacheId, programObj, varName) {
        var varLocation = curContextCache.attributes[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getAttribLocation(programObj, varName);
          curContextCache.attributes[cacheId] = varLocation;
        }
        if (varLocation !== -1) {
          curContext.disableVertexAttribArray(varLocation);
        }
      }
      var createProgramObject = function(curContext2, vetexShaderSource, fragmentShaderSource) {
        var vertexShaderObject = curContext2.createShader(curContext2.VERTEX_SHADER);
        curContext2.shaderSource(vertexShaderObject, vetexShaderSource);
        curContext2.compileShader(vertexShaderObject);
        if (!curContext2.getShaderParameter(vertexShaderObject, curContext2.COMPILE_STATUS)) {
          throw curContext2.getShaderInfoLog(vertexShaderObject);
        }
        var fragmentShaderObject = curContext2.createShader(curContext2.FRAGMENT_SHADER);
        curContext2.shaderSource(fragmentShaderObject, fragmentShaderSource);
        curContext2.compileShader(fragmentShaderObject);
        if (!curContext2.getShaderParameter(fragmentShaderObject, curContext2.COMPILE_STATUS)) {
          throw curContext2.getShaderInfoLog(fragmentShaderObject);
        }
        var programObject = curContext2.createProgram();
        curContext2.attachShader(programObject, vertexShaderObject);
        curContext2.attachShader(programObject, fragmentShaderObject);
        curContext2.linkProgram(programObject);
        if (!curContext2.getProgramParameter(programObject, curContext2.LINK_STATUS)) {
          throw "Error linking shaders.";
        }
        return programObject;
      };
      var imageModeCorner = function(x, y, w, h, whAreSizes) {
        return {
          x,
          y,
          w,
          h
        };
      };
      var imageModeConvert2 = imageModeCorner;
      var imageModeCorners = function(x, y, w, h, whAreSizes) {
        return {
          x,
          y,
          w: whAreSizes ? w : w - x,
          h: whAreSizes ? h : h - y
        };
      };
      var imageModeCenter = function(x, y, w, h, whAreSizes) {
        return {
          x: x - w / 2,
          y: y - h / 2,
          w,
          h
        };
      };
      var DrawingShared = function() {
      };
      var Drawing2D = function() {
      };
      var Drawing3D = function() {
      };
      var DrawingPre = function() {
      };
      Drawing2D.prototype = new DrawingShared();
      Drawing2D.prototype.constructor = Drawing2D;
      Drawing3D.prototype = new DrawingShared();
      Drawing3D.prototype.constructor = Drawing3D;
      DrawingPre.prototype = new DrawingShared();
      DrawingPre.prototype.constructor = DrawingPre;
      DrawingShared.prototype.a3DOnlyFunction = noop;
      p.shape = function(shape, x, y, width, height) {
        if (arguments.length >= 1 && arguments[0] !== null) {
          if (shape.isVisible()) {
            p.pushMatrix();
            if (curShapeMode === PConstants3.CENTER) {
              if (arguments.length === 5) {
                p.translate(x - width / 2, y - height / 2);
                p.scale(width / shape.getWidth(), height / shape.getHeight());
              } else if (arguments.length === 3) {
                p.translate(x - shape.getWidth() / 2, -shape.getHeight() / 2);
              } else {
                p.translate(-shape.getWidth() / 2, -shape.getHeight() / 2);
              }
            } else if (curShapeMode === PConstants3.CORNER) {
              if (arguments.length === 5) {
                p.translate(x, y);
                p.scale(width / shape.getWidth(), height / shape.getHeight());
              } else if (arguments.length === 3) {
                p.translate(x, y);
              }
            } else if (curShapeMode === PConstants3.CORNERS) {
              if (arguments.length === 5) {
                width -= x;
                height -= y;
                p.translate(x, y);
                p.scale(width / shape.getWidth(), height / shape.getHeight());
              } else if (arguments.length === 3) {
                p.translate(x, y);
              }
            }
            shape.draw(p);
            if (arguments.length === 1 && curShapeMode === PConstants3.CENTER || arguments.length > 1) {
              p.popMatrix();
            }
          }
        }
      };
      p.shapeMode = function(mode) {
        curShapeMode = mode;
      };
      p.loadShape = function(filename) {
        if (arguments.length === 1) {
          if (filename.indexOf(".svg") > -1) {
            return new PShapeSVG2(null, filename);
          }
        }
        return null;
      };
      p.loadXML = function(uri) {
        return new XML(p, uri);
      };
      p.parseXML = function(xmlstring) {
        var element = new XML();
        element.parse(xmlstring);
        return element;
      };
      var printMatrixHelper2 = function(elements) {
        var big = 0;
        for (var i2 = 0; i2 < elements.length; i2++) {
          if (i2 !== 0) {
            big = Math.max(big, Math.abs(elements[i2]));
          } else {
            big = Math.abs(elements[i2]);
          }
        }
        var digits = (big + "").indexOf(".");
        if (digits === 0) {
          digits = 1;
        } else if (digits === -1) {
          digits = (big + "").length;
        }
        return digits;
      };
      var PMatrix2D2 = p.PMatrix2D = function() {
        if (arguments.length === 0) {
          this.reset();
        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
          this.set(arguments[0].array());
        } else if (arguments.length === 6) {
          this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
      };
      PMatrix2D2.prototype = {
        /**
         * @member PMatrix2D
         * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.
         *
         * @param {PMatrix2D} matrix    the matrix to set this matrix to
         * @param {float[]} elements    an array of elements to set this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the third element of the matrix
         * @param {float} m10           the fourth element of the matrix
         * @param {float} m11           the fith element of the matrix
         * @param {float} m12           the sixth element of the matrix
         */
        set: function() {
          if (arguments.length === 6) {
            var a = arguments;
            this.set([
              a[0],
              a[1],
              a[2],
              a[3],
              a[4],
              a[5]
            ]);
          } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
            this.elements = arguments[0].array();
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            this.elements = arguments[0].slice();
          }
        },
        /**
         * @member PMatrix2D
         * The get() function returns a copy of this PMatrix2D.
         *
         * @return {PMatrix2D} a copy of this PMatrix2D
         */
        get: function() {
          var outgoing = new PMatrix2D2();
          outgoing.set(this.elements);
          return outgoing;
        },
        /**
         * @member PMatrix2D
         * The reset() function sets this PMatrix2D to the identity matrix.
         */
        reset: function() {
          this.set([1, 0, 0, 0, 1, 0]);
        },
        /**
         * @member PMatrix2D
         * The array() function returns a copy of the element values.
         * @addon
         *
         * @return {float[]} returns a copy of the element values
         */
        array: function array() {
          return this.elements.slice();
        },
        /**
         * @member PMatrix2D
         * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.
         *
         * @param {float} tx  the x-axis coordinate to move to
         * @param {float} ty  the y-axis coordinate to move to
         */
        translate: function(tx, ty) {
          this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];
          this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];
        },
        /**
         * @member PMatrix2D
         * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.
         *
         * @param {float} tx  the x-axis coordinate to move to
         * @param {float} ty  the y-axis coordinate to move to
         */
        invTranslate: function(tx, ty) {
          this.translate(-tx, -ty);
        },
        /**
        * @member PMatrix2D
        * The transpose() function is not used in processingjs.
        */
        transpose: function() {
        },
        /**
         * @member PMatrix2D
         * The mult() function multiplied this matrix.
         * If two array elements are passed in the function will multiply a two element vector against this matrix.
         * If target is null or not length four, a new float array will be returned.
         * The values for vec and target can be the same (though that's less efficient).
         * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.
         *
         * @param {PVector} source, target  the PVectors used to multiply this matrix
         * @param {float[]} source, target  the arrays used to multiply this matrix
         *
         * @return {PVector|float[]} returns a PVector or an array representing the new matrix
         */
        mult: function(source2, target) {
          var x, y;
          if (source2 instanceof PVector3) {
            x = source2.x;
            y = source2.y;
            if (!target) {
              target = new PVector3();
            }
          } else if (source2 instanceof Array) {
            x = source2[0];
            y = source2[1];
            if (!target) {
              target = [];
            }
          }
          if (target instanceof Array) {
            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];
            target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];
          } else if (target instanceof PVector3) {
            target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];
            target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];
            target.z = 0;
          }
          return target;
        },
        /**
         * @member PMatrix2D
         * The multX() function calculates the x component of a vector from a transformation.
         *
         * @param {float} x the x component of the vector being transformed
         * @param {float} y the y component of the vector being transformed
         *
         * @return {float} returnes the result of the calculation
         */
        multX: function(x, y) {
          return x * this.elements[0] + y * this.elements[1] + this.elements[2];
        },
        /**
         * @member PMatrix2D
         * The multY() function calculates the y component of a vector from a transformation.
         *
         * @param {float} x the x component of the vector being transformed
         * @param {float} y the y component of the vector being transformed
         *
         * @return {float} returnes the result of the calculation
         */
        multY: function(x, y) {
          return x * this.elements[3] + y * this.elements[4] + this.elements[5];
        },
        /**
         * @member PMatrix2D
         * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        skewX: function(angle) {
          this.apply(1, 0, 1, angle, 0, 0);
        },
        /**
         * @member PMatrix2D
         * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        skewY: function(angle) {
          this.apply(1, 0, 1, 0, angle, 0);
        },
        /**
         * @member PMatrix2D
         * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        shearX: function(angle) {
          this.apply(1, 0, 1, Math.tan(angle), 0, 0);
        },
        /**
         * @member PMatrix2D
         * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        shearY: function(angle) {
          this.apply(1, 0, 1, 0, Math.tan(angle), 0);
        },
        /**
         * @member PMatrix2D
         * The determinant() function calvculates the determinant of this matrix.
         *
         * @return {float} the determinant of the matrix
         */
        determinant: function() {
          return this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3];
        },
        /**
         * @member PMatrix2D
         * The invert() function inverts this matrix
         *
         * @return {boolean} true if successful
         */
        invert: function() {
          var d = this.determinant();
          if (Math.abs(d) > PConstants3.MIN_INT) {
            var old00 = this.elements[0];
            var old01 = this.elements[1];
            var old02 = this.elements[2];
            var old10 = this.elements[3];
            var old11 = this.elements[4];
            var old12 = this.elements[5];
            this.elements[0] = old11 / d;
            this.elements[3] = -old10 / d;
            this.elements[1] = -old01 / d;
            this.elements[4] = old00 / d;
            this.elements[2] = (old01 * old12 - old11 * old02) / d;
            this.elements[5] = (old10 * old02 - old00 * old12) / d;
            return true;
          }
          return false;
        },
        /**
         * @member PMatrix2D
         * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.
         * This is equivalent to a two parameter call.
         *
         * @param {float} sx  the amount to scale on the x-axis
         * @param {float} sy  the amount to scale on the y-axis
         */
        scale: function(sx, sy) {
          if (sx && !sy) {
            sy = sx;
          }
          if (sx && sy) {
            this.elements[0] *= sx;
            this.elements[1] *= sy;
            this.elements[3] *= sx;
            this.elements[4] *= sy;
          }
        },
        /**
         * @member PMatrix2D
         * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.
         * This is equivalent to a two parameter call.
         *
         * @param {float} sx  the amount to scale on the x-axis
         * @param {float} sy  the amount to scale on the y-axis
         */
        invScale: function(sx, sy) {
          if (sx && !sy) {
            sy = sx;
          }
          this.scale(1 / sx, 1 / sy);
        },
        /**
         * @member PMatrix2D
         * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.
         *
         * @param {PMatrix2D} matrix    the matrix to apply this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the third element of the matrix
         * @param {float} m10           the fourth element of the matrix
         * @param {float} m11           the fith element of the matrix
         * @param {float} m12           the sixth element of the matrix
         */
        apply: function() {
          var source2;
          if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
            source2 = arguments[0].array();
          } else if (arguments.length === 6) {
            source2 = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            source2 = arguments[0];
          }
          var result = [
            0,
            0,
            this.elements[2],
            0,
            0,
            this.elements[5]
          ];
          var e = 0;
          for (var row = 0; row < 2; row++) {
            for (var col = 0; col < 3; col++, e++) {
              result[e] += this.elements[row * 3 + 0] * source2[col + 0] + this.elements[row * 3 + 1] * source2[col + 3];
            }
          }
          this.elements = result.slice();
        },
        /**
         * @member PMatrix2D
         * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.
         *
         * @param {PMatrix2D} matrix    the matrix to apply this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the third element of the matrix
         * @param {float} m10           the fourth element of the matrix
         * @param {float} m11           the fith element of the matrix
         * @param {float} m12           the sixth element of the matrix
         */
        preApply: function() {
          var source2;
          if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
            source2 = arguments[0].array();
          } else if (arguments.length === 6) {
            source2 = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            source2 = arguments[0];
          }
          var result = [
            0,
            0,
            source2[2],
            0,
            0,
            source2[5]
          ];
          result[2] = source2[2] + this.elements[2] * source2[0] + this.elements[5] * source2[1];
          result[5] = source2[5] + this.elements[2] * source2[3] + this.elements[5] * source2[4];
          result[0] = this.elements[0] * source2[0] + this.elements[3] * source2[1];
          result[3] = this.elements[0] * source2[3] + this.elements[3] * source2[4];
          result[1] = this.elements[1] * source2[0] + this.elements[4] * source2[1];
          result[4] = this.elements[1] * source2[3] + this.elements[4] * source2[4];
          this.elements = result.slice();
        },
        /**
         * @member PMatrix2D
         * The rotate() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotate: function(angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var temp1 = this.elements[0];
          var temp2 = this.elements[1];
          this.elements[0] = c * temp1 + s * temp2;
          this.elements[1] = -s * temp1 + c * temp2;
          temp1 = this.elements[3];
          temp2 = this.elements[4];
          this.elements[3] = c * temp1 + s * temp2;
          this.elements[4] = -s * temp1 + c * temp2;
        },
        /**
         * @member PMatrix2D
         * The rotateZ() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotateZ: function(angle) {
          this.rotate(angle);
        },
        /**
         * @member PMatrix2D
         * The invRotateZ() function rotates the matrix in opposite direction.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        invRotateZ: function(angle) {
          this.rotateZ(angle - Math.PI);
        },
        /**
         * @member PMatrix2D
         * The print() function prints out the elements of this matrix
         */
        print: function() {
          var digits = printMatrixHelper2(this.elements);
          var output = "" + p.nfs(this.elements[0], digits, 4) + " " + p.nfs(this.elements[1], digits, 4) + " " + p.nfs(this.elements[2], digits, 4) + "\n" + p.nfs(this.elements[3], digits, 4) + " " + p.nfs(this.elements[4], digits, 4) + " " + p.nfs(this.elements[5], digits, 4) + "\n\n";
          p.println(output);
        }
      };
      var PMatrix3D2 = p.PMatrix3D = function() {
        this.reset();
      };
      PMatrix3D2.prototype = {
        /**
         * @member PMatrix2D
         * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.
         *
         * @param {PMatrix3D} matrix    the initial matrix to set to
         * @param {float[]} elements    an array of elements to set this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the second element of the matrix
         * @param {float} m02           the third element of the matrix
         * @param {float} m03           the fourth element of the matrix
         * @param {float} m10           the fifth element of the matrix
         * @param {float} m11           the sixth element of the matrix
         * @param {float} m12           the seventh element of the matrix
         * @param {float} m13           the eight element of the matrix
         * @param {float} m20           the nineth element of the matrix
         * @param {float} m21           the tenth element of the matrix
         * @param {float} m22           the eleventh element of the matrix
         * @param {float} m23           the twelveth element of the matrix
         * @param {float} m30           the thirteenth element of the matrix
         * @param {float} m31           the fourtheenth element of the matrix
         * @param {float} m32           the fivetheenth element of the matrix
         * @param {float} m33           the sixteenth element of the matrix
         */
        set: function() {
          if (arguments.length === 16) {
            this.elements = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
            this.elements = arguments[0].array();
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            this.elements = arguments[0].slice();
          }
        },
        /**
         * @member PMatrix3D
         * The get() function returns a copy of this PMatrix3D.
         *
         * @return {PMatrix3D} a copy of this PMatrix3D
         */
        get: function() {
          var outgoing = new PMatrix3D2();
          outgoing.set(this.elements);
          return outgoing;
        },
        /**
         * @member PMatrix3D
         * The reset() function sets this PMatrix3D to the identity matrix.
         */
        reset: function() {
          this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ];
        },
        /**
         * @member PMatrix3D
         * The array() function returns a copy of the element values.
         * @addon
         *
         * @return {float[]} returns a copy of the element values
         */
        array: function array() {
          return this.elements.slice();
        },
        /**
         * @member PMatrix3D
         * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.
         *
         * @param {float} tx  the x-axis coordinate to move to
         * @param {float} ty  the y-axis coordinate to move to
         * @param {float} tz  the z-axis coordinate to move to
         */
        translate: function(tx, ty, tz) {
          if (tz === undef) {
            tz = 0;
          }
          this.elements[3] += tx * this.elements[0] + ty * this.elements[1] + tz * this.elements[2];
          this.elements[7] += tx * this.elements[4] + ty * this.elements[5] + tz * this.elements[6];
          this.elements[11] += tx * this.elements[8] + ty * this.elements[9] + tz * this.elements[10];
          this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];
        },
        /**
         * @member PMatrix3D
         * The transpose() function transpose this matrix.
         */
        transpose: function() {
          var temp = this.elements[4];
          this.elements[4] = this.elements[1];
          this.elements[1] = temp;
          temp = this.elements[8];
          this.elements[8] = this.elements[2];
          this.elements[2] = temp;
          temp = this.elements[6];
          this.elements[6] = this.elements[9];
          this.elements[9] = temp;
          temp = this.elements[3];
          this.elements[3] = this.elements[12];
          this.elements[12] = temp;
          temp = this.elements[7];
          this.elements[7] = this.elements[13];
          this.elements[13] = temp;
          temp = this.elements[11];
          this.elements[11] = this.elements[14];
          this.elements[14] = temp;
        },
        /**
         * @member PMatrix3D
         * The mult() function multiplied this matrix.
         * If two array elements are passed in the function will multiply a two element vector against this matrix.
         * If target is null or not length four, a new float array will be returned.
         * The values for vec and target can be the same (though that's less efficient).
         * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.
         *
         * @param {PVector} source, target  the PVectors used to multiply this matrix
         * @param {float[]} source, target  the arrays used to multiply this matrix
         *
         * @return {PVector|float[]} returns a PVector or an array representing the new matrix
         */
        mult: function(source2, target) {
          var x, y, z, w;
          if (source2 instanceof PVector3) {
            x = source2.x;
            y = source2.y;
            z = source2.z;
            w = 1;
            if (!target) {
              target = new PVector3();
            }
          } else if (source2 instanceof Array) {
            x = source2[0];
            y = source2[1];
            z = source2[2];
            w = source2[3] || 1;
            if (!target || target.length !== 3 && target.length !== 4) {
              target = [0, 0, 0];
            }
          }
          if (target instanceof Array) {
            if (target.length === 3) {
              target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
              target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
              target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
            } else if (target.length === 4) {
              target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;
              target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;
              target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;
              target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;
            }
          }
          if (target instanceof PVector3) {
            target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
            target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
            target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
          }
          return target;
        },
        /**
         * @member PMatrix3D
         * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.
         *
         * @param {PMatrix3D} matrix    the matrix to apply this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the second element of the matrix
         * @param {float} m02           the third element of the matrix
         * @param {float} m03           the fourth element of the matrix
         * @param {float} m10           the fifth element of the matrix
         * @param {float} m11           the sixth element of the matrix
         * @param {float} m12           the seventh element of the matrix
         * @param {float} m13           the eight element of the matrix
         * @param {float} m20           the nineth element of the matrix
         * @param {float} m21           the tenth element of the matrix
         * @param {float} m22           the eleventh element of the matrix
         * @param {float} m23           the twelveth element of the matrix
         * @param {float} m30           the thirteenth element of the matrix
         * @param {float} m31           the fourtheenth element of the matrix
         * @param {float} m32           the fivetheenth element of the matrix
         * @param {float} m33           the sixteenth element of the matrix
         */
        preApply: function() {
          var source2;
          if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
            source2 = arguments[0].array();
          } else if (arguments.length === 16) {
            source2 = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            source2 = arguments[0];
          }
          var result = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          var e = 0;
          for (var row = 0; row < 4; row++) {
            for (var col = 0; col < 4; col++, e++) {
              result[e] += this.elements[col + 0] * source2[row * 4 + 0] + this.elements[col + 4] * source2[row * 4 + 1] + this.elements[col + 8] * source2[row * 4 + 2] + this.elements[col + 12] * source2[row * 4 + 3];
            }
          }
          this.elements = result.slice();
        },
        /**
         * @member PMatrix3D
         * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.
         *
         * @param {PMatrix3D} matrix    the matrix to apply this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the second element of the matrix
         * @param {float} m02           the third element of the matrix
         * @param {float} m03           the fourth element of the matrix
         * @param {float} m10           the fifth element of the matrix
         * @param {float} m11           the sixth element of the matrix
         * @param {float} m12           the seventh element of the matrix
         * @param {float} m13           the eight element of the matrix
         * @param {float} m20           the nineth element of the matrix
         * @param {float} m21           the tenth element of the matrix
         * @param {float} m22           the eleventh element of the matrix
         * @param {float} m23           the twelveth element of the matrix
         * @param {float} m30           the thirteenth element of the matrix
         * @param {float} m31           the fourtheenth element of the matrix
         * @param {float} m32           the fivetheenth element of the matrix
         * @param {float} m33           the sixteenth element of the matrix
         */
        apply: function() {
          var source2;
          if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
            source2 = arguments[0].array();
          } else if (arguments.length === 16) {
            source2 = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            source2 = arguments[0];
          }
          var result = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          var e = 0;
          for (var row = 0; row < 4; row++) {
            for (var col = 0; col < 4; col++, e++) {
              result[e] += this.elements[row * 4 + 0] * source2[col + 0] + this.elements[row * 4 + 1] * source2[col + 4] + this.elements[row * 4 + 2] * source2[col + 8] + this.elements[row * 4 + 3] * source2[col + 12];
            }
          }
          this.elements = result.slice();
        },
        /**
         * @member PMatrix3D
         * The rotate() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotate: function(angle, v0, v1, v2) {
          if (arguments.length < 4) {
            this.rotateZ(angle);
          } else {
            var v = new PVector3(v0, v1, v2);
            var m = v.mag();
            if (m === 0) {
              return;
            } else if (m != 1) {
              v.normalize();
              v0 = v.x;
              v1 = v.y;
              v2 = v.z;
            }
            var c = p.cos(angle);
            var s = p.sin(angle);
            var t2 = 1 - c;
            this.apply(
              t2 * v0 * v0 + c,
              t2 * v0 * v1 - s * v2,
              t2 * v0 * v2 + s * v1,
              0,
              t2 * v0 * v1 + s * v2,
              t2 * v1 * v1 + c,
              t2 * v1 * v2 - s * v0,
              0,
              t2 * v0 * v2 - s * v1,
              t2 * v1 * v2 + s * v0,
              t2 * v2 * v2 + c,
              0,
              0,
              0,
              0,
              1
            );
          }
        },
        /**
         * @member PMatrix3D
         * The invApply() function applies the inverted matrix to this matrix.
         *
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the second element of the matrix
         * @param {float} m02           the third element of the matrix
         * @param {float} m03           the fourth element of the matrix
         * @param {float} m10           the fifth element of the matrix
         * @param {float} m11           the sixth element of the matrix
         * @param {float} m12           the seventh element of the matrix
         * @param {float} m13           the eight element of the matrix
         * @param {float} m20           the nineth element of the matrix
         * @param {float} m21           the tenth element of the matrix
         * @param {float} m22           the eleventh element of the matrix
         * @param {float} m23           the twelveth element of the matrix
         * @param {float} m30           the thirteenth element of the matrix
         * @param {float} m31           the fourtheenth element of the matrix
         * @param {float} m32           the fivetheenth element of the matrix
         * @param {float} m33           the sixteenth element of the matrix
         *
         * @return {boolean} returns true if the operation was successful.
         */
        invApply: function() {
          if (inverseCopy2 === undef) {
            inverseCopy2 = new PMatrix3D2();
          }
          var a = arguments;
          inverseCopy2.set(
            a[0],
            a[1],
            a[2],
            a[3],
            a[4],
            a[5],
            a[6],
            a[7],
            a[8],
            a[9],
            a[10],
            a[11],
            a[12],
            a[13],
            a[14],
            a[15]
          );
          if (!inverseCopy2.invert()) {
            return false;
          }
          this.preApply(inverseCopy2);
          return true;
        },
        /**
         * @member PMatrix3D
         * The rotateZ() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotateX: function(angle) {
          var c = p.cos(angle);
          var s = p.sin(angle);
          this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);
        },
        /**
         * @member PMatrix3D
         * The rotateY() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotateY: function(angle) {
          var c = p.cos(angle);
          var s = p.sin(angle);
          this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);
        },
        /**
         * @member PMatrix3D
         * The rotateZ() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotateZ: function(angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        },
        /**
         * @member PMatrix3D
         * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.
         * This is equivalent to a three parameter call.
         *
         * @param {float} sx  the amount to scale on the x-axis
         * @param {float} sy  the amount to scale on the y-axis
         * @param {float} sz  the amount to scale on the z-axis
         */
        scale: function(sx, sy, sz) {
          if (sx && !sy && !sz) {
            sy = sz = sx;
          } else if (sx && sy && !sz) {
            sz = 1;
          }
          if (sx && sy && sz) {
            this.elements[0] *= sx;
            this.elements[1] *= sy;
            this.elements[2] *= sz;
            this.elements[4] *= sx;
            this.elements[5] *= sy;
            this.elements[6] *= sz;
            this.elements[8] *= sx;
            this.elements[9] *= sy;
            this.elements[10] *= sz;
            this.elements[12] *= sx;
            this.elements[13] *= sy;
            this.elements[14] *= sz;
          }
        },
        /**
         * @member PMatrix3D
         * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        skewX: function(angle) {
          var t2 = Math.tan(angle);
          this.apply(1, t2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        /**
         * @member PMatrix3D
         * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        skewY: function(angle) {
          var t2 = Math.tan(angle);
          this.apply(1, 0, 0, 0, t2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        /**
         * @member PMatrix3D
         * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of shear specified in radians
         */
        shearX: function(angle) {
          var t2 = Math.tan(angle);
          this.apply(1, t2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        /**
         * @member PMatrix3D
         * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of shear specified in radians
         */
        shearY: function(angle) {
          var t2 = Math.tan(angle);
          this.apply(1, 0, 0, 0, t2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        multX: function(x, y, z, w) {
          if (!z) {
            return this.elements[0] * x + this.elements[1] * y + this.elements[3];
          }
          if (!w) {
            return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
          }
          return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;
        },
        multY: function(x, y, z, w) {
          if (!z) {
            return this.elements[4] * x + this.elements[5] * y + this.elements[7];
          }
          if (!w) {
            return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
          }
          return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;
        },
        multZ: function(x, y, z, w) {
          if (!w) {
            return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
          }
          return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;
        },
        multW: function(x, y, z, w) {
          if (!w) {
            return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];
          }
          return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;
        },
        /**
         * @member PMatrix3D
         * The invert() function inverts this matrix
         *
         * @return {boolean} true if successful
         */
        invert: function() {
          var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];
          var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];
          var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];
          var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];
          var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];
          var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];
          var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];
          var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];
          var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];
          var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];
          var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];
          var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];
          var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;
          if (Math.abs(fDet) <= 1e-9) {
            return false;
          }
          var kInv = [];
          kInv[0] = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;
          kInv[4] = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;
          kInv[8] = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;
          kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;
          kInv[1] = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;
          kInv[5] = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;
          kInv[9] = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;
          kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;
          kInv[2] = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;
          kInv[6] = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;
          kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;
          kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;
          kInv[3] = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;
          kInv[7] = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;
          kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;
          kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;
          var fInvDet = 1 / fDet;
          kInv[0] *= fInvDet;
          kInv[1] *= fInvDet;
          kInv[2] *= fInvDet;
          kInv[3] *= fInvDet;
          kInv[4] *= fInvDet;
          kInv[5] *= fInvDet;
          kInv[6] *= fInvDet;
          kInv[7] *= fInvDet;
          kInv[8] *= fInvDet;
          kInv[9] *= fInvDet;
          kInv[10] *= fInvDet;
          kInv[11] *= fInvDet;
          kInv[12] *= fInvDet;
          kInv[13] *= fInvDet;
          kInv[14] *= fInvDet;
          kInv[15] *= fInvDet;
          this.elements = kInv.slice();
          return true;
        },
        toString: function() {
          var str = "";
          for (var i2 = 0; i2 < 15; i2++) {
            str += this.elements[i2] + ", ";
          }
          str += this.elements[15];
          return str;
        },
        /**
         * @member PMatrix3D
         * The print() function prints out the elements of this matrix
         */
        print: function() {
          var digits = printMatrixHelper2(this.elements);
          var output = "" + p.nfs(this.elements[0], digits, 4) + " " + p.nfs(this.elements[1], digits, 4) + " " + p.nfs(this.elements[2], digits, 4) + " " + p.nfs(this.elements[3], digits, 4) + "\n" + p.nfs(this.elements[4], digits, 4) + " " + p.nfs(this.elements[5], digits, 4) + " " + p.nfs(this.elements[6], digits, 4) + " " + p.nfs(this.elements[7], digits, 4) + "\n" + p.nfs(this.elements[8], digits, 4) + " " + p.nfs(this.elements[9], digits, 4) + " " + p.nfs(this.elements[10], digits, 4) + " " + p.nfs(this.elements[11], digits, 4) + "\n" + p.nfs(this.elements[12], digits, 4) + " " + p.nfs(this.elements[13], digits, 4) + " " + p.nfs(this.elements[14], digits, 4) + " " + p.nfs(this.elements[15], digits, 4) + "\n\n";
          p.println(output);
        },
        invTranslate: function(tx, ty, tz) {
          this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);
        },
        invRotateX: function(angle) {
          var c = Math.cos(-angle);
          var s = Math.sin(-angle);
          this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);
        },
        invRotateY: function(angle) {
          var c = Math.cos(-angle);
          var s = Math.sin(-angle);
          this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);
        },
        invRotateZ: function(angle) {
          var c = Math.cos(-angle);
          var s = Math.sin(-angle);
          this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        },
        invScale: function(x, y, z) {
          this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);
        }
      };
      var PMatrixStack = p.PMatrixStack = function() {
        this.matrixStack = [];
      };
      PMatrixStack.prototype.load = function() {
        var tmpMatrix = drawing.$newPMatrix();
        if (arguments.length === 1) {
          tmpMatrix.set(arguments[0]);
        } else {
          tmpMatrix.set(arguments);
        }
        this.matrixStack.push(tmpMatrix);
      };
      Drawing2D.prototype.$newPMatrix = function() {
        return new PMatrix2D2();
      };
      Drawing3D.prototype.$newPMatrix = function() {
        return new PMatrix3D2();
      };
      PMatrixStack.prototype.push = function() {
        this.matrixStack.push(this.peek());
      };
      PMatrixStack.prototype.pop = function() {
        return this.matrixStack.pop();
      };
      PMatrixStack.prototype.peek = function() {
        var tmpMatrix = drawing.$newPMatrix();
        tmpMatrix.set(this.matrixStack[this.matrixStack.length - 1]);
        return tmpMatrix;
      };
      PMatrixStack.prototype.mult = function(matrix) {
        this.matrixStack[this.matrixStack.length - 1].apply(matrix);
      };
      p.split = function(str, delim) {
        return str.split(delim);
      };
      p.splitTokens = function(str, tokens) {
        if (tokens === undef) {
          return str.split(/\s+/g);
        }
        var chars = tokens.split(/()/g), buffer = "", len = str.length, i2, c, tokenized = [];
        for (i2 = 0; i2 < len; i2++) {
          c = str[i2];
          if (chars.indexOf(c) > -1) {
            if (buffer !== "") {
              tokenized.push(buffer);
            }
            buffer = "";
          } else {
            buffer += c;
          }
        }
        if (buffer !== "") {
          tokenized.push(buffer);
        }
        return tokenized;
      };
      p.append = function(array, element) {
        array[array.length] = element;
        return array;
      };
      p.concat = function(array1, array2) {
        return array1.concat(array2);
      };
      p.sort = function(array, numElem) {
        var ret = [];
        if (array.length > 0) {
          var elemsToCopy = numElem > 0 ? numElem : array.length;
          for (var i2 = 0; i2 < elemsToCopy; i2++) {
            ret.push(array[i2]);
          }
          if (typeof array[0] === "string") {
            ret.sort();
          } else {
            ret.sort(function(a, b) {
              return a - b;
            });
          }
          if (numElem > 0) {
            for (var j = ret.length; j < array.length; j++) {
              ret.push(array[j]);
            }
          }
        }
        return ret;
      };
      p.splice = function(array, value, index) {
        if (value.length === 0) {
          return array;
        }
        if (value instanceof Array) {
          for (var i2 = 0, j = index; i2 < value.length; j++, i2++) {
            array.splice(j, 0, value[i2]);
          }
        } else {
          array.splice(index, 0, value);
        }
        return array;
      };
      p.subset = function(array, offset, length) {
        var end = length !== undef ? offset + length : array.length;
        return array.slice(offset, end);
      };
      p.join = function(array, seperator) {
        return array.join(seperator);
      };
      p.shorten = function(ary) {
        var newary = [];
        var len = ary.length;
        for (var i2 = 0; i2 < len; i2++) {
          newary[i2] = ary[i2];
        }
        newary.pop();
        return newary;
      };
      p.expand = function(ary, targetSize) {
        var temp = ary.slice(0), newSize = targetSize || ary.length * 2;
        temp.length = newSize;
        return temp;
      };
      p.arrayCopy = function() {
        var src, srcPos = 0, dest, destPos = 0, length;
        if (arguments.length === 2) {
          src = arguments[0];
          dest = arguments[1];
          length = src.length;
        } else if (arguments.length === 3) {
          src = arguments[0];
          dest = arguments[1];
          length = arguments[2];
        } else if (arguments.length === 5) {
          src = arguments[0];
          srcPos = arguments[1];
          dest = arguments[2];
          destPos = arguments[3];
          length = arguments[4];
        }
        for (var i2 = srcPos, j = destPos; i2 < length + srcPos; i2++, j++) {
          if (dest[j] !== undef) {
            dest[j] = src[i2];
          } else {
            throw "array index out of bounds exception";
          }
        }
      };
      p.reverse = function(array) {
        return array.reverse();
      };
      p.mix = function(a, b, f) {
        return a + ((b - a) * f >> 8);
      };
      p.peg = function(n) {
        return n < 0 ? 0 : n > 255 ? 255 : n;
      };
      p.modes = function() {
        var ALPHA_MASK = PConstants3.ALPHA_MASK, RED_MASK = PConstants3.RED_MASK, GREEN_MASK = PConstants3.GREEN_MASK, BLUE_MASK = PConstants3.BLUE_MASK, min = Math.min, max = Math.max;
        function applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb) {
          var a = min(((c1 & 4278190080) >>> 24) + f, 255) << 24;
          var r = ar + ((cr - ar) * f >> 8);
          r = (r < 0 ? 0 : r > 255 ? 255 : r) << 16;
          var g = ag + ((cg - ag) * f >> 8);
          g = (g < 0 ? 0 : g > 255 ? 255 : g) << 8;
          var b = ab + ((cb - ab) * f >> 8);
          b = b < 0 ? 0 : b > 255 ? 255 : b;
          return a | r | g | b;
        }
        return {
          replace: function(c1, c2) {
            return c2;
          },
          blend: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = c1 & RED_MASK, ag = c1 & GREEN_MASK, ab = c1 & BLUE_MASK, br = c2 & RED_MASK, bg = c2 & GREEN_MASK, bb = c2 & BLUE_MASK;
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | ar + ((br - ar) * f >> 8) & RED_MASK | ag + ((bg - ag) * f >> 8) & GREEN_MASK | ab + ((bb - ab) * f >> 8) & BLUE_MASK;
          },
          add: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24;
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | min((c1 & RED_MASK) + ((c2 & RED_MASK) >> 8) * f, RED_MASK) & RED_MASK | min((c1 & GREEN_MASK) + ((c2 & GREEN_MASK) >> 8) * f, GREEN_MASK) & GREEN_MASK | min((c1 & BLUE_MASK) + ((c2 & BLUE_MASK) * f >> 8), BLUE_MASK);
          },
          subtract: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24;
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | max((c1 & RED_MASK) - ((c2 & RED_MASK) >> 8) * f, GREEN_MASK) & RED_MASK | max((c1 & GREEN_MASK) - ((c2 & GREEN_MASK) >> 8) * f, BLUE_MASK) & GREEN_MASK | max((c1 & BLUE_MASK) - ((c2 & BLUE_MASK) * f >> 8), 0);
          },
          lightest: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24;
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | max(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f) & RED_MASK | max(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f) & GREEN_MASK | max(c1 & BLUE_MASK, (c2 & BLUE_MASK) * f >> 8);
          },
          darkest: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = c1 & RED_MASK, ag = c1 & GREEN_MASK, ab = c1 & BLUE_MASK, br = min(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f), bg = min(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f), bb = min(c1 & BLUE_MASK, (c2 & BLUE_MASK) * f >> 8);
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | ar + ((br - ar) * f >> 8) & RED_MASK | ag + ((bg - ag) * f >> 8) & GREEN_MASK | ab + ((bb - ab) * f >> 8) & BLUE_MASK;
          },
          difference: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar > br ? ar - br : br - ar, cg = ag > bg ? ag - bg : bg - ag, cb = ab > bb ? ab - bb : bb - ab;
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          exclusion: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar + br - (ar * br >> 7), cg = ag + bg - (ag * bg >> 7), cb = ab + bb - (ab * bb >> 7);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          multiply: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar * br >> 8, cg = ag * bg >> 8, cb = ab * bb >> 8;
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          screen: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = 255 - ((255 - ar) * (255 - br) >> 8), cg = 255 - ((255 - ag) * (255 - bg) >> 8), cb = 255 - ((255 - ab) * (255 - bb) >> 8);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          hard_light: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = br < 128 ? ar * br >> 7 : 255 - ((255 - ar) * (255 - br) >> 7), cg = bg < 128 ? ag * bg >> 7 : 255 - ((255 - ag) * (255 - bg) >> 7), cb = bb < 128 ? ab * bb >> 7 : 255 - ((255 - ab) * (255 - bb) >> 7);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          soft_light: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = (ar * br >> 7) + (ar * ar >> 8) - (ar * ar * br >> 15), cg = (ag * bg >> 7) + (ag * ag >> 8) - (ag * ag * bg >> 15), cb = (ab * bb >> 7) + (ab * ab >> 8) - (ab * ab * bb >> 15);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          overlay: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar < 128 ? ar * br >> 7 : 255 - ((255 - ar) * (255 - br) >> 7), cg = ag < 128 ? ag * bg >> 7 : 255 - ((255 - ag) * (255 - bg) >> 7), cb = ab < 128 ? ab * bb >> 7 : 255 - ((255 - ab) * (255 - bb) >> 7);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          dodge: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK;
            var cr = 255;
            if (br !== 255) {
              cr = (ar << 8) / (255 - br);
              cr = cr < 0 ? 0 : cr > 255 ? 255 : cr;
            }
            var cg = 255;
            if (bg !== 255) {
              cg = (ag << 8) / (255 - bg);
              cg = cg < 0 ? 0 : cg > 255 ? 255 : cg;
            }
            var cb = 255;
            if (bb !== 255) {
              cb = (ab << 8) / (255 - bb);
              cb = cb < 0 ? 0 : cb > 255 ? 255 : cb;
            }
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          burn: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK;
            var cr = 0;
            if (br !== 0) {
              cr = (255 - ar << 8) / br;
              cr = 255 - (cr < 0 ? 0 : cr > 255 ? 255 : cr);
            }
            var cg = 0;
            if (bg !== 0) {
              cg = (255 - ag << 8) / bg;
              cg = 255 - (cg < 0 ? 0 : cg > 255 ? 255 : cg);
            }
            var cb = 0;
            if (bb !== 0) {
              cb = (255 - ab << 8) / bb;
              cb = 255 - (cb < 0 ? 0 : cb > 255 ? 255 : cb);
            }
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          }
        };
      }();
      function color$4(aValue1, aValue2, aValue3, aValue4) {
        var r, g, b, a;
        if (curColorMode === PConstants3.HSB) {
          var rgb = p.color.toRGB(aValue1, aValue2, aValue3);
          r = rgb[0];
          g = rgb[1];
          b = rgb[2];
        } else {
          r = Math.round(255 * (aValue1 / colorModeX));
          g = Math.round(255 * (aValue2 / colorModeY));
          b = Math.round(255 * (aValue3 / colorModeZ));
        }
        a = Math.round(255 * (aValue4 / colorModeA));
        r = r < 0 ? 0 : r;
        g = g < 0 ? 0 : g;
        b = b < 0 ? 0 : b;
        a = a < 0 ? 0 : a;
        r = r > 255 ? 255 : r;
        g = g > 255 ? 255 : g;
        b = b > 255 ? 255 : b;
        a = a > 255 ? 255 : a;
        return a << 24 & PConstants3.ALPHA_MASK | r << 16 & PConstants3.RED_MASK | g << 8 & PConstants3.GREEN_MASK | b & PConstants3.BLUE_MASK;
      }
      function color$2(aValue1, aValue2) {
        var a;
        if (aValue1 & PConstants3.ALPHA_MASK) {
          a = Math.round(255 * (aValue2 / colorModeA));
          a = a > 255 ? 255 : a;
          a = a < 0 ? 0 : a;
          return aValue1 - (aValue1 & PConstants3.ALPHA_MASK) + (a << 24 & PConstants3.ALPHA_MASK);
        }
        if (curColorMode === PConstants3.RGB) {
          return color$4(aValue1, aValue1, aValue1, aValue2);
        }
        if (curColorMode === PConstants3.HSB) {
          return color$4(0, 0, aValue1 / colorModeX * colorModeZ, aValue2);
        }
      }
      function color$1(aValue1) {
        if (aValue1 <= colorModeX && aValue1 >= 0) {
          if (curColorMode === PConstants3.RGB) {
            return color$4(aValue1, aValue1, aValue1, colorModeA);
          }
          if (curColorMode === PConstants3.HSB) {
            return color$4(0, 0, aValue1 / colorModeX * colorModeZ, colorModeA);
          }
        }
        if (aValue1) {
          if (aValue1 > 2147483647) {
            aValue1 -= 4294967296;
          }
          return aValue1;
        }
      }
      p.color = function(aValue1, aValue2, aValue3, aValue4) {
        if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef && aValue4 !== undef) {
          return color$4(aValue1, aValue2, aValue3, aValue4);
        }
        if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef) {
          return color$4(aValue1, aValue2, aValue3, colorModeA);
        }
        if (aValue1 !== undef && aValue2 !== undef) {
          return color$2(aValue1, aValue2);
        }
        if (typeof aValue1 === "number") {
          return color$1(aValue1);
        }
        return color$4(colorModeX, colorModeY, colorModeZ, colorModeA);
      };
      p.color.toString = function(colorInt) {
        return "rgba(" + ((colorInt & PConstants3.RED_MASK) >>> 16) + "," + ((colorInt & PConstants3.GREEN_MASK) >>> 8) + "," + (colorInt & PConstants3.BLUE_MASK) + "," + ((colorInt & PConstants3.ALPHA_MASK) >>> 24) / 255 + ")";
      };
      p.color.toInt = function(r, g, b, a) {
        return a << 24 & PConstants3.ALPHA_MASK | r << 16 & PConstants3.RED_MASK | g << 8 & PConstants3.GREEN_MASK | b & PConstants3.BLUE_MASK;
      };
      p.color.toArray = function(colorInt) {
        return [
          (colorInt & PConstants3.RED_MASK) >>> 16,
          (colorInt & PConstants3.GREEN_MASK) >>> 8,
          colorInt & PConstants3.BLUE_MASK,
          (colorInt & PConstants3.ALPHA_MASK) >>> 24
        ];
      };
      p.color.toGLArray = function(colorInt) {
        return [
          ((colorInt & PConstants3.RED_MASK) >>> 16) / 255,
          ((colorInt & PConstants3.GREEN_MASK) >>> 8) / 255,
          (colorInt & PConstants3.BLUE_MASK) / 255,
          ((colorInt & PConstants3.ALPHA_MASK) >>> 24) / 255
        ];
      };
      p.color.toRGB = function(h, s, b) {
        h = h > colorModeX ? colorModeX : h;
        s = s > colorModeY ? colorModeY : s;
        b = b > colorModeZ ? colorModeZ : b;
        h = h < 0 ? 0 : h;
        h = h / colorModeX * 360;
        s = s / colorModeY * 100;
        b = b / colorModeZ * 100;
        var br = Math.round(b / 100 * 255);
        if (s === 0) {
          return [br, br, br];
        }
        var hue = h % 360;
        var f = hue % 60;
        var p2 = Math.round(b * (100 - s) / 1e4 * 255);
        var q = Math.round(b * (6e3 - s * f) / 6e5 * 255);
        var t2 = Math.round(b * (6e3 - s * (60 - f)) / 6e5 * 255);
        switch (Math.floor(hue / 60)) {
          case 0:
            return [br, t2, p2];
          case 1:
            return [q, br, p2];
          case 2:
            return [p2, br, t2];
          case 3:
            return [p2, q, br];
          case 4:
            return [t2, p2, br];
          case 5:
            return [br, p2, q];
          default:
            Processing3.debug("Unexpectedly hit default case in toRGB function.");
        }
      };
      function colorToHSB(colorInt) {
        var red, green, blue;
        red = ((colorInt & PConstants3.RED_MASK) >>> 16) / 255;
        green = ((colorInt & PConstants3.GREEN_MASK) >>> 8) / 255;
        blue = (colorInt & PConstants3.BLUE_MASK) / 255;
        var max = p.max(p.max(red, green), blue), min = p.min(p.min(red, green), blue), hue, saturation;
        if (min === max) {
          return [0, 0, max * colorModeZ];
        }
        saturation = (max - min) / max;
        if (red === max) {
          hue = (green - blue) / (max - min);
        } else if (green === max) {
          hue = 2 + (blue - red) / (max - min);
        } else {
          hue = 4 + (red - green) / (max - min);
        }
        hue /= 6;
        if (hue < 0) {
          hue += 1;
        } else if (hue > 1) {
          hue -= 1;
        }
        return [hue * colorModeX, saturation * colorModeY, max * colorModeZ];
      }
      p.brightness = function(colInt) {
        return colorToHSB(colInt)[2];
      };
      p.saturation = function(colInt) {
        return colorToHSB(colInt)[1];
      };
      p.hue = function(colInt) {
        return colorToHSB(colInt)[0];
      };
      p.red = function(aColor) {
        return ((aColor & PConstants3.RED_MASK) >>> 16) / 255 * colorModeX;
      };
      p.green = function(aColor) {
        return ((aColor & PConstants3.GREEN_MASK) >>> 8) / 255 * colorModeY;
      };
      p.blue = function(aColor) {
        return (aColor & PConstants3.BLUE_MASK) / 255 * colorModeZ;
      };
      p.alpha = function(aColor) {
        return ((aColor & PConstants3.ALPHA_MASK) >>> 24) / 255 * colorModeA;
      };
      p.lerpColor = function(c1, c2, amt) {
        var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;
        var hsb1, hsb2, rgb, h, s;
        var colorBits1 = p.color(c1);
        var colorBits2 = p.color(c2);
        if (curColorMode === PConstants3.HSB) {
          hsb1 = colorToHSB(colorBits1);
          a1 = ((colorBits1 & PConstants3.ALPHA_MASK) >>> 24) / colorModeA;
          hsb2 = colorToHSB(colorBits2);
          a2 = ((colorBits2 & PConstants3.ALPHA_MASK) >>> 24) / colorModeA;
          h = p.lerp(hsb1[0], hsb2[0], amt);
          s = p.lerp(hsb1[1], hsb2[1], amt);
          b = p.lerp(hsb1[2], hsb2[2], amt);
          rgb = p.color.toRGB(h, s, b);
          a = p.lerp(a1, a2, amt) * colorModeA + 0.5 | 0;
          return a << 24 & PConstants3.ALPHA_MASK | rgb[0] << 16 & PConstants3.RED_MASK | rgb[1] << 8 & PConstants3.GREEN_MASK | rgb[2] & PConstants3.BLUE_MASK;
        }
        r1 = (colorBits1 & PConstants3.RED_MASK) >>> 16;
        g1 = (colorBits1 & PConstants3.GREEN_MASK) >>> 8;
        b1 = colorBits1 & PConstants3.BLUE_MASK;
        a1 = ((colorBits1 & PConstants3.ALPHA_MASK) >>> 24) / colorModeA;
        r2 = (colorBits2 & PConstants3.RED_MASK) >>> 16;
        g2 = (colorBits2 & PConstants3.GREEN_MASK) >>> 8;
        b2 = colorBits2 & PConstants3.BLUE_MASK;
        a2 = ((colorBits2 & PConstants3.ALPHA_MASK) >>> 24) / colorModeA;
        r = p.lerp(r1, r2, amt) + 0.5 | 0;
        g = p.lerp(g1, g2, amt) + 0.5 | 0;
        b = p.lerp(b1, b2, amt) + 0.5 | 0;
        a = p.lerp(a1, a2, amt) * colorModeA + 0.5 | 0;
        return a << 24 & PConstants3.ALPHA_MASK | r << 16 & PConstants3.RED_MASK | g << 8 & PConstants3.GREEN_MASK | b & PConstants3.BLUE_MASK;
      };
      p.colorMode = function() {
        curColorMode = arguments[0];
        if (arguments.length > 1) {
          colorModeX = arguments[1];
          colorModeY = arguments[2] || arguments[1];
          colorModeZ = arguments[3] || arguments[1];
          colorModeA = arguments[4] || arguments[1];
        }
      };
      p.blendColor = function(c1, c2, mode) {
        if (mode === PConstants3.REPLACE) {
          return p.modes.replace(c1, c2);
        } else if (mode === PConstants3.BLEND) {
          return p.modes.blend(c1, c2);
        } else if (mode === PConstants3.ADD) {
          return p.modes.add(c1, c2);
        } else if (mode === PConstants3.SUBTRACT) {
          return p.modes.subtract(c1, c2);
        } else if (mode === PConstants3.LIGHTEST) {
          return p.modes.lightest(c1, c2);
        } else if (mode === PConstants3.DARKEST) {
          return p.modes.darkest(c1, c2);
        } else if (mode === PConstants3.DIFFERENCE) {
          return p.modes.difference(c1, c2);
        } else if (mode === PConstants3.EXCLUSION) {
          return p.modes.exclusion(c1, c2);
        } else if (mode === PConstants3.MULTIPLY) {
          return p.modes.multiply(c1, c2);
        } else if (mode === PConstants3.SCREEN) {
          return p.modes.screen(c1, c2);
        } else if (mode === PConstants3.HARD_LIGHT) {
          return p.modes.hard_light(c1, c2);
        } else if (mode === PConstants3.SOFT_LIGHT) {
          return p.modes.soft_light(c1, c2);
        } else if (mode === PConstants3.OVERLAY) {
          return p.modes.overlay(c1, c2);
        } else if (mode === PConstants3.DODGE) {
          return p.modes.dodge(c1, c2);
        } else if (mode === PConstants3.BURN) {
          return p.modes.burn(c1, c2);
        }
      };
      function saveContext() {
        curContext.save();
      }
      function restoreContext() {
        curContext.restore();
        isStrokeDirty = true;
        isFillDirty = true;
      }
      p.printMatrix = function() {
        modelView.print();
      };
      Drawing2D.prototype.translate = function(x, y) {
        modelView.translate(x, y);
        modelViewInv.invTranslate(x, y);
        curContext.translate(x, y);
      };
      Drawing3D.prototype.translate = function(x, y, z) {
        modelView.translate(x, y, z);
        modelViewInv.invTranslate(x, y, z);
      };
      Drawing2D.prototype.scale = function(x, y) {
        modelView.scale(x, y);
        modelViewInv.invScale(x, y);
        curContext.scale(x, y || x);
      };
      Drawing3D.prototype.scale = function(x, y, z) {
        modelView.scale(x, y, z);
        modelViewInv.invScale(x, y, z);
      };
      Drawing2D.prototype.transform = function(pmatrix) {
        var e = pmatrix.array();
        curContext.transform(e[0], e[3], e[1], e[4], e[2], e[5]);
      };
      Drawing3D.prototype.transformm = function(pmatrix3d) {
        throw "p.transform is currently not supported in 3D mode";
      };
      Drawing2D.prototype.pushMatrix = function() {
        userMatrixStack.load(modelView);
        userReverseMatrixStack.load(modelViewInv);
        saveContext();
      };
      Drawing3D.prototype.pushMatrix = function() {
        userMatrixStack.load(modelView);
        userReverseMatrixStack.load(modelViewInv);
      };
      Drawing2D.prototype.popMatrix = function() {
        modelView.set(userMatrixStack.pop());
        modelViewInv.set(userReverseMatrixStack.pop());
        restoreContext();
      };
      Drawing3D.prototype.popMatrix = function() {
        modelView.set(userMatrixStack.pop());
        modelViewInv.set(userReverseMatrixStack.pop());
      };
      Drawing2D.prototype.resetMatrix = function() {
        modelView.reset();
        modelViewInv.reset();
        curContext.setTransform(1, 0, 0, 1, 0, 0);
      };
      Drawing3D.prototype.resetMatrix = function() {
        modelView.reset();
        modelViewInv.reset();
      };
      DrawingShared.prototype.applyMatrix = function() {
        var a = arguments;
        modelView.apply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
        modelViewInv.invApply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
      };
      Drawing2D.prototype.applyMatrix = function() {
        var a = arguments;
        for (var cnt = a.length; cnt < 16; cnt++) {
          a[cnt] = 0;
        }
        a[10] = a[15] = 1;
        DrawingShared.prototype.applyMatrix.apply(this, a);
      };
      p.rotateX = function(angleInRadians) {
        modelView.rotateX(angleInRadians);
        modelViewInv.invRotateX(angleInRadians);
      };
      Drawing2D.prototype.rotateZ = function() {
        throw "rotateZ() is not supported in 2D mode. Use rotate(float) instead.";
      };
      Drawing3D.prototype.rotateZ = function(angleInRadians) {
        modelView.rotateZ(angleInRadians);
        modelViewInv.invRotateZ(angleInRadians);
      };
      p.rotateY = function(angleInRadians) {
        modelView.rotateY(angleInRadians);
        modelViewInv.invRotateY(angleInRadians);
      };
      Drawing2D.prototype.rotate = function(angleInRadians) {
        modelView.rotateZ(angleInRadians);
        modelViewInv.invRotateZ(angleInRadians);
        curContext.rotate(angleInRadians);
      };
      Drawing3D.prototype.rotate = function(angleInRadians) {
        if (arguments.length < 4) {
          p.rotateZ(angleInRadians);
        } else {
          modelView.rotate(angleInRadians, arguments[1], arguments[2], arguments[3]);
          modelViewInv.rotate(-angleInRadians, arguments[1], arguments[2], arguments[3]);
        }
      };
      Drawing2D.prototype.shearX = function(angleInRadians) {
        modelView.shearX(angleInRadians);
        curContext.transform(1, 0, angleInRadians, 1, 0, 0);
      };
      Drawing3D.prototype.shearX = function(angleInRadians) {
        modelView.shearX(angleInRadians);
      };
      Drawing2D.prototype.shearY = function(angleInRadians) {
        modelView.shearY(angleInRadians);
        curContext.transform(1, angleInRadians, 0, 1, 0, 0);
      };
      Drawing3D.prototype.shearY = function(angleInRadians) {
        modelView.shearY(angleInRadians);
      };
      p.pushStyle = function() {
        saveContext();
        p.pushMatrix();
        var newState = {
          "doFill": doFill,
          "currentFillColor": currentFillColor,
          "doStroke": doStroke,
          "currentStrokeColor": currentStrokeColor,
          "curTint": curTint,
          "curRectMode": curRectMode,
          "curColorMode": curColorMode,
          "colorModeX": colorModeX,
          "colorModeZ": colorModeZ,
          "colorModeY": colorModeY,
          "colorModeA": colorModeA,
          "curTextFont": curTextFont,
          "horizontalTextAlignment": horizontalTextAlignment,
          "verticalTextAlignment": verticalTextAlignment,
          "textMode": textMode,
          "curFontName": curFontName,
          "curTextSize": curTextSize,
          "curTextAscent": curTextAscent,
          "curTextDescent": curTextDescent,
          "curTextLeading": curTextLeading
        };
        styleArray.push(newState);
      };
      p.popStyle = function() {
        var oldState = styleArray.pop();
        if (oldState) {
          restoreContext();
          p.popMatrix();
          doFill = oldState.doFill;
          currentFillColor = oldState.currentFillColor;
          doStroke = oldState.doStroke;
          currentStrokeColor = oldState.currentStrokeColor;
          curTint = oldState.curTint;
          curRectMode = oldState.curRectMode;
          curColorMode = oldState.curColorMode;
          colorModeX = oldState.colorModeX;
          colorModeZ = oldState.colorModeZ;
          colorModeY = oldState.colorModeY;
          colorModeA = oldState.colorModeA;
          curTextFont = oldState.curTextFont;
          curFontName = oldState.curFontName;
          curTextSize = oldState.curTextSize;
          horizontalTextAlignment = oldState.horizontalTextAlignment;
          verticalTextAlignment = oldState.verticalTextAlignment;
          textMode = oldState.textMode;
          curTextAscent = oldState.curTextAscent;
          curTextDescent = oldState.curTextDescent;
          curTextLeading = oldState.curTextLeading;
        } else {
          throw "Too many popStyle() without enough pushStyle()";
        }
      };
      p.year = function() {
        return (/* @__PURE__ */ new Date()).getFullYear();
      };
      p.month = function() {
        return (/* @__PURE__ */ new Date()).getMonth() + 1;
      };
      p.day = function() {
        return (/* @__PURE__ */ new Date()).getDate();
      };
      p.hour = function() {
        return (/* @__PURE__ */ new Date()).getHours();
      };
      p.minute = function() {
        return (/* @__PURE__ */ new Date()).getMinutes();
      };
      p.second = function() {
        return (/* @__PURE__ */ new Date()).getSeconds();
      };
      p.millis = function() {
        return Date.now() - start;
      };
      function redrawHelper() {
        var sec = (Date.now() - timeSinceLastFPS) / 1e3;
        framesSinceLastFPS++;
        var fps = framesSinceLastFPS / sec;
        if (sec > 0.5) {
          timeSinceLastFPS = Date.now();
          framesSinceLastFPS = 0;
          p.__frameRate = fps;
        }
        p.frameCount++;
      }
      Drawing2D.prototype.redraw = function() {
        redrawHelper();
        curContext.lineWidth = lineWidth;
        var pmouseXLastEvent = p.pmouseX, pmouseYLastEvent = p.pmouseY;
        p.pmouseX = pmouseXLastFrame;
        p.pmouseY = pmouseYLastFrame;
        saveContext();
        p.draw();
        restoreContext();
        pmouseXLastFrame = p.mouseX;
        pmouseYLastFrame = p.mouseY;
        p.pmouseX = pmouseXLastEvent;
        p.pmouseY = pmouseYLastEvent;
      };
      Drawing3D.prototype.redraw = function() {
        redrawHelper();
        var pmouseXLastEvent = p.pmouseX, pmouseYLastEvent = p.pmouseY;
        p.pmouseX = pmouseXLastFrame;
        p.pmouseY = pmouseYLastFrame;
        curContext.clear(curContext.DEPTH_BUFFER_BIT);
        curContextCache = { attributes: {}, locations: {} };
        p.noLights();
        p.lightFalloff(1, 0, 0);
        p.shininess(1);
        p.ambient(255, 255, 255);
        p.specular(0, 0, 0);
        p.emissive(0, 0, 0);
        p.camera();
        p.draw();
        pmouseXLastFrame = p.mouseX;
        pmouseYLastFrame = p.mouseY;
        p.pmouseX = pmouseXLastEvent;
        p.pmouseY = pmouseYLastEvent;
      };
      p.noLoop = function() {
        doLoop = false;
        loopStarted = false;
        clearInterval(looping);
        curSketch.onPause();
      };
      p.loop = function() {
        if (loopStarted) {
          return;
        }
        timeSinceLastFPS = Date.now();
        framesSinceLastFPS = 0;
        looping = window2.setInterval(function() {
          try {
            curSketch.onFrameStart();
            p.redraw();
            curSketch.onFrameEnd();
          } catch (e_loop) {
            window2.clearInterval(looping);
            throw e_loop;
          }
        }, curMsPerFrame);
        doLoop = true;
        loopStarted = true;
        curSketch.onLoop();
      };
      p.frameRate = function(aRate) {
        curFrameRate = aRate;
        curMsPerFrame = 1e3 / curFrameRate;
        if (doLoop) {
          p.noLoop();
          p.loop();
        }
      };
      p.exit = function() {
        window2.clearInterval(looping);
        removeInstance(p.externals.canvas.id);
        delete curElement.onmousedown;
        for (var lib in Processing3.lib) {
          if (Processing3.lib.hasOwnProperty(lib)) {
            if (Processing3.lib[lib].hasOwnProperty("detach")) {
              Processing3.lib[lib].detach(p);
            }
          }
        }
        var i2 = eventHandlers.length;
        while (i2--) {
          detachEventHandler2(eventHandlers[i2]);
        }
        curSketch.onExit();
      };
      p.cursor = function() {
        if (arguments.length > 1 || arguments.length === 1 && arguments[0] instanceof p.PImage) {
          var image = arguments[0], x, y;
          if (arguments.length >= 3) {
            x = arguments[1];
            y = arguments[2];
            if (x < 0 || y < 0 || y >= image.height || x >= image.width) {
              throw "x and y must be non-negative and less than the dimensions of the image";
            }
          } else {
            x = image.width >>> 1;
            y = image.height >>> 1;
          }
          var imageDataURL = image.toDataURL();
          var style = 'url("' + imageDataURL + '") ' + x + " " + y + ", default";
          curCursor = curElement.style.cursor = style;
        } else if (arguments.length === 1) {
          var mode = arguments[0];
          curCursor = curElement.style.cursor = mode;
        } else {
          curCursor = curElement.style.cursor = oldCursor;
        }
      };
      p.noCursor = function() {
        curCursor = curElement.style.cursor = PConstants3.NOCURSOR;
      };
      p.link = function(href, target) {
        if (target !== undef) {
          window2.open(href, target);
        } else {
          window2.location = href;
        }
      };
      p.beginDraw = noop;
      p.endDraw = noop;
      Drawing2D.prototype.toImageData = function(x, y, w, h) {
        x = x !== undef ? x : 0;
        y = y !== undef ? y : 0;
        w = w !== undef ? w : p.width;
        h = h !== undef ? h : p.height;
        return curContext.getImageData(x, y, w, h);
      };
      Drawing3D.prototype.toImageData = function(x, y, w, h) {
        x = x !== undef ? x : 0;
        y = y !== undef ? y : 0;
        w = w !== undef ? w : p.width;
        h = h !== undef ? h : p.height;
        var c = document2.createElement("canvas"), ctx = c.getContext("2d"), obj = ctx.createImageData(w, h), uBuff = new Uint8Array2(w * h * 4);
        curContext.readPixels(x, y, w, h, curContext.RGBA, curContext.UNSIGNED_BYTE, uBuff);
        for (var i2 = 0, ul = uBuff.length, obj_data = obj.data; i2 < ul; i2++) {
          obj_data[i2] = uBuff[(h - 1 - Math.floor(i2 / 4 / w)) * w * 4 + i2 % (w * 4)];
        }
        return obj;
      };
      p.status = function(text) {
        window2.status = text;
      };
      p.binary = function(num, numBits) {
        var bit;
        if (numBits > 0) {
          bit = numBits;
        } else if (num instanceof Char2) {
          bit = 16;
          num |= 0;
        } else {
          bit = 32;
          while (bit > 1 && !(num >>> bit - 1 & 1)) {
            bit--;
          }
        }
        var result = "";
        while (bit > 0) {
          result += num >>> --bit & 1 ? "1" : "0";
        }
        return result;
      };
      p.unbinary = function(binaryString) {
        var i2 = binaryString.length - 1, mask = 1, result = 0;
        while (i2 >= 0) {
          var ch = binaryString[i2--];
          if (ch !== "0" && ch !== "1") {
            throw "the value passed into unbinary was not an 8 bit binary number";
          }
          if (ch === "1") {
            result += mask;
          }
          mask <<= 1;
        }
        return result;
      };
      var decimalToHex = function(d, padding) {
        padding = padding === undef || padding === null ? padding = 8 : padding;
        if (d < 0) {
          d = 4294967295 + d + 1;
        }
        var hex = Number(d).toString(16).toUpperCase();
        while (hex.length < padding) {
          hex = "0" + hex;
        }
        if (hex.length >= padding) {
          hex = hex.substring(hex.length - padding, hex.length);
        }
        return hex;
      };
      p.hex = function(value, len) {
        if (arguments.length === 1) {
          if (value instanceof Char2) {
            len = 4;
          } else {
            len = 8;
          }
        }
        return decimalToHex(value, len);
      };
      function unhexScalar(hex) {
        var value = parseInt("0x" + hex, 16);
        if (value > 2147483647) {
          value -= 4294967296;
        }
        return value;
      }
      p.unhex = function(hex) {
        if (hex instanceof Array) {
          var arr = [];
          for (var i2 = 0; i2 < hex.length; i2++) {
            arr.push(unhexScalar(hex[i2]));
          }
          return arr;
        }
        return unhexScalar(hex);
      };
      p.loadStrings = function(filename) {
        if (localStorage[filename]) {
          return localStorage[filename].split("\n");
        }
        var filecontent = ajax(filename);
        if (typeof filecontent !== "string" || filecontent === "") {
          return [];
        }
        filecontent = filecontent.replace(/(\r\n?)/g, "\n").replace(/\n$/, "");
        return filecontent.split("\n");
      };
      p.saveStrings = function(filename, strings) {
        localStorage[filename] = strings.join("\n");
      };
      p.loadBytes = function(url) {
        var string = ajax(url);
        var ret = [];
        for (var i2 = 0; i2 < string.length; i2++) {
          ret.push(string.charCodeAt(i2));
        }
        return ret;
      };
      p.matchAll = function(aString, aRegExp) {
        var results = [], latest;
        var regexp = new RegExp(aRegExp, "g");
        while ((latest = regexp.exec(aString)) !== null) {
          results.push(latest);
          if (latest[0].length === 0) {
            ++regexp.lastIndex;
          }
        }
        return results.length > 0 ? results : null;
      };
      p.match = function(str, regexp) {
        return str.match(regexp);
      };
      var logBuffer = [];
      p.println = function() {
        Processing3.logger.println.apply(Processing3.logger, arguments);
      };
      p.print = function() {
        Processing3.logger.print.apply(Processing3.logger, arguments);
      };
      p.str = function(val) {
        if (val instanceof Array) {
          var arr = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            arr.push(val[i2].toString() + "");
          }
          return arr;
        }
        return val.toString() + "";
      };
      function booleanScalar(val) {
        if (typeof val === "number") {
          return val !== 0;
        }
        if (typeof val === "boolean") {
          return val;
        }
        if (typeof val === "string") {
          return val.toLowerCase() === "true";
        }
        if (val instanceof Char2) {
          return val.code === 49 || val.code === 84 || val.code === 116;
        }
      }
      p.parseBoolean = function(val) {
        if (val instanceof Array) {
          var ret = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            ret.push(booleanScalar(val[i2]));
          }
          return ret;
        }
        return booleanScalar(val);
      };
      p.parseByte = function(what) {
        if (what instanceof Array) {
          var bytes = [];
          for (var i2 = 0; i2 < what.length; i2++) {
            bytes.push(0 - (what[i2] & 128) | what[i2] & 127);
          }
          return bytes;
        }
        return 0 - (what & 128) | what & 127;
      };
      p.parseChar = function(key) {
        if (typeof key === "number") {
          return new Char2(String.fromCharCode(key & 65535));
        }
        if (key instanceof Array) {
          var ret = [];
          for (var i2 = 0; i2 < key.length; i2++) {
            ret.push(new Char2(String.fromCharCode(key[i2] & 65535)));
          }
          return ret;
        }
        throw "char() may receive only one argument of type int, byte, int[], or byte[].";
      };
      function floatScalar(val) {
        if (typeof val === "number") {
          return val;
        }
        if (typeof val === "boolean") {
          return val ? 1 : 0;
        }
        if (typeof val === "string") {
          return parseFloat(val);
        }
        if (val instanceof Char2) {
          return val.code;
        }
      }
      p.parseFloat = function(val) {
        if (val instanceof Array) {
          var ret = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            ret.push(floatScalar(val[i2]));
          }
          return ret;
        }
        return floatScalar(val);
      };
      function intScalar(val, radix) {
        if (typeof val === "number") {
          return val & 4294967295;
        }
        if (typeof val === "boolean") {
          return val ? 1 : 0;
        }
        if (typeof val === "string") {
          var number = parseInt(val, radix || 10);
          return number & 4294967295;
        }
        if (val instanceof Char2) {
          return val.code;
        }
      }
      p.parseInt = function(val, radix) {
        if (val instanceof Array) {
          var ret = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            if (typeof val[i2] === "string" && !/^\s*[+\-]?\d+\s*$/.test(val[i2])) {
              ret.push(0);
            } else {
              ret.push(intScalar(val[i2], radix));
            }
          }
          return ret;
        }
        return intScalar(val, radix);
      };
      p.__int_cast = function(val) {
        return 0 | val;
      };
      p.__instanceof = function(obj, type) {
        if (typeof type !== "function") {
          throw "Function is expected as type argument for instanceof operator";
        }
        if (typeof obj === "string") {
          return type === Object || type === String;
        }
        if (obj instanceof type) {
          return true;
        }
        if (typeof obj !== "object" || obj === null) {
          return false;
        }
        var objType = obj.constructor;
        if (type.$isInterface) {
          var interfaces = [];
          while (objType) {
            if (objType.$interfaces) {
              interfaces = interfaces.concat(objType.$interfaces);
            }
            objType = objType.$base;
          }
          while (interfaces.length > 0) {
            var i2 = interfaces.shift();
            if (i2 === type) {
              return true;
            }
            if (i2.$interfaces) {
              interfaces = interfaces.concat(i2.$interfaces);
            }
          }
          return false;
        }
        while (objType.hasOwnProperty("$base")) {
          objType = objType.$base;
          if (objType === type) {
            return true;
          }
        }
        return false;
      };
      DrawingShared.prototype.size = function(aWidth, aHeight, aMode) {
        if (doStroke) {
          p.stroke(0);
        }
        if (doFill) {
          p.fill(255);
        }
        var savedProperties = {
          fillStyle: curContext.fillStyle,
          strokeStyle: curContext.strokeStyle,
          lineCap: curContext.lineCap,
          lineJoin: curContext.lineJoin
        };
        if (curElement.style.length > 0) {
          curElement.style.removeProperty("width");
          curElement.style.removeProperty("height");
        }
        curElement.width = p.width = aWidth || 100;
        curElement.height = p.height = aHeight || 100;
        for (var prop in savedProperties) {
          if (savedProperties.hasOwnProperty(prop)) {
            curContext[prop] = savedProperties[prop];
          }
        }
        p.textFont(curTextFont);
        p.background();
        maxPixelsCached = Math.max(1e3, aWidth * aHeight * 0.05);
        p.externals.context = curContext;
        for (var i2 = 0; i2 < PConstants3.SINCOS_LENGTH; i2++) {
          sinLUT[i2] = p.sin(i2 * (PConstants3.PI / 180) * 0.5);
          cosLUT[i2] = p.cos(i2 * (PConstants3.PI / 180) * 0.5);
        }
      };
      Drawing2D.prototype.size = function(aWidth, aHeight, aMode) {
        if (curContext === undef) {
          curContext = curElement.getContext("2d");
          userMatrixStack = new PMatrixStack();
          userReverseMatrixStack = new PMatrixStack();
          modelView = new PMatrix2D2();
          modelViewInv = new PMatrix2D2();
        }
        DrawingShared.prototype.size.apply(this, arguments);
      };
      Drawing3D.prototype.size = /* @__PURE__ */ function() {
        var size3DCalled = false;
        return function size(aWidth, aHeight, aMode) {
          if (size3DCalled) {
            throw "Multiple calls to size() for 3D renders are not allowed.";
          }
          size3DCalled = true;
          function getGLContext(canvas) {
            var ctxNames = ["experimental-webgl", "webgl", "webkit-3d"], gl;
            for (var i2 = 0, l2 = ctxNames.length; i2 < l2; i2++) {
              gl = canvas.getContext(ctxNames[i2], { antialias: false, preserveDrawingBuffer: true });
              if (gl) {
                break;
              }
            }
            return gl;
          }
          try {
            curElement.width = p.width = aWidth || 100;
            curElement.height = p.height = aHeight || 100;
            curContext = getGLContext(curElement);
            canTex = curContext.createTexture();
            textTex = curContext.createTexture();
          } catch (e_size) {
            Processing3.debug(e_size);
          }
          if (!curContext) {
            throw "WebGL context is not supported on this browser.";
          }
          curContext.viewport(0, 0, curElement.width, curElement.height);
          curContext.enable(curContext.DEPTH_TEST);
          curContext.enable(curContext.BLEND);
          curContext.blendFunc(curContext.SRC_ALPHA, curContext.ONE_MINUS_SRC_ALPHA);
          programObject2D = createProgramObject(curContext, vertexShaderSrc2D, fragmentShaderSrc2D);
          programObjectUnlitShape = createProgramObject(curContext, vertexShaderSrcUnlitShape, fragmentShaderSrcUnlitShape);
          p.strokeWeight(1);
          programObject3D = createProgramObject(curContext, vertexShaderSrc3D, fragmentShaderSrc3D);
          curContext.useProgram(programObject3D);
          uniformi("usingTexture3d", programObject3D, "usingTexture", usingTexture);
          p.lightFalloff(1, 0, 0);
          p.shininess(1);
          p.ambient(255, 255, 255);
          p.specular(0, 0, 0);
          p.emissive(0, 0, 0);
          boxBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, boxBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, boxVerts, curContext.STATIC_DRAW);
          boxNormBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, boxNormBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, boxNorms, curContext.STATIC_DRAW);
          boxOutlineBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, boxOutlineBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, boxOutlineVerts, curContext.STATIC_DRAW);
          rectBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, rectBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, rectVerts, curContext.STATIC_DRAW);
          rectNormBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, rectNormBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, rectNorms, curContext.STATIC_DRAW);
          sphereBuffer = curContext.createBuffer();
          lineBuffer = curContext.createBuffer();
          fillBuffer = curContext.createBuffer();
          fillColorBuffer = curContext.createBuffer();
          strokeColorBuffer = curContext.createBuffer();
          shapeTexVBO = curContext.createBuffer();
          pointBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, pointBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2([0, 0, 0]), curContext.STATIC_DRAW);
          textBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, textBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]), curContext.STATIC_DRAW);
          textureBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, textureBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2([0, 0, 1, 0, 1, 1, 0, 1]), curContext.STATIC_DRAW);
          indexBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
          curContext.bufferData(curContext.ELEMENT_ARRAY_BUFFER, new Uint16Array2([0, 1, 2, 2, 3, 0]), curContext.STATIC_DRAW);
          cam = new PMatrix3D2();
          cameraInv = new PMatrix3D2();
          modelView = new PMatrix3D2();
          modelViewInv = new PMatrix3D2();
          projection = new PMatrix3D2();
          p.camera();
          p.perspective();
          userMatrixStack = new PMatrixStack();
          userReverseMatrixStack = new PMatrixStack();
          curveBasisMatrix = new PMatrix3D2();
          curveToBezierMatrix = new PMatrix3D2();
          curveDrawMatrix = new PMatrix3D2();
          bezierDrawMatrix = new PMatrix3D2();
          bezierBasisInverse = new PMatrix3D2();
          bezierBasisMatrix = new PMatrix3D2();
          bezierBasisMatrix.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);
          DrawingShared.prototype.size.apply(this, arguments);
        };
      }();
      Drawing2D.prototype.ambientLight = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.ambientLight = function(r, g, b, x, y, z) {
        if (lightCount === PConstants3.MAX_LIGHTS) {
          throw "can only create " + PConstants3.MAX_LIGHTS + " lights";
        }
        var pos = new PVector3(x, y, z);
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.mult(pos, pos);
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        curContext.useProgram(programObject3D);
        uniformf("uLights.color.3d." + lightCount, programObject3D, "uLights" + lightCount + ".color", normalizedCol);
        uniformf("uLights.position.3d." + lightCount, programObject3D, "uLights" + lightCount + ".position", pos.array());
        uniformi("uLights.type.3d." + lightCount, programObject3D, "uLights" + lightCount + ".type", 0);
        uniformi("uLightCount3d", programObject3D, "uLightCount", ++lightCount);
      };
      Drawing2D.prototype.directionalLight = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.directionalLight = function(r, g, b, nx, ny, nz) {
        if (lightCount === PConstants3.MAX_LIGHTS) {
          throw "can only create " + PConstants3.MAX_LIGHTS + " lights";
        }
        curContext.useProgram(programObject3D);
        var mvm = new PMatrix3D2();
        mvm.scale(1, -1, 1);
        mvm.apply(modelView.array());
        mvm = mvm.array();
        var dir = [
          mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,
          mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,
          mvm[2] * nx + mvm[6] * ny + mvm[10] * nz
        ];
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        uniformf("uLights.color.3d." + lightCount, programObject3D, "uLights" + lightCount + ".color", normalizedCol);
        uniformf("uLights.position.3d." + lightCount, programObject3D, "uLights" + lightCount + ".position", dir);
        uniformi("uLights.type.3d." + lightCount, programObject3D, "uLights" + lightCount + ".type", 1);
        uniformi("uLightCount3d", programObject3D, "uLightCount", ++lightCount);
      };
      Drawing2D.prototype.lightFalloff = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.lightFalloff = function(constant, linear, quadratic) {
        curContext.useProgram(programObject3D);
        uniformf("uFalloff3d", programObject3D, "uFalloff", [constant, linear, quadratic]);
      };
      Drawing2D.prototype.lightSpecular = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.lightSpecular = function(r, g, b) {
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        curContext.useProgram(programObject3D);
        uniformf("uSpecular3d", programObject3D, "uSpecular", normalizedCol);
      };
      p.lights = function() {
        p.ambientLight(128, 128, 128);
        p.directionalLight(128, 128, 128, 0, 0, -1);
        p.lightFalloff(1, 0, 0);
        p.lightSpecular(0, 0, 0);
      };
      Drawing2D.prototype.pointLight = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.pointLight = function(r, g, b, x, y, z) {
        if (lightCount === PConstants3.MAX_LIGHTS) {
          throw "can only create " + PConstants3.MAX_LIGHTS + " lights";
        }
        var pos = new PVector3(x, y, z);
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.mult(pos, pos);
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        curContext.useProgram(programObject3D);
        uniformf("uLights.color.3d." + lightCount, programObject3D, "uLights" + lightCount + ".color", normalizedCol);
        uniformf("uLights.position.3d." + lightCount, programObject3D, "uLights" + lightCount + ".position", pos.array());
        uniformi("uLights.type.3d." + lightCount, programObject3D, "uLights" + lightCount + ".type", 2);
        uniformi("uLightCount3d", programObject3D, "uLightCount", ++lightCount);
      };
      Drawing2D.prototype.noLights = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.noLights = function() {
        lightCount = 0;
        curContext.useProgram(programObject3D);
        uniformi("uLightCount3d", programObject3D, "uLightCount", lightCount);
      };
      Drawing2D.prototype.spotLight = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.spotLight = function(r, g, b, x, y, z, nx, ny, nz, angle, concentration) {
        if (lightCount === PConstants3.MAX_LIGHTS) {
          throw "can only create " + PConstants3.MAX_LIGHTS + " lights";
        }
        curContext.useProgram(programObject3D);
        var pos = new PVector3(x, y, z);
        var mvm = new PMatrix3D2();
        mvm.scale(1, -1, 1);
        mvm.apply(modelView.array());
        mvm.mult(pos, pos);
        mvm = mvm.array();
        var dir = [
          mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,
          mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,
          mvm[2] * nx + mvm[6] * ny + mvm[10] * nz
        ];
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        uniformf("uLights.color.3d." + lightCount, programObject3D, "uLights" + lightCount + ".color", normalizedCol);
        uniformf("uLights.position.3d." + lightCount, programObject3D, "uLights" + lightCount + ".position", pos.array());
        uniformf("uLights.direction.3d." + lightCount, programObject3D, "uLights" + lightCount + ".direction", dir);
        uniformf("uLights.concentration.3d." + lightCount, programObject3D, "uLights" + lightCount + ".concentration", concentration);
        uniformf("uLights.angle.3d." + lightCount, programObject3D, "uLights" + lightCount + ".angle", angle);
        uniformi("uLights.type.3d." + lightCount, programObject3D, "uLights" + lightCount + ".type", 3);
        uniformi("uLightCount3d", programObject3D, "uLightCount", ++lightCount);
      };
      Drawing2D.prototype.beginCamera = function() {
        throw "beginCamera() is not available in 2D mode";
      };
      Drawing3D.prototype.beginCamera = function() {
        if (manipulatingCamera) {
          throw "You cannot call beginCamera() again before calling endCamera()";
        }
        manipulatingCamera = true;
        modelView = cameraInv;
        modelViewInv = cam;
      };
      Drawing2D.prototype.endCamera = function() {
        throw "endCamera() is not available in 2D mode";
      };
      Drawing3D.prototype.endCamera = function() {
        if (!manipulatingCamera) {
          throw "You cannot call endCamera() before calling beginCamera()";
        }
        modelView.set(cam);
        modelViewInv.set(cameraInv);
        manipulatingCamera = false;
      };
      p.camera = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
        if (eyeX === undef) {
          cameraX = p.width / 2;
          cameraY = p.height / 2;
          cameraZ = cameraY / Math.tan(cameraFOV / 2);
          eyeX = cameraX;
          eyeY = cameraY;
          eyeZ = cameraZ;
          centerX = cameraX;
          centerY = cameraY;
          centerZ = 0;
          upX = 0;
          upY = 1;
          upZ = 0;
        }
        var z = new PVector3(eyeX - centerX, eyeY - centerY, eyeZ - centerZ);
        var y = new PVector3(upX, upY, upZ);
        z.normalize();
        var x = PVector3.cross(y, z);
        y = PVector3.cross(z, x);
        x.normalize();
        y.normalize();
        var xX = x.x, xY = x.y, xZ = x.z;
        var yX = y.x, yY = y.y, yZ = y.z;
        var zX = z.x, zY = z.y, zZ = z.z;
        cam.set(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);
        cam.translate(-eyeX, -eyeY, -eyeZ);
        cameraInv.reset();
        cameraInv.invApply(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);
        cameraInv.translate(eyeX, eyeY, eyeZ);
        modelView.set(cam);
        modelViewInv.set(cameraInv);
      };
      p.perspective = function(fov, aspect, near, far) {
        if (arguments.length === 0) {
          cameraY = curElement.height / 2;
          cameraZ = cameraY / Math.tan(cameraFOV / 2);
          cameraNear = cameraZ / 10;
          cameraFar = cameraZ * 10;
          cameraAspect = p.width / p.height;
          fov = cameraFOV;
          aspect = cameraAspect;
          near = cameraNear;
          far = cameraFar;
        }
        var yMax, yMin, xMax, xMin;
        yMax = near * Math.tan(fov / 2);
        yMin = -yMax;
        xMax = yMax * aspect;
        xMin = yMin * aspect;
        p.frustum(xMin, xMax, yMin, yMax, near, far);
      };
      Drawing2D.prototype.frustum = function() {
        throw "Processing.js: frustum() is not supported in 2D mode";
      };
      Drawing3D.prototype.frustum = function(left, right, bottom, top, near, far) {
        frustumMode = true;
        projection = new PMatrix3D2();
        projection.set(
          2 * near / (right - left),
          0,
          (right + left) / (right - left),
          0,
          0,
          2 * near / (top - bottom),
          (top + bottom) / (top - bottom),
          0,
          0,
          0,
          -(far + near) / (far - near),
          -(2 * far * near) / (far - near),
          0,
          0,
          -1,
          0
        );
        var proj = new PMatrix3D2();
        proj.set(projection);
        proj.transpose();
        curContext.useProgram(programObject2D);
        uniformMatrix("projection2d", programObject2D, "uProjection", false, proj.array());
        curContext.useProgram(programObject3D);
        uniformMatrix("projection3d", programObject3D, "uProjection", false, proj.array());
        curContext.useProgram(programObjectUnlitShape);
        uniformMatrix("uProjectionUS", programObjectUnlitShape, "uProjection", false, proj.array());
      };
      p.ortho = function(left, right, bottom, top, near, far) {
        if (arguments.length === 0) {
          left = 0;
          right = p.width;
          bottom = 0;
          top = p.height;
          near = -10;
          far = 10;
        }
        var x = 2 / (right - left);
        var y = 2 / (top - bottom);
        var z = -2 / (far - near);
        var tx = -(right + left) / (right - left);
        var ty = -(top + bottom) / (top - bottom);
        var tz = -(far + near) / (far - near);
        projection = new PMatrix3D2();
        projection.set(x, 0, 0, tx, 0, y, 0, ty, 0, 0, z, tz, 0, 0, 0, 1);
        var proj = new PMatrix3D2();
        proj.set(projection);
        proj.transpose();
        curContext.useProgram(programObject2D);
        uniformMatrix("projection2d", programObject2D, "uProjection", false, proj.array());
        curContext.useProgram(programObject3D);
        uniformMatrix("projection3d", programObject3D, "uProjection", false, proj.array());
        curContext.useProgram(programObjectUnlitShape);
        uniformMatrix("uProjectionUS", programObjectUnlitShape, "uProjection", false, proj.array());
        frustumMode = false;
      };
      p.printProjection = function() {
        projection.print();
      };
      p.printCamera = function() {
        cam.print();
      };
      Drawing2D.prototype.box = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.box = function(w, h, d) {
        if (!h || !d) {
          h = d = w;
        }
        var model = new PMatrix3D2();
        model.scale(w, h, d);
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        if (doFill) {
          curContext.useProgram(programObject3D);
          uniformMatrix("model3d", programObject3D, "uModel", false, model.array());
          uniformMatrix("view3d", programObject3D, "uView", false, view.array());
          curContext.enable(curContext.POLYGON_OFFSET_FILL);
          curContext.polygonOffset(1, 1);
          uniformf("color3d", programObject3D, "uColor", fillStyle);
          if (lightCount > 0) {
            var v = new PMatrix3D2();
            v.set(view);
            var m = new PMatrix3D2();
            m.set(model);
            v.mult(m);
            var normalMatrix = new PMatrix3D2();
            normalMatrix.set(v);
            normalMatrix.invert();
            normalMatrix.transpose();
            uniformMatrix("uNormalTransform3d", programObject3D, "uNormalTransform", false, normalMatrix.array());
            vertexAttribPointer("aNormal3d", programObject3D, "aNormal", 3, boxNormBuffer);
          } else {
            disableVertexAttribPointer("aNormal3d", programObject3D, "aNormal");
          }
          vertexAttribPointer("aVertex3d", programObject3D, "aVertex", 3, boxBuffer);
          disableVertexAttribPointer("aColor3d", programObject3D, "aColor");
          disableVertexAttribPointer("aTexture3d", programObject3D, "aTexture");
          curContext.drawArrays(curContext.TRIANGLES, 0, boxVerts.length / 3);
          curContext.disable(curContext.POLYGON_OFFSET_FILL);
        }
        if (lineWidth > 0 && doStroke) {
          curContext.useProgram(programObject2D);
          uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
          uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText2d", programObject2D, "uIsDrawingText", false);
          vertexAttribPointer("vertex2d", programObject2D, "aVertex", 3, boxOutlineBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          curContext.drawArrays(curContext.LINES, 0, boxOutlineVerts.length / 3);
        }
      };
      var initSphere = function() {
        var i2;
        sphereVerts = [];
        for (i2 = 0; i2 < sphereDetailU; i2++) {
          sphereVerts.push(0);
          sphereVerts.push(-1);
          sphereVerts.push(0);
          sphereVerts.push(sphereX[i2]);
          sphereVerts.push(sphereY[i2]);
          sphereVerts.push(sphereZ[i2]);
        }
        sphereVerts.push(0);
        sphereVerts.push(-1);
        sphereVerts.push(0);
        sphereVerts.push(sphereX[0]);
        sphereVerts.push(sphereY[0]);
        sphereVerts.push(sphereZ[0]);
        var v1, v11, v2;
        var voff = 0;
        for (i2 = 2; i2 < sphereDetailV; i2++) {
          v1 = v11 = voff;
          voff += sphereDetailU;
          v2 = voff;
          for (var j = 0; j < sphereDetailU; j++) {
            sphereVerts.push(sphereX[v1]);
            sphereVerts.push(sphereY[v1]);
            sphereVerts.push(sphereZ[v1++]);
            sphereVerts.push(sphereX[v2]);
            sphereVerts.push(sphereY[v2]);
            sphereVerts.push(sphereZ[v2++]);
          }
          v1 = v11;
          v2 = voff;
          sphereVerts.push(sphereX[v1]);
          sphereVerts.push(sphereY[v1]);
          sphereVerts.push(sphereZ[v1]);
          sphereVerts.push(sphereX[v2]);
          sphereVerts.push(sphereY[v2]);
          sphereVerts.push(sphereZ[v2]);
        }
        for (i2 = 0; i2 < sphereDetailU; i2++) {
          v2 = voff + i2;
          sphereVerts.push(sphereX[v2]);
          sphereVerts.push(sphereY[v2]);
          sphereVerts.push(sphereZ[v2]);
          sphereVerts.push(0);
          sphereVerts.push(1);
          sphereVerts.push(0);
        }
        sphereVerts.push(sphereX[voff]);
        sphereVerts.push(sphereY[voff]);
        sphereVerts.push(sphereZ[voff]);
        sphereVerts.push(0);
        sphereVerts.push(1);
        sphereVerts.push(0);
        curContext.bindBuffer(curContext.ARRAY_BUFFER, sphereBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(sphereVerts), curContext.STATIC_DRAW);
      };
      p.sphereDetail = function(ures, vres) {
        var i2;
        if (arguments.length === 1) {
          ures = vres = arguments[0];
        }
        if (ures < 3) {
          ures = 3;
        }
        if (vres < 2) {
          vres = 2;
        }
        if (ures === sphereDetailU && vres === sphereDetailV) {
          return;
        }
        var delta = PConstants3.SINCOS_LENGTH / ures;
        var cx = new Float32Array2(ures);
        var cz = new Float32Array2(ures);
        for (i2 = 0; i2 < ures; i2++) {
          cx[i2] = cosLUT[i2 * delta % PConstants3.SINCOS_LENGTH | 0];
          cz[i2] = sinLUT[i2 * delta % PConstants3.SINCOS_LENGTH | 0];
        }
        var vertCount = ures * (vres - 1) + 2;
        var currVert = 0;
        sphereX = new Float32Array2(vertCount);
        sphereY = new Float32Array2(vertCount);
        sphereZ = new Float32Array2(vertCount);
        var angle_step = PConstants3.SINCOS_LENGTH * 0.5 / vres;
        var angle = angle_step;
        for (i2 = 1; i2 < vres; i2++) {
          var curradius = sinLUT[angle % PConstants3.SINCOS_LENGTH | 0];
          var currY = -cosLUT[angle % PConstants3.SINCOS_LENGTH | 0];
          for (var j = 0; j < ures; j++) {
            sphereX[currVert] = cx[j] * curradius;
            sphereY[currVert] = currY;
            sphereZ[currVert++] = cz[j] * curradius;
          }
          angle += angle_step;
        }
        sphereDetailU = ures;
        sphereDetailV = vres;
        initSphere();
      };
      Drawing2D.prototype.sphere = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.sphere = function() {
        var sRad = arguments[0];
        if (sphereDetailU < 3 || sphereDetailV < 2) {
          p.sphereDetail(30);
        }
        var model = new PMatrix3D2();
        model.scale(sRad, sRad, sRad);
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        if (doFill) {
          if (lightCount > 0) {
            var v = new PMatrix3D2();
            v.set(view);
            var m = new PMatrix3D2();
            m.set(model);
            v.mult(m);
            var normalMatrix = new PMatrix3D2();
            normalMatrix.set(v);
            normalMatrix.invert();
            normalMatrix.transpose();
            uniformMatrix("uNormalTransform3d", programObject3D, "uNormalTransform", false, normalMatrix.array());
            vertexAttribPointer("aNormal3d", programObject3D, "aNormal", 3, sphereBuffer);
          } else {
            disableVertexAttribPointer("aNormal3d", programObject3D, "aNormal");
          }
          curContext.useProgram(programObject3D);
          disableVertexAttribPointer("aTexture3d", programObject3D, "aTexture");
          uniformMatrix("uModel3d", programObject3D, "uModel", false, model.array());
          uniformMatrix("uView3d", programObject3D, "uView", false, view.array());
          vertexAttribPointer("aVertex3d", programObject3D, "aVertex", 3, sphereBuffer);
          disableVertexAttribPointer("aColor3d", programObject3D, "aColor");
          curContext.enable(curContext.POLYGON_OFFSET_FILL);
          curContext.polygonOffset(1, 1);
          uniformf("uColor3d", programObject3D, "uColor", fillStyle);
          curContext.drawArrays(curContext.TRIANGLE_STRIP, 0, sphereVerts.length / 3);
          curContext.disable(curContext.POLYGON_OFFSET_FILL);
        }
        if (lineWidth > 0 && doStroke) {
          curContext.useProgram(programObject2D);
          uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
          uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
          vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, sphereBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText", programObject2D, "uIsDrawingText", false);
          curContext.drawArrays(curContext.LINE_STRIP, 0, sphereVerts.length / 3);
        }
      };
      p.modelX = function(x, y, z) {
        var mv = modelView.array();
        var ci = cameraInv.array();
        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
        var ox = ci[0] * ax + ci[1] * ay + ci[2] * az + ci[3] * aw;
        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;
        return ow !== 0 ? ox / ow : ox;
      };
      p.modelY = function(x, y, z) {
        var mv = modelView.array();
        var ci = cameraInv.array();
        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
        var oy = ci[4] * ax + ci[5] * ay + ci[6] * az + ci[7] * aw;
        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;
        return ow !== 0 ? oy / ow : oy;
      };
      p.modelZ = function(x, y, z) {
        var mv = modelView.array();
        var ci = cameraInv.array();
        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
        var oz = ci[8] * ax + ci[9] * ay + ci[10] * az + ci[11] * aw;
        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;
        return ow !== 0 ? oz / ow : oz;
      };
      Drawing2D.prototype.ambient = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.ambient = function(v1, v2, v3) {
        curContext.useProgram(programObject3D);
        uniformi("uUsingMat3d", programObject3D, "uUsingMat", true);
        var col = p.color(v1, v2, v3);
        uniformf("uMaterialAmbient3d", programObject3D, "uMaterialAmbient", p.color.toGLArray(col).slice(0, 3));
      };
      Drawing2D.prototype.emissive = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.emissive = function(v1, v2, v3) {
        curContext.useProgram(programObject3D);
        uniformi("uUsingMat3d", programObject3D, "uUsingMat", true);
        var col = p.color(v1, v2, v3);
        uniformf("uMaterialEmissive3d", programObject3D, "uMaterialEmissive", p.color.toGLArray(col).slice(0, 3));
      };
      Drawing2D.prototype.shininess = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.shininess = function(shine) {
        curContext.useProgram(programObject3D);
        uniformi("uUsingMat3d", programObject3D, "uUsingMat", true);
        uniformf("uShininess3d", programObject3D, "uShininess", shine);
      };
      Drawing2D.prototype.specular = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.specular = function(v1, v2, v3) {
        curContext.useProgram(programObject3D);
        uniformi("uUsingMat3d", programObject3D, "uUsingMat", true);
        var col = p.color(v1, v2, v3);
        uniformf("uMaterialSpecular3d", programObject3D, "uMaterialSpecular", p.color.toGLArray(col).slice(0, 3));
      };
      p.screenX = function(x, y, z) {
        var mv = modelView.array();
        if (mv.length === 16) {
          var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
          var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
          var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
          var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
          var pj = projection.array();
          var ox = pj[0] * ax + pj[1] * ay + pj[2] * az + pj[3] * aw;
          var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;
          if (ow !== 0) {
            ox /= ow;
          }
          return p.width * (1 + ox) / 2;
        }
        return modelView.multX(x, y);
      };
      p.screenY = function screenY(x, y, z) {
        var mv = modelView.array();
        if (mv.length === 16) {
          var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
          var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
          var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
          var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
          var pj = projection.array();
          var oy = pj[4] * ax + pj[5] * ay + pj[6] * az + pj[7] * aw;
          var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;
          if (ow !== 0) {
            oy /= ow;
          }
          return p.height * (1 + oy) / 2;
        }
        return modelView.multY(x, y);
      };
      p.screenZ = function screenZ(x, y, z) {
        var mv = modelView.array();
        if (mv.length !== 16) {
          return 0;
        }
        var pj = projection.array();
        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
        var oz = pj[8] * ax + pj[9] * ay + pj[10] * az + pj[11] * aw;
        var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;
        if (ow !== 0) {
          oz /= ow;
        }
        return (oz + 1) / 2;
      };
      DrawingShared.prototype.fill = function() {
        var color = p.color.apply(this, arguments);
        if (color === currentFillColor && doFill) {
          return;
        }
        doFill = true;
        currentFillColor = color;
      };
      Drawing2D.prototype.fill = function() {
        DrawingShared.prototype.fill.apply(this, arguments);
        isFillDirty = true;
      };
      Drawing3D.prototype.fill = function() {
        DrawingShared.prototype.fill.apply(this, arguments);
        fillStyle = p.color.toGLArray(currentFillColor);
      };
      function executeContextFill() {
        if (doFill) {
          if (isFillDirty) {
            curContext.fillStyle = p.color.toString(currentFillColor);
            isFillDirty = false;
          }
          curContext.fill();
        }
      }
      p.noFill = function() {
        doFill = false;
      };
      DrawingShared.prototype.stroke = function() {
        var color = p.color.apply(this, arguments);
        if (color === currentStrokeColor && doStroke) {
          return;
        }
        doStroke = true;
        currentStrokeColor = color;
      };
      Drawing2D.prototype.stroke = function() {
        DrawingShared.prototype.stroke.apply(this, arguments);
        isStrokeDirty = true;
      };
      Drawing3D.prototype.stroke = function() {
        DrawingShared.prototype.stroke.apply(this, arguments);
        strokeStyle = p.color.toGLArray(currentStrokeColor);
      };
      function executeContextStroke() {
        if (doStroke) {
          if (isStrokeDirty) {
            curContext.strokeStyle = p.color.toString(currentStrokeColor);
            isStrokeDirty = false;
          }
          curContext.stroke();
        }
      }
      p.noStroke = function() {
        doStroke = false;
      };
      DrawingShared.prototype.strokeWeight = function(w) {
        lineWidth = w;
      };
      Drawing2D.prototype.strokeWeight = function(w) {
        DrawingShared.prototype.strokeWeight.apply(this, arguments);
        curContext.lineWidth = w;
      };
      Drawing3D.prototype.strokeWeight = function(w) {
        DrawingShared.prototype.strokeWeight.apply(this, arguments);
        curContext.useProgram(programObject2D);
        uniformf("pointSize2d", programObject2D, "uPointSize", w);
        curContext.useProgram(programObjectUnlitShape);
        uniformf("pointSizeUnlitShape", programObjectUnlitShape, "uPointSize", w);
        curContext.lineWidth(w);
      };
      p.strokeCap = function(value) {
        drawing.$ensureContext().lineCap = value;
      };
      p.strokeJoin = function(value) {
        drawing.$ensureContext().lineJoin = value;
      };
      Drawing2D.prototype.smooth = function() {
        renderSmooth = true;
        var style = curElement.style;
        style.setProperty("image-rendering", "optimizeQuality", "important");
        style.setProperty("-ms-interpolation-mode", "bicubic", "important");
        if (curContext.hasOwnProperty("mozImageSmoothingEnabled")) {
          curContext.mozImageSmoothingEnabled = true;
        }
      };
      Drawing3D.prototype.smooth = function() {
        renderSmooth = true;
      };
      Drawing2D.prototype.noSmooth = function() {
        renderSmooth = false;
        var style = curElement.style;
        style.setProperty("image-rendering", "optimizeSpeed", "important");
        style.setProperty("image-rendering", "-moz-crisp-edges", "important");
        style.setProperty("image-rendering", "-webkit-optimize-contrast", "important");
        style.setProperty("image-rendering", "optimize-contrast", "important");
        style.setProperty("-ms-interpolation-mode", "nearest-neighbor", "important");
        if (curContext.hasOwnProperty("mozImageSmoothingEnabled")) {
          curContext.mozImageSmoothingEnabled = false;
        }
      };
      Drawing3D.prototype.noSmooth = function() {
        renderSmooth = false;
      };
      Drawing2D.prototype.point = function(x, y) {
        if (!doStroke) {
          return;
        }
        if (!renderSmooth) {
          x = Math.round(x);
          y = Math.round(y);
        }
        curContext.fillStyle = p.color.toString(currentStrokeColor);
        isFillDirty = true;
        if (lineWidth > 1) {
          curContext.beginPath();
          curContext.arc(x, y, lineWidth / 2, 0, PConstants3.TWO_PI, false);
          curContext.fill();
        } else {
          curContext.fillRect(x, y, 1, 1);
        }
      };
      Drawing3D.prototype.point = function(x, y, z) {
        var model = new PMatrix3D2();
        model.translate(x, y, z || 0);
        model.transpose();
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObject2D);
        uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
        uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
        if (lineWidth > 0 && doStroke) {
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText2d", programObject2D, "uIsDrawingText", false);
          uniformi("uSmooth2d", programObject2D, "uSmooth", renderSmooth);
          vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, pointBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          curContext.drawArrays(curContext.POINTS, 0, 1);
        }
      };
      p.beginShape = function(type) {
        curShape = type;
        curvePoints = [];
        vertArray2 = [];
      };
      Drawing2D.prototype.vertex = function(x, y, moveTo) {
        var vert = [];
        if (firstVert) {
          firstVert = false;
        }
        vert.isVert = true;
        vert[0] = x;
        vert[1] = y;
        vert[2] = 0;
        vert[3] = 0;
        vert[4] = 0;
        vert[5] = currentFillColor;
        vert[6] = currentStrokeColor;
        vertArray2.push(vert);
        if (moveTo) {
          vertArray2[vertArray2.length - 1].moveTo = moveTo;
        }
      };
      Drawing3D.prototype.vertex = function(x, y, z, u, v) {
        var vert = [];
        if (firstVert) {
          firstVert = false;
        }
        vert.isVert = true;
        if (v === undef && usingTexture) {
          v = u;
          u = z;
          z = 0;
        }
        if (u !== undef && v !== undef) {
          if (curTextureMode === PConstants3.IMAGE) {
            u /= curTexture.width;
            v /= curTexture.height;
          }
          u = u > 1 ? 1 : u;
          u = u < 0 ? 0 : u;
          v = v > 1 ? 1 : v;
          v = v < 0 ? 0 : v;
        }
        vert[0] = x;
        vert[1] = y;
        vert[2] = z || 0;
        vert[3] = u || 0;
        vert[4] = v || 0;
        vert[5] = fillStyle[0];
        vert[6] = fillStyle[1];
        vert[7] = fillStyle[2];
        vert[8] = fillStyle[3];
        vert[9] = strokeStyle[0];
        vert[10] = strokeStyle[1];
        vert[11] = strokeStyle[2];
        vert[12] = strokeStyle[3];
        vert[13] = normalX;
        vert[14] = normalY;
        vert[15] = normalZ;
        vertArray2.push(vert);
      };
      var point3D = function(vArray, cArray) {
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObjectUnlitShape);
        uniformMatrix("uViewUS", programObjectUnlitShape, "uView", false, view.array());
        uniformi("uSmoothUS", programObjectUnlitShape, "uSmooth", renderSmooth);
        vertexAttribPointer("aVertexUS", programObjectUnlitShape, "aVertex", 3, pointBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(vArray), curContext.STREAM_DRAW);
        vertexAttribPointer("aColorUS", programObjectUnlitShape, "aColor", 4, fillColorBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(cArray), curContext.STREAM_DRAW);
        curContext.drawArrays(curContext.POINTS, 0, vArray.length / 3);
      };
      var line3D = function(vArray, mode, cArray) {
        var ctxMode;
        if (mode === "LINES") {
          ctxMode = curContext.LINES;
        } else if (mode === "LINE_LOOP") {
          ctxMode = curContext.LINE_LOOP;
        } else {
          ctxMode = curContext.LINE_STRIP;
        }
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObjectUnlitShape);
        uniformMatrix("uViewUS", programObjectUnlitShape, "uView", false, view.array());
        vertexAttribPointer("aVertexUS", programObjectUnlitShape, "aVertex", 3, lineBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(vArray), curContext.STREAM_DRAW);
        vertexAttribPointer("aColorUS", programObjectUnlitShape, "aColor", 4, strokeColorBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(cArray), curContext.STREAM_DRAW);
        curContext.drawArrays(ctxMode, 0, vArray.length / 3);
      };
      var fill3D = function(vArray, mode, cArray, tArray) {
        var ctxMode;
        if (mode === "TRIANGLES") {
          ctxMode = curContext.TRIANGLES;
        } else if (mode === "TRIANGLE_FAN") {
          ctxMode = curContext.TRIANGLE_FAN;
        } else {
          ctxMode = curContext.TRIANGLE_STRIP;
        }
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObject3D);
        uniformMatrix("model3d", programObject3D, "uModel", false, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        uniformMatrix("view3d", programObject3D, "uView", false, view.array());
        curContext.enable(curContext.POLYGON_OFFSET_FILL);
        curContext.polygonOffset(1, 1);
        uniformf("color3d", programObject3D, "uColor", [-1, 0, 0, 0]);
        vertexAttribPointer("vertex3d", programObject3D, "aVertex", 3, fillBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(vArray), curContext.STREAM_DRAW);
        if (usingTexture && curTint !== null) {
          curTint3d(cArray);
        }
        vertexAttribPointer("aColor3d", programObject3D, "aColor", 4, fillColorBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(cArray), curContext.STREAM_DRAW);
        disableVertexAttribPointer("aNormal3d", programObject3D, "aNormal");
        if (usingTexture) {
          uniformi("uUsingTexture3d", programObject3D, "uUsingTexture", usingTexture);
          vertexAttribPointer("aTexture3d", programObject3D, "aTexture", 2, shapeTexVBO);
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(tArray), curContext.STREAM_DRAW);
        }
        curContext.drawArrays(ctxMode, 0, vArray.length / 3);
        curContext.disable(curContext.POLYGON_OFFSET_FILL);
      };
      function fillStrokeClose() {
        executeContextFill();
        executeContextStroke();
        curContext.closePath();
      }
      Drawing2D.prototype.endShape = function(mode) {
        if (vertArray2.length === 0) {
          return;
        }
        var closeShape = mode === PConstants3.CLOSE;
        if (closeShape) {
          vertArray2.push(vertArray2[0]);
        }
        var lineVertArray = [];
        var fillVertArray = [];
        var colorVertArray = [];
        var strokeVertArray = [];
        var texVertArray = [];
        var cachedVertArray;
        firstVert = true;
        var i2, j, k;
        var vertArrayLength = vertArray2.length;
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 0; j < 3; j++) {
            fillVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 5; j < 9; j++) {
            colorVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 9; j < 13; j++) {
            strokeVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          texVertArray.push(cachedVertArray[3]);
          texVertArray.push(cachedVertArray[4]);
        }
        if (isCurve && (curShape === PConstants3.POLYGON || curShape === undef)) {
          if (vertArrayLength > 3) {
            var b = [], s = 1 - curTightness;
            curContext.beginPath();
            curContext.moveTo(vertArray2[1][0], vertArray2[1][1]);
            for (i2 = 1; i2 + 2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              b[0] = [cachedVertArray[0], cachedVertArray[1]];
              b[1] = [
                cachedVertArray[0] + (s * vertArray2[i2 + 1][0] - s * vertArray2[i2 - 1][0]) / 6,
                cachedVertArray[1] + (s * vertArray2[i2 + 1][1] - s * vertArray2[i2 - 1][1]) / 6
              ];
              b[2] = [
                vertArray2[i2 + 1][0] + (s * vertArray2[i2][0] - s * vertArray2[i2 + 2][0]) / 6,
                vertArray2[i2 + 1][1] + (s * vertArray2[i2][1] - s * vertArray2[i2 + 2][1]) / 6
              ];
              b[3] = [vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]];
              curContext.bezierCurveTo(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);
            }
            fillStrokeClose();
          }
        } else if (isBezier && (curShape === PConstants3.POLYGON || curShape === undef)) {
          curContext.beginPath();
          for (i2 = 0; i2 < vertArrayLength; i2++) {
            cachedVertArray = vertArray2[i2];
            if (vertArray2[i2].isVert) {
              if (vertArray2[i2].moveTo) {
                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
              } else {
                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
              }
            } else {
              curContext.bezierCurveTo(vertArray2[i2][0], vertArray2[i2][1], vertArray2[i2][2], vertArray2[i2][3], vertArray2[i2][4], vertArray2[i2][5]);
            }
          }
          fillStrokeClose();
        } else {
          if (curShape === PConstants3.POINTS) {
            for (i2 = 0; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              if (doStroke) {
                p.stroke(cachedVertArray[6]);
              }
              p.point(cachedVertArray[0], cachedVertArray[1]);
            }
          } else if (curShape === PConstants3.LINES) {
            for (i2 = 0; i2 + 1 < vertArrayLength; i2 += 2) {
              cachedVertArray = vertArray2[i2];
              if (doStroke) {
                p.stroke(vertArray2[i2 + 1][6]);
              }
              p.line(cachedVertArray[0], cachedVertArray[1], vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
            }
          } else if (curShape === PConstants3.TRIANGLES) {
            for (i2 = 0; i2 + 2 < vertArrayLength; i2 += 3) {
              cachedVertArray = vertArray2[i2];
              curContext.beginPath();
              curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
              curContext.lineTo(vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
              curContext.lineTo(vertArray2[i2 + 2][0], vertArray2[i2 + 2][1]);
              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
              if (doFill) {
                p.fill(vertArray2[i2 + 2][5]);
                executeContextFill();
              }
              if (doStroke) {
                p.stroke(vertArray2[i2 + 2][6]);
                executeContextStroke();
              }
              curContext.closePath();
            }
          } else if (curShape === PConstants3.TRIANGLE_STRIP) {
            for (i2 = 0; i2 + 1 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              curContext.beginPath();
              curContext.moveTo(vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
              if (doStroke) {
                p.stroke(vertArray2[i2 + 1][6]);
              }
              if (doFill) {
                p.fill(vertArray2[i2 + 1][5]);
              }
              if (i2 + 2 < vertArrayLength) {
                curContext.lineTo(vertArray2[i2 + 2][0], vertArray2[i2 + 2][1]);
                if (doStroke) {
                  p.stroke(vertArray2[i2 + 2][6]);
                }
                if (doFill) {
                  p.fill(vertArray2[i2 + 2][5]);
                }
              }
              fillStrokeClose();
            }
          } else if (curShape === PConstants3.TRIANGLE_FAN) {
            if (vertArrayLength > 2) {
              curContext.beginPath();
              curContext.moveTo(vertArray2[0][0], vertArray2[0][1]);
              curContext.lineTo(vertArray2[1][0], vertArray2[1][1]);
              curContext.lineTo(vertArray2[2][0], vertArray2[2][1]);
              if (doFill) {
                p.fill(vertArray2[2][5]);
                executeContextFill();
              }
              if (doStroke) {
                p.stroke(vertArray2[2][6]);
                executeContextStroke();
              }
              curContext.closePath();
              for (i2 = 3; i2 < vertArrayLength; i2++) {
                cachedVertArray = vertArray2[i2];
                curContext.beginPath();
                curContext.moveTo(vertArray2[0][0], vertArray2[0][1]);
                curContext.lineTo(vertArray2[i2 - 1][0], vertArray2[i2 - 1][1]);
                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
                if (doFill) {
                  p.fill(cachedVertArray[5]);
                  executeContextFill();
                }
                if (doStroke) {
                  p.stroke(cachedVertArray[6]);
                  executeContextStroke();
                }
                curContext.closePath();
              }
            }
          } else if (curShape === PConstants3.QUADS) {
            for (i2 = 0; i2 + 3 < vertArrayLength; i2 += 4) {
              cachedVertArray = vertArray2[i2];
              curContext.beginPath();
              curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
              for (j = 1; j < 4; j++) {
                curContext.lineTo(vertArray2[i2 + j][0], vertArray2[i2 + j][1]);
              }
              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
              if (doFill) {
                p.fill(vertArray2[i2 + 3][5]);
                executeContextFill();
              }
              if (doStroke) {
                p.stroke(vertArray2[i2 + 3][6]);
                executeContextStroke();
              }
              curContext.closePath();
            }
          } else if (curShape === PConstants3.QUAD_STRIP) {
            if (vertArrayLength > 3) {
              for (i2 = 0; i2 + 1 < vertArrayLength; i2 += 2) {
                cachedVertArray = vertArray2[i2];
                curContext.beginPath();
                if (i2 + 3 < vertArrayLength) {
                  curContext.moveTo(vertArray2[i2 + 2][0], vertArray2[i2 + 2][1]);
                  curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
                  curContext.lineTo(vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
                  curContext.lineTo(vertArray2[i2 + 3][0], vertArray2[i2 + 3][1]);
                  if (doFill) {
                    p.fill(vertArray2[i2 + 3][5]);
                  }
                  if (doStroke) {
                    p.stroke(vertArray2[i2 + 3][6]);
                  }
                } else {
                  curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
                  curContext.lineTo(vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
                }
                fillStrokeClose();
              }
            }
          } else {
            curContext.beginPath();
            curContext.moveTo(vertArray2[0][0], vertArray2[0][1]);
            for (i2 = 1; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              if (cachedVertArray.isVert) {
                if (cachedVertArray.moveTo) {
                  curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
                } else {
                  curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
                }
              }
            }
            fillStrokeClose();
          }
        }
        isCurve = false;
        isBezier = false;
        curveVertArray = [];
        curveVertCount = 0;
        if (closeShape) {
          vertArray2.pop();
        }
      };
      Drawing3D.prototype.endShape = function(mode) {
        if (vertArray2.length === 0) {
          return;
        }
        var closeShape = mode === PConstants3.CLOSE;
        var lineVertArray = [];
        var fillVertArray = [];
        var colorVertArray = [];
        var strokeVertArray = [];
        var texVertArray = [];
        var cachedVertArray;
        firstVert = true;
        var i2, j, k;
        var vertArrayLength = vertArray2.length;
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 0; j < 3; j++) {
            fillVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 5; j < 9; j++) {
            colorVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 9; j < 13; j++) {
            strokeVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          texVertArray.push(cachedVertArray[3]);
          texVertArray.push(cachedVertArray[4]);
        }
        if (closeShape) {
          fillVertArray.push(vertArray2[0][0]);
          fillVertArray.push(vertArray2[0][1]);
          fillVertArray.push(vertArray2[0][2]);
          for (i2 = 5; i2 < 9; i2++) {
            colorVertArray.push(vertArray2[0][i2]);
          }
          for (i2 = 9; i2 < 13; i2++) {
            strokeVertArray.push(vertArray2[0][i2]);
          }
          texVertArray.push(vertArray2[0][3]);
          texVertArray.push(vertArray2[0][4]);
        }
        if (isCurve && (curShape === PConstants3.POLYGON || curShape === undef)) {
          lineVertArray = fillVertArray;
          if (doStroke) {
            line3D(lineVertArray, null, strokeVertArray);
          }
          if (doFill) {
            fill3D(fillVertArray, null, colorVertArray);
          }
        } else if (isBezier && (curShape === PConstants3.POLYGON || curShape === undef)) {
          lineVertArray = fillVertArray;
          lineVertArray.splice(lineVertArray.length - 3);
          strokeVertArray.splice(strokeVertArray.length - 4);
          if (doStroke) {
            line3D(lineVertArray, null, strokeVertArray);
          }
          if (doFill) {
            fill3D(fillVertArray, "TRIANGLES", colorVertArray);
          }
        } else {
          if (curShape === PConstants3.POINTS) {
            for (i2 = 0; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              for (j = 0; j < 3; j++) {
                lineVertArray.push(cachedVertArray[j]);
              }
            }
            point3D(lineVertArray, strokeVertArray);
          } else if (curShape === PConstants3.LINES) {
            for (i2 = 0; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              for (j = 0; j < 3; j++) {
                lineVertArray.push(cachedVertArray[j]);
              }
            }
            for (i2 = 0; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              for (j = 5; j < 9; j++) {
                colorVertArray.push(cachedVertArray[j]);
              }
            }
            line3D(lineVertArray, "LINES", strokeVertArray);
          } else if (curShape === PConstants3.TRIANGLES) {
            if (vertArrayLength > 2) {
              for (i2 = 0; i2 + 2 < vertArrayLength; i2 += 3) {
                fillVertArray = [];
                texVertArray = [];
                lineVertArray = [];
                colorVertArray = [];
                strokeVertArray = [];
                for (j = 0; j < 3; j++) {
                  for (k = 0; k < 3; k++) {
                    lineVertArray.push(vertArray2[i2 + j][k]);
                    fillVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 3; j++) {
                  for (k = 3; k < 5; k++) {
                    texVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 3; j++) {
                  for (k = 5; k < 9; k++) {
                    colorVertArray.push(vertArray2[i2 + j][k]);
                    strokeVertArray.push(vertArray2[i2 + j][k + 4]);
                  }
                }
                if (doStroke) {
                  line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
                }
                if (doFill || usingTexture) {
                  fill3D(fillVertArray, "TRIANGLES", colorVertArray, texVertArray);
                }
              }
            }
          } else if (curShape === PConstants3.TRIANGLE_STRIP) {
            if (vertArrayLength > 2) {
              for (i2 = 0; i2 + 2 < vertArrayLength; i2++) {
                lineVertArray = [];
                fillVertArray = [];
                strokeVertArray = [];
                colorVertArray = [];
                texVertArray = [];
                for (j = 0; j < 3; j++) {
                  for (k = 0; k < 3; k++) {
                    lineVertArray.push(vertArray2[i2 + j][k]);
                    fillVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 3; j++) {
                  for (k = 3; k < 5; k++) {
                    texVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 3; j++) {
                  for (k = 5; k < 9; k++) {
                    strokeVertArray.push(vertArray2[i2 + j][k + 4]);
                    colorVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                if (doFill || usingTexture) {
                  fill3D(fillVertArray, "TRIANGLE_STRIP", colorVertArray, texVertArray);
                }
                if (doStroke) {
                  line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
                }
              }
            }
          } else if (curShape === PConstants3.TRIANGLE_FAN) {
            if (vertArrayLength > 2) {
              for (i2 = 0; i2 < 3; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(cachedVertArray[j]);
                }
              }
              for (i2 = 0; i2 < 3; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(cachedVertArray[j]);
                }
              }
              if (doStroke) {
                line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
              }
              for (i2 = 2; i2 + 1 < vertArrayLength; i2++) {
                lineVertArray = [];
                strokeVertArray = [];
                lineVertArray.push(vertArray2[0][0]);
                lineVertArray.push(vertArray2[0][1]);
                lineVertArray.push(vertArray2[0][2]);
                strokeVertArray.push(vertArray2[0][9]);
                strokeVertArray.push(vertArray2[0][10]);
                strokeVertArray.push(vertArray2[0][11]);
                strokeVertArray.push(vertArray2[0][12]);
                for (j = 0; j < 2; j++) {
                  for (k = 0; k < 3; k++) {
                    lineVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 2; j++) {
                  for (k = 9; k < 13; k++) {
                    strokeVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                if (doStroke) {
                  line3D(lineVertArray, "LINE_STRIP", strokeVertArray);
                }
              }
              if (doFill || usingTexture) {
                fill3D(fillVertArray, "TRIANGLE_FAN", colorVertArray, texVertArray);
              }
            }
          } else if (curShape === PConstants3.QUADS) {
            for (i2 = 0; i2 + 3 < vertArrayLength; i2 += 4) {
              lineVertArray = [];
              for (j = 0; j < 4; j++) {
                cachedVertArray = vertArray2[i2 + j];
                for (k = 0; k < 3; k++) {
                  lineVertArray.push(cachedVertArray[k]);
                }
              }
              if (doStroke) {
                line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
              }
              if (doFill) {
                fillVertArray = [];
                colorVertArray = [];
                texVertArray = [];
                for (j = 0; j < 3; j++) {
                  fillVertArray.push(vertArray2[i2][j]);
                }
                for (j = 5; j < 9; j++) {
                  colorVertArray.push(vertArray2[i2][j]);
                }
                for (j = 0; j < 3; j++) {
                  fillVertArray.push(vertArray2[i2 + 1][j]);
                }
                for (j = 5; j < 9; j++) {
                  colorVertArray.push(vertArray2[i2 + 1][j]);
                }
                for (j = 0; j < 3; j++) {
                  fillVertArray.push(vertArray2[i2 + 3][j]);
                }
                for (j = 5; j < 9; j++) {
                  colorVertArray.push(vertArray2[i2 + 3][j]);
                }
                for (j = 0; j < 3; j++) {
                  fillVertArray.push(vertArray2[i2 + 2][j]);
                }
                for (j = 5; j < 9; j++) {
                  colorVertArray.push(vertArray2[i2 + 2][j]);
                }
                if (usingTexture) {
                  texVertArray.push(vertArray2[i2 + 0][3]);
                  texVertArray.push(vertArray2[i2 + 0][4]);
                  texVertArray.push(vertArray2[i2 + 1][3]);
                  texVertArray.push(vertArray2[i2 + 1][4]);
                  texVertArray.push(vertArray2[i2 + 3][3]);
                  texVertArray.push(vertArray2[i2 + 3][4]);
                  texVertArray.push(vertArray2[i2 + 2][3]);
                  texVertArray.push(vertArray2[i2 + 2][4]);
                }
                fill3D(fillVertArray, "TRIANGLE_STRIP", colorVertArray, texVertArray);
              }
            }
          } else if (curShape === PConstants3.QUAD_STRIP) {
            var tempArray = [];
            if (vertArrayLength > 3) {
              for (i2 = 0; i2 < 2; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(cachedVertArray[j]);
                }
              }
              for (i2 = 0; i2 < 2; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(cachedVertArray[j]);
                }
              }
              line3D(lineVertArray, "LINE_STRIP", strokeVertArray);
              if (vertArrayLength > 4 && vertArrayLength % 2 > 0) {
                tempArray = fillVertArray.splice(fillVertArray.length - 3);
                vertArray2.pop();
              }
              for (i2 = 0; i2 + 3 < vertArrayLength; i2 += 2) {
                lineVertArray = [];
                strokeVertArray = [];
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(vertArray2[i2 + 1][j]);
                }
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(vertArray2[i2 + 3][j]);
                }
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(vertArray2[i2 + 2][j]);
                }
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(vertArray2[i2 + 0][j]);
                }
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(vertArray2[i2 + 1][j]);
                }
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(vertArray2[i2 + 3][j]);
                }
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(vertArray2[i2 + 2][j]);
                }
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(vertArray2[i2 + 0][j]);
                }
                if (doStroke) {
                  line3D(lineVertArray, "LINE_STRIP", strokeVertArray);
                }
              }
              if (doFill || usingTexture) {
                fill3D(fillVertArray, "TRIANGLE_LIST", colorVertArray, texVertArray);
              }
            }
          } else {
            if (vertArrayLength === 1) {
              for (j = 0; j < 3; j++) {
                lineVertArray.push(vertArray2[0][j]);
              }
              for (j = 9; j < 13; j++) {
                strokeVertArray.push(vertArray2[0][j]);
              }
              point3D(lineVertArray, strokeVertArray);
            } else {
              for (i2 = 0; i2 < vertArrayLength; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(cachedVertArray[j]);
                }
                for (j = 5; j < 9; j++) {
                  strokeVertArray.push(cachedVertArray[j]);
                }
              }
              if (doStroke && closeShape) {
                line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
              } else if (doStroke && !closeShape) {
                line3D(lineVertArray, "LINE_STRIP", strokeVertArray);
              }
              if (doFill || usingTexture) {
                fill3D(fillVertArray, "TRIANGLE_FAN", colorVertArray, texVertArray);
              }
            }
          }
          usingTexture = false;
          curContext.useProgram(programObject3D);
          uniformi("usingTexture3d", programObject3D, "uUsingTexture", usingTexture);
        }
        isCurve = false;
        isBezier = false;
        curveVertArray = [];
        curveVertCount = 0;
      };
      var splineForward = function(segments, matrix) {
        var f = 1 / segments;
        var ff = f * f;
        var fff = ff * f;
        matrix.set(0, 0, 0, 1, fff, ff, f, 0, 6 * fff, 2 * ff, 0, 0, 6 * fff, 0, 0, 0);
      };
      var curveInit = function() {
        if (!curveDrawMatrix) {
          curveBasisMatrix = new PMatrix3D2();
          curveDrawMatrix = new PMatrix3D2();
          curveInited = true;
        }
        var s = curTightness;
        curveBasisMatrix.set(
          (s - 1) / 2,
          (s + 3) / 2,
          (-3 - s) / 2,
          (1 - s) / 2,
          1 - s,
          (-5 - s) / 2,
          s + 2,
          (s - 1) / 2,
          (s - 1) / 2,
          0,
          (1 - s) / 2,
          0,
          0,
          1,
          0,
          0
        );
        splineForward(curveDet, curveDrawMatrix);
        if (!bezierBasisInverse) {
          curveToBezierMatrix = new PMatrix3D2();
        }
        curveToBezierMatrix.set(curveBasisMatrix);
        curveToBezierMatrix.preApply(bezierBasisInverse);
        curveDrawMatrix.apply(curveBasisMatrix);
      };
      Drawing2D.prototype.bezierVertex = function() {
        isBezier = true;
        var vert = [];
        if (firstVert) {
          throw "vertex() must be used at least once before calling bezierVertex()";
        }
        for (var i2 = 0; i2 < arguments.length; i2++) {
          vert[i2] = arguments[i2];
        }
        vertArray2.push(vert);
        vertArray2[vertArray2.length - 1].isVert = false;
      };
      Drawing3D.prototype.bezierVertex = function() {
        isBezier = true;
        var vert = [];
        if (firstVert) {
          throw "vertex() must be used at least once before calling bezierVertex()";
        }
        if (arguments.length === 9) {
          if (bezierDrawMatrix === undef) {
            bezierDrawMatrix = new PMatrix3D2();
          }
          var lastPoint = vertArray2.length - 1;
          splineForward(bezDetail, bezierDrawMatrix);
          bezierDrawMatrix.apply(bezierBasisMatrix);
          var draw = bezierDrawMatrix.array();
          var x1 = vertArray2[lastPoint][0], y1 = vertArray2[lastPoint][1], z1 = vertArray2[lastPoint][2];
          var xplot1 = draw[4] * x1 + draw[5] * arguments[0] + draw[6] * arguments[3] + draw[7] * arguments[6];
          var xplot2 = draw[8] * x1 + draw[9] * arguments[0] + draw[10] * arguments[3] + draw[11] * arguments[6];
          var xplot3 = draw[12] * x1 + draw[13] * arguments[0] + draw[14] * arguments[3] + draw[15] * arguments[6];
          var yplot1 = draw[4] * y1 + draw[5] * arguments[1] + draw[6] * arguments[4] + draw[7] * arguments[7];
          var yplot2 = draw[8] * y1 + draw[9] * arguments[1] + draw[10] * arguments[4] + draw[11] * arguments[7];
          var yplot3 = draw[12] * y1 + draw[13] * arguments[1] + draw[14] * arguments[4] + draw[15] * arguments[7];
          var zplot1 = draw[4] * z1 + draw[5] * arguments[2] + draw[6] * arguments[5] + draw[7] * arguments[8];
          var zplot2 = draw[8] * z1 + draw[9] * arguments[2] + draw[10] * arguments[5] + draw[11] * arguments[8];
          var zplot3 = draw[12] * z1 + draw[13] * arguments[2] + draw[14] * arguments[5] + draw[15] * arguments[8];
          for (var j = 0; j < bezDetail; j++) {
            x1 += xplot1;
            xplot1 += xplot2;
            xplot2 += xplot3;
            y1 += yplot1;
            yplot1 += yplot2;
            yplot2 += yplot3;
            z1 += zplot1;
            zplot1 += zplot2;
            zplot2 += zplot3;
            p.vertex(x1, y1, z1);
          }
          p.vertex(arguments[6], arguments[7], arguments[8]);
        }
      };
      p.texture = function(pimage) {
        var curContext2 = drawing.$ensureContext();
        if (pimage.__texture) {
          curContext2.bindTexture(curContext2.TEXTURE_2D, pimage.__texture);
        } else if (pimage.localName === "canvas") {
          curContext2.bindTexture(curContext2.TEXTURE_2D, canTex);
          curContext2.texImage2D(curContext2.TEXTURE_2D, 0, curContext2.RGBA, curContext2.RGBA, curContext2.UNSIGNED_BYTE, pimage);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_MAG_FILTER, curContext2.LINEAR);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_MIN_FILTER, curContext2.LINEAR);
          curContext2.generateMipmap(curContext2.TEXTURE_2D);
          curTexture.width = pimage.width;
          curTexture.height = pimage.height;
        } else {
          var texture = curContext2.createTexture(), cvs = document2.createElement("canvas"), cvsTextureCtx = cvs.getContext("2d"), pot;
          if (pimage.width & pimage.width - 1 === 0) {
            cvs.width = pimage.width;
          } else {
            pot = 1;
            while (pot < pimage.width) {
              pot *= 2;
            }
            cvs.width = pot;
          }
          if (pimage.height & pimage.height - 1 === 0) {
            cvs.height = pimage.height;
          } else {
            pot = 1;
            while (pot < pimage.height) {
              pot *= 2;
            }
            cvs.height = pot;
          }
          cvsTextureCtx.drawImage(pimage.sourceImg, 0, 0, pimage.width, pimage.height, 0, 0, cvs.width, cvs.height);
          curContext2.bindTexture(curContext2.TEXTURE_2D, texture);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_MIN_FILTER, curContext2.LINEAR_MIPMAP_LINEAR);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_MAG_FILTER, curContext2.LINEAR);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_WRAP_T, curContext2.CLAMP_TO_EDGE);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_WRAP_S, curContext2.CLAMP_TO_EDGE);
          curContext2.texImage2D(curContext2.TEXTURE_2D, 0, curContext2.RGBA, curContext2.RGBA, curContext2.UNSIGNED_BYTE, cvs);
          curContext2.generateMipmap(curContext2.TEXTURE_2D);
          pimage.__texture = texture;
          curTexture.width = pimage.width;
          curTexture.height = pimage.height;
        }
        usingTexture = true;
        curContext2.useProgram(programObject3D);
        uniformi("usingTexture3d", programObject3D, "uUsingTexture", usingTexture);
      };
      p.textureMode = function(mode) {
        curTextureMode = mode;
      };
      var curveVertexSegment = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
        var x0 = x2;
        var y0 = y2;
        var z0 = z2;
        var draw = curveDrawMatrix.array();
        var xplot1 = draw[4] * x1 + draw[5] * x2 + draw[6] * x3 + draw[7] * x4;
        var xplot2 = draw[8] * x1 + draw[9] * x2 + draw[10] * x3 + draw[11] * x4;
        var xplot3 = draw[12] * x1 + draw[13] * x2 + draw[14] * x3 + draw[15] * x4;
        var yplot1 = draw[4] * y1 + draw[5] * y2 + draw[6] * y3 + draw[7] * y4;
        var yplot2 = draw[8] * y1 + draw[9] * y2 + draw[10] * y3 + draw[11] * y4;
        var yplot3 = draw[12] * y1 + draw[13] * y2 + draw[14] * y3 + draw[15] * y4;
        var zplot1 = draw[4] * z1 + draw[5] * z2 + draw[6] * z3 + draw[7] * z4;
        var zplot2 = draw[8] * z1 + draw[9] * z2 + draw[10] * z3 + draw[11] * z4;
        var zplot3 = draw[12] * z1 + draw[13] * z2 + draw[14] * z3 + draw[15] * z4;
        p.vertex(x0, y0, z0);
        for (var j = 0; j < curveDet; j++) {
          x0 += xplot1;
          xplot1 += xplot2;
          xplot2 += xplot3;
          y0 += yplot1;
          yplot1 += yplot2;
          yplot2 += yplot3;
          z0 += zplot1;
          zplot1 += zplot2;
          zplot2 += zplot3;
          p.vertex(x0, y0, z0);
        }
      };
      Drawing2D.prototype.curveVertex = function(x, y) {
        isCurve = true;
        p.vertex(x, y);
      };
      Drawing3D.prototype.curveVertex = function(x, y, z) {
        isCurve = true;
        if (!curveInited) {
          curveInit();
        }
        var vert = [];
        vert[0] = x;
        vert[1] = y;
        vert[2] = z;
        curveVertArray.push(vert);
        curveVertCount++;
        if (curveVertCount > 3) {
          curveVertexSegment(
            curveVertArray[curveVertCount - 4][0],
            curveVertArray[curveVertCount - 4][1],
            curveVertArray[curveVertCount - 4][2],
            curveVertArray[curveVertCount - 3][0],
            curveVertArray[curveVertCount - 3][1],
            curveVertArray[curveVertCount - 3][2],
            curveVertArray[curveVertCount - 2][0],
            curveVertArray[curveVertCount - 2][1],
            curveVertArray[curveVertCount - 2][2],
            curveVertArray[curveVertCount - 1][0],
            curveVertArray[curveVertCount - 1][1],
            curveVertArray[curveVertCount - 1][2]
          );
        }
      };
      Drawing2D.prototype.curve = function(x1, y1, x2, y2, x3, y3, x4, y4) {
        p.beginShape();
        p.curveVertex(x1, y1);
        p.curveVertex(x2, y2);
        p.curveVertex(x3, y3);
        p.curveVertex(x4, y4);
        p.endShape();
      };
      Drawing3D.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
        if (z4 !== undef) {
          p.beginShape();
          p.curveVertex(x1, y1, z1);
          p.curveVertex(x2, y2, z2);
          p.curveVertex(x3, y3, z3);
          p.curveVertex(x4, y4, z4);
          p.endShape();
          return;
        }
        p.beginShape();
        p.curveVertex(x1, y1);
        p.curveVertex(z1, x2);
        p.curveVertex(y2, z2);
        p.curveVertex(x3, y3);
        p.endShape();
      };
      p.curveTightness = function(tightness) {
        curTightness = tightness;
      };
      p.curveDetail = function(detail) {
        curveDet = detail;
        curveInit();
      };
      p.rectMode = function(aRectMode) {
        curRectMode = aRectMode;
      };
      p.imageMode = function(mode) {
        switch (mode) {
          case PConstants3.CORNER:
            imageModeConvert2 = imageModeCorner;
            break;
          case PConstants3.CORNERS:
            imageModeConvert2 = imageModeCorners;
            break;
          case PConstants3.CENTER:
            imageModeConvert2 = imageModeCenter;
            break;
          default:
            throw "Invalid imageMode";
        }
      };
      p.ellipseMode = function(aEllipseMode) {
        curEllipseMode2 = aEllipseMode;
      };
      p.arc = function(x, y, width, height, start2, stop, mode) {
        if (width <= 0 || stop < start2) {
          return;
        }
        if (curEllipseMode2 === PConstants3.CORNERS) {
          width = width - x;
          height = height - y;
        } else if (curEllipseMode2 === PConstants3.RADIUS) {
          x = x - width;
          y = y - height;
          width = width * 2;
          height = height * 2;
        } else if (curEllipseMode2 === PConstants3.CENTER) {
          x = x - width / 2;
          y = y - height / 2;
        }
        while (start2 < 0) {
          start2 += PConstants3.TWO_PI;
          stop += PConstants3.TWO_PI;
        }
        if (stop - start2 > PConstants3.TWO_PI) {
          stop = start2 + PConstants3.TWO_PI;
        }
        var hr = width / 2, vr = height / 2, centerX = x + hr, centerY = y + vr, step = 1 / (hr + vr);
        var drawSlice = /* @__PURE__ */ function(x2, y2, start3, step2, stop2) {
          return function(p2, closed, i2, a, e) {
            i2 = 0;
            a = start3;
            e = stop2 + step2;
            p2.beginShape();
            if (closed) {
              p2.vertex(x2 - 0.5, y2 - 0.5);
            }
            for (; a < e; i2++, a = i2 * step2 + start3) {
              p2.vertex(
                x2 + Math.cos(a) * hr | 0,
                y2 + Math.sin(a) * vr | 0
              );
            }
            if (mode === PConstants3.OPEN && doFill) {
              p2.vertex(centerX + Math.cos(start3) * hr, centerY + Math.sin(start3) * vr);
            } else if (mode === PConstants3.CHORD) {
              p2.vertex(centerX + Math.cos(start3) * hr, centerY + Math.sin(start3) * vr);
            } else if (mode === PConstants3.PIE) {
              p2.line(centerX + Math.cos(start3) * hr, centerY + Math.sin(start3) * vr, centerX, centerY);
              p2.line(centerX, centerY, centerX + Math.cos(stop2) * hr, centerY + Math.sin(stop2) * vr);
            }
            p2.endShape(closed ? PConstants3.CLOSE : void 0);
          };
        }(centerX + 0.5, centerY + 0.5, start2, step, stop);
        if (doFill) {
          var savedStroke = doStroke;
          doStroke = false;
          drawSlice(p, true);
          doStroke = savedStroke;
        }
        if (doStroke) {
          var savedFill = doFill;
          doFill = false;
          drawSlice(p);
          doFill = savedFill;
        }
      };
      Drawing2D.prototype.line = function(x1, y1, x2, y2) {
        if (!doStroke) {
          return;
        }
        if (!renderSmooth) {
          x1 = Math.round(x1);
          x2 = Math.round(x2);
          y1 = Math.round(y1);
          y2 = Math.round(y2);
        }
        if (x1 === x2 && y1 === y2) {
          p.point(x1, y1);
          return;
        }
        var swap = undef, lineCap = undef, drawCrisp = true, currentModelView = modelView.array(), identityMatrix = [1, 0, 0, 0, 1, 0];
        for (var i2 = 0; i2 < 6 && drawCrisp; i2++) {
          drawCrisp = currentModelView[i2] === identityMatrix[i2];
        }
        if (drawCrisp) {
          if (x1 === x2) {
            if (y1 > y2) {
              swap = y1;
              y1 = y2;
              y2 = swap;
            }
            y2++;
            if (lineWidth % 2 === 1) {
              curContext.translate(0.5, 0);
            }
          } else if (y1 === y2) {
            if (x1 > x2) {
              swap = x1;
              x1 = x2;
              x2 = swap;
            }
            x2++;
            if (lineWidth % 2 === 1) {
              curContext.translate(0, 0.5);
            }
          }
          if (lineWidth === 1) {
            lineCap = curContext.lineCap;
            curContext.lineCap = "butt";
          }
        }
        curContext.beginPath();
        curContext.moveTo(x1 || 0, y1 || 0);
        curContext.lineTo(x2 || 0, y2 || 0);
        executeContextStroke();
        if (drawCrisp) {
          if (x1 === x2 && lineWidth % 2 === 1) {
            curContext.translate(-0.5, 0);
          } else if (y1 === y2 && lineWidth % 2 === 1) {
            curContext.translate(0, -0.5);
          }
          if (lineWidth === 1) {
            curContext.lineCap = lineCap;
          }
        }
      };
      Drawing3D.prototype.line = function(x1, y1, z1, x2, y2, z2) {
        if (y2 === undef || z2 === undef) {
          z2 = 0;
          y2 = x2;
          x2 = z1;
          z1 = 0;
        }
        if (x1 === x2 && y1 === y2 && z1 === z2) {
          p.point(x1, y1, z1);
          return;
        }
        var lineVerts = [x1, y1, z1, x2, y2, z2];
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        if (lineWidth > 0 && doStroke) {
          curContext.useProgram(programObject2D);
          uniformMatrix("uModel2d", programObject2D, "uModel", false, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
          uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText", programObject2D, "uIsDrawingText", false);
          vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, lineBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(lineVerts), curContext.STREAM_DRAW);
          curContext.drawArrays(curContext.LINES, 0, 2);
        }
      };
      Drawing2D.prototype.bezier = function() {
        if (arguments.length !== 8) {
          throw "You must use 8 parameters for bezier() in 2D mode";
        }
        p.beginShape();
        p.vertex(arguments[0], arguments[1]);
        p.bezierVertex(
          arguments[2],
          arguments[3],
          arguments[4],
          arguments[5],
          arguments[6],
          arguments[7]
        );
        p.endShape();
      };
      Drawing3D.prototype.bezier = function() {
        if (arguments.length !== 12) {
          throw "You must use 12 parameters for bezier() in 3D mode";
        }
        p.beginShape();
        p.vertex(arguments[0], arguments[1], arguments[2]);
        p.bezierVertex(
          arguments[3],
          arguments[4],
          arguments[5],
          arguments[6],
          arguments[7],
          arguments[8],
          arguments[9],
          arguments[10],
          arguments[11]
        );
        p.endShape();
      };
      p.bezierDetail = function(detail) {
        bezDetail = detail;
      };
      p.bezierPoint = function(a, b, c, d, t2) {
        return (1 - t2) * (1 - t2) * (1 - t2) * a + 3 * (1 - t2) * (1 - t2) * t2 * b + 3 * (1 - t2) * t2 * t2 * c + t2 * t2 * t2 * d;
      };
      p.bezierTangent = function(a, b, c, d, t2) {
        return 3 * t2 * t2 * (-a + 3 * b - 3 * c + d) + 6 * t2 * (a - 2 * b + c) + 3 * (-a + b);
      };
      p.curvePoint = function(a, b, c, d, t2) {
        return 0.5 * (2 * b + (-a + c) * t2 + (2 * a - 5 * b + 4 * c - d) * t2 * t2 + (-a + 3 * b - 3 * c + d) * t2 * t2 * t2);
      };
      p.curveTangent = function(a, b, c, d, t2) {
        return 0.5 * (-a + c + 2 * (2 * a - 5 * b + 4 * c - d) * t2 + 3 * (-a + 3 * b - 3 * c + d) * t2 * t2);
      };
      p.triangle = function(x1, y1, x2, y2, x3, y3) {
        p.beginShape(PConstants3.TRIANGLES);
        p.vertex(x1, y1, 0);
        p.vertex(x2, y2, 0);
        p.vertex(x3, y3, 0);
        p.endShape();
      };
      p.quad = function(x1, y1, x2, y2, x3, y3, x4, y4) {
        p.beginShape(PConstants3.QUADS);
        p.vertex(x1, y1, 0);
        p.vertex(x2, y2, 0);
        p.vertex(x3, y3, 0);
        p.vertex(x4, y4, 0);
        p.endShape();
      };
      var roundedRect$2d = function(x, y, width, height, tl, tr, br, bl) {
        if (bl === undef) {
          tr = tl;
          br = tl;
          bl = tl;
        }
        var halfWidth = width / 2, halfHeight = height / 2;
        if (tl > halfWidth || tl > halfHeight) {
          tl = Math.min(halfWidth, halfHeight);
        }
        if (tr > halfWidth || tr > halfHeight) {
          tr = Math.min(halfWidth, halfHeight);
        }
        if (br > halfWidth || br > halfHeight) {
          br = Math.min(halfWidth, halfHeight);
        }
        if (bl > halfWidth || bl > halfHeight) {
          bl = Math.min(halfWidth, halfHeight);
        }
        if (!doFill || doStroke) {
          curContext.translate(0.5, 0.5);
        }
        curContext.beginPath();
        curContext.moveTo(x + tl, y);
        curContext.lineTo(x + width - tr, y);
        curContext.quadraticCurveTo(x + width, y, x + width, y + tr);
        curContext.lineTo(x + width, y + height - br);
        curContext.quadraticCurveTo(x + width, y + height, x + width - br, y + height);
        curContext.lineTo(x + bl, y + height);
        curContext.quadraticCurveTo(x, y + height, x, y + height - bl);
        curContext.lineTo(x, y + tl);
        curContext.quadraticCurveTo(x, y, x + tl, y);
        if (!doFill || doStroke) {
          curContext.translate(-0.5, -0.5);
        }
        executeContextFill();
        executeContextStroke();
      };
      Drawing2D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {
        if (width != "" + width && height != "" + height) {
          return;
        }
        if (curRectMode === PConstants3.CORNERS) {
          width -= x;
          height -= y;
        } else if (curRectMode === PConstants3.RADIUS) {
          width *= 2;
          height *= 2;
          x -= width / 2;
          y -= height / 2;
        } else if (curRectMode === PConstants3.CENTER) {
          x -= width / 2;
          y -= height / 2;
        }
        if (!renderSmooth) {
          x = Math.round(x);
          y = Math.round(y);
          width = Math.round(width);
          height = Math.round(height);
        }
        if (tl !== undef) {
          roundedRect$2d(x, y, width, height, tl, tr, br, bl);
          return;
        }
        if (doStroke && lineWidth % 2 === 1) {
          curContext.translate(0.5, 0.5);
        }
        curContext.beginPath();
        curContext.rect(x, y, width, height);
        executeContextFill();
        executeContextStroke();
        if (doStroke && lineWidth % 2 === 1) {
          curContext.translate(-0.5, -0.5);
        }
      };
      Drawing3D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {
        if (tl !== undef) {
          throw "rect() with rounded corners is not supported in 3D mode";
        }
        if (curRectMode === PConstants3.CORNERS) {
          width -= x;
          height -= y;
        } else if (curRectMode === PConstants3.RADIUS) {
          width *= 2;
          height *= 2;
          x -= width / 2;
          y -= height / 2;
        } else if (curRectMode === PConstants3.CENTER) {
          x -= width / 2;
          y -= height / 2;
        }
        var model = new PMatrix3D2();
        model.translate(x, y, 0);
        model.scale(width, height, 1);
        model.transpose();
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        if (lineWidth > 0 && doStroke) {
          curContext.useProgram(programObject2D);
          uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
          uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText2d", programObject2D, "uIsDrawingText", false);
          vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, rectBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          curContext.drawArrays(curContext.LINE_LOOP, 0, rectVerts.length / 3);
        }
        if (doFill) {
          curContext.useProgram(programObject3D);
          uniformMatrix("uModel3d", programObject3D, "uModel", false, model.array());
          uniformMatrix("uView3d", programObject3D, "uView", false, view.array());
          curContext.enable(curContext.POLYGON_OFFSET_FILL);
          curContext.polygonOffset(1, 1);
          uniformf("color3d", programObject3D, "uColor", fillStyle);
          if (lightCount > 0) {
            var v = new PMatrix3D2();
            v.set(view);
            var m = new PMatrix3D2();
            m.set(model);
            v.mult(m);
            var normalMatrix = new PMatrix3D2();
            normalMatrix.set(v);
            normalMatrix.invert();
            normalMatrix.transpose();
            uniformMatrix("uNormalTransform3d", programObject3D, "uNormalTransform", false, normalMatrix.array());
            vertexAttribPointer("aNormal3d", programObject3D, "aNormal", 3, rectNormBuffer);
          } else {
            disableVertexAttribPointer("normal3d", programObject3D, "aNormal");
          }
          vertexAttribPointer("vertex3d", programObject3D, "aVertex", 3, rectBuffer);
          curContext.drawArrays(curContext.TRIANGLE_FAN, 0, rectVerts.length / 3);
          curContext.disable(curContext.POLYGON_OFFSET_FILL);
        }
      };
      Drawing2D.prototype.ellipse = function(x, y, width, height) {
        x = x || 0;
        y = y || 0;
        if (width <= 0 && height <= 0) {
          return;
        }
        if (curEllipseMode2 === PConstants3.RADIUS) {
          width *= 2;
          height *= 2;
        } else if (curEllipseMode2 === PConstants3.CORNERS) {
          width = width - x;
          height = height - y;
          x += width / 2;
          y += height / 2;
        } else if (curEllipseMode2 === PConstants3.CORNER) {
          x += width / 2;
          y += height / 2;
        }
        if (width === height) {
          curContext.beginPath();
          curContext.arc(x, y, width / 2, 0, PConstants3.TWO_PI, false);
          executeContextFill();
          executeContextStroke();
        } else {
          var w = width / 2, h = height / 2, C = 0.5522847498307933, c_x = C * w, c_y = C * h;
          p.beginShape();
          p.vertex(x + w, y);
          p.bezierVertex(x + w, y - c_y, x + c_x, y - h, x, y - h);
          p.bezierVertex(x - c_x, y - h, x - w, y - c_y, x - w, y);
          p.bezierVertex(x - w, y + c_y, x - c_x, y + h, x, y + h);
          p.bezierVertex(x + c_x, y + h, x + w, y + c_y, x + w, y);
          p.endShape();
        }
      };
      Drawing3D.prototype.ellipse = function(x, y, width, height) {
        x = x || 0;
        y = y || 0;
        if (width <= 0 && height <= 0) {
          return;
        }
        if (curEllipseMode2 === PConstants3.RADIUS) {
          width *= 2;
          height *= 2;
        } else if (curEllipseMode2 === PConstants3.CORNERS) {
          width = width - x;
          height = height - y;
          x += width / 2;
          y += height / 2;
        } else if (curEllipseMode2 === PConstants3.CORNER) {
          x += width / 2;
          y += height / 2;
        }
        var w = width / 2, h = height / 2, C = 0.5522847498307933, c_x = C * w, c_y = C * h;
        p.beginShape();
        p.vertex(x + w, y);
        p.bezierVertex(x + w, y - c_y, 0, x + c_x, y - h, 0, x, y - h, 0);
        p.bezierVertex(x - c_x, y - h, 0, x - w, y - c_y, 0, x - w, y, 0);
        p.bezierVertex(x - w, y + c_y, 0, x - c_x, y + h, 0, x, y + h, 0);
        p.bezierVertex(x + c_x, y + h, 0, x + w, y + c_y, 0, x + w, y, 0);
        p.endShape();
        if (doFill) {
          var xAv = 0, yAv = 0, i2, j;
          for (i2 = 0; i2 < vertArray2.length; i2++) {
            xAv += vertArray2[i2][0];
            yAv += vertArray2[i2][1];
          }
          xAv /= vertArray2.length;
          yAv /= vertArray2.length;
          var vert = [], fillVertArray = [], colorVertArray = [];
          vert[0] = xAv;
          vert[1] = yAv;
          vert[2] = 0;
          vert[3] = 0;
          vert[4] = 0;
          vert[5] = fillStyle[0];
          vert[6] = fillStyle[1];
          vert[7] = fillStyle[2];
          vert[8] = fillStyle[3];
          vert[9] = strokeStyle[0];
          vert[10] = strokeStyle[1];
          vert[11] = strokeStyle[2];
          vert[12] = strokeStyle[3];
          vert[13] = normalX;
          vert[14] = normalY;
          vert[15] = normalZ;
          vertArray2.unshift(vert);
          for (i2 = 0; i2 < vertArray2.length; i2++) {
            for (j = 0; j < 3; j++) {
              fillVertArray.push(vertArray2[i2][j]);
            }
            for (j = 5; j < 9; j++) {
              colorVertArray.push(vertArray2[i2][j]);
            }
          }
          fill3D(fillVertArray, "TRIANGLE_FAN", colorVertArray);
        }
      };
      p.normal = function(nx, ny, nz) {
        if (arguments.length !== 3 || !(typeof nx === "number" && typeof ny === "number" && typeof nz === "number")) {
          throw "normal() requires three numeric arguments.";
        }
        normalX = nx;
        normalY = ny;
        normalZ = nz;
        if (curShape !== 0) {
          if (normalMode === PConstants3.NORMAL_MODE_AUTO) {
            normalMode = PConstants3.NORMAL_MODE_SHAPE;
          } else if (normalMode === PConstants3.NORMAL_MODE_SHAPE) {
            normalMode = PConstants3.NORMAL_MODE_VERTEX;
          }
        }
      };
      p.save = function(file, img) {
        if (img !== undef) {
          return window2.open(img.toDataURL(), "_blank");
        }
        return window2.open(p.externals.canvas.toDataURL(), "_blank");
      };
      var saveNumber = 0;
      p.saveFrame = function(file) {
        if (file === undef) {
          file = "screen-####.png";
        }
        var frameFilename = file.replace(/#+/, function(all) {
          var s = "" + saveNumber++;
          while (s.length < all.length) {
            s = "0" + s;
          }
          return s;
        });
        p.save(frameFilename);
      };
      var utilityContext2d = document2.createElement("canvas").getContext("2d");
      var canvasDataCache = [undef, undef, undef];
      function getCanvasData(obj, w, h) {
        var canvasData = canvasDataCache.shift();
        if (canvasData === undef) {
          canvasData = {};
          canvasData.canvas = document2.createElement("canvas");
          canvasData.context = canvasData.canvas.getContext("2d");
        }
        canvasDataCache.push(canvasData);
        var canvas = canvasData.canvas, context = canvasData.context, width = w || obj.width, height = h || obj.height;
        canvas.width = width;
        canvas.height = height;
        if (!obj) {
          context.clearRect(0, 0, width, height);
        } else if ("data" in obj) {
          context.putImageData(obj, 0, 0);
        } else {
          context.clearRect(0, 0, width, height);
          context.drawImage(obj, 0, 0, width, height);
        }
        return canvasData;
      }
      function buildPixelsObject(pImage) {
        return {
          getLength: /* @__PURE__ */ function(aImg) {
            return function() {
              if (aImg.isRemote) {
                throw "Image is loaded remotely. Cannot get length.";
              } else {
                return aImg.imageData.data.length ? aImg.imageData.data.length / 4 : 0;
              }
            };
          }(pImage),
          getPixel: /* @__PURE__ */ function(aImg) {
            return function(i2) {
              var offset = i2 * 4, data = aImg.imageData.data;
              if (aImg.isRemote) {
                throw "Image is loaded remotely. Cannot get pixels.";
              }
              return data[offset + 3] << 24 & PConstants3.ALPHA_MASK | data[offset] << 16 & PConstants3.RED_MASK | data[offset + 1] << 8 & PConstants3.GREEN_MASK | data[offset + 2] & PConstants3.BLUE_MASK;
            };
          }(pImage),
          setPixel: /* @__PURE__ */ function(aImg) {
            return function(i2, c) {
              var offset = i2 * 4, data = aImg.imageData.data;
              if (aImg.isRemote) {
                throw "Image is loaded remotely. Cannot set pixel.";
              }
              data[offset + 0] = (c & PConstants3.RED_MASK) >>> 16;
              data[offset + 1] = (c & PConstants3.GREEN_MASK) >>> 8;
              data[offset + 2] = c & PConstants3.BLUE_MASK;
              data[offset + 3] = (c & PConstants3.ALPHA_MASK) >>> 24;
              aImg.__isDirty = true;
            };
          }(pImage),
          toArray: /* @__PURE__ */ function(aImg) {
            return function() {
              var arr = [], data = aImg.imageData.data, length = aImg.width * aImg.height;
              if (aImg.isRemote) {
                throw "Image is loaded remotely. Cannot get pixels.";
              }
              for (var i2 = 0, offset = 0; i2 < length; i2++, offset += 4) {
                arr.push(data[offset + 3] << 24 & PConstants3.ALPHA_MASK | data[offset] << 16 & PConstants3.RED_MASK | data[offset + 1] << 8 & PConstants3.GREEN_MASK | data[offset + 2] & PConstants3.BLUE_MASK);
              }
              return arr;
            };
          }(pImage),
          set: /* @__PURE__ */ function(aImg) {
            return function(arr) {
              var offset, data, c;
              if (this.isRemote) {
                throw "Image is loaded remotely. Cannot set pixels.";
              }
              data = aImg.imageData.data;
              for (var i2 = 0, aL = arr.length; i2 < aL; i2++) {
                c = arr[i2];
                offset = i2 * 4;
                data[offset + 0] = (c & PConstants3.RED_MASK) >>> 16;
                data[offset + 1] = (c & PConstants3.GREEN_MASK) >>> 8;
                data[offset + 2] = c & PConstants3.BLUE_MASK;
                data[offset + 3] = (c & PConstants3.ALPHA_MASK) >>> 24;
              }
              aImg.__isDirty = true;
            };
          }(pImage)
        };
      }
      var PImage = function(aWidth, aHeight, aFormat) {
        this.__isDirty = false;
        if (aWidth instanceof HTMLImageElement) {
          this.fromHTMLImageData(aWidth);
        } else if (aHeight || aFormat) {
          this.width = aWidth || 1;
          this.height = aHeight || 1;
          var canvas = this.sourceImg = document2.createElement("canvas");
          canvas.width = this.width;
          canvas.height = this.height;
          var imageData = this.imageData = canvas.getContext("2d").createImageData(this.width, this.height);
          this.format = aFormat === PConstants3.ARGB || aFormat === PConstants3.ALPHA ? aFormat : PConstants3.RGB;
          if (this.format === PConstants3.RGB) {
            for (var i2 = 3, data = this.imageData.data, len = data.length; i2 < len; i2 += 4) {
              data[i2] = 255;
            }
          }
          this.__isDirty = true;
          this.updatePixels();
        } else {
          this.width = 0;
          this.height = 0;
          this.imageData = utilityContext2d.createImageData(1, 1);
          this.format = PConstants3.ARGB;
        }
        this.pixels = buildPixelsObject(this);
      };
      PImage.prototype = {
        /**
         * Temporary hack to deal with cross-Processing-instance created PImage.  See
         * tickets #1623 and #1644.
         */
        __isPImage: true,
        /**
        * @member PImage
        * Updates the image with the data in its pixels[] array. Use in conjunction with loadPixels(). If
        * you're only reading pixels from the array, there's no need to call updatePixels().
        * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule
        * is that any time you want to manipulate the pixels[] array, you must first call loadPixels(), and
        * after changes have been made, call updatePixels(). Even if the renderer may not seem to use this
        * function in the current Processing release, this will always be subject to change.
        * Currently, none of the renderers use the additional parameters to updatePixels().
        */
        updatePixels: function() {
          var canvas = this.sourceImg;
          if (canvas && canvas instanceof HTMLCanvasElement && this.__isDirty) {
            canvas.getContext("2d").putImageData(this.imageData, 0, 0);
          }
          this.__isDirty = false;
        },
        fromHTMLImageData: function(htmlImg) {
          var canvasData = getCanvasData(htmlImg);
          try {
            var imageData = canvasData.context.getImageData(0, 0, htmlImg.width, htmlImg.height);
            this.fromImageData(imageData);
          } catch (e) {
            if (htmlImg.width && htmlImg.height) {
              this.isRemote = true;
              this.width = htmlImg.width;
              this.height = htmlImg.height;
            }
          }
          this.sourceImg = htmlImg;
        },
        "get": function(x, y, w, h) {
          if (!arguments.length) {
            return p.get(this);
          }
          if (arguments.length === 2) {
            return p.get(x, y, this);
          }
          if (arguments.length === 4) {
            return p.get(x, y, w, h, this);
          }
        },
        /**
        * @member PImage
        * Changes the color of any pixel or writes an image directly into the image. The x and y parameter
        * specify the pixel or the upper-left corner of the image. The color parameter specifies the color value.
        * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data
        * directly into pixels[]. The equivalent statement to "set(x, y, #000000)" using pixels[] is
        * "pixels[y*width+x] = #000000". Processing requires calling loadPixels() to load the display window
        * data into the pixels[] array before getting the values and calling updatePixels() to update the window.
        *
        * @param {int} x        x-coordinate of the pixel or upper-left corner of the image
        * @param {int} y        y-coordinate of the pixel or upper-left corner of the image
        * @param {color} color  any value of the color datatype
        *
        * @see get
        * @see pixels[]
        * @see copy
        */
        "set": function(x, y, c) {
          p.set(x, y, c, this);
          this.__isDirty = true;
        },
        /**
        * @member PImage
        * Blends a region of pixels into the image specified by the img parameter. These copies utilize full
        * alpha channel support and a choice of the following modes to blend the colors of source pixels (A)
        * with the ones of pixels in the destination image (B):
        * BLEND - linear interpolation of colours: C = A*factor + B
        * ADD - additive blending with white clip: C = min(A*factor + B, 255)
        * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)
        * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)
        * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)
        * DIFFERENCE - subtract colors from underlying image.
        * EXCLUSION - similar to DIFFERENCE, but less extreme.
        * MULTIPLY - Multiply the colors, result will always be darker.
        * SCREEN - Opposite multiply, uses inverse values of the colors.
        * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.
        * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.
        * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.
        * DODGE - Lightens light tones and increases contrast, ignores darks. Called "Color Dodge" in Illustrator and Photoshop.
        * BURN - Darker areas are applied, increasing contrast, ignores lights. Called "Color Burn" in Illustrator and Photoshop.
        * All modes use the alpha information (highest byte) of source image pixels as the blending factor.
        * If the source and destination regions are different sizes, the image will be automatically resized to
        * match the destination size. If the srcImg parameter is not used, the display window is used as the source image.
        * This function ignores imageMode().
        *
        * @param {int} x              X coordinate of the source's upper left corner
        * @param {int} y              Y coordinate of the source's upper left corner
        * @param {int} width          source image width
        * @param {int} height         source image height
        * @param {int} dx             X coordinate of the destinations's upper left corner
        * @param {int} dy             Y coordinate of the destinations's upper left corner
        * @param {int} dwidth         destination image width
        * @param {int} dheight        destination image height
        * @param {PImage} srcImg      an image variable referring to the source image
        * @param {MODE} MODE          Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION,
        * MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN
        *
        * @see alpha
        * @see copy
        */
        blend: function(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE) {
          if (arguments.length === 9) {
            p.blend(this, srcImg, x, y, width, height, dx, dy, dwidth, dheight, this);
          } else if (arguments.length === 10) {
            p.blend(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE, this);
          }
          delete this.sourceImg;
        },
        /**
        * @member PImage
        * Copies a region of pixels from one image into another. If the source and destination regions
        * aren't the same size, it will automatically resize source pixels to fit the specified target region.
        * No alpha information is used in the process, however if the source image has an alpha channel set,
        * it will be copied as well. This function ignores imageMode().
        *
        * @param {int} sx             X coordinate of the source's upper left corner
        * @param {int} sy             Y coordinate of the source's upper left corner
        * @param {int} swidth         source image width
        * @param {int} sheight        source image height
        * @param {int} dx             X coordinate of the destinations's upper left corner
        * @param {int} dy             Y coordinate of the destinations's upper left corner
        * @param {int} dwidth         destination image width
        * @param {int} dheight        destination image height
        * @param {PImage} srcImg      an image variable referring to the source image
        *
        * @see alpha
        * @see blend
        */
        copy: function(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
          if (arguments.length === 8) {
            p.blend(this, srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, PConstants3.REPLACE, this);
          } else if (arguments.length === 9) {
            p.blend(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight, PConstants3.REPLACE, this);
          }
          delete this.sourceImg;
        },
        /**
        * @member PImage
        * Filters an image as defined by one of the following modes:
        * THRESHOLD - converts the image to black and white pixels depending if they are above or below
        * the threshold defined by the level parameter. The level must be between 0.0 (black) and 1.0(white).
        * If no level is specified, 0.5 is used.
        * GRAY - converts any colors in the image to grayscale equivalents
        * INVERT - sets each pixel to its inverse value
        * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter
        * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring.
        * If no level parameter is used, the blur is equivalent to Guassian blur of radius 1.
        * OPAQUE - sets the alpha channel to entirely opaque.
        * ERODE - reduces the light areas with the amount defined by the level parameter.
        * DILATE - increases the light areas with the amount defined by the level parameter
        *
        * @param {MODE} MODE        Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE
        * @param {int|float} param  in the range from 0 to 1
        */
        filter: function(mode, param) {
          if (arguments.length === 2) {
            p.filter(mode, param, this);
          } else if (arguments.length === 1) {
            p.filter(mode, null, this);
          }
          delete this.sourceImg;
        },
        /**
        * @member PImage
        * Saves the image into a file. Images are saved in TIFF, TARGA, JPEG, and PNG format depending on
        * the extension within the filename  parameter. For example, "image.tif" will have a TIFF image and
        * "image.png" will save a PNG image. If no extension is included in the filename, the image will save
        * in TIFF format and .tif will be added to the name. These files are saved to the sketch's folder,
        * which may be opened by selecting "Show sketch folder" from the "Sketch" menu. It is not possible to
        * use save() while running the program in a web browser.
        * To save an image created within the code, rather than through loading, it's necessary to make the
        * image with the createImage() function so it is aware of the location of the program and can therefore
        * save the file to the right place. See the createImage() reference for more information.
        *
        * @param {String} filename        a sequence of letters and numbers
        */
        save: function(file) {
          p.save(file, this);
        },
        /**
        * @member PImage
        * Resize the image to a new width and height. To make the image scale proportionally, use 0 as the
        * value for the wide or high parameter.
        *
        * @param {int} wide         the resized image width
        * @param {int} high         the resized image height
        *
        * @see get
        */
        resize: function(w, h) {
          if (this.isRemote) {
            throw "Image is loaded remotely. Cannot resize.";
          }
          if (this.width !== 0 || this.height !== 0) {
            if (w === 0 && h !== 0) {
              w = Math.floor(this.width / this.height * h);
            } else if (h === 0 && w !== 0) {
              h = Math.floor(this.height / this.width * w);
            }
            var canvas = getCanvasData(this.imageData).canvas;
            var imageData = getCanvasData(canvas, w, h).context.getImageData(0, 0, w, h);
            this.fromImageData(imageData);
          }
        },
        /**
        * @member PImage
        * Masks part of an image from displaying by loading another image and using it as an alpha channel.
        * This mask image should only contain grayscale data, but only the blue color channel is used. The
        * mask image needs to be the same size as the image to which it is applied.
        * In addition to using a mask image, an integer array containing the alpha channel data can be
        * specified directly. This method is useful for creating dynamically generated alpha masks. This
        * array must be of the same length as the target image's pixels array and should contain only grayscale
        * data of values between 0-255.
        *
        * @param {PImage} maskImg         any PImage object used as the alpha channel for "img", needs to be same
        *                                 size as "img"
        * @param {int[]} maskArray        any array of Integer numbers used as the alpha channel, needs to be same
        *                                 length as the image's pixel array
        */
        mask: function(mask) {
          var obj = this.toImageData(), i2, size;
          if (mask instanceof PImage || mask.__isPImage) {
            if (mask.width === this.width && mask.height === this.height) {
              mask = mask.toImageData();
              for (i2 = 2, size = this.width * this.height * 4; i2 < size; i2 += 4) {
                obj.data[i2 + 1] = mask.data[i2];
              }
            } else {
              throw "mask must have the same dimensions as PImage.";
            }
          } else if (mask instanceof Array) {
            if (this.width * this.height === mask.length) {
              for (i2 = 0, size = mask.length; i2 < size; ++i2) {
                obj.data[i2 * 4 + 3] = mask[i2];
              }
            } else {
              throw "mask array must be the same length as PImage pixels array.";
            }
          }
          this.fromImageData(obj);
        },
        // These are intentionally left blank for PImages, we work live with pixels and draw as necessary
        /**
        * @member PImage
        * Loads the pixel data for the image into its pixels[] array. This function must always be called
        * before reading from or writing to pixels[].
        * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the
        * rule is that any time you want to manipulate the pixels[] array, you must first call loadPixels(),
        * and after changes have been made, call updatePixels(). Even if the renderer may not seem to use
        * this function in the current Processing release, this will always be subject to change.
        */
        loadPixels: noop,
        toImageData: function() {
          if (this.isRemote) {
            return this.sourceImg;
          }
          if (!this.__isDirty) {
            return this.imageData;
          }
          var canvasData = getCanvasData(this.sourceImg);
          return canvasData.context.getImageData(0, 0, this.width, this.height);
        },
        toDataURL: function() {
          if (this.isRemote) {
            throw "Image is loaded remotely. Cannot create dataURI.";
          }
          var canvasData = getCanvasData(this.imageData);
          return canvasData.canvas.toDataURL();
        },
        fromImageData: function(canvasImg) {
          var w = canvasImg.width, h = canvasImg.height, canvas = document2.createElement("canvas"), ctx = canvas.getContext("2d");
          this.width = canvas.width = w;
          this.height = canvas.height = h;
          ctx.putImageData(canvasImg, 0, 0);
          this.format = PConstants3.ARGB;
          this.imageData = canvasImg;
          this.sourceImg = canvas;
        }
      };
      p.PImage = PImage;
      p.createImage = function(w, h, mode) {
        return new PImage(w, h, mode);
      };
      p.loadImage = function(file, type, callback) {
        var pimg;
        if (curSketch.imageCache.images[file]) {
          pimg = new PImage(curSketch.imageCache.images[file]);
          pimg.loaded = true;
          return pimg;
        }
        pimg = new PImage();
        var img = document2.createElement("img");
        pimg.sourceImg = img;
        img.onload = /* @__PURE__ */ function(aImage, aPImage, aCallback) {
          var image = aImage;
          var pimg2 = aPImage;
          var callback2 = aCallback;
          return function() {
            pimg2.fromHTMLImageData(image);
            pimg2.loaded = true;
            if (callback2) {
              callback2();
            }
          };
        }(img, pimg, callback);
        img.src = file;
        return pimg;
      };
      p.requestImage = p.loadImage;
      function get$2(x, y) {
        var data;
        if (x >= p.width || x < 0 || y < 0 || y >= p.height) {
          return 0;
        }
        if (isContextReplaced) {
          var offset = ((0 | x) + p.width * (0 | y)) * 4;
          data = p.imageData.data;
          return data[offset + 3] << 24 & PConstants3.ALPHA_MASK | data[offset] << 16 & PConstants3.RED_MASK | data[offset + 1] << 8 & PConstants3.GREEN_MASK | data[offset + 2] & PConstants3.BLUE_MASK;
        }
        data = p.toImageData(0 | x, 0 | y, 1, 1).data;
        return data[3] << 24 & PConstants3.ALPHA_MASK | data[0] << 16 & PConstants3.RED_MASK | data[1] << 8 & PConstants3.GREEN_MASK | data[2] & PConstants3.BLUE_MASK;
      }
      function get$3(x, y, img) {
        if (img.isRemote) {
          throw "Image is loaded remotely. Cannot get x,y.";
        }
        var offset = y * img.width * 4 + x * 4, data = img.imageData.data;
        return data[offset + 3] << 24 & PConstants3.ALPHA_MASK | data[offset] << 16 & PConstants3.RED_MASK | data[offset + 1] << 8 & PConstants3.GREEN_MASK | data[offset + 2] & PConstants3.BLUE_MASK;
      }
      function get$4(x, y, w, h) {
        var c = new PImage(w, h, PConstants3.ARGB);
        c.fromImageData(p.toImageData(x, y, w, h));
        return c;
      }
      function get$5(x, y, w, h, img) {
        if (img.isRemote) {
          throw "Image is loaded remotely. Cannot get x,y,w,h.";
        }
        var c = new PImage(w, h, PConstants3.ARGB), cData = c.imageData.data, imgWidth = img.width, imgHeight = img.height, imgData = img.imageData.data;
        var startRow = Math.max(0, -y), startColumn = Math.max(0, -x), stopRow = Math.min(h, imgHeight - y), stopColumn = Math.min(w, imgWidth - x);
        for (var i2 = startRow; i2 < stopRow; ++i2) {
          var sourceOffset = ((y + i2) * imgWidth + (x + startColumn)) * 4;
          var targetOffset = (i2 * w + startColumn) * 4;
          for (var j = startColumn; j < stopColumn; ++j) {
            cData[targetOffset++] = imgData[sourceOffset++];
            cData[targetOffset++] = imgData[sourceOffset++];
            cData[targetOffset++] = imgData[sourceOffset++];
            cData[targetOffset++] = imgData[sourceOffset++];
          }
        }
        c.__isDirty = true;
        return c;
      }
      p.get = function(x, y, w, h, img) {
        if (img !== void 0) {
          return get$5(x, y, w, h, img);
        }
        if (h !== void 0) {
          return get$4(x, y, w, h);
        }
        if (w !== void 0) {
          return get$3(x, y, w);
        }
        if (y !== void 0) {
          return get$2(x, y);
        }
        if (x !== void 0) {
          return get$5(0, 0, x.width, x.height, x);
        }
        return get$4(0, 0, p.width, p.height);
      };
      p.createGraphics = function(w, h, render) {
        var pg = new Processing3();
        pg.size(w, h, render);
        pg.background(0, 0);
        return pg;
      };
      function resetContext() {
        if (isContextReplaced) {
          curContext = originalContext;
          isContextReplaced = false;
          p.updatePixels();
        }
      }
      function SetPixelContextWrapper() {
        function wrapFunction(newContext, name) {
          function wrapper() {
            resetContext();
            curContext[name].apply(curContext, arguments);
          }
          newContext[name] = wrapper;
        }
        function wrapProperty(newContext, name) {
          function getter() {
            resetContext();
            return curContext[name];
          }
          function setter(value) {
            resetContext();
            curContext[name] = value;
          }
          p.defineProperty(newContext, name, { get: getter, set: setter });
        }
        for (var n in curContext) {
          if (typeof curContext[n] === "function") {
            wrapFunction(this, n);
          } else {
            wrapProperty(this, n);
          }
        }
      }
      function replaceContext() {
        if (isContextReplaced) {
          return;
        }
        p.loadPixels();
        if (proxyContext === null) {
          originalContext = curContext;
          proxyContext = new SetPixelContextWrapper();
        }
        isContextReplaced = true;
        curContext = proxyContext;
        setPixelsCached = 0;
      }
      function set$3(x, y, c) {
        if (x < p.width && x >= 0 && y >= 0 && y < p.height) {
          replaceContext();
          p.pixels.setPixel((0 | x) + p.width * (0 | y), c);
          if (++setPixelsCached > maxPixelsCached) {
            resetContext();
          }
        }
      }
      function set$4(x, y, obj, img) {
        if (img.isRemote) {
          throw "Image is loaded remotely. Cannot set x,y.";
        }
        var c = p.color.toArray(obj);
        var offset = y * img.width * 4 + x * 4;
        var data = img.imageData.data;
        data[offset] = c[0];
        data[offset + 1] = c[1];
        data[offset + 2] = c[2];
        data[offset + 3] = c[3];
      }
      p.set = function(x, y, obj, img) {
        var color, oldFill;
        if (arguments.length === 3) {
          if (typeof obj === "number") {
            set$3(x, y, obj);
          } else if (obj instanceof PImage || obj.__isPImage) {
            p.image(obj, x, y);
          }
        } else if (arguments.length === 4) {
          set$4(x, y, obj, img);
        }
      };
      p.imageData = {};
      p.pixels = {
        getLength: function() {
          return p.imageData.data.length ? p.imageData.data.length / 4 : 0;
        },
        getPixel: function(i2) {
          var offset = i2 * 4, data = p.imageData.data;
          return data[offset + 3] << 24 & 4278190080 | data[offset + 0] << 16 & 16711680 | data[offset + 1] << 8 & 65280 | data[offset + 2] & 255;
        },
        setPixel: function(i2, c) {
          var offset = i2 * 4, data = p.imageData.data;
          data[offset + 0] = (c & 16711680) >>> 16;
          data[offset + 1] = (c & 65280) >>> 8;
          data[offset + 2] = c & 255;
          data[offset + 3] = (c & 4278190080) >>> 24;
        },
        toArray: function() {
          var arr = [], length = p.imageData.width * p.imageData.height, data = p.imageData.data;
          for (var i2 = 0, offset = 0; i2 < length; i2++, offset += 4) {
            arr.push(data[offset + 3] << 24 & 4278190080 | data[offset + 0] << 16 & 16711680 | data[offset + 1] << 8 & 65280 | data[offset + 2] & 255);
          }
          return arr;
        },
        set: function(arr) {
          for (var i2 = 0, aL = arr.length; i2 < aL; i2++) {
            this.setPixel(i2, arr[i2]);
          }
        }
      };
      p.loadPixels = function() {
        p.imageData = drawing.$ensureContext().getImageData(0, 0, p.width, p.height);
      };
      p.updatePixels = function() {
        if (p.imageData) {
          drawing.$ensureContext().putImageData(p.imageData, 0, 0);
        }
      };
      p.hint = function(which) {
        var curContext2 = drawing.$ensureContext();
        if (which === PConstants3.DISABLE_DEPTH_TEST) {
          curContext2.disable(curContext2.DEPTH_TEST);
          curContext2.depthMask(false);
          curContext2.clear(curContext2.DEPTH_BUFFER_BIT);
        } else if (which === PConstants3.ENABLE_DEPTH_TEST) {
          curContext2.enable(curContext2.DEPTH_TEST);
          curContext2.depthMask(true);
        } else if (which === PConstants3.ENABLE_OPENGL_2X_SMOOTH || which === PConstants3.ENABLE_OPENGL_4X_SMOOTH) {
          renderSmooth = true;
        } else if (which === PConstants3.DISABLE_OPENGL_2X_SMOOTH) {
          renderSmooth = false;
        }
      };
      var backgroundHelper = function(arg1, arg2, arg3, arg4) {
        var obj;
        if (arg1 instanceof PImage || arg1.__isPImage) {
          obj = arg1;
          if (!obj.loaded) {
            throw "Error using image in background(): PImage not loaded.";
          }
          if (obj.width !== p.width || obj.height !== p.height) {
            throw "Background image must be the same dimensions as the canvas.";
          }
        } else {
          obj = p.color(arg1, arg2, arg3, arg4);
        }
        backgroundObj = obj;
      };
      Drawing2D.prototype.background = function(arg1, arg2, arg3, arg4) {
        if (arg1 !== undef) {
          backgroundHelper(arg1, arg2, arg3, arg4);
        }
        if (backgroundObj instanceof PImage || backgroundObj.__isPImage) {
          saveContext();
          curContext.setTransform(1, 0, 0, 1, 0, 0);
          p.image(backgroundObj, 0, 0);
          restoreContext();
        } else {
          saveContext();
          curContext.setTransform(1, 0, 0, 1, 0, 0);
          if (p.alpha(backgroundObj) !== colorModeA) {
            curContext.clearRect(0, 0, p.width, p.height);
          }
          curContext.fillStyle = p.color.toString(backgroundObj);
          curContext.fillRect(0, 0, p.width, p.height);
          isFillDirty = true;
          restoreContext();
        }
      };
      Drawing3D.prototype.background = function(arg1, arg2, arg3, arg4) {
        if (arguments.length > 0) {
          backgroundHelper(arg1, arg2, arg3, arg4);
        }
        var c = p.color.toGLArray(backgroundObj);
        curContext.clearColor(c[0], c[1], c[2], c[3]);
        curContext.clear(curContext.COLOR_BUFFER_BIT | curContext.DEPTH_BUFFER_BIT);
      };
      Drawing2D.prototype.image = function(img, x, y, w, h) {
        x = Math.round(x);
        y = Math.round(y);
        if (img.width > 0) {
          var wid = w || img.width;
          var hgt = h || img.height;
          var bounds = imageModeConvert2(x || 0, y || 0, w || img.width, h || img.height, arguments.length < 4);
          var fastImage = !!img.sourceImg && curTint === null;
          if (fastImage) {
            var htmlElement = img.sourceImg;
            if (img.__isDirty) {
              img.updatePixels();
            }
            curContext.drawImage(
              htmlElement,
              0,
              0,
              htmlElement.width,
              htmlElement.height,
              bounds.x,
              bounds.y,
              bounds.w,
              bounds.h
            );
          } else {
            var obj = img.toImageData();
            if (curTint !== null) {
              curTint(obj);
              img.__isDirty = true;
            }
            curContext.drawImage(
              getCanvasData(obj).canvas,
              0,
              0,
              img.width,
              img.height,
              bounds.x,
              bounds.y,
              bounds.w,
              bounds.h
            );
          }
        }
      };
      Drawing3D.prototype.image = function(img, x, y, w, h) {
        if (img.width > 0) {
          x = Math.round(x);
          y = Math.round(y);
          w = w || img.width;
          h = h || img.height;
          p.beginShape(p.QUADS);
          p.texture(img);
          p.vertex(x, y, 0, 0, 0);
          p.vertex(x, y + h, 0, 0, h);
          p.vertex(x + w, y + h, 0, w, h);
          p.vertex(x + w, y, 0, w, 0);
          p.endShape();
        }
      };
      p.tint = function(a1, a2, a3, a4) {
        var tintColor = p.color(a1, a2, a3, a4);
        var r = p.red(tintColor) / colorModeX;
        var g = p.green(tintColor) / colorModeY;
        var b = p.blue(tintColor) / colorModeZ;
        var a = p.alpha(tintColor) / colorModeA;
        curTint = function(obj) {
          var data = obj.data, length = 4 * obj.width * obj.height;
          for (var i2 = 0; i2 < length; ) {
            data[i2++] *= r;
            data[i2++] *= g;
            data[i2++] *= b;
            data[i2++] *= a;
          }
        };
        curTint3d = function(data) {
          for (var i2 = 0; i2 < data.length; ) {
            data[i2++] = r;
            data[i2++] = g;
            data[i2++] = b;
            data[i2++] = a;
          }
        };
      };
      p.noTint = function() {
        curTint = null;
        curTint3d = null;
      };
      p.copy = function(src, sx, sy, sw, sh, dx, dy, dw, dh) {
        if (dh === undef) {
          dh = dw;
          dw = dy;
          dy = dx;
          dx = sh;
          sh = sw;
          sw = sy;
          sy = sx;
          sx = src;
          src = p;
        }
        p.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, PConstants3.REPLACE);
      };
      p.blend = function(src, sx, sy, sw, sh, dx, dy, dw, dh, mode, pimgdest) {
        if (src.isRemote) {
          throw "Image is loaded remotely. Cannot blend image.";
        }
        if (mode === undef) {
          mode = dh;
          dh = dw;
          dw = dy;
          dy = dx;
          dx = sh;
          sh = sw;
          sw = sy;
          sy = sx;
          sx = src;
          src = p;
        }
        var sx2 = sx + sw, sy2 = sy + sh, dx2 = dx + dw, dy2 = dy + dh, dest = pimgdest || p;
        if (pimgdest === undef || mode === undef) {
          p.loadPixels();
        }
        src.loadPixels();
        if (src === p && p.intersect(sx, sy, sx2, sy2, dx, dy, dx2, dy2)) {
          p.blit_resize(
            p.get(sx, sy, sx2 - sx, sy2 - sy),
            0,
            0,
            sx2 - sx - 1,
            sy2 - sy - 1,
            dest.imageData.data,
            dest.width,
            dest.height,
            dx,
            dy,
            dx2,
            dy2,
            mode
          );
        } else {
          p.blit_resize(src, sx, sy, sx2, sy2, dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);
        }
        if (pimgdest === undef) {
          p.updatePixels();
        }
      };
      var buildBlurKernel = function(r) {
        var radius = p.floor(r * 3.5), i2;
        radius = radius < 1 ? 1 : radius < 248 ? radius : 248;
        if (p.shared.blurRadius !== radius) {
          p.shared.blurRadius = radius;
          p.shared.blurKernelSize = 1 + (p.shared.blurRadius << 1);
          p.shared.blurKernel = new Float32Array2(p.shared.blurKernelSize);
          var sharedBlurKernal = p.shared.blurKernel;
          var sharedBlurKernelSize = p.shared.blurKernelSize;
          var sharedBlurRadius = p.shared.blurRadius;
          for (i2 = 0; i2 < sharedBlurKernelSize; i2++) {
            sharedBlurKernal[i2] = 0;
          }
          var radiusiSquared = (radius - 1) * (radius - 1);
          for (i2 = 1; i2 < radius; i2++) {
            sharedBlurKernal[radius + i2] = sharedBlurKernal[radius - i2] = radiusiSquared;
          }
          sharedBlurKernal[radius] = radius * radius;
        }
      };
      var blurARGB = function(r, aImg) {
        var sum, cr, cg, cb, ca, c, m;
        var read2, ri, ym, ymi, bk0;
        var wh = aImg.pixels.getLength();
        var r2 = new Float32Array2(wh);
        var g2 = new Float32Array2(wh);
        var b2 = new Float32Array2(wh);
        var a2 = new Float32Array2(wh);
        var yi = 0;
        var x, y, i2, offset;
        buildBlurKernel(r);
        var aImgHeight = aImg.height;
        var aImgWidth = aImg.width;
        var sharedBlurKernelSize = p.shared.blurKernelSize;
        var sharedBlurRadius = p.shared.blurRadius;
        var sharedBlurKernal = p.shared.blurKernel;
        var pix = aImg.imageData.data;
        for (y = 0; y < aImgHeight; y++) {
          for (x = 0; x < aImgWidth; x++) {
            cb = cg = cr = ca = sum = 0;
            read2 = x - sharedBlurRadius;
            if (read2 < 0) {
              bk0 = -read2;
              read2 = 0;
            } else {
              if (read2 >= aImgWidth) {
                break;
              }
              bk0 = 0;
            }
            for (i2 = bk0; i2 < sharedBlurKernelSize; i2++) {
              if (read2 >= aImgWidth) {
                break;
              }
              offset = (read2 + yi) * 4;
              m = sharedBlurKernal[i2];
              ca += m * pix[offset + 3];
              cr += m * pix[offset];
              cg += m * pix[offset + 1];
              cb += m * pix[offset + 2];
              sum += m;
              read2++;
            }
            ri = yi + x;
            a2[ri] = ca / sum;
            r2[ri] = cr / sum;
            g2[ri] = cg / sum;
            b2[ri] = cb / sum;
          }
          yi += aImgWidth;
        }
        yi = 0;
        ym = -sharedBlurRadius;
        ymi = ym * aImgWidth;
        for (y = 0; y < aImgHeight; y++) {
          for (x = 0; x < aImgWidth; x++) {
            cb = cg = cr = ca = sum = 0;
            if (ym < 0) {
              bk0 = ri = -ym;
              read2 = x;
            } else {
              if (ym >= aImgHeight) {
                break;
              }
              bk0 = 0;
              ri = ym;
              read2 = x + ymi;
            }
            for (i2 = bk0; i2 < sharedBlurKernelSize; i2++) {
              if (ri >= aImgHeight) {
                break;
              }
              m = sharedBlurKernal[i2];
              ca += m * a2[read2];
              cr += m * r2[read2];
              cg += m * g2[read2];
              cb += m * b2[read2];
              sum += m;
              ri++;
              read2 += aImgWidth;
            }
            offset = (x + yi) * 4;
            pix[offset] = cr / sum;
            pix[offset + 1] = cg / sum;
            pix[offset + 2] = cb / sum;
            pix[offset + 3] = ca / sum;
          }
          yi += aImgWidth;
          ymi += aImgWidth;
          ym++;
        }
      };
      var dilate = function(isInverted, aImg) {
        var currIdx = 0;
        var maxIdx = aImg.pixels.getLength();
        var out = new Int32Array2(maxIdx);
        var currRowIdx, maxRowIdx, colOrig, colOut, currLum;
        var idxRight, idxLeft, idxUp, idxDown, colRight, colLeft, colUp, colDown, lumRight, lumLeft, lumUp, lumDown;
        if (!isInverted) {
          while (currIdx < maxIdx) {
            currRowIdx = currIdx;
            maxRowIdx = currIdx + aImg.width;
            while (currIdx < maxRowIdx) {
              colOrig = colOut = aImg.pixels.getPixel(currIdx);
              idxLeft = currIdx - 1;
              idxRight = currIdx + 1;
              idxUp = currIdx - aImg.width;
              idxDown = currIdx + aImg.width;
              if (idxLeft < currRowIdx) {
                idxLeft = currIdx;
              }
              if (idxRight >= maxRowIdx) {
                idxRight = currIdx;
              }
              if (idxUp < 0) {
                idxUp = 0;
              }
              if (idxDown >= maxIdx) {
                idxDown = currIdx;
              }
              colUp = aImg.pixels.getPixel(idxUp);
              colLeft = aImg.pixels.getPixel(idxLeft);
              colDown = aImg.pixels.getPixel(idxDown);
              colRight = aImg.pixels.getPixel(idxRight);
              currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
              lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
              lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
              lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
              lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
              if (lumLeft > currLum) {
                colOut = colLeft;
                currLum = lumLeft;
              }
              if (lumRight > currLum) {
                colOut = colRight;
                currLum = lumRight;
              }
              if (lumUp > currLum) {
                colOut = colUp;
                currLum = lumUp;
              }
              if (lumDown > currLum) {
                colOut = colDown;
                currLum = lumDown;
              }
              out[currIdx++] = colOut;
            }
          }
        } else {
          while (currIdx < maxIdx) {
            currRowIdx = currIdx;
            maxRowIdx = currIdx + aImg.width;
            while (currIdx < maxRowIdx) {
              colOrig = colOut = aImg.pixels.getPixel(currIdx);
              idxLeft = currIdx - 1;
              idxRight = currIdx + 1;
              idxUp = currIdx - aImg.width;
              idxDown = currIdx + aImg.width;
              if (idxLeft < currRowIdx) {
                idxLeft = currIdx;
              }
              if (idxRight >= maxRowIdx) {
                idxRight = currIdx;
              }
              if (idxUp < 0) {
                idxUp = 0;
              }
              if (idxDown >= maxIdx) {
                idxDown = currIdx;
              }
              colUp = aImg.pixels.getPixel(idxUp);
              colLeft = aImg.pixels.getPixel(idxLeft);
              colDown = aImg.pixels.getPixel(idxDown);
              colRight = aImg.pixels.getPixel(idxRight);
              currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
              lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
              lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
              lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
              lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
              if (lumLeft < currLum) {
                colOut = colLeft;
                currLum = lumLeft;
              }
              if (lumRight < currLum) {
                colOut = colRight;
                currLum = lumRight;
              }
              if (lumUp < currLum) {
                colOut = colUp;
                currLum = lumUp;
              }
              if (lumDown < currLum) {
                colOut = colDown;
                currLum = lumDown;
              }
              out[currIdx++] = colOut;
            }
          }
        }
        aImg.pixels.set(out);
      };
      p.filter = function(kind, param, aImg) {
        var img, col, lum, i2;
        if (arguments.length === 3) {
          aImg.loadPixels();
          img = aImg;
        } else {
          p.loadPixels();
          img = p;
        }
        if (param === undef) {
          param = null;
        }
        if (img.isRemote) {
          throw "Image is loaded remotely. Cannot filter image.";
        }
        var imglen = img.pixels.getLength();
        switch (kind) {
          case PConstants3.BLUR:
            var radius = param || 1;
            blurARGB(radius, img);
            break;
          case PConstants3.GRAY:
            if (img.format === PConstants3.ALPHA) {
              for (i2 = 0; i2 < imglen; i2++) {
                col = 255 - img.pixels.getPixel(i2);
                img.pixels.setPixel(i2, 4278190080 | col << 16 | col << 8 | col);
              }
              img.format = PConstants3.RGB;
            } else {
              for (i2 = 0; i2 < imglen; i2++) {
                col = img.pixels.getPixel(i2);
                lum = 77 * (col >> 16 & 255) + 151 * (col >> 8 & 255) + 28 * (col & 255) >> 8;
                img.pixels.setPixel(i2, col & PConstants3.ALPHA_MASK | lum << 16 | lum << 8 | lum);
              }
            }
            break;
          case PConstants3.INVERT:
            for (i2 = 0; i2 < imglen; i2++) {
              img.pixels.setPixel(i2, img.pixels.getPixel(i2) ^ 16777215);
            }
            break;
          case PConstants3.POSTERIZE:
            if (param === null) {
              throw "Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)";
            }
            var levels = p.floor(param);
            if (levels < 2 || levels > 255) {
              throw "Levels must be between 2 and 255 for filter(POSTERIZE, levels)";
            }
            var levels1 = levels - 1;
            for (i2 = 0; i2 < imglen; i2++) {
              var rlevel = img.pixels.getPixel(i2) >> 16 & 255;
              var glevel = img.pixels.getPixel(i2) >> 8 & 255;
              var blevel = img.pixels.getPixel(i2) & 255;
              rlevel = (rlevel * levels >> 8) * 255 / levels1;
              glevel = (glevel * levels >> 8) * 255 / levels1;
              blevel = (blevel * levels >> 8) * 255 / levels1;
              img.pixels.setPixel(i2, 4278190080 & img.pixels.getPixel(i2) | rlevel << 16 | glevel << 8 | blevel);
            }
            break;
          case PConstants3.OPAQUE:
            for (i2 = 0; i2 < imglen; i2++) {
              img.pixels.setPixel(i2, img.pixels.getPixel(i2) | 4278190080);
            }
            img.format = PConstants3.RGB;
            break;
          case PConstants3.THRESHOLD:
            if (param === null) {
              param = 0.5;
            }
            if (param < 0 || param > 1) {
              throw "Level must be between 0 and 1 for filter(THRESHOLD, level)";
            }
            var thresh = p.floor(param * 255);
            for (i2 = 0; i2 < imglen; i2++) {
              var max = p.max((img.pixels.getPixel(i2) & PConstants3.RED_MASK) >> 16, p.max((img.pixels.getPixel(i2) & PConstants3.GREEN_MASK) >> 8, img.pixels.getPixel(i2) & PConstants3.BLUE_MASK));
              img.pixels.setPixel(i2, img.pixels.getPixel(i2) & PConstants3.ALPHA_MASK | (max < thresh ? 0 : 16777215));
            }
            break;
          case PConstants3.ERODE:
            dilate(true, img);
            break;
          case PConstants3.DILATE:
            dilate(false, img);
            break;
        }
        img.updatePixels();
      };
      p.shared = {
        fracU: 0,
        ifU: 0,
        fracV: 0,
        ifV: 0,
        u1: 0,
        u2: 0,
        v1: 0,
        v2: 0,
        sX: 0,
        sY: 0,
        iw: 0,
        iw1: 0,
        ih1: 0,
        ul: 0,
        ll: 0,
        ur: 0,
        lr: 0,
        cUL: 0,
        cLL: 0,
        cUR: 0,
        cLR: 0,
        srcXOffset: 0,
        srcYOffset: 0,
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        srcBuffer: null,
        blurRadius: 0,
        blurKernelSize: 0,
        blurKernel: null
      };
      p.intersect = function(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2) {
        var sw = sx2 - sx1 + 1;
        var sh = sy2 - sy1 + 1;
        var dw = dx2 - dx1 + 1;
        var dh = dy2 - dy1 + 1;
        if (dx1 < sx1) {
          dw += dx1 - sx1;
          if (dw > sw) {
            dw = sw;
          }
        } else {
          var w = sw + sx1 - dx1;
          if (dw > w) {
            dw = w;
          }
        }
        if (dy1 < sy1) {
          dh += dy1 - sy1;
          if (dh > sh) {
            dh = sh;
          }
        } else {
          var h = sh + sy1 - dy1;
          if (dh > h) {
            dh = h;
          }
        }
        return !(dw <= 0 || dh <= 0);
      };
      var blendFuncs = {};
      blendFuncs[PConstants3.BLEND] = p.modes.blend;
      blendFuncs[PConstants3.ADD] = p.modes.add;
      blendFuncs[PConstants3.SUBTRACT] = p.modes.subtract;
      blendFuncs[PConstants3.LIGHTEST] = p.modes.lightest;
      blendFuncs[PConstants3.DARKEST] = p.modes.darkest;
      blendFuncs[PConstants3.REPLACE] = p.modes.replace;
      blendFuncs[PConstants3.DIFFERENCE] = p.modes.difference;
      blendFuncs[PConstants3.EXCLUSION] = p.modes.exclusion;
      blendFuncs[PConstants3.MULTIPLY] = p.modes.multiply;
      blendFuncs[PConstants3.SCREEN] = p.modes.screen;
      blendFuncs[PConstants3.OVERLAY] = p.modes.overlay;
      blendFuncs[PConstants3.HARD_LIGHT] = p.modes.hard_light;
      blendFuncs[PConstants3.SOFT_LIGHT] = p.modes.soft_light;
      blendFuncs[PConstants3.DODGE] = p.modes.dodge;
      blendFuncs[PConstants3.BURN] = p.modes.burn;
      p.blit_resize = function(img, srcX1, srcY1, srcX2, srcY2, destPixels, screenW, screenH, destX1, destY1, destX2, destY2, mode) {
        var x, y;
        if (srcX1 < 0) {
          srcX1 = 0;
        }
        if (srcY1 < 0) {
          srcY1 = 0;
        }
        if (srcX2 >= img.width) {
          srcX2 = img.width - 1;
        }
        if (srcY2 >= img.height) {
          srcY2 = img.height - 1;
        }
        var srcW = srcX2 - srcX1;
        var srcH = srcY2 - srcY1;
        var destW = destX2 - destX1;
        var destH = destY2 - destY1;
        if (destW <= 0 || destH <= 0 || srcW <= 0 || srcH <= 0 || destX1 >= screenW || destY1 >= screenH || srcX1 >= img.width || srcY1 >= img.height) {
          return;
        }
        var dx = Math.floor(srcW / destW * PConstants3.PRECISIONF);
        var dy = Math.floor(srcH / destH * PConstants3.PRECISIONF);
        var pshared = p.shared;
        pshared.srcXOffset = Math.floor(destX1 < 0 ? -destX1 * dx : srcX1 * PConstants3.PRECISIONF);
        pshared.srcYOffset = Math.floor(destY1 < 0 ? -destY1 * dy : srcY1 * PConstants3.PRECISIONF);
        if (destX1 < 0) {
          destW += destX1;
          destX1 = 0;
        }
        if (destY1 < 0) {
          destH += destY1;
          destY1 = 0;
        }
        destW = Math.min(destW, screenW - destX1);
        destH = Math.min(destH, screenH - destY1);
        var destOffset = destY1 * screenW + destX1;
        var destColor;
        pshared.srcBuffer = img.imageData.data;
        pshared.iw = img.width;
        pshared.iw1 = img.width - 1;
        pshared.ih1 = img.height - 1;
        var filterBilinear = p.filter_bilinear, filterNewScanline = p.filter_new_scanline, blendFunc = blendFuncs[mode], blendedColor, idx, cULoffset, cURoffset, cLLoffset, cLRoffset, ALPHA_MASK = PConstants3.ALPHA_MASK, RED_MASK = PConstants3.RED_MASK, GREEN_MASK = PConstants3.GREEN_MASK, BLUE_MASK = PConstants3.BLUE_MASK, PREC_MAXVAL = PConstants3.PREC_MAXVAL, PRECISIONB = PConstants3.PRECISIONB, PREC_RED_SHIFT = PConstants3.PREC_RED_SHIFT, PREC_ALPHA_SHIFT = PConstants3.PREC_ALPHA_SHIFT, srcBuffer = pshared.srcBuffer, min = Math.min;
        for (y = 0; y < destH; y++) {
          pshared.sX = pshared.srcXOffset;
          pshared.fracV = pshared.srcYOffset & PREC_MAXVAL;
          pshared.ifV = PREC_MAXVAL - pshared.fracV;
          pshared.v1 = (pshared.srcYOffset >> PRECISIONB) * pshared.iw;
          pshared.v2 = min((pshared.srcYOffset >> PRECISIONB) + 1, pshared.ih1) * pshared.iw;
          for (x = 0; x < destW; x++) {
            idx = (destOffset + x) * 4;
            destColor = destPixels[idx + 3] << 24 & ALPHA_MASK | destPixels[idx] << 16 & RED_MASK | destPixels[idx + 1] << 8 & GREEN_MASK | destPixels[idx + 2] & BLUE_MASK;
            pshared.fracU = pshared.sX & PREC_MAXVAL;
            pshared.ifU = PREC_MAXVAL - pshared.fracU;
            pshared.ul = pshared.ifU * pshared.ifV >> PRECISIONB;
            pshared.ll = pshared.ifU * pshared.fracV >> PRECISIONB;
            pshared.ur = pshared.fracU * pshared.ifV >> PRECISIONB;
            pshared.lr = pshared.fracU * pshared.fracV >> PRECISIONB;
            pshared.u1 = pshared.sX >> PRECISIONB;
            pshared.u2 = min(pshared.u1 + 1, pshared.iw1);
            cULoffset = (pshared.v1 + pshared.u1) * 4;
            cURoffset = (pshared.v1 + pshared.u2) * 4;
            cLLoffset = (pshared.v2 + pshared.u1) * 4;
            cLRoffset = (pshared.v2 + pshared.u2) * 4;
            pshared.cUL = srcBuffer[cULoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cULoffset] << 16 & RED_MASK | srcBuffer[cULoffset + 1] << 8 & GREEN_MASK | srcBuffer[cULoffset + 2] & BLUE_MASK;
            pshared.cUR = srcBuffer[cURoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cURoffset] << 16 & RED_MASK | srcBuffer[cURoffset + 1] << 8 & GREEN_MASK | srcBuffer[cURoffset + 2] & BLUE_MASK;
            pshared.cLL = srcBuffer[cLLoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cLLoffset] << 16 & RED_MASK | srcBuffer[cLLoffset + 1] << 8 & GREEN_MASK | srcBuffer[cLLoffset + 2] & BLUE_MASK;
            pshared.cLR = srcBuffer[cLRoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cLRoffset] << 16 & RED_MASK | srcBuffer[cLRoffset + 1] << 8 & GREEN_MASK | srcBuffer[cLRoffset + 2] & BLUE_MASK;
            pshared.r = pshared.ul * ((pshared.cUL & RED_MASK) >> 16) + pshared.ll * ((pshared.cLL & RED_MASK) >> 16) + pshared.ur * ((pshared.cUR & RED_MASK) >> 16) + pshared.lr * ((pshared.cLR & RED_MASK) >> 16) << PREC_RED_SHIFT & RED_MASK;
            pshared.g = pshared.ul * (pshared.cUL & GREEN_MASK) + pshared.ll * (pshared.cLL & GREEN_MASK) + pshared.ur * (pshared.cUR & GREEN_MASK) + pshared.lr * (pshared.cLR & GREEN_MASK) >>> PRECISIONB & GREEN_MASK;
            pshared.b = pshared.ul * (pshared.cUL & BLUE_MASK) + pshared.ll * (pshared.cLL & BLUE_MASK) + pshared.ur * (pshared.cUR & BLUE_MASK) + pshared.lr * (pshared.cLR & BLUE_MASK) >>> PRECISIONB;
            pshared.a = pshared.ul * ((pshared.cUL & ALPHA_MASK) >>> 24) + pshared.ll * ((pshared.cLL & ALPHA_MASK) >>> 24) + pshared.ur * ((pshared.cUR & ALPHA_MASK) >>> 24) + pshared.lr * ((pshared.cLR & ALPHA_MASK) >>> 24) << PREC_ALPHA_SHIFT & ALPHA_MASK;
            blendedColor = blendFunc(destColor, pshared.a | pshared.r | pshared.g | pshared.b);
            destPixels[idx] = (blendedColor & RED_MASK) >>> 16;
            destPixels[idx + 1] = (blendedColor & GREEN_MASK) >>> 8;
            destPixels[idx + 2] = blendedColor & BLUE_MASK;
            destPixels[idx + 3] = (blendedColor & ALPHA_MASK) >>> 24;
            pshared.sX += dx;
          }
          destOffset += screenW;
          pshared.srcYOffset += dy;
        }
      };
      p.loadFont = function(name, size) {
        if (name === undef) {
          throw "font name required in loadFont.";
        }
        if (name.indexOf(".svg") === -1) {
          if (size === undef) {
            size = curTextFont.size;
          }
          return PFont3.get(name, size);
        }
        var font = p.loadGlyphs(name);
        return {
          name,
          css: "12px sans-serif",
          glyph: true,
          units_per_em: font.units_per_em,
          horiz_adv_x: 1 / font.units_per_em * font.horiz_adv_x,
          ascent: font.ascent,
          descent: font.descent,
          width: function(str) {
            var width = 0;
            var len = str.length;
            for (var i2 = 0; i2 < len; i2++) {
              try {
                width += parseFloat(p.glyphLook(p.glyphTable[name], str[i2]).horiz_adv_x);
              } catch (e) {
                Processing3.debug(e);
              }
            }
            return width / p.glyphTable[name].units_per_em;
          }
        };
      };
      p.createFont = function(name, size) {
        return p.loadFont(name, size);
      };
      p.textFont = function(pfont, size) {
        if (size !== undef) {
          if (!pfont.glyph) {
            pfont = PFont3.get(pfont.name, size);
          }
          curTextSize = size;
        }
        curTextFont = pfont;
        curFontName = curTextFont.name;
        curTextAscent = curTextFont.ascent;
        curTextDescent = curTextFont.descent;
        curTextLeading = curTextFont.leading;
        var curContext2 = drawing.$ensureContext();
        curContext2.font = curTextFont.css;
      };
      p.textSize = function(size) {
        curTextFont = PFont3.get(curFontName, size);
        curTextSize = size;
        curTextAscent = curTextFont.ascent;
        curTextDescent = curTextFont.descent;
        curTextLeading = curTextFont.leading;
        var curContext2 = drawing.$ensureContext();
        curContext2.font = curTextFont.css;
      };
      p.textAscent = function() {
        return curTextAscent;
      };
      p.textDescent = function() {
        return curTextDescent;
      };
      p.textLeading = function(leading) {
        curTextLeading = leading;
      };
      p.textAlign = function(xalign, yalign) {
        horizontalTextAlignment = xalign;
        verticalTextAlignment = yalign || PConstants3.BASELINE;
      };
      function toP5String(obj) {
        if (obj instanceof String) {
          return obj;
        }
        if (typeof obj === "number") {
          if (obj === (0 | obj)) {
            return obj.toString();
          }
          return p.nf(obj, 0, 3);
        }
        if (obj === null || obj === undef) {
          return "";
        }
        return obj.toString();
      }
      Drawing2D.prototype.textWidth = function(str) {
        var lines = toP5String(str).split(/\r?\n/g), width = 0;
        var i2, linesCount = lines.length;
        curContext.font = curTextFont.css;
        for (i2 = 0; i2 < linesCount; ++i2) {
          width = Math.max(width, curTextFont.measureTextWidth(lines[i2]));
        }
        return width | 0;
      };
      Drawing3D.prototype.textWidth = function(str) {
        var lines = toP5String(str).split(/\r?\n/g), width = 0;
        var i2, linesCount = lines.length;
        if (textcanvas === undef) {
          textcanvas = document2.createElement("canvas");
        }
        var textContext = textcanvas.getContext("2d");
        textContext.font = curTextFont.css;
        for (i2 = 0; i2 < linesCount; ++i2) {
          width = Math.max(width, textContext.measureText(lines[i2]).width);
        }
        return width | 0;
      };
      p.glyphLook = function(font, chr) {
        try {
          switch (chr) {
            case "1":
              return font.one;
            case "2":
              return font.two;
            case "3":
              return font.three;
            case "4":
              return font.four;
            case "5":
              return font.five;
            case "6":
              return font.six;
            case "7":
              return font.seven;
            case "8":
              return font.eight;
            case "9":
              return font.nine;
            case "0":
              return font.zero;
            case " ":
              return font.space;
            case "$":
              return font.dollar;
            case "!":
              return font.exclam;
            case '"':
              return font.quotedbl;
            case "#":
              return font.numbersign;
            case "%":
              return font.percent;
            case "&":
              return font.ampersand;
            case "'":
              return font.quotesingle;
            case "(":
              return font.parenleft;
            case ")":
              return font.parenright;
            case "*":
              return font.asterisk;
            case "+":
              return font.plus;
            case ",":
              return font.comma;
            case "-":
              return font.hyphen;
            case ".":
              return font.period;
            case "/":
              return font.slash;
            case "_":
              return font.underscore;
            case ":":
              return font.colon;
            case ";":
              return font.semicolon;
            case "<":
              return font.less;
            case "=":
              return font.equal;
            case ">":
              return font.greater;
            case "?":
              return font.question;
            case "@":
              return font.at;
            case "[":
              return font.bracketleft;
            case "\\":
              return font.backslash;
            case "]":
              return font.bracketright;
            case "^":
              return font.asciicircum;
            case "`":
              return font.grave;
            case "{":
              return font.braceleft;
            case "|":
              return font.bar;
            case "}":
              return font.braceright;
            case "~":
              return font.asciitilde;
            // If the character is not 'special', access it by object reference
            default:
              return font[chr];
          }
        } catch (e) {
          Processing3.debug(e);
        }
      };
      Drawing2D.prototype.text$line = function(str, x, y, z, align) {
        var textWidth = 0, xOffset = 0;
        if (!curTextFont.glyph) {
          if (str && "fillText" in curContext) {
            if (isFillDirty) {
              curContext.fillStyle = p.color.toString(currentFillColor);
              isFillDirty = false;
            }
            if (align === PConstants3.RIGHT || align === PConstants3.CENTER) {
              textWidth = curTextFont.measureTextWidth(str);
              if (align === PConstants3.RIGHT) {
                xOffset = -textWidth;
              } else {
                xOffset = -textWidth / 2;
              }
            }
            curContext.fillText(str, x + xOffset, y);
          }
        } else {
          var font = p.glyphTable[curFontName];
          saveContext();
          curContext.translate(x, y + curTextSize);
          if (align === PConstants3.RIGHT || align === PConstants3.CENTER) {
            textWidth = font.width(str);
            if (align === PConstants3.RIGHT) {
              xOffset = -textWidth;
            } else {
              xOffset = -textWidth / 2;
            }
          }
          var upem = font.units_per_em, newScale = 1 / upem * curTextSize;
          curContext.scale(newScale, newScale);
          for (var i2 = 0, len = str.length; i2 < len; i2++) {
            try {
              p.glyphLook(font, str[i2]).draw();
            } catch (e) {
              Processing3.debug(e);
            }
          }
          restoreContext();
        }
      };
      Drawing3D.prototype.text$line = function(str, x, y, z, align) {
        if (textcanvas === undef) {
          textcanvas = document2.createElement("canvas");
        }
        var oldContext = curContext;
        curContext = textcanvas.getContext("2d");
        curContext.font = curTextFont.css;
        var textWidth = curTextFont.measureTextWidth(str);
        textcanvas.width = textWidth;
        textcanvas.height = curTextSize;
        curContext = textcanvas.getContext("2d");
        curContext.font = curTextFont.css;
        curContext.textBaseline = "top";
        Drawing2D.prototype.text$line(str, 0, 0, 0, PConstants3.LEFT);
        var aspect = textcanvas.width / textcanvas.height;
        curContext = oldContext;
        curContext.bindTexture(curContext.TEXTURE_2D, textTex);
        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, textcanvas);
        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);
        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);
        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);
        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);
        var xOffset = 0;
        if (align === PConstants3.RIGHT) {
          xOffset = -textWidth;
        } else if (align === PConstants3.CENTER) {
          xOffset = -textWidth / 2;
        }
        var model = new PMatrix3D2();
        var scalefactor = curTextSize * 0.5;
        model.translate(x + xOffset - scalefactor / 2, y - scalefactor, z);
        model.scale(-aspect * scalefactor, -scalefactor, scalefactor);
        model.translate(-1, -1, -1);
        model.transpose();
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObject2D);
        vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, textBuffer);
        vertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord", 2, textureBuffer);
        uniformi("uSampler2d", programObject2D, "uSampler", [0]);
        uniformi("uIsDrawingText2d", programObject2D, "uIsDrawingText", true);
        uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
        uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
        uniformf("uColor2d", programObject2D, "uColor", fillStyle);
        curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
        curContext.drawElements(curContext.TRIANGLES, 6, curContext.UNSIGNED_SHORT, 0);
      };
      function text$4(str, x, y, z) {
        var lines, linesCount;
        if (str.indexOf("\n") < 0) {
          lines = [str];
          linesCount = 1;
        } else {
          lines = str.split(/\r?\n/g);
          linesCount = lines.length;
        }
        var yOffset = 0;
        if (verticalTextAlignment === PConstants3.TOP) {
          yOffset = curTextAscent + curTextDescent;
        } else if (verticalTextAlignment === PConstants3.CENTER) {
          yOffset = curTextAscent / 2 - (linesCount - 1) * curTextLeading / 2;
        } else if (verticalTextAlignment === PConstants3.BOTTOM) {
          yOffset = -(curTextDescent + (linesCount - 1) * curTextLeading);
        }
        for (var i2 = 0; i2 < linesCount; ++i2) {
          var line = lines[i2];
          drawing.text$line(line, x, y + yOffset, z, horizontalTextAlignment);
          yOffset += curTextLeading;
        }
      }
      function text$6(str, x, y, width, height, z) {
        if (str.length === 0 || width === 0 || height === 0) {
          return;
        }
        if (curTextSize > height) {
          return;
        }
        var spaceMark = -1;
        var start2 = 0;
        var lineWidth2 = 0;
        var drawCommands = [];
        for (var charPos = 0, len = str.length; charPos < len; charPos++) {
          var currentChar = str[charPos];
          var spaceChar = currentChar === " ";
          var letterWidth = curTextFont.measureTextWidth(currentChar);
          if (currentChar !== "\n" && lineWidth2 + letterWidth <= width) {
            if (spaceChar) {
              spaceMark = charPos;
            }
            lineWidth2 += letterWidth;
          } else {
            if (spaceMark + 1 === start2) {
              if (charPos > 0) {
                spaceMark = charPos;
              } else {
                return;
              }
            }
            if (currentChar === "\n") {
              drawCommands.push({ text: str.substring(start2, charPos), width: lineWidth2 });
              start2 = charPos + 1;
            } else {
              drawCommands.push({ text: str.substring(start2, spaceMark + 1), width: lineWidth2 });
              start2 = spaceMark + 1;
            }
            lineWidth2 = 0;
            charPos = start2 - 1;
          }
        }
        if (start2 < len) {
          drawCommands.push({ text: str.substring(start2), width: lineWidth2 });
        }
        var xOffset = 1, yOffset = curTextAscent;
        if (horizontalTextAlignment === PConstants3.CENTER) {
          xOffset = width / 2;
        } else if (horizontalTextAlignment === PConstants3.RIGHT) {
          xOffset = width;
        }
        var linesCount = drawCommands.length, visibleLines = Math.min(linesCount, Math.floor(height / curTextLeading));
        if (verticalTextAlignment === PConstants3.TOP) {
          yOffset = curTextAscent + curTextDescent;
        } else if (verticalTextAlignment === PConstants3.CENTER) {
          yOffset = height / 2 - curTextLeading * (visibleLines / 2 - 1);
        } else if (verticalTextAlignment === PConstants3.BOTTOM) {
          yOffset = curTextDescent + curTextLeading;
        }
        var command, drawCommand, leading;
        for (command = 0; command < linesCount; command++) {
          leading = command * curTextLeading;
          if (yOffset + leading > height - curTextDescent) {
            break;
          }
          drawCommand = drawCommands[command];
          drawing.text$line(drawCommand.text, x + xOffset, y + yOffset + leading, z, horizontalTextAlignment);
        }
      }
      p.text = function() {
        if (textMode === PConstants3.SHAPE) {
          return;
        }
        if (arguments.length === 3) {
          text$4(toP5String(arguments[0]), arguments[1], arguments[2], 0);
        } else if (arguments.length === 4) {
          text$4(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3]);
        } else if (arguments.length === 5) {
          text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], 0);
        } else if (arguments.length === 6) {
          text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
      };
      p.textMode = function(mode) {
        textMode = mode;
      };
      p.loadGlyphs = function(url) {
        var x, y, cx, cy, nx, ny, d, a, lastCom, lenC, horiz_adv_x, getXY = "[0-9\\-]+", path;
        var regex = function(needle, hay) {
          var i2 = 0, results = [], latest, regexp = new RegExp(needle, "g");
          latest = results[i2] = regexp.exec(hay);
          while (latest) {
            i2++;
            latest = results[i2] = regexp.exec(hay);
          }
          return results;
        };
        var buildPath = function(d2) {
          var c = regex("[A-Za-z][0-9\\- ]+|Z", d2);
          var beforePathDraw = function() {
            saveContext();
            return drawing.$ensureContext();
          };
          var afterPathDraw = function() {
            executeContextFill();
            executeContextStroke();
            restoreContext();
          };
          path = "return {draw:function(){var curContext=beforePathDraw();curContext.beginPath();";
          x = 0;
          y = 0;
          cx = 0;
          cy = 0;
          nx = 0;
          ny = 0;
          d2 = 0;
          a = 0;
          lastCom = "";
          lenC = c.length - 1;
          for (var j = 0; j < lenC; j++) {
            var com = c[j][0], xy = regex(getXY, com);
            switch (com[0]) {
              case "M":
                x = parseFloat(xy[0][0]);
                y = parseFloat(xy[1][0]);
                path += "curContext.moveTo(" + x + "," + -y + ");";
                break;
              case "L":
                x = parseFloat(xy[0][0]);
                y = parseFloat(xy[1][0]);
                path += "curContext.lineTo(" + x + "," + -y + ");";
                break;
              case "H":
                x = parseFloat(xy[0][0]);
                path += "curContext.lineTo(" + x + "," + -y + ");";
                break;
              case "V":
                y = parseFloat(xy[0][0]);
                path += "curContext.lineTo(" + x + "," + -y + ");";
                break;
              case "T":
                nx = parseFloat(xy[0][0]);
                ny = parseFloat(xy[1][0]);
                if (lastCom === "Q" || lastCom === "T") {
                  d2 = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(cy - y, 2));
                  a = Math.PI + Math.atan2(cx - x, cy - y);
                  cx = x + Math.sin(a) * d2;
                  cy = y + Math.cos(a) * d2;
                } else {
                  cx = x;
                  cy = y;
                }
                path += "curContext.quadraticCurveTo(" + cx + "," + -cy + "," + nx + "," + -ny + ");";
                x = nx;
                y = ny;
                break;
              case "Q":
                cx = parseFloat(xy[0][0]);
                cy = parseFloat(xy[1][0]);
                nx = parseFloat(xy[2][0]);
                ny = parseFloat(xy[3][0]);
                path += "curContext.quadraticCurveTo(" + cx + "," + -cy + "," + nx + "," + -ny + ");";
                x = nx;
                y = ny;
                break;
              case "Z":
                path += "curContext.closePath();";
                break;
            }
            lastCom = com[0];
          }
          path += "afterPathDraw();";
          path += "curContext.translate(" + horiz_adv_x + ",0);";
          path += "}}";
          return new Function("beforePathDraw", "afterPathDraw", path)(beforePathDraw, afterPathDraw);
        };
        var parseSVGFont = function(svg) {
          var font = svg.getElementsByTagName("font");
          p.glyphTable[url].horiz_adv_x = font[0].getAttribute("horiz-adv-x");
          var font_face = svg.getElementsByTagName("font-face")[0];
          p.glyphTable[url].units_per_em = parseFloat(font_face.getAttribute("units-per-em"));
          p.glyphTable[url].ascent = parseFloat(font_face.getAttribute("ascent"));
          p.glyphTable[url].descent = parseFloat(font_face.getAttribute("descent"));
          var glyph = svg.getElementsByTagName("glyph"), len = glyph.length;
          for (var i2 = 0; i2 < len; i2++) {
            var unicode = glyph[i2].getAttribute("unicode");
            var name = glyph[i2].getAttribute("glyph-name");
            horiz_adv_x = glyph[i2].getAttribute("horiz-adv-x");
            if (horiz_adv_x === null) {
              horiz_adv_x = p.glyphTable[url].horiz_adv_x;
            }
            d = glyph[i2].getAttribute("d");
            if (d !== undef) {
              path = buildPath(d);
              p.glyphTable[url][name] = {
                name,
                unicode,
                horiz_adv_x,
                draw: path.draw
              };
            }
          }
        };
        var loadXML = function() {
          var xmlDoc;
          try {
            xmlDoc = document2.implementation.createDocument("", "", null);
          } catch (e_fx_op) {
            Processing3.debug(e_fx_op.message);
            return;
          }
          try {
            xmlDoc.async = false;
            xmlDoc.load(url);
            parseSVGFont(xmlDoc.getElementsByTagName("svg")[0]);
          } catch (e_sf_ch) {
            Processing3.debug(e_sf_ch);
            try {
              var xmlhttp = new window2.XMLHttpRequest();
              xmlhttp.open("GET", url, false);
              xmlhttp.send(null);
              parseSVGFont(xmlhttp.responseXML.documentElement);
            } catch (e) {
              Processing3.debug(e_sf_ch);
            }
          }
        };
        p.glyphTable[url] = {};
        loadXML(url);
        return p.glyphTable[url];
      };
      p.param = function(name) {
        var attributeName = "data-processing-" + name;
        if (curElement.hasAttribute(attributeName)) {
          return curElement.getAttribute(attributeName);
        }
        for (var i2 = 0, len = curElement.childNodes.length; i2 < len; ++i2) {
          var item = curElement.childNodes.item(i2);
          if (item.nodeType !== 1 || item.tagName.toLowerCase() !== "param") {
            continue;
          }
          if (item.getAttribute("name") === name) {
            return item.getAttribute("value");
          }
        }
        if (curSketch.params.hasOwnProperty(name)) {
          return curSketch.params[name];
        }
        return null;
      };
      function wireDimensionalFunctions(mode) {
        if (mode === "3D") {
          drawing = new Drawing3D();
        } else if (mode === "2D") {
          drawing = new Drawing2D();
        } else {
          drawing = new DrawingPre();
        }
        for (var i2 in DrawingPre.prototype) {
          if (DrawingPre.prototype.hasOwnProperty(i2) && i2.indexOf("$") < 0) {
            p[i2] = drawing[i2];
          }
        }
        drawing.$init();
      }
      function createDrawingPreFunction(name) {
        return function() {
          wireDimensionalFunctions("2D");
          return drawing[name].apply(this, arguments);
        };
      }
      DrawingPre.prototype.translate = createDrawingPreFunction("translate");
      DrawingPre.prototype.transform = createDrawingPreFunction("transform");
      DrawingPre.prototype.scale = createDrawingPreFunction("scale");
      DrawingPre.prototype.pushMatrix = createDrawingPreFunction("pushMatrix");
      DrawingPre.prototype.popMatrix = createDrawingPreFunction("popMatrix");
      DrawingPre.prototype.resetMatrix = createDrawingPreFunction("resetMatrix");
      DrawingPre.prototype.applyMatrix = createDrawingPreFunction("applyMatrix");
      DrawingPre.prototype.rotate = createDrawingPreFunction("rotate");
      DrawingPre.prototype.rotateZ = createDrawingPreFunction("rotateZ");
      DrawingPre.prototype.shearX = createDrawingPreFunction("shearX");
      DrawingPre.prototype.shearY = createDrawingPreFunction("shearY");
      DrawingPre.prototype.redraw = createDrawingPreFunction("redraw");
      DrawingPre.prototype.toImageData = createDrawingPreFunction("toImageData");
      DrawingPre.prototype.ambientLight = createDrawingPreFunction("ambientLight");
      DrawingPre.prototype.directionalLight = createDrawingPreFunction("directionalLight");
      DrawingPre.prototype.lightFalloff = createDrawingPreFunction("lightFalloff");
      DrawingPre.prototype.lightSpecular = createDrawingPreFunction("lightSpecular");
      DrawingPre.prototype.pointLight = createDrawingPreFunction("pointLight");
      DrawingPre.prototype.noLights = createDrawingPreFunction("noLights");
      DrawingPre.prototype.spotLight = createDrawingPreFunction("spotLight");
      DrawingPre.prototype.beginCamera = createDrawingPreFunction("beginCamera");
      DrawingPre.prototype.endCamera = createDrawingPreFunction("endCamera");
      DrawingPre.prototype.frustum = createDrawingPreFunction("frustum");
      DrawingPre.prototype.box = createDrawingPreFunction("box");
      DrawingPre.prototype.sphere = createDrawingPreFunction("sphere");
      DrawingPre.prototype.ambient = createDrawingPreFunction("ambient");
      DrawingPre.prototype.emissive = createDrawingPreFunction("emissive");
      DrawingPre.prototype.shininess = createDrawingPreFunction("shininess");
      DrawingPre.prototype.specular = createDrawingPreFunction("specular");
      DrawingPre.prototype.fill = createDrawingPreFunction("fill");
      DrawingPre.prototype.stroke = createDrawingPreFunction("stroke");
      DrawingPre.prototype.strokeWeight = createDrawingPreFunction("strokeWeight");
      DrawingPre.prototype.smooth = createDrawingPreFunction("smooth");
      DrawingPre.prototype.noSmooth = createDrawingPreFunction("noSmooth");
      DrawingPre.prototype.point = createDrawingPreFunction("point");
      DrawingPre.prototype.vertex = createDrawingPreFunction("vertex");
      DrawingPre.prototype.endShape = createDrawingPreFunction("endShape");
      DrawingPre.prototype.bezierVertex = createDrawingPreFunction("bezierVertex");
      DrawingPre.prototype.curveVertex = createDrawingPreFunction("curveVertex");
      DrawingPre.prototype.curve = createDrawingPreFunction("curve");
      DrawingPre.prototype.line = createDrawingPreFunction("line");
      DrawingPre.prototype.bezier = createDrawingPreFunction("bezier");
      DrawingPre.prototype.rect = createDrawingPreFunction("rect");
      DrawingPre.prototype.ellipse = createDrawingPreFunction("ellipse");
      DrawingPre.prototype.background = createDrawingPreFunction("background");
      DrawingPre.prototype.image = createDrawingPreFunction("image");
      DrawingPre.prototype.textWidth = createDrawingPreFunction("textWidth");
      DrawingPre.prototype.text$line = createDrawingPreFunction("text$line");
      DrawingPre.prototype.$ensureContext = createDrawingPreFunction("$ensureContext");
      DrawingPre.prototype.$newPMatrix = createDrawingPreFunction("$newPMatrix");
      DrawingPre.prototype.size = function(aWidth, aHeight, aMode) {
        wireDimensionalFunctions(aMode === PConstants3.WEBGL ? "3D" : "2D");
        p.size(aWidth, aHeight, aMode);
      };
      DrawingPre.prototype.$init = noop;
      Drawing2D.prototype.$init = function() {
        p.size(p.width, p.height);
        curContext.lineCap = "round";
        p.noSmooth();
        p.disableContextMenu();
      };
      Drawing3D.prototype.$init = function() {
        p.use3DContext = true;
        p.disableContextMenu();
      };
      DrawingShared.prototype.$ensureContext = function() {
        return curContext;
      };
      if (!curElement.getAttribute("tabindex")) {
        curElement.setAttribute("tabindex", 0);
      }
      function getKeyCode(e) {
        var code = e.which || e.keyCode;
        switch (code) {
          case 13:
            return 10;
          case 91:
          // META L (Saf/Mac)
          case 93:
          // META R (Saf/Mac)
          case 224:
            return 157;
          case 57392:
            return 17;
          case 46:
            return 127;
          case 45:
            return 155;
        }
        return code;
      }
      function getKeyChar(e) {
        var c = e.which || e.keyCode;
        var anyShiftPressed = e.shiftKey || e.ctrlKey || e.altKey || e.metaKey;
        switch (c) {
          case 13:
            c = anyShiftPressed ? 13 : 10;
            break;
          case 8:
            c = anyShiftPressed ? 127 : 8;
            break;
        }
        return new Char2(c);
      }
      function suppressKeyEvent(e) {
        if (typeof e.preventDefault === "function") {
          e.preventDefault();
        } else if (typeof e.stopPropagation === "function") {
          e.stopPropagation();
        }
        return false;
      }
      function updateKeyPressed() {
        var ch;
        for (ch in pressedKeysMap) {
          if (pressedKeysMap.hasOwnProperty(ch)) {
            p.__keyPressed = true;
            return;
          }
        }
        p.__keyPressed = false;
      }
      function resetKeyPressed() {
        p.__keyPressed = false;
        pressedKeysMap = [];
        lastPressedKeyCode = null;
      }
      function simulateKeyTyped(code, c) {
        pressedKeysMap[code] = c;
        lastPressedKeyCode = null;
        p.key = c;
        p.keyCode = code;
        p.keyPressed();
        p.keyCode = 0;
        p.keyTyped();
        updateKeyPressed();
      }
      function handleKeydown(e) {
        var code = getKeyCode(e);
        if (code === PConstants3.DELETE) {
          simulateKeyTyped(code, new Char2(127));
          return;
        }
        if (codedKeys.indexOf(code) < 0) {
          lastPressedKeyCode = code;
          return;
        }
        var c = new Char2(PConstants3.CODED);
        p.key = c;
        p.keyCode = code;
        pressedKeysMap[code] = c;
        p.keyPressed();
        lastPressedKeyCode = null;
        updateKeyPressed();
        return suppressKeyEvent(e);
      }
      function handleKeypress(e) {
        if (lastPressedKeyCode === null) {
          return;
        }
        var code = lastPressedKeyCode, c = getKeyChar(e);
        simulateKeyTyped(code, c);
        return suppressKeyEvent(e);
      }
      function handleKeyup(e) {
        var code = getKeyCode(e), c = pressedKeysMap[code];
        if (c === undef) {
          return;
        }
        p.key = c;
        p.keyCode = code;
        p.keyReleased();
        delete pressedKeysMap[code];
        updateKeyPressed();
      }
      if (!pgraphicsMode) {
        if (aCode instanceof Processing3.Sketch) {
          curSketch = aCode;
        } else if (typeof aCode === "function") {
          curSketch = new Processing3.Sketch(aCode);
        } else if (!aCode) {
          curSketch = new Processing3.Sketch(function() {
          });
        } else {
          curSketch = Processing3.compile(aCode);
        }
        p.externals.sketch = curSketch;
        wireDimensionalFunctions();
        p.setupLive2D = function() {
          console.log("setting up l2d!");
          var l2d = defaultScope2.Live2D.getInstance();
          l2d.pjsToModern(p);
          return l2d;
        };
        curElement.onfocus = function() {
          p.focused = true;
        };
        curElement.onblur = function() {
          p.focused = false;
          if (!curSketch.options.globalKeyEvents) {
            resetKeyPressed();
          }
        };
        if (curSketch.options.pauseOnBlur) {
          attachEventHandler(window2, "focus", function() {
            if (doLoop) {
              p.loop();
            }
          });
          attachEventHandler(window2, "blur", function() {
            if (doLoop && loopStarted) {
              p.noLoop();
              doLoop = true;
            }
            resetKeyPressed();
          });
        }
        var keyTrigger = curSketch.options.globalKeyEvents ? window2 : curElement;
        attachEventHandler(keyTrigger, "keydown", handleKeydown);
        attachEventHandler(keyTrigger, "keypress", handleKeypress);
        attachEventHandler(keyTrigger, "keyup", handleKeyup);
        for (var i in Processing3.lib) {
          if (Processing3.lib.hasOwnProperty(i)) {
            if (Processing3.lib[i].hasOwnProperty("attach")) {
              Processing3.lib[i].attach(p);
            } else if (Processing3.lib[i] instanceof Function) {
              Processing3.lib[i].call(this);
            }
          }
        }
        var retryInterval = 100;
        var executeSketch = function(processing) {
          if (!(curSketch.imageCache.pending || PFont3.preloading.pending(retryInterval))) {
            if (window2.opera) {
              var link, element, operaCache = curSketch.imageCache.operaCache;
              for (link in operaCache) {
                if (operaCache.hasOwnProperty(link)) {
                  element = operaCache[link];
                  if (element !== null) {
                    document2.body.removeChild(element);
                  }
                  delete operaCache[link];
                }
              }
            }
            curSketch.attach(processing, defaultScope2);
            curSketch.onLoad(processing);
            if (processing.setup) {
              processing.setup();
              processing.resetMatrix();
              curSketch.onSetup();
            }
            resetContext();
            if (processing.draw) {
              if (!doLoop) {
                processing.redraw();
              } else {
                processing.loop();
              }
            }
          } else {
            window2.setTimeout(function() {
              executeSketch(processing);
            }, retryInterval);
          }
        };
        addInstance(this);
        executeSketch(p);
      } else {
        curSketch = new Processing3.Sketch();
        wireDimensionalFunctions();
        p.size = function(w, h, render) {
          if (render && render === PConstants3.WEBGL) {
            wireDimensionalFunctions("3D");
          } else {
            wireDimensionalFunctions("2D");
          }
          p.size(w, h, render);
        };
      }
    };
    Processing3.debug = function() {
      if ("console" in window2) {
        return function(msg) {
          window2.console.log("Processing.js: " + msg);
        };
      }
      return noop;
    }();
    Processing3.prototype = defaultScope2;
    Processing3.instances = processingInstances;
    Processing3.getInstanceById = function(name) {
      return processingInstances[processingInstanceIds[name]];
    };
    (function(Processing4) {
      var unsupportedP5 = "open() createOutput() createInput() BufferedReader selectFolder() dataPath() createWriter() selectOutput() beginRecord() saveStream() endRecord() selectInput() saveBytes() createReader() beginRaw() endRaw() PrintWriter delay()".split(" "), count = unsupportedP5.length, prettyName, p5Name;
      function createUnsupportedFunc(n) {
        return function() {
          throw "Processing.js does not support " + n + ".";
        };
      }
      while (count--) {
        prettyName = unsupportedP5[count];
        p5Name = prettyName.replace("()", "");
        Processing4[p5Name] = createUnsupportedFunc(prettyName);
      }
    })(defaultScope2);
    return Processing3;
  }
  var Processing_default = Processing2;

  // src/Helpers/PjsConsole.js
  function PjsConsole(document2) {
    var e = { BufferMax: 200 }, style = document2.createElement("style"), added = false;
    style.textContent = [
      ".pjsconsole.hidden {",
      "  display: none!important;",
      "}"
    ].join("\n");
    e.wrapper = document2.createElement("div");
    style.textContent += [
      "",
      ".pjsconsole {",
      "  opacity: .75;",
      "  display: block;",
      "  position: fixed;",
      "  bottom: 0px;",
      "  left: 0px;",
      "  right: 0px;",
      "  height: 50px;",
      "  background-color: #aaa;",
      "}"
    ].join("\n");
    e.wrapper.classList.add("pjsconsole");
    e.dragger = document2.createElement("div");
    style.textContent += [
      "",
      ".pjsconsole .dragger {",
      "  display: block;",
      "  border: 3px black raised;",
      "  cursor: n-resize;",
      "  position: absolute;",
      "  top: 0px;",
      "  left: 0px;",
      "  right: 0px;",
      "  height: 5px;",
      "  background-color: #333;",
      "}"
    ].join("\n");
    e.dragger.classList.add("dragger");
    e.closer = document2.createElement("div");
    style.textContent += [
      "",
      ".pjsconsole .closer {",
      "  opacity: .5;",
      "  display: block;",
      "  border: 3px black raised;",
      "  position: absolute;",
      "  top: 10px;",
      "  right: 30px;",
      "  height: 20px;",
      "  width: 20px;",
      "  background-color: #ddd;",
      "  color: #000;",
      "  line-height: 20px;",
      "  text-align: center;",
      "  cursor: pointer",
      "}"
    ].join("\n");
    e.closer.classList.add("closer");
    e.closer.innerHTML = "&#10006;";
    e.javaconsole = document2.createElement("div");
    style.textContent += [
      "",
      ".pjsconsole .console {",
      "  overflow-x: auto;",
      "  display: block;",
      "  position: absolute;",
      "  left: 10px;",
      "  right: 0px;",
      "  bottom: 5px;",
      "  top: 10px;",
      "  overflow-y: scroll;",
      "  height: 40px;",
      "}"
    ].join("\n");
    e.javaconsole.setAttribute("class", "console");
    e.wrapper.appendChild(e.dragger);
    e.wrapper.appendChild(e.javaconsole);
    e.wrapper.appendChild(e.closer);
    e.dragger.onmousedown = function(t2) {
      e.divheight = e.wrapper.style.height;
      if (document2.selection) document2.selection.empty();
      else window.getSelection().removeAllRanges();
      var n = t2.screenY;
      window.onmousemove = function(t3) {
        e.wrapper.style.height = parseFloat(e.divheight) + (n - t3.screenY) + "px";
        e.javaconsole.style.height = parseFloat(e.divheight) + (n - t3.screenY) - 10 + "px";
      };
      window.onmouseup = function(t3) {
        if (document2.selection) document2.selection.empty();
        else window.getSelection().removeAllRanges();
        e.wrapper.style.height = parseFloat(e.divheight) + (n - t3.screenY) + "px";
        e.javaconsole.style.height = parseFloat(e.divheight) + (n - t3.screenY) - 10 + "px";
        window.onmousemove = null;
        window.onmouseup = null;
      };
    };
    e.BufferArray = [];
    e.print = e.log = function() {
      if (!added) {
        document2.body.appendChild(style);
        document2.body.appendChild(e.wrapper);
        added = true;
      }
      var args = Array.prototype.slice.call(arguments);
      t = args.map(function(t2, idx) {
        return t2 + (idx + 1 === args.length ? "" : " ");
      }).join("");
      if (e.BufferArray[e.BufferArray.length - 1]) e.BufferArray[e.BufferArray.length - 1] += t + "";
      else e.BufferArray.push(t);
      e.javaconsole.innerHTML = e.BufferArray.join("");
      e.showconsole();
    };
    e.println = function() {
      var args = Array.prototype.slice.call(arguments);
      args.push("<br>");
      e.print.apply(e, args);
      if (e.BufferArray.length > e.BufferMax) {
        e.BufferArray.splice(0, 1);
      } else {
        e.javaconsole.scrollTop = e.javaconsole.scrollHeight;
      }
    };
    e.showconsole = function() {
      e.wrapper.classList.remove("hidden");
    };
    e.hideconsole = function() {
      e.wrapper.classList.add("hidden");
    };
    e.closer.onclick = function() {
      e.hideconsole();
    };
    e.hideconsole();
    return e;
  }

  // src/Parser/Parser.js
  function setupParser(Processing3, options) {
    var defaultScope2 = options.defaultScope, PConstants3 = defaultScope2.PConstants, aFunctions = options.aFunctions, Browser2 = options.Browser, document2 = Browser2.document, undef;
    function getGlobalMembers() {
      var names = [
        /* this code is generated by jsglobals.js */
        "abs",
        "acos",
        "alpha",
        "ambient",
        "ambientLight",
        "append",
        "applyMatrix",
        "arc",
        "arrayCopy",
        "asin",
        "atan",
        "atan2",
        "background",
        "beginCamera",
        "beginDraw",
        "beginShape",
        "bezier",
        "bezierDetail",
        "bezierPoint",
        "bezierTangent",
        "bezierVertex",
        "binary",
        "blend",
        "blendColor",
        "blit_resize",
        "blue",
        "box",
        "breakShape",
        "brightness",
        "camera",
        "ceil",
        "Character",
        "color",
        "colorMode",
        "concat",
        "constrain",
        "copy",
        "cos",
        "createFont",
        "createGraphics",
        "createImage",
        "cursor",
        "curve",
        "curveDetail",
        "curvePoint",
        "curveTangent",
        "curveTightness",
        "curveVertex",
        "day",
        "degrees",
        "directionalLight",
        "disableContextMenu",
        "dist",
        "draw",
        "ellipse",
        "ellipseMode",
        "emissive",
        "enableContextMenu",
        "endCamera",
        "endDraw",
        "endShape",
        "exit",
        "exp",
        "expand",
        "externals",
        "fill",
        "filter",
        "floor",
        "focused",
        "frameCount",
        "frameRate",
        "frustum",
        "get",
        "glyphLook",
        "glyphTable",
        "green",
        "height",
        "hex",
        "hint",
        "hour",
        "hue",
        "image",
        "imageMode",
        "intersect",
        "join",
        "key",
        "keyCode",
        "keyPressed",
        "keyReleased",
        "keyTyped",
        "lerp",
        "lerpColor",
        "lightFalloff",
        "lights",
        "lightSpecular",
        "line",
        "link",
        "loadBytes",
        "loadFont",
        "loadGlyphs",
        "loadImage",
        "loadPixels",
        "loadShape",
        "loadXML",
        "loadStrings",
        "log",
        "loop",
        "mag",
        "map",
        "match",
        "matchAll",
        "max",
        "millis",
        "min",
        "minute",
        "mix",
        "modelX",
        "modelY",
        "modelZ",
        "modes",
        "month",
        "mouseButton",
        "mouseClicked",
        "mouseDragged",
        "mouseMoved",
        "mouseOut",
        "mouseOver",
        "mousePressed",
        "mouseReleased",
        "mouseScroll",
        "mouseScrolled",
        "mouseX",
        "mouseY",
        "name",
        "nf",
        "nfc",
        "nfp",
        "nfs",
        "noCursor",
        "noFill",
        "noise",
        "noiseDetail",
        "noiseSeed",
        "noLights",
        "noLoop",
        "norm",
        "normal",
        "noSmooth",
        "noStroke",
        "noTint",
        "ortho",
        "param",
        "parseBoolean",
        "parseByte",
        "parseChar",
        "parseFloat",
        "parseInt",
        "parseXML",
        "peg",
        "perspective",
        "PImage",
        "pixels",
        "PMatrix2D",
        "PMatrix3D",
        "PMatrixStack",
        "pmouseX",
        "pmouseY",
        "point",
        "pointLight",
        "popMatrix",
        "popStyle",
        "pow",
        "print",
        "printCamera",
        "println",
        "printMatrix",
        "printProjection",
        "PShape",
        "PShapeSVG",
        "pushMatrix",
        "pushStyle",
        "quad",
        "radians",
        "random",
        "randomGaussian",
        "randomSeed",
        "rect",
        "rectMode",
        "red",
        "redraw",
        "requestImage",
        "resetMatrix",
        "reverse",
        "rotate",
        "rotateX",
        "rotateY",
        "rotateZ",
        "round",
        "saturation",
        "save",
        "saveFrame",
        "saveStrings",
        "scale",
        "screenX",
        "screenY",
        "screenZ",
        "second",
        "set",
        "setup",
        "shape",
        "shapeMode",
        "shared",
        "shearX",
        "shearY",
        "shininess",
        "shorten",
        "sin",
        "size",
        "smooth",
        "sort",
        "specular",
        "sphere",
        "sphereDetail",
        "splice",
        "split",
        "splitTokens",
        "spotLight",
        "sq",
        "sqrt",
        "status",
        "str",
        "stroke",
        "strokeCap",
        "strokeJoin",
        "strokeWeight",
        "subset",
        "tan",
        "text",
        "textAlign",
        "textAscent",
        "textDescent",
        "textFont",
        "textLeading",
        "textMode",
        "textSize",
        "texture",
        "textureMode",
        "textWidth",
        "tint",
        "toImageData",
        "touchCancel",
        "touchEnd",
        "touchMove",
        "touchStart",
        "translate",
        "transform",
        "triangle",
        "trim",
        "unbinary",
        "unhex",
        "updatePixels",
        "use3DContext",
        "vertex",
        "width",
        "XMLElement",
        "XML",
        "year",
        "__contains",
        "__equals",
        "__equalsIgnoreCase",
        "__frameRate",
        "__hashCode",
        "__int_cast",
        "__instanceof",
        "__keyPressed",
        "__mousePressed",
        "__printStackTrace",
        "__replace",
        "__replaceAll",
        "__replaceFirst",
        "__toCharArray",
        "__split",
        "__codePointAt",
        "__startsWith",
        "__endsWith",
        "__matches",
        "setupLive2D"
      ];
      if (aFunctions) {
        Object.keys(aFunctions).forEach(function(name) {
          names.push(name);
        });
      }
      var members = {};
      var i, l2;
      for (i = 0, l2 = names.length; i < l2; ++i) {
        members[names[i]] = null;
      }
      for (var lib in Processing3.lib) {
        if (Processing3.lib.hasOwnProperty(lib)) {
          if (Processing3.lib[lib].exports) {
            var exportedNames = Processing3.lib[lib].exports;
            for (i = 0, l2 = exportedNames.length; i < l2; ++i) {
              members[exportedNames[i]] = null;
            }
          }
        }
      }
      members["test"] = null;
      return members;
    }
    function parseProcessing(code) {
      var globalMembers = getGlobalMembers();
      function splitToAtoms(code2) {
        var atoms2 = [];
        var items = code2.split(/([\{\[\(\)\]\}])/);
        var result = items[0];
        var stack = [];
        for (var i = 1; i < items.length; i += 2) {
          var item = items[i];
          if (item === "[" || item === "{" || item === "(") {
            stack.push(result);
            result = item;
          } else if (item === "]" || item === "}" || item === ")") {
            var kind = item === "}" ? "A" : item === ")" ? "B" : "C";
            var index = atoms2.length;
            atoms2.push(result + item);
            result = stack.pop() + '"' + kind + (index + 1) + '"';
          }
          result += items[i + 1];
        }
        atoms2.unshift(result);
        return atoms2;
      }
      function injectStrings(code2, strings2) {
        return code2.replace(/'(\d+)'/g, function(all, index) {
          var val = strings2[index];
          if (val.charAt(0) === "/") {
            return val;
          }
          return /^'((?:[^'\\\n])|(?:\\.[0-9A-Fa-f]*))'$/.test(val) ? "(new $p.Character(" + val + "))" : val;
        });
      }
      function trimSpaces(string) {
        var m1 = /^\s*/.exec(string), result;
        if (m1[0].length === string.length) {
          result = { left: m1[0], middle: "", right: "" };
        } else {
          var m2 = /\s*$/.exec(string);
          result = { left: m1[0], middle: string.substring(m1[0].length, m2.index), right: m2[0] };
        }
        result.untrim = function(t2) {
          return this.left + t2 + this.right;
        };
        return result;
      }
      function trim(string) {
        return string.replace(/^\s+/, "").replace(/\s+$/, "");
      }
      function appendToLookupTable(table, array) {
        for (var i = 0, l2 = array.length; i < l2; ++i) {
          table[array[i]] = null;
        }
        return table;
      }
      function isLookupTableEmpty(table) {
        for (var i in table) {
          if (table.hasOwnProperty(i)) {
            return false;
          }
        }
        return true;
      }
      function getAtomIndex(templ) {
        return templ.substring(2, templ.length - 1);
      }
      var codeWoExtraCr = code.replace(/\r\n?|\n\r/g, "\n");
      var strings = [];
      var codeWoStrings = codeWoExtraCr.replace(
        /("(?:[^"\\\n]|\\.)*")|('(?:[^'\\\n]|\\.)*')|(([\[\(=|&!\^:?]\s*)(\/(?![*\/])(?:[^\/\\\n]|\\.)*\/[gim]*)\b)|(\/\/[^\n]*\n)|(\/\*(?:(?!\*\/)(?:.|\n))*\*\/)/g,
        function(all, quoted, aposed, regexCtx, prefix, regex, singleComment, comment) {
          var index;
          if (quoted || aposed) {
            index = strings.length;
            strings.push(all);
            return "'" + index + "'";
          }
          if (regexCtx) {
            index = strings.length;
            strings.push(regex);
            return prefix + "'" + index + "'";
          }
          return comment !== "" ? " " : "\n";
        }
      );
      codeWoStrings = codeWoStrings.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {
        return "__x005F_x" + hexCode;
      });
      codeWoStrings = codeWoStrings.replace(/\$/g, "__x0024");
      codeWoStrings = codeWoStrings.replace(/return\s*[\n\r]+/g, "return ");
      var genericsWereRemoved;
      var codeWoGenerics = codeWoStrings;
      var replaceFunc = function(all, before, types, after) {
        if (!!before || !!after) {
          return all;
        }
        genericsWereRemoved = true;
        return "";
      };
      do {
        genericsWereRemoved = false;
        codeWoGenerics = codeWoGenerics.replace(/([<]?)<\s*((?:\?|[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)(?:\[\])*(?:\s+(?:extends|super)\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)?(?:\s*,\s*(?:\?|[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)(?:\[\])*(?:\s+(?:extends|super)\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)?)*)\s*>([=]?)/g, replaceFunc);
      } while (genericsWereRemoved);
      var atoms = splitToAtoms(codeWoGenerics);
      var replaceContext;
      var declaredClasses = {}, currentClassId, classIdSeed = 0;
      function addAtom(text, type) {
        var lastIndex = atoms.length;
        atoms.push(text);
        return '"' + type + lastIndex + '"';
      }
      function generateClassId() {
        return "class" + ++classIdSeed;
      }
      function appendClass(class_, classId, scopeId) {
        class_.classId = classId;
        class_.scopeId = scopeId;
        declaredClasses[classId] = class_;
      }
      var transformClassBody, transformInterfaceBody, transformStatementsBlock, transformStatements, transformMain, transformExpression;
      var classesRegex = /\b((?:(?:public|private|final|protected|static|abstract)\s+)*)(class|interface)\s+([A-Za-z_$][\w$]*\b)(\s+extends\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*,\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*\b)*)?(\s+implements\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*,\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*\b)*)?\s*("A\d+")/g;
      var methodsRegex = /\b((?:(?:public|private|final|protected|static|abstract|synchronized)\s+)*)((?!(?:else|new|return|throw|function|public|private|protected)\b)[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*"C\d+")*)\s*([A-Za-z_$][\w$]*\b)\s*("B\d+")(\s*throws\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*,\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)*)?\s*("A\d+"|;)/g;
      var fieldTest = /^((?:(?:public|private|final|protected|static)\s+)*)((?!(?:else|new|return|throw)\b)[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*"C\d+")*)\s*([A-Za-z_$][\w$]*\b)\s*(?:"C\d+"\s*)*([=,]|$)/;
      var cstrsRegex = /\b((?:(?:public|private|final|protected|static|abstract)\s+)*)((?!(?:new|return|throw)\b)[A-Za-z_$][\w$]*\b)\s*("B\d+")(\s*throws\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*,\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)*)?\s*("A\d+")/g;
      var attrAndTypeRegex = /^((?:(?:public|private|final|protected|static)\s+)*)((?!(?:new|return|throw)\b)[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*"C\d+")*)\s*/;
      var functionsRegex = /\bfunction(?:\s+([A-Za-z_$][\w$]*))?\s*("B\d+")\s*("A\d+")/g;
      function extractClassesAndMethods(code2) {
        var s = code2;
        s = s.replace(classesRegex, function(all) {
          return addAtom(all, "E");
        });
        s = s.replace(methodsRegex, function(all) {
          return addAtom(all, "D");
        });
        s = s.replace(functionsRegex, function(all) {
          return addAtom(all, "H");
        });
        return s;
      }
      function extractConstructors(code2, className) {
        var result = code2.replace(cstrsRegex, function(all, attr, name, params, throws_, body) {
          if (name !== className) {
            return all;
          }
          return addAtom(all, "G");
        });
        return result;
      }
      function AstParam(name) {
        this.name = name;
      }
      AstParam.prototype.toString = function() {
        return this.name;
      };
      function AstParams(params, methodArgsParam) {
        this.params = params;
        this.methodArgsParam = methodArgsParam;
      }
      AstParams.prototype.getNames = function() {
        var names = [];
        for (var i = 0, l2 = this.params.length; i < l2; ++i) {
          names.push(this.params[i].name);
        }
        return names;
      };
      AstParams.prototype.prependMethodArgs = function(body) {
        if (!this.methodArgsParam) {
          return body;
        }
        return "{\nvar " + this.methodArgsParam.name + " = Array.prototype.slice.call(arguments, " + this.params.length + ");\n" + body.substring(1);
      };
      AstParams.prototype.toString = function() {
        if (this.params.length === 0) {
          return "()";
        }
        var result = "(";
        for (var i = 0, l2 = this.params.length; i < l2; ++i) {
          result += this.params[i] + ", ";
        }
        return result.substring(0, result.length - 2) + ")";
      };
      function transformParams(params) {
        var paramsWoPars = trim(params.substring(1, params.length - 1));
        var result = [], methodArgsParam = null;
        if (paramsWoPars !== "") {
          var paramList = paramsWoPars.split(",");
          for (var i = 0; i < paramList.length; ++i) {
            var param = /\b([A-Za-z_$][\w$]*\b)(\s*"[ABC][\d]*")*\s*$/.exec(paramList[i]);
            if (i === paramList.length - 1 && paramList[i].indexOf("...") >= 0) {
              methodArgsParam = new AstParam(param[1]);
              break;
            }
            result.push(new AstParam(param[1]));
          }
        }
        return new AstParams(result, methodArgsParam);
      }
      function preExpressionTransform(expr) {
        var s = expr;
        s = s.replace(/\bnew\s+([A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)(?:\s*"C\d+")+\s*("A\d+")/g, function(all, type, init) {
          return init;
        });
        s = s.replace(/\bnew\s+([A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)(?:\s*"B\d+")\s*("A\d+")/g, function(all, type, init) {
          return addAtom(all, "F");
        });
        s = s.replace(functionsRegex, function(all) {
          return addAtom(all, "H");
        });
        s = s.replace(/\bnew\s+([A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)\s*("C\d+"(?:\s*"C\d+")*)/g, function(all, type, index) {
          var args = index.replace(/"C(\d+)"/g, function(all2, j) {
            return atoms[j];
          }).replace(/\[\s*\]/g, "[null]").replace(/\s*\]\s*\[\s*/g, ", ");
          var arrayInitializer = "{" + args.substring(1, args.length - 1) + "}";
          var createArrayArgs = "('" + type + "', " + addAtom(arrayInitializer, "A") + ")";
          return "$p.createJavaArray" + addAtom(createArrayArgs, "B");
        });
        s = s.replace(/(\.\s*length)\s*"B\d+"/g, "$1");
        s = s.replace(/#([0-9A-Fa-f]{6})\b/g, function(all, digits) {
          return "0xFF" + digits;
        });
        s = s.replace(/"B(\d+)"(\s*(?:[\w$']|"B))/g, function(all, index, next) {
          var atom = atoms[index];
          if (!/^\(\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*\s*(?:"C\d+"\s*)*\)$/.test(atom)) {
            return all;
          }
          if (/^\(\s*int\s*\)$/.test(atom)) {
            return "(int)" + next;
          }
          var indexParts = atom.split(/"C(\d+)"/g);
          if (indexParts.length > 1) {
            if (!/^\[\s*\]$/.test(atoms[indexParts[1]])) {
              return all;
            }
          }
          return "" + next;
        });
        s = s.replace(/\(int\)([^,\]\)\}\?\:\*\+\-\/\^\|\%\&\~<\>\=]+)/g, function(all, arg) {
          var trimmed = trimSpaces(arg);
          return trimmed.untrim("__int_cast(" + trimmed.middle + ")");
        });
        s = s.replace(/\bsuper(\s*"B\d+")/g, "$$superCstr$1").replace(/\bsuper(\s*\.)/g, "$$super$1");
        s = s.replace(/\b0+((\d*)(?:\.[\d*])?(?:[eE][\-\+]?\d+)?[fF]?)\b/, function(all, numberWo0, intPart) {
          if (numberWo0 === intPart) {
            return all;
          }
          return intPart === "" ? "0" + numberWo0 : numberWo0;
        });
        s = s.replace(/\b(\.?\d+\.?)[fF]\b/g, "$1");
        s = s.replace(/([^\s])%([^=\s])/g, "$1 % $2");
        s = s.replace(/\b(frameRate|keyPressed|mousePressed)\b(?!\s*"B)/g, "__$1");
        s = s.replace(/\b(boolean|byte|char|float|int)\s*"B/g, function(all, name) {
          return "parse" + name.substring(0, 1).toUpperCase() + name.substring(1) + '"B';
        });
        s = s.replace(
          /\bpixels\b\s*(("C(\d+)")|\.length)?(\s*=(?!=)([^,\]\)\}]+))?/g,
          function(all, indexOrLength, index, atomIndex, equalsPart, rightSide) {
            if (index) {
              var atom = atoms[atomIndex];
              if (equalsPart) {
                return "pixels.setPixel" + addAtom("(" + atom.substring(1, atom.length - 1) + "," + rightSide + ")", "B");
              }
              return "pixels.getPixel" + addAtom("(" + atom.substring(1, atom.length - 1) + ")", "B");
            }
            if (indexOrLength) {
              return "pixels.getLength" + addAtom("()", "B");
            }
            if (equalsPart) {
              return "pixels.set" + addAtom("(" + rightSide + ")", "B");
            }
            return "pixels.toArray" + addAtom("()", "B");
          }
        );
        var repeatJavaReplacement;
        function replacePrototypeMethods(all, subject, method, atomIndex) {
          var atom = atoms[atomIndex];
          repeatJavaReplacement = true;
          var trimmed = trimSpaces(atom.substring(1, atom.length - 1));
          return "__" + method + (trimmed.middle === "" ? addAtom("(" + subject.replace(/\.\s*$/, "") + ")", "B") : addAtom("(" + subject.replace(/\.\s*$/, "") + "," + trimmed.middle + ")", "B"));
        }
        do {
          repeatJavaReplacement = false;
          s = s.replace(
            /((?:'\d+'|\b[A-Za-z_$][\w$]*\s*(?:"[BC]\d+")*)\s*\.\s*(?:[A-Za-z_$][\w$]*\s*(?:"[BC]\d+"\s*)*\.\s*)*)(replace|replaceAll|replaceFirst|contains|equals|equalsIgnoreCase|hashCode|toCharArray|printStackTrace|split|startsWith|endsWith|codePointAt|matches)\s*"B(\d+)"/g,
            replacePrototypeMethods
          );
        } while (repeatJavaReplacement);
        function replaceInstanceof(all, subject, type) {
          repeatJavaReplacement = true;
          return "__instanceof" + addAtom("(" + subject + ", " + type + ")", "B");
        }
        do {
          repeatJavaReplacement = false;
          s = s.replace(
            /((?:'\d+'|\b[A-Za-z_$][\w$]*\s*(?:"[BC]\d+")*)\s*(?:\.\s*[A-Za-z_$][\w$]*\s*(?:"[BC]\d+"\s*)*)*)instanceof\s+([A-Za-z_$][\w$]*\s*(?:\.\s*[A-Za-z_$][\w$]*)*)/g,
            replaceInstanceof
          );
        } while (repeatJavaReplacement);
        s = s.replace(/\bthis(\s*"B\d+")/g, "$$constr$1");
        return s;
      }
      function AstInlineClass(baseInterfaceName, body) {
        this.baseInterfaceName = baseInterfaceName;
        this.body = body;
        body.owner = this;
      }
      AstInlineClass.prototype.toString = function() {
        return "new (" + this.body + ")";
      };
      function transformInlineClass(class_) {
        var m = new RegExp(/\bnew\s*([A-Za-z_$][\w$]*\s*(?:\.\s*[A-Za-z_$][\w$]*)*)\s*"B\d+"\s*"A(\d+)"/).exec(class_);
        var oldClassId = currentClassId, newClassId = generateClassId();
        currentClassId = newClassId;
        var uniqueClassName = m[1] + "$" + newClassId;
        var inlineClass = new AstInlineClass(
          uniqueClassName,
          transformClassBody(atoms[m[2]], uniqueClassName, "", "implements " + m[1])
        );
        appendClass(inlineClass, newClassId, oldClassId);
        currentClassId = oldClassId;
        return inlineClass;
      }
      function AstFunction(name, params, body) {
        this.name = name;
        this.params = params;
        this.body = body;
      }
      AstFunction.prototype.toString = function() {
        var oldContext = replaceContext;
        var names = appendToLookupTable({ "this": null }, this.params.getNames());
        replaceContext = function(subject) {
          return names.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
        };
        var result = "function";
        if (this.name) {
          result += " " + this.name;
        }
        var body = this.params.prependMethodArgs(this.body.toString());
        result += this.params + " " + body;
        replaceContext = oldContext;
        return result;
      };
      function transformFunction(class_) {
        var m = new RegExp(/\b([A-Za-z_$][\w$]*)\s*"B(\d+)"\s*"A(\d+)"/).exec(class_);
        return new AstFunction(
          m[1] !== "function" ? m[1] : null,
          transformParams(atoms[m[2]]),
          transformStatementsBlock(atoms[m[3]])
        );
      }
      function AstInlineObject(members) {
        this.members = members;
      }
      AstInlineObject.prototype.toString = function() {
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          return subject.name === "this" ? "this" : oldContext(subject);
        };
        var result = "";
        for (var i = 0, l2 = this.members.length; i < l2; ++i) {
          if (this.members[i].label) {
            result += this.members[i].label + ": ";
          }
          result += this.members[i].value.toString() + ", ";
        }
        replaceContext = oldContext;
        return result.substring(0, result.length - 2);
      };
      function transformInlineObject(obj) {
        var members = obj.split(",");
        for (var i = 0; i < members.length; ++i) {
          var label = members[i].indexOf(":");
          if (label < 0) {
            members[i] = { value: transformExpression(members[i]) };
          } else {
            members[i] = {
              label: trim(members[i].substring(0, label)),
              value: transformExpression(trim(members[i].substring(label + 1)))
            };
          }
        }
        return new AstInlineObject(members);
      }
      function expandExpression(expr) {
        if (expr.charAt(0) === "(" || expr.charAt(0) === "[") {
          return expr.charAt(0) + expandExpression(expr.substring(1, expr.length - 1)) + expr.charAt(expr.length - 1);
        }
        if (expr.charAt(0) === "{") {
          if (/^\{\s*(?:[A-Za-z_$][\w$]*|'\d+')\s*:/.test(expr)) {
            return "{" + addAtom(expr.substring(1, expr.length - 1), "I") + "}";
          }
          return "[" + expandExpression(expr.substring(1, expr.length - 1)) + "]";
        }
        var trimmed = trimSpaces(expr);
        var result = preExpressionTransform(trimmed.middle);
        result = result.replace(/"[ABC](\d+)"/g, function(all, index) {
          return expandExpression(atoms[index]);
        });
        return trimmed.untrim(result);
      }
      function replaceContextInVars(expr) {
        return expr.replace(
          /(\.\s*)?((?:\b[A-Za-z_]|\$)[\w$]*)(\s*\.\s*([A-Za-z_$][\w$]*)(\s*\()?)?/g,
          function(all, memberAccessSign, identifier, suffix, subMember, callSign) {
            if (memberAccessSign) {
              return all;
            }
            var subject = { name: identifier, member: subMember, callSign: !!callSign };
            return replaceContext(subject) + (suffix === undef ? "" : suffix);
          }
        );
      }
      function AstExpression(expr, transforms) {
        this.expr = expr;
        this.transforms = transforms;
      }
      AstExpression.prototype.toString = function() {
        var transforms = this.transforms;
        var expr = replaceContextInVars(this.expr);
        return expr.replace(/"!(\d+)"/g, function(all, index) {
          return transforms[index].toString();
        });
      };
      transformExpression = function(expr) {
        var transforms = [];
        var s = expandExpression(expr);
        s = s.replace(/"H(\d+)"/g, function(all, index) {
          transforms.push(transformFunction(atoms[index]));
          return '"!' + (transforms.length - 1) + '"';
        });
        s = s.replace(/"F(\d+)"/g, function(all, index) {
          transforms.push(transformInlineClass(atoms[index]));
          return '"!' + (transforms.length - 1) + '"';
        });
        s = s.replace(/"I(\d+)"/g, function(all, index) {
          transforms.push(transformInlineObject(atoms[index]));
          return '"!' + (transforms.length - 1) + '"';
        });
        return new AstExpression(s, transforms);
      };
      function AstVarDefinition(name, value, isDefault) {
        this.name = name;
        this.value = value;
        this.isDefault = isDefault;
      }
      AstVarDefinition.prototype.toString = function() {
        return this.name + " = " + this.value;
      };
      function transformVarDefinition(def, defaultTypeValue) {
        var eqIndex = def.indexOf("=");
        var name, value, isDefault;
        if (eqIndex < 0) {
          name = def;
          value = defaultTypeValue;
          isDefault = true;
        } else {
          name = def.substring(0, eqIndex);
          value = transformExpression(def.substring(eqIndex + 1));
          isDefault = false;
        }
        return new AstVarDefinition(
          trim(name.replace(/(\s*"C\d+")+/g, "")),
          value,
          isDefault
        );
      }
      function getDefaultValueForType(type) {
        if (type === "int" || type === "float") {
          return "0";
        }
        if (type === "boolean") {
          return "false";
        }
        if (type === "color") {
          return "0x00000000";
        }
        return "null";
      }
      function AstVar(definitions, varType) {
        this.definitions = definitions;
        this.varType = varType;
      }
      AstVar.prototype.getNames = function() {
        var names = [];
        for (var i = 0, l2 = this.definitions.length; i < l2; ++i) {
          names.push(this.definitions[i].name);
        }
        return names;
      };
      AstVar.prototype.toString = function() {
        return "var " + this.definitions.join(",");
      };
      function AstStatement(expression) {
        this.expression = expression;
      }
      AstStatement.prototype.toString = function() {
        return this.expression.toString();
      };
      function transformStatement(statement) {
        if (fieldTest.test(statement)) {
          var attrAndType = attrAndTypeRegex.exec(statement);
          var definitions = statement.substring(attrAndType[0].length).split(",");
          var defaultTypeValue = getDefaultValueForType(attrAndType[2]);
          for (var i = 0; i < definitions.length; ++i) {
            definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);
          }
          return new AstVar(definitions, attrAndType[2]);
        }
        return new AstStatement(transformExpression(statement));
      }
      function AstForExpression(initStatement, condition, step) {
        this.initStatement = initStatement;
        this.condition = condition;
        this.step = step;
      }
      AstForExpression.prototype.toString = function() {
        return "(" + this.initStatement + "; " + this.condition + "; " + this.step + ")";
      };
      function AstForInExpression(initStatement, container) {
        this.initStatement = initStatement;
        this.container = container;
      }
      AstForInExpression.prototype.toString = function() {
        var init = this.initStatement.toString();
        if (init.indexOf("=") >= 0) {
          init = init.substring(0, init.indexOf("="));
        }
        return "(" + init + " in " + this.container + ")";
      };
      function AstForEachExpression(initStatement, container) {
        this.initStatement = initStatement;
        this.container = container;
      }
      AstForEachExpression.iteratorId = 0;
      AstForEachExpression.prototype.toString = function() {
        var init = this.initStatement.toString();
        var iterator3 = "$it" + AstForEachExpression.iteratorId++;
        var variableName = init.replace(/^\s*var\s*/, "").split("=")[0];
        var initIteratorAndVariable = "var " + iterator3 + " = new $p.ObjectIterator(" + this.container + "), " + variableName + " = void(0)";
        var nextIterationCondition = iterator3 + ".hasNext() && ((" + variableName + " = " + iterator3 + ".next()) || true)";
        return "(" + initIteratorAndVariable + "; " + nextIterationCondition + ";)";
      };
      function transformForExpression(expr) {
        var content;
        if (/\bin\b/.test(expr)) {
          content = expr.substring(1, expr.length - 1).split(/\bin\b/g);
          return new AstForInExpression(
            transformStatement(trim(content[0])),
            transformExpression(content[1])
          );
        }
        if (expr.indexOf(":") >= 0 && expr.indexOf(";") < 0) {
          content = expr.substring(1, expr.length - 1).split(":");
          return new AstForEachExpression(
            transformStatement(trim(content[0])),
            transformExpression(content[1])
          );
        }
        content = expr.substring(1, expr.length - 1).split(";");
        return new AstForExpression(
          transformStatement(trim(content[0])),
          transformExpression(content[1]),
          transformExpression(content[2])
        );
      }
      function sortByWeight(array) {
        array.sort(function(a, b) {
          return b.weight - a.weight;
        });
      }
      function AstInnerInterface(name, body, isStatic) {
        this.name = name;
        this.body = body;
        this.isStatic = isStatic;
        body.owner = this;
      }
      AstInnerInterface.prototype.toString = function() {
        return "" + this.body;
      };
      function AstInnerClass(name, body, isStatic) {
        this.name = name;
        this.body = body;
        this.isStatic = isStatic;
        body.owner = this;
      }
      AstInnerClass.prototype.toString = function() {
        return "" + this.body;
      };
      function transformInnerClass(class_) {
        var m = classesRegex.exec(class_);
        classesRegex.lastIndex = 0;
        var isStatic = m[1].indexOf("static") >= 0;
        var body = atoms[getAtomIndex(m[6])], innerClass;
        var oldClassId = currentClassId, newClassId = generateClassId();
        currentClassId = newClassId;
        if (m[2] === "interface") {
          innerClass = new AstInnerInterface(m[3], transformInterfaceBody(body, m[3], m[4]), isStatic);
        } else {
          innerClass = new AstInnerClass(m[3], transformClassBody(body, m[3], m[4], m[5]), isStatic);
        }
        appendClass(innerClass, newClassId, oldClassId);
        currentClassId = oldClassId;
        return innerClass;
      }
      function AstClassMethod(name, params, body, isStatic) {
        this.name = name;
        this.params = params;
        this.body = body;
        this.isStatic = isStatic;
      }
      AstClassMethod.prototype.toString = function() {
        var paramNames = appendToLookupTable({}, this.params.getNames());
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
        };
        var body = this.params.prependMethodArgs(this.body.toString());
        var result = "function " + this.methodId + this.params + " " + body + "\n";
        replaceContext = oldContext;
        return result;
      };
      function transformClassMethod(method) {
        var m = methodsRegex.exec(method);
        methodsRegex.lastIndex = 0;
        var isStatic = m[1].indexOf("static") >= 0;
        var body = m[6] !== ";" ? atoms[getAtomIndex(m[6])] : "{}";
        return new AstClassMethod(
          m[3],
          transformParams(atoms[getAtomIndex(m[4])]),
          transformStatementsBlock(body),
          isStatic
        );
      }
      function AstClassField(definitions, fieldType, isStatic) {
        this.definitions = definitions;
        this.fieldType = fieldType;
        this.isStatic = isStatic;
      }
      AstClassField.prototype.getNames = function() {
        var names = [];
        for (var i = 0, l2 = this.definitions.length; i < l2; ++i) {
          names.push(this.definitions[i].name);
        }
        return names;
      };
      AstClassField.prototype.toString = function() {
        var thisPrefix = replaceContext({ name: "[this]" });
        if (this.isStatic) {
          var className = this.owner.name;
          var staticDeclarations = [];
          for (var i = 0, l2 = this.definitions.length; i < l2; ++i) {
            var definition = this.definitions[i];
            var name = definition.name, staticName = className + "." + name;
            var declaration = "if(" + staticName + " === void(0)) {\n " + staticName + " = " + definition.value + "; }\n$p.defineProperty(" + thisPrefix + ", '" + name + "', { get: function(){return " + staticName + ";}, set: function(val){" + staticName + " = val;} });\n";
            staticDeclarations.push(declaration);
          }
          return staticDeclarations.join("");
        }
        return thisPrefix + "." + this.definitions.join("; " + thisPrefix + ".");
      };
      function transformClassField(statement) {
        var attrAndType = attrAndTypeRegex.exec(statement);
        var isStatic = attrAndType[1].indexOf("static") >= 0;
        var definitions = statement.substring(attrAndType[0].length).split(/,\s*/g);
        var defaultTypeValue = getDefaultValueForType(attrAndType[2]);
        for (var i = 0; i < definitions.length; ++i) {
          definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);
        }
        return new AstClassField(definitions, attrAndType[2], isStatic);
      }
      function AstConstructor(params, body) {
        this.params = params;
        this.body = body;
      }
      AstConstructor.prototype.toString = function() {
        var paramNames = appendToLookupTable({}, this.params.getNames());
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
        };
        var prefix = "function $constr_" + this.params.params.length + this.params.toString();
        var body = this.params.prependMethodArgs(this.body.toString());
        if (!/\$(superCstr|constr)\b/.test(body)) {
          body = "{\n$superCstr();\n" + body.substring(1);
        }
        replaceContext = oldContext;
        return prefix + body + "\n";
      };
      function transformConstructor(cstr) {
        var m = new RegExp(/"B(\d+)"\s*"A(\d+)"/).exec(cstr);
        var params = transformParams(atoms[m[1]]);
        return new AstConstructor(params, transformStatementsBlock(atoms[m[2]]));
      }
      function AstInterfaceBody(name, interfacesNames, methodsNames, fields, innerClasses, misc) {
        var i, l2;
        this.name = name;
        this.interfacesNames = interfacesNames;
        this.methodsNames = methodsNames;
        this.fields = fields;
        this.innerClasses = innerClasses;
        this.misc = misc;
        for (i = 0, l2 = fields.length; i < l2; ++i) {
          fields[i].owner = this;
        }
      }
      AstInterfaceBody.prototype.getMembers = function(classFields, classMethods, classInners) {
        if (this.owner.base) {
          this.owner.base.body.getMembers(classFields, classMethods, classInners);
        }
        var i, j, l2, m;
        for (i = 0, l2 = this.fields.length; i < l2; ++i) {
          var fieldNames = this.fields[i].getNames();
          for (j = 0, m = fieldNames.length; j < m; ++j) {
            classFields[fieldNames[j]] = this.fields[i];
          }
        }
        for (i = 0, l2 = this.methodsNames.length; i < l2; ++i) {
          var methodName = this.methodsNames[i];
          classMethods[methodName] = true;
        }
        for (i = 0, l2 = this.innerClasses.length; i < l2; ++i) {
          var innerClass = this.innerClasses[i];
          classInners[innerClass.name] = innerClass;
        }
      };
      AstInterfaceBody.prototype.toString = function() {
        function getScopeLevel(p) {
          var i2 = 0;
          while (p) {
            ++i2;
            p = p.scope;
          }
          return i2;
        }
        var scopeLevel = getScopeLevel(this.owner);
        var className = this.name;
        var staticDefinitions = "";
        var metadata = "";
        var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};
        this.getMembers(thisClassFields, thisClassMethods, thisClassInners);
        var i, l2, j, m;
        if (this.owner.interfaces) {
          var resolvedInterfaces = [], resolvedInterface;
          for (i = 0, l2 = this.interfacesNames.length; i < l2; ++i) {
            if (!this.owner.interfaces[i]) {
              continue;
            }
            resolvedInterface = replaceContext({ name: this.interfacesNames[i] });
            resolvedInterfaces.push(resolvedInterface);
            staticDefinitions += "$p.extendInterfaceMembers(" + className + ", " + resolvedInterface + ");\n";
          }
          metadata += className + ".$interfaces = [" + resolvedInterfaces.join(", ") + "];\n";
        }
        metadata += className + ".$isInterface = true;\n";
        metadata += className + ".$methods = ['" + this.methodsNames.join("', '") + "'];\n";
        sortByWeight(this.innerClasses);
        for (i = 0, l2 = this.innerClasses.length; i < l2; ++i) {
          var innerClass = this.innerClasses[i];
          if (innerClass.isStatic) {
            staticDefinitions += className + "." + innerClass.name + " = " + innerClass + ";\n";
          }
        }
        for (i = 0, l2 = this.fields.length; i < l2; ++i) {
          var field = this.fields[i];
          if (field.isStatic) {
            staticDefinitions += className + "." + field.definitions.join(";\n" + className + ".") + ";\n";
          }
        }
        return "(function() {\nfunction " + className + "() { throw 'Unable to create the interface'; }\n" + staticDefinitions + metadata + "return " + className + ";\n})()";
      };
      transformInterfaceBody = function(body, name, baseInterfaces) {
        var declarations = body.substring(1, body.length - 1);
        declarations = extractClassesAndMethods(declarations);
        declarations = extractConstructors(declarations, name);
        var methodsNames = [], classes = [];
        declarations = declarations.replace(/"([DE])(\d+)"/g, function(all, type, index) {
          if (type === "D") {
            methodsNames.push(index);
          } else if (type === "E") {
            classes.push(index);
          }
          return "";
        });
        var fields = declarations.split(/;(?:\s*;)*/g);
        var baseInterfaceNames;
        var i, l2;
        if (baseInterfaces !== undef) {
          baseInterfaceNames = baseInterfaces.replace(/^\s*extends\s+(.+?)\s*$/g, "$1").split(/\s*,\s*/g);
        }
        for (i = 0, l2 = methodsNames.length; i < l2; ++i) {
          var method = transformClassMethod(atoms[methodsNames[i]]);
          methodsNames[i] = method.name;
        }
        for (i = 0, l2 = fields.length - 1; i < l2; ++i) {
          var field = trimSpaces(fields[i]);
          fields[i] = transformClassField(field.middle);
        }
        var tail = fields.pop();
        for (i = 0, l2 = classes.length; i < l2; ++i) {
          classes[i] = transformInnerClass(atoms[classes[i]]);
        }
        return new AstInterfaceBody(name, baseInterfaceNames, methodsNames, fields, classes, { tail });
      };
      function AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs, innerClasses, misc) {
        var i, l2;
        this.name = name;
        this.baseClassName = baseClassName;
        this.interfacesNames = interfacesNames;
        this.functions = functions;
        this.methods = methods;
        this.fields = fields;
        this.cstrs = cstrs;
        this.innerClasses = innerClasses;
        this.misc = misc;
        for (i = 0, l2 = fields.length; i < l2; ++i) {
          fields[i].owner = this;
        }
      }
      AstClassBody.prototype.getMembers = function(classFields, classMethods, classInners) {
        if (this.owner.base) {
          this.owner.base.body.getMembers(classFields, classMethods, classInners);
        }
        var i, j, l2, m;
        for (i = 0, l2 = this.fields.length; i < l2; ++i) {
          var fieldNames = this.fields[i].getNames();
          for (j = 0, m = fieldNames.length; j < m; ++j) {
            classFields[fieldNames[j]] = this.fields[i];
          }
        }
        for (i = 0, l2 = this.methods.length; i < l2; ++i) {
          var method = this.methods[i];
          classMethods[method.name] = method;
        }
        for (i = 0, l2 = this.innerClasses.length; i < l2; ++i) {
          var innerClass = this.innerClasses[i];
          classInners[innerClass.name] = innerClass;
        }
      };
      AstClassBody.prototype.toString = function() {
        function getScopeLevel(p) {
          var i2 = 0;
          while (p) {
            ++i2;
            p = p.scope;
          }
          return i2;
        }
        var scopeLevel = getScopeLevel(this.owner);
        var selfId = "$this_" + scopeLevel;
        var className = this.name;
        var result = "var " + selfId + " = this;\n";
        var staticDefinitions = "";
        var metadata = "";
        var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};
        this.getMembers(thisClassFields, thisClassMethods, thisClassInners);
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          var name = subject.name;
          if (name === "this") {
            return subject.callSign || !subject.member ? selfId + ".$self" : selfId;
          }
          if (thisClassFields.hasOwnProperty(name)) {
            return thisClassFields[name].isStatic ? className + "." + name : selfId + "." + name;
          }
          if (thisClassInners.hasOwnProperty(name)) {
            return selfId + "." + name;
          }
          if (thisClassMethods.hasOwnProperty(name)) {
            return thisClassMethods[name].isStatic ? className + "." + name : selfId + ".$self." + name;
          }
          return oldContext(subject);
        };
        var resolvedBaseClassName;
        if (this.baseClassName) {
          resolvedBaseClassName = oldContext({ name: this.baseClassName });
          result += "var $super = { $upcast: " + selfId + " };\n";
          result += "function $superCstr(){" + resolvedBaseClassName + ".apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}\n";
          metadata += className + ".$base = " + resolvedBaseClassName + ";\n";
        } else {
          result += "function $superCstr(){$p.extendClassChain(" + selfId + ")}\n";
        }
        if (this.owner.base) {
          staticDefinitions += "$p.extendStaticMembers(" + className + ", " + resolvedBaseClassName + ");\n";
        }
        var i, l2, j, m;
        if (this.owner.interfaces) {
          var resolvedInterfaces = [], resolvedInterface;
          for (i = 0, l2 = this.interfacesNames.length; i < l2; ++i) {
            if (!this.owner.interfaces[i]) {
              continue;
            }
            resolvedInterface = oldContext({ name: this.interfacesNames[i] });
            resolvedInterfaces.push(resolvedInterface);
            staticDefinitions += "$p.extendInterfaceMembers(" + className + ", " + resolvedInterface + ");\n";
          }
          metadata += className + ".$interfaces = [" + resolvedInterfaces.join(", ") + "];\n";
        }
        if (this.functions.length > 0) {
          result += this.functions.join("\n") + "\n";
        }
        sortByWeight(this.innerClasses);
        for (i = 0, l2 = this.innerClasses.length; i < l2; ++i) {
          var innerClass = this.innerClasses[i];
          if (innerClass.isStatic) {
            staticDefinitions += className + "." + innerClass.name + " = " + innerClass + ";\n";
            result += selfId + "." + innerClass.name + " = " + className + "." + innerClass.name + ";\n";
          } else {
            result += selfId + "." + innerClass.name + " = " + innerClass + ";\n";
          }
        }
        for (i = 0, l2 = this.fields.length; i < l2; ++i) {
          var field = this.fields[i];
          if (field.isStatic) {
            staticDefinitions += className + "." + field.definitions.join(";\n" + className + ".") + ";\n";
            for (j = 0, m = field.definitions.length; j < m; ++j) {
              var fieldName = field.definitions[j].name, staticName = className + "." + fieldName;
              result += "$p.defineProperty(" + selfId + ", '" + fieldName + "', {get: function(){return " + staticName + "}, set: function(val){" + staticName + " = val}});\n";
            }
          } else {
            result += selfId + "." + field.definitions.join(";\n" + selfId + ".") + ";\n";
          }
        }
        var methodOverloads = {};
        for (i = 0, l2 = this.methods.length; i < l2; ++i) {
          var method = this.methods[i];
          var overload = methodOverloads[method.name];
          var methodId = method.name + "$" + method.params.params.length;
          var hasMethodArgs = !!method.params.methodArgsParam;
          if (overload) {
            ++overload;
            methodId += "_" + overload;
          } else {
            overload = 1;
          }
          method.methodId = methodId;
          methodOverloads[method.name] = overload;
          if (method.isStatic) {
            staticDefinitions += method;
            staticDefinitions += "$p.addMethod(" + className + ", '" + method.name + "', " + methodId + ", " + hasMethodArgs + ");\n";
            result += "$p.addMethod(" + selfId + ", '" + method.name + "', " + methodId + ", " + hasMethodArgs + ");\n";
          } else {
            result += method;
            result += "$p.addMethod(" + selfId + ", '" + method.name + "', " + methodId + ", " + hasMethodArgs + ");\n";
          }
        }
        result += trim(this.misc.tail);
        if (this.cstrs.length > 0) {
          result += this.cstrs.join("\n") + "\n";
        }
        result += "function $constr() {\n";
        var cstrsIfs = [];
        for (i = 0, l2 = this.cstrs.length; i < l2; ++i) {
          var paramsLength = this.cstrs[i].params.params.length;
          var methodArgsPresent = !!this.cstrs[i].params.methodArgsParam;
          cstrsIfs.push("if(arguments.length " + (methodArgsPresent ? ">=" : "===") + " " + paramsLength + ") { $constr_" + paramsLength + ".apply(" + selfId + ", arguments); }");
        }
        if (cstrsIfs.length > 0) {
          result += cstrsIfs.join(" else ") + " else ";
        }
        result += "$superCstr();\n}\n";
        result += "$constr.apply(null, arguments);\n";
        replaceContext = oldContext;
        return "(function() {\nfunction " + className + "() {\n" + result + "}\n" + staticDefinitions + metadata + "return " + className + ";\n})()";
      };
      transformClassBody = function(body, name, baseName, interfaces) {
        var declarations = body.substring(1, body.length - 1);
        declarations = extractClassesAndMethods(declarations);
        declarations = extractConstructors(declarations, name);
        var methods = [], classes = [], cstrs = [], functions = [];
        declarations = declarations.replace(/"([DEGH])(\d+)"/g, function(all, type, index) {
          if (type === "D") {
            methods.push(index);
          } else if (type === "E") {
            classes.push(index);
          } else if (type === "H") {
            functions.push(index);
          } else {
            cstrs.push(index);
          }
          return "";
        });
        var fields = declarations.replace(/^(?:\s*;)+/, "").split(/;(?:\s*;)*/g);
        var baseClassName, interfacesNames;
        var i;
        if (baseName !== undef) {
          baseClassName = baseName.replace(/^\s*extends\s+([A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)\s*$/g, "$1");
        }
        if (interfaces !== undef) {
          interfacesNames = interfaces.replace(/^\s*implements\s+(.+?)\s*$/g, "$1").split(/\s*,\s*/g);
        }
        for (i = 0; i < functions.length; ++i) {
          functions[i] = transformFunction(atoms[functions[i]]);
        }
        for (i = 0; i < methods.length; ++i) {
          methods[i] = transformClassMethod(atoms[methods[i]]);
        }
        for (i = 0; i < fields.length - 1; ++i) {
          var field = trimSpaces(fields[i]);
          fields[i] = transformClassField(field.middle);
        }
        var tail = fields.pop();
        for (i = 0; i < cstrs.length; ++i) {
          cstrs[i] = transformConstructor(atoms[cstrs[i]]);
        }
        for (i = 0; i < classes.length; ++i) {
          classes[i] = transformInnerClass(atoms[classes[i]]);
        }
        return new AstClassBody(
          name,
          baseClassName,
          interfacesNames,
          functions,
          methods,
          fields,
          cstrs,
          classes,
          { tail }
        );
      };
      function AstInterface(name, body) {
        this.name = name;
        this.body = body;
        body.owner = this;
      }
      AstInterface.prototype.toString = function() {
        return "var " + this.name + " = " + this.body + ";\n$p." + this.name + " = " + this.name + ";\n";
      };
      function AstClass(name, body) {
        this.name = name;
        this.body = body;
        body.owner = this;
      }
      AstClass.prototype.toString = function() {
        return "var " + this.name + " = " + this.body + ";\n$p." + this.name + " = " + this.name + ";\n";
      };
      function transformGlobalClass(class_) {
        var m = classesRegex.exec(class_);
        classesRegex.lastIndex = 0;
        var body = atoms[getAtomIndex(m[6])];
        var oldClassId = currentClassId, newClassId = generateClassId();
        currentClassId = newClassId;
        var globalClass;
        if (m[2] === "interface") {
          globalClass = new AstInterface(m[3], transformInterfaceBody(body, m[3], m[4]));
        } else {
          globalClass = new AstClass(m[3], transformClassBody(body, m[3], m[4], m[5]));
        }
        appendClass(globalClass, newClassId, oldClassId);
        currentClassId = oldClassId;
        return globalClass;
      }
      function AstMethod(name, params, body) {
        this.name = name;
        this.params = params;
        this.body = body;
      }
      AstMethod.prototype.toString = function() {
        var paramNames = appendToLookupTable({}, this.params.getNames());
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
        };
        var body = this.params.prependMethodArgs(this.body.toString());
        var result = "function " + this.name + this.params + " " + body + "\n$p." + this.name + " = " + this.name + ";\n" + this.name + " = " + this.name + ".bind($p);";
        replaceContext = oldContext;
        return result;
      };
      function transformGlobalMethod(method) {
        var m = methodsRegex.exec(method);
        var result = methodsRegex.lastIndex = 0;
        return new AstMethod(
          m[3],
          transformParams(atoms[getAtomIndex(m[4])]),
          transformStatementsBlock(atoms[getAtomIndex(m[6])])
        );
      }
      function preStatementsTransform(statements) {
        var s = statements;
        s = s.replace(/\b(catch\s*"B\d+"\s*"A\d+")(\s*catch\s*"B\d+"\s*"A\d+")+/g, "$1");
        return s;
      }
      function AstForStatement(argument, misc) {
        this.argument = argument;
        this.misc = misc;
      }
      AstForStatement.prototype.toString = function() {
        return this.misc.prefix + this.argument.toString();
      };
      function AstCatchStatement(argument, misc) {
        this.argument = argument;
        this.misc = misc;
      }
      AstCatchStatement.prototype.toString = function() {
        return this.misc.prefix + this.argument.toString();
      };
      function AstPrefixStatement(name, argument, misc) {
        this.name = name;
        this.argument = argument;
        this.misc = misc;
      }
      AstPrefixStatement.prototype.toString = function() {
        var result = this.misc.prefix;
        if (this.argument !== undef) {
          result += this.argument.toString();
        }
        return result;
      };
      function AstSwitchCase(expr) {
        this.expr = expr;
      }
      AstSwitchCase.prototype.toString = function() {
        return "case " + this.expr + ":";
      };
      function AstLabel(label) {
        this.label = label;
      }
      AstLabel.prototype.toString = function() {
        return this.label;
      };
      transformStatements = function(statements, transformMethod, transformClass) {
        var nextStatement = new RegExp(/\b(catch|for|if|switch|while|with)\s*"B(\d+)"|\b(do|else|finally|return|throw|try|break|continue)\b|("[ADEH](\d+)")|\b(case)\s+([^:]+):|\b([A-Za-z_$][\w$]*\s*:)|(;)/g);
        var res = [];
        statements = preStatementsTransform(statements);
        var lastIndex = 0, m, space;
        while ((m = nextStatement.exec(statements)) !== null) {
          if (m[1] !== undef) {
            var i = statements.lastIndexOf('"B', nextStatement.lastIndex);
            var statementsPrefix = statements.substring(lastIndex, i);
            if (m[1] === "for") {
              res.push(new AstForStatement(
                transformForExpression(atoms[m[2]]),
                { prefix: statementsPrefix }
              ));
            } else if (m[1] === "catch") {
              res.push(new AstCatchStatement(
                transformParams(atoms[m[2]]),
                { prefix: statementsPrefix }
              ));
            } else {
              res.push(new AstPrefixStatement(
                m[1],
                transformExpression(atoms[m[2]]),
                { prefix: statementsPrefix }
              ));
            }
          } else if (m[3] !== undef) {
            res.push(new AstPrefixStatement(
              m[3],
              undef,
              { prefix: statements.substring(lastIndex, nextStatement.lastIndex) }
            ));
          } else if (m[4] !== undef) {
            space = statements.substring(lastIndex, nextStatement.lastIndex - m[4].length);
            if (trim(space).length !== 0) {
              continue;
            }
            res.push(space);
            var kind = m[4].charAt(1), atomIndex = m[5];
            if (kind === "D") {
              res.push(transformMethod(atoms[atomIndex]));
            } else if (kind === "E") {
              res.push(transformClass(atoms[atomIndex]));
            } else if (kind === "H") {
              res.push(transformFunction(atoms[atomIndex]));
            } else {
              res.push(transformStatementsBlock(atoms[atomIndex]));
            }
          } else if (m[6] !== undef) {
            res.push(new AstSwitchCase(transformExpression(trim(m[7]))));
          } else if (m[8] !== undef) {
            space = statements.substring(lastIndex, nextStatement.lastIndex - m[8].length);
            if (trim(space).length !== 0) {
              continue;
            }
            res.push(new AstLabel(statements.substring(lastIndex, nextStatement.lastIndex)));
          } else {
            var statement = trimSpaces(statements.substring(lastIndex, nextStatement.lastIndex - 1));
            res.push(statement.left);
            res.push(transformStatement(statement.middle));
            res.push(statement.right + ";");
          }
          lastIndex = nextStatement.lastIndex;
        }
        var statementsTail = trimSpaces(statements.substring(lastIndex));
        res.push(statementsTail.left);
        if (statementsTail.middle !== "") {
          res.push(transformStatement(statementsTail.middle));
          res.push(";" + statementsTail.right);
        }
        return res;
      };
      function getLocalNames(statements) {
        var localNames = [];
        for (var i = 0, l2 = statements.length; i < l2; ++i) {
          var statement = statements[i];
          if (statement instanceof AstVar) {
            localNames = localNames.concat(statement.getNames());
          } else if (statement instanceof AstForStatement && statement.argument.initStatement instanceof AstVar) {
            localNames = localNames.concat(statement.argument.initStatement.getNames());
          } else if (statement instanceof AstInnerInterface || statement instanceof AstInnerClass || statement instanceof AstInterface || statement instanceof AstClass || statement instanceof AstMethod || statement instanceof AstFunction) {
            localNames.push(statement.name);
          }
        }
        return appendToLookupTable({}, localNames);
      }
      function AstStatementsBlock(statements) {
        this.statements = statements;
      }
      AstStatementsBlock.prototype.toString = function() {
        var localNames = getLocalNames(this.statements);
        var oldContext = replaceContext;
        if (!isLookupTableEmpty(localNames)) {
          replaceContext = function(subject) {
            return localNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
          };
        }
        var result = "{\n" + this.statements.join("") + "\n}";
        replaceContext = oldContext;
        return result;
      };
      transformStatementsBlock = function(block) {
        var content = trimSpaces(block.substring(1, block.length - 1));
        return new AstStatementsBlock(transformStatements(content.middle));
      };
      function AstRoot(statements) {
        this.statements = statements;
      }
      AstRoot.prototype.toString = function() {
        var classes = [], otherStatements = [], statement;
        for (var i = 0, len = this.statements.length; i < len; ++i) {
          statement = this.statements[i];
          if (statement instanceof AstClass || statement instanceof AstInterface) {
            classes.push(statement);
          } else {
            otherStatements.push(statement);
          }
        }
        sortByWeight(classes);
        var localNames = getLocalNames(this.statements);
        replaceContext = function(subject) {
          var name = subject.name;
          if (localNames.hasOwnProperty(name)) {
            return name;
          }
          if (globalMembers.hasOwnProperty(name) || PConstants3.hasOwnProperty(name) || defaultScope2.hasOwnProperty(name)) {
            return "$p." + name;
          }
          return name;
        };
        var result = "// this code was autogenerated from PJS\n(function($p) {\n" + classes.join("") + "\n" + otherStatements.join("") + "\n})";
        replaceContext = null;
        return result;
      };
      transformMain = function() {
        var statements = extractClassesAndMethods(atoms[0]);
        statements = statements.replace(/\bimport\s+[^;]+;/g, "");
        return new AstRoot(transformStatements(
          statements,
          transformGlobalMethod,
          transformGlobalClass
        ));
      };
      function generateMetadata(ast) {
        var globalScope = {};
        var id, class_;
        for (id in declaredClasses) {
          if (declaredClasses.hasOwnProperty(id)) {
            class_ = declaredClasses[id];
            var scopeId = class_.scopeId, name = class_.name;
            if (scopeId) {
              var scope = declaredClasses[scopeId];
              class_.scope = scope;
              if (scope.inScope === undef) {
                scope.inScope = {};
              }
              scope.inScope[name] = class_;
            } else {
              globalScope[name] = class_;
            }
          }
        }
        function findInScopes(class_2, name2) {
          var parts = name2.split(".");
          var currentScope = class_2.scope, found;
          while (currentScope) {
            if (currentScope.hasOwnProperty(parts[0])) {
              found = currentScope[parts[0]];
              break;
            }
            currentScope = currentScope.scope;
          }
          if (found === undef) {
            found = globalScope[parts[0]];
          }
          for (var i2 = 1, l3 = parts.length; i2 < l3 && found; ++i2) {
            found = found.inScope[parts[i2]];
          }
          return found;
        }
        for (id in declaredClasses) {
          if (declaredClasses.hasOwnProperty(id)) {
            class_ = declaredClasses[id];
            var baseClassName = class_.body.baseClassName;
            if (baseClassName) {
              var parent = findInScopes(class_, baseClassName);
              if (parent) {
                class_.base = parent;
                if (!parent.derived) {
                  parent.derived = [];
                }
                parent.derived.push(class_);
              }
            }
            var interfacesNames = class_.body.interfacesNames, interfaces = [], i, l2;
            if (interfacesNames && interfacesNames.length > 0) {
              for (i = 0, l2 = interfacesNames.length; i < l2; ++i) {
                var interface_ = findInScopes(class_, interfacesNames[i]);
                interfaces.push(interface_);
                if (!interface_) {
                  continue;
                }
                if (!interface_.derived) {
                  interface_.derived = [];
                }
                interface_.derived.push(class_);
              }
              if (interfaces.length > 0) {
                class_.interfaces = interfaces;
              }
            }
          }
        }
      }
      function setWeight(ast) {
        var queue = [], tocheck = {};
        var id, scopeId, class_;
        for (id in declaredClasses) {
          if (declaredClasses.hasOwnProperty(id)) {
            class_ = declaredClasses[id];
            if (!class_.inScope && !class_.derived) {
              queue.push(id);
              class_.weight = 0;
            } else {
              var dependsOn = [];
              if (class_.inScope) {
                for (scopeId in class_.inScope) {
                  if (class_.inScope.hasOwnProperty(scopeId)) {
                    dependsOn.push(class_.inScope[scopeId]);
                  }
                }
              }
              if (class_.derived) {
                dependsOn = dependsOn.concat(class_.derived);
              }
              tocheck[id] = dependsOn;
            }
          }
        }
        function removeDependentAndCheck(targetId, from) {
          var dependsOn2 = tocheck[targetId];
          if (!dependsOn2) {
            return false;
          }
          var i2 = dependsOn2.indexOf(from);
          if (i2 < 0) {
            return false;
          }
          dependsOn2.splice(i2, 1);
          if (dependsOn2.length > 0) {
            return false;
          }
          delete tocheck[targetId];
          return true;
        }
        while (queue.length > 0) {
          id = queue.shift();
          class_ = declaredClasses[id];
          if (class_.scopeId && removeDependentAndCheck(class_.scopeId, class_)) {
            queue.push(class_.scopeId);
            declaredClasses[class_.scopeId].weight = class_.weight + 1;
          }
          if (class_.base && removeDependentAndCheck(class_.base.classId, class_)) {
            queue.push(class_.base.classId);
            class_.base.weight = class_.weight + 1;
          }
          if (class_.interfaces) {
            var i, l2;
            for (i = 0, l2 = class_.interfaces.length; i < l2; ++i) {
              if (!class_.interfaces[i] || !removeDependentAndCheck(class_.interfaces[i].classId, class_)) {
                continue;
              }
              queue.push(class_.interfaces[i].classId);
              class_.interfaces[i].weight = class_.weight + 1;
            }
          }
        }
      }
      var transformed = transformMain();
      generateMetadata(transformed);
      setWeight(transformed);
      var redendered = transformed.toString();
      redendered = redendered.replace(/\s*\n(?:[\t ]*\n)+/g, "\n\n");
      redendered = redendered.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {
        return String.fromCharCode(parseInt(hexCode, 16));
      });
      return injectStrings(redendered, strings);
    }
    function preprocessCode(aCode, sketch) {
      var dm = new RegExp(/\/\*\s*@pjs\s+((?:[^\*]|\*+[^\*\/])*)\*\//g).exec(aCode);
      if (dm && dm.length === 2) {
        var jsonItems = [], directives = dm.splice(1, 2)[0].replace(/\{([\s\S]*?)\}/g, /* @__PURE__ */ function() {
          return function(all, item) {
            jsonItems.push(item);
            return "{" + (jsonItems.length - 1) + "}";
          };
        }()).replace("\n", "").replace("\r", "").split(";");
        var clean = function(s) {
          return s.replace(/^\s*["']?/, "").replace(/["']?\s*$/, "");
        };
        for (var i = 0, dl = directives.length; i < dl; i++) {
          var pair = directives[i].split("=");
          if (pair && pair.length === 2) {
            var key = clean(pair[0]), value = clean(pair[1]), list = [];
            if (key === "preload") {
              list = value.split(",");
              for (var j = 0, jl = list.length; j < jl; j++) {
                var imageName = clean(list[j]);
                sketch.imageCache.add(imageName);
              }
            } else if (key === "font") {
              list = value.split(",");
              for (var x = 0, xl = list.length; x < xl; x++) {
                var fontName = clean(list[x]), index = /^\{(\d*?)\}$/.exec(fontName);
                PFont.preloading.add(index ? JSON.parse("{" + jsonItems[index[1]] + "}") : fontName);
              }
            } else if (key === "pauseOnBlur") {
              sketch.options.pauseOnBlur = value === "true";
            } else if (key === "globalKeyEvents") {
              sketch.options.globalKeyEvents = value === "true";
            } else if (key.substring(0, 6) === "param-") {
              sketch.params[key.substring(6)] = value;
            } else {
              sketch.options[key] = value;
            }
          }
        }
      }
      return aCode;
    }
    Processing3.compile = function(pdeCode) {
      var sketch = new Processing3.Sketch();
      var code = preprocessCode(pdeCode, sketch);
      var compiledPde = parseProcessing(code);
      sketch.sourceCode = compiledPde;
      return sketch;
    };
    Processing3.logger = new PjsConsole(document2);
    return Processing3;
  }

  // src/Helpers/finalizeProcessing.js
  function finalizeProcessing(Processing3, options) {
    var window2 = options.window, document2 = options.document, XMLHttpRequest2 = window2.XMLHttpRequest, noop = options.noop, isDOMPresent = options.isDOMPresent, version = options.version, undef;
    Processing3.version = version ? version : "@DEV-VERSION@";
    Processing3.lib = {};
    Processing3.registerLibrary = function(name, library) {
      Processing3.lib[name] = library;
      if (library.hasOwnProperty("init")) {
        library.init(defaultScope);
      }
    };
    Processing3.Sketch = function(attachFunction) {
      this.attachFunction = attachFunction;
      this.options = {
        pauseOnBlur: false,
        globalKeyEvents: false
      };
      this.onLoad = noop;
      this.onSetup = noop;
      this.onPause = noop;
      this.onLoop = noop;
      this.onFrameStart = noop;
      this.onFrameEnd = noop;
      this.onExit = noop;
      this.params = {};
      this.imageCache = {
        pending: 0,
        images: {},
        // Opera requires special administration for preloading
        operaCache: {},
        // Specify an optional img arg if the image is already loaded in the DOM,
        // otherwise href will get loaded.
        add: function(href, img) {
          if (this.images[href]) {
            return;
          }
          if (!isDOMPresent) {
            this.images[href] = null;
          }
          if (!img) {
            img = new Image();
            img.onload = /* @__PURE__ */ function(owner) {
              return function() {
                owner.pending--;
              };
            }(this);
            this.pending++;
            img.src = href;
          }
          this.images[href] = img;
          if (window2.opera) {
            var div = document2.createElement("div");
            div.appendChild(img);
            div.style.position = "absolute";
            div.style.opacity = 0;
            div.style.width = "1px";
            div.style.height = "1px";
            if (!this.operaCache[href]) {
              document2.body.appendChild(div);
              this.operaCache[href] = div;
            }
          }
        }
      };
      this.sourceCode = void 0;
      this.attach = function(processing) {
        if (typeof this.attachFunction === "function") {
          this.attachFunction(processing);
        } else if (this.sourceCode) {
          var func = new Function("return (" + this.sourceCode + ");")();
          func(processing);
          this.attachFunction = func;
        } else {
          throw "Unable to attach sketch to the processing instance";
        }
      };
      this.toString = function() {
        var i;
        var code = "((function(Sketch) {\n";
        code += "var sketch = new Sketch(\n" + this.sourceCode + ");\n";
        for (i in this.options) {
          if (this.options.hasOwnProperty(i)) {
            var value = this.options[i];
            code += "sketch.options." + i + " = " + (typeof value === "string" ? '"' + value + '"' : "" + value) + ";\n";
          }
        }
        for (i in this.imageCache) {
          if (this.options.hasOwnProperty(i)) {
            code += 'sketch.imageCache.add("' + i + '");\n';
          }
        }
        code += "return sketch;\n})(Processing.Sketch))";
        return code;
      };
    };
    var loadSketchFromSources = Processing3.loadSketchFromSources = function(canvas, sources, onComplete) {
      var code = [], errors = [], sourcesCount = sources.length, loaded = 0;
      function ajaxAsync(url, callback) {
        var xhr = new XMLHttpRequest2();
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            var error;
            if (xhr.status !== 200 && xhr.status !== 0) {
              error = "Invalid XHR status " + xhr.status;
            } else if (xhr.responseText === "") {
              if ("withCredentials" in new XMLHttpRequest2() && new XMLHttpRequest2().withCredentials === false && window2.location.protocol === "file:") {
                error = "XMLHttpRequest failure, possibly due to a same-origin policy violation. You can try loading this page in another browser, or load it from http://localhost using a local webserver. See the Processing.js README for a more detailed explanation of this problem and solutions.";
              } else {
                error = "File is empty.";
              }
            }
            callback(xhr.responseText, error);
          }
        };
        xhr.open("GET", url, true);
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType("application/json");
        }
        xhr.setRequestHeader("If-Modified-Since", "Fri, 01 Jan 1960 00:00:00 GMT");
        xhr.send(null);
      }
      function loadBlock(index, filename) {
        function callback(block, error) {
          code[index] = block;
          ++loaded;
          if (error) {
            errors.push(filename + " ==> " + error);
          }
          if (loaded === sourcesCount) {
            if (errors.length === 0) {
              var sketch = new Processing3(canvas, code.join("\n"));
              if (onComplete) {
                onComplete(sketch);
              }
            } else {
              throw "Processing.js: Unable to load pjs sketch files: " + errors.join("\n");
            }
          }
        }
        if (filename.charAt(0) === "#") {
          var scriptElement = document2.getElementById(filename.substring(1));
          if (scriptElement) {
            callback(scriptElement.text || scriptElement.textContent);
          } else {
            callback("", "Unable to load pjs sketch: element with id '" + filename.substring(1) + "' was not found");
          }
          return;
        }
        ajaxAsync(filename, callback);
      }
      for (var i = 0; i < sourcesCount; ++i) {
        loadBlock(i, sources[i]);
      }
    };
    var init = function() {
      document2.removeEventListener("DOMContentLoaded", init, false);
      var i;
      while (Processing3.instances.length > 0) {
        for (i = Processing3.instances.length - 1; i >= 0; i--) {
          if (Processing3.instances[i]) {
            Processing3.instances[i].exit();
          }
        }
      }
      var canvas = document2.getElementsByTagName("canvas"), filenames;
      for (i = 0, l = canvas.length; i < l; i++) {
        var processingSources = canvas[i].getAttribute("data-processing-sources");
        if (processingSources === null) {
          processingSources = canvas[i].getAttribute("data-src");
          if (processingSources === null) {
            processingSources = canvas[i].getAttribute("datasrc");
          }
        }
        if (processingSources) {
          filenames = processingSources.split(/\s+/g);
          for (var j = 0; j < filenames.length; ) {
            if (filenames[j]) {
              j++;
            } else {
              filenames.splice(j, 1);
            }
          }
          loadSketchFromSources(canvas[i], filenames);
        }
      }
      var s, last, source2, instance, nodelist = document2.getElementsByTagName("script"), scripts = [];
      for (s = nodelist.length - 1; s >= 0; s--) {
        scripts.push(nodelist[s]);
      }
      for (s = 0, last = scripts.length; s < last; s++) {
        var script = scripts[s];
        if (!script.getAttribute) {
          continue;
        }
        var type = script.getAttribute("type");
        if (type && (type.toLowerCase() === "text/processing" || type.toLowerCase() === "application/processing")) {
          var target = script.getAttribute("data-processing-target");
          canvas = undef;
          if (target) {
            canvas = document2.getElementById(target);
          } else {
            var nextSibling = script.nextSibling;
            while (nextSibling && nextSibling.nodeType !== 1) {
              nextSibling = nextSibling.nextSibling;
            }
            if (nextSibling && nextSibling.nodeName.toLowerCase() === "canvas") {
              canvas = nextSibling;
            }
          }
          if (canvas) {
            if (script.getAttribute("src")) {
              filenames = script.getAttribute("src").split(/\s+/);
              loadSketchFromSources(canvas, filenames);
              continue;
            }
            source2 = script.textContent || script.text;
            instance = new Processing3(canvas, source2);
          }
        }
      }
    };
    document2.addEventListener("DOMContentLoaded", init, false);
    Processing3.reload = init;
    Processing3.disableInit = function() {
      document2.removeEventListener("DOMContentLoaded", init, false);
    };
    return Processing3;
  }

  // src/Live2D/dist/type/csmvector.js
  var _csmVector = class _csmVector {
    /**
     * 
     * @param iniitalCapacity _capacity * sizeof(T)
     * @param zeroClear true0
     */
    constructor(initialCapacity = 0) {
      __publicField(this, "_ptr");
      // 
      __publicField(this, "_size");
      // 
      __publicField(this, "_capacity");
      if (initialCapacity < 1) {
        this._ptr = [];
        this._capacity = 0;
        this._size = 0;
      } else {
        this._ptr = new Array(initialCapacity);
        this._capacity = initialCapacity;
        this._size = 0;
      }
    }
    /**
     * 
     */
    at(index) {
      return this._ptr[index];
    }
    /**
     * 
     * @param index 
     * @param value 
     */
    set(index, value) {
      this._ptr[index] = value;
    }
    /**
     * 
     */
    get(offset = 0) {
      const ret = new Array();
      for (let i = offset; i < this._size; i++) {
        ret.push(this._ptr[i]);
      }
      return ret;
    }
    /**
     * pushBack
     * @param value PushBack
     */
    pushBack(value) {
      if (this._size >= this._capacity) {
        this.prepareCapacity(this._capacity == 0 ? _csmVector.DefaultSize : this._capacity * 2);
      }
      this._ptr[this._size++] = value;
    }
    /**
     * 
     */
    clear() {
      this._ptr.length = 0;
      this._size = 0;
    }
    /**
     * 
     * @return 
     */
    getSize() {
      return this._size;
    }
    /**
     * 
     * @param newSize 
     * @param value 
     */
    assign(newSize, value) {
      const curSize = this._size;
      if (curSize < newSize) {
        this.prepareCapacity(newSize);
      }
      for (let i = 0; i < newSize; i++) {
        this._ptr[i] = value;
      }
      this._size = newSize;
    }
    /**
     * 
     */
    resize(newSize, value = null) {
      this.updateSize(newSize, value, true);
    }
    /**
     * 
     */
    updateSize(newSize, value = null, callPlacementNew = true) {
      const curSize = this._size;
      if (curSize < newSize) {
        this.prepareCapacity(newSize);
        if (callPlacementNew) {
          for (let i = this._size; i < newSize; i++) {
            if (typeof value == "function") {
              this._ptr[i] = JSON.parse(JSON.stringify(new value()));
            } else {
              this._ptr[i] = value;
            }
          }
        } else {
          for (let i = this._size; i < newSize; i++) {
            this._ptr[i] = value;
          }
        }
      } else {
        const sub = this._size - newSize;
        this._ptr.splice(this._size - sub, sub);
      }
      this._size = newSize;
    }
    /**
     * 
     * @param position 
     * @param begin 
     * @param end 
     */
    insert(position, begin, end) {
      let dstSi = position._index;
      const srcSi = begin._index;
      const srcEi = end._index;
      const addCount = srcEi - srcSi;
      this.prepareCapacity(this._size + addCount);
      const addSize = this._size - dstSi;
      if (addSize > 0) {
        for (let i = 0; i < addSize; i++) {
          this._ptr.splice(dstSi + i, 0, null);
        }
      }
      for (let i = srcSi; i < srcEi; i++, dstSi++) {
        this._ptr[dstSi] = begin._vector._ptr[i];
      }
      this._size = this._size + addCount;
    }
    /**
     * 
     * @param index 
     * @return true 
     * @return false 
     */
    remove(index) {
      if (index < 0 || this._size <= index) {
        return false;
      }
      this._ptr.splice(index, 1);
      --this._size;
      return true;
    }
    /**
     * 
     * @param ite 
     */
    erase(ite) {
      const index = ite._index;
      if (index < 0 || this._size <= index) {
        return ite;
      }
      this._ptr.splice(index, 1);
      --this._size;
      const ite2 = new iterator(this, index);
      return ite2;
    }
    /**
     * 
     * @param newSize .
     */
    prepareCapacity(newSize) {
      if (newSize > this._capacity) {
        if (this._capacity == 0) {
          this._ptr = new Array(newSize);
          this._capacity = newSize;
        } else {
          this._ptr.length = newSize;
          this._capacity = newSize;
        }
      }
    }
    /**
     * 
     */
    begin() {
      const ite = this._size == 0 ? this.end() : new iterator(this, 0);
      return ite;
    }
    /**
     * 
     */
    end() {
      const ite = new iterator(this, this._size);
      return ite;
    }
    getOffset(offset) {
      const newVector = new _csmVector();
      newVector._ptr = this.get(offset);
      newVector._size = this.get(offset).length;
      newVector._capacity = this.get(offset).length;
      return newVector;
    }
    // 
  };
  // 
  __publicField(_csmVector, "DefaultSize", 10);
  var csmVector = _csmVector;
  var iterator = class _iterator {
    /**
     * 
     */
    constructor(v, index) {
      __publicField(this, "_index");
      // 
      __publicField(this, "_vector");
      this._vector = v != void 0 ? v : null;
      this._index = index != void 0 ? index : 0;
    }
    /**
     * 
     */
    set(ite) {
      this._index = ite._index;
      this._vector = ite._vector;
      return this;
    }
    /**
     * ++
     */
    preIncrement() {
      ++this._index;
      return this;
    }
    /**
     * --
     */
    preDecrement() {
      --this._index;
      return this;
    }
    /**
     * ++
     */
    increment() {
      const iteold = new _iterator(this._vector, this._index++);
      return iteold;
    }
    /**
     * --
     */
    decrement() {
      const iteold = new _iterator(this._vector, this._index--);
      return iteold;
    }
    /**
     * ptr
     */
    ptr() {
      return this._vector._ptr[this._index];
    }
    /**
     * =
     */
    substitution(ite) {
      this._index = ite._index;
      this._vector = ite._vector;
      return this;
    }
    /**
     * !=
     */
    notEqual(ite) {
      return this._index != ite._index || this._vector != ite._vector;
    }
    // 
  };
  var Live2DCubismFramework;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.csmVector = csmVector;
    Live2DCubismFramework42.iterator = iterator;
  })(Live2DCubismFramework || (Live2DCubismFramework = {}));

  // src/Live2D/dist/type/csmstring.js
  var csmString = class {
    /**
     * 
     */
    constructor(s) {
      __publicField(this, "s");
      this.s = s;
    }
    /**
     * 
     *
     * @param c 
     * @return 
     */
    append(c, length) {
      this.s += length !== void 0 ? c.substr(0, length) : c;
      return this;
    }
    /**
     * 
     * @param length    
     * @param v         
     * @return 
     */
    expansion(length, v) {
      for (let i = 0; i < length; i++) {
        this.append(v);
      }
      return this;
    }
    /**
     * 
     */
    getBytes() {
      return encodeURIComponent(this.s).replace(/%../g, "x").length;
    }
    /**
     * 
     */
    getLength() {
      return this.s.length;
    }
    /**
     *  <
     * @param s 
     * @return true:    
     * @return false:   
     */
    isLess(s) {
      return this.s < s.s;
    }
    /**
     *  >
     * @param s 
     * @return true:    
     * @return false:   
     */
    isGreat(s) {
      return this.s > s.s;
    }
    /**
     *  ==
     * @param s 
     * @return true:    
     * @return false:   
     */
    isEqual(s) {
      return this.s == s;
    }
    /**
     * 
     * @return true: 
     * @return false: 
     */
    isEmpty() {
      return this.s.length == 0;
    }
  };
  var Live2DCubismFramework2;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.csmString = csmString;
  })(Live2DCubismFramework2 || (Live2DCubismFramework2 = {}));

  // src/Live2D/dist/id/cubismid.js
  var CubismId = class _CubismId {
    /**
     * 
     *
     * @note 
     */
    constructor(id) {
      __publicField(this, "_id");
      if (typeof id === "string") {
        this._id = new csmString(id);
        return;
      }
      this._id = id;
    }
    /**
     * CubismId
     *
     * @param id ID
     * @returns CubismId
     * @note IDCubismId
     *       CubismIdManager().getId(id)
     */
    static createIdInternal(id) {
      return new _CubismId(id);
    }
    /**
     * ID
     */
    getString() {
      return this._id;
    }
    /**
     * id
     * @param c id
     * @return true,false
     */
    isEqual(c) {
      if (typeof c === "string") {
        return this._id.isEqual(c);
      } else if (c instanceof csmString) {
        return this._id.isEqual(c.s);
      } else if (c instanceof _CubismId) {
        return this._id.isEqual(c._id.s);
      }
      return false;
    }
    /**
     * id
     * @param c id
     * @return true,false
     */
    isNotEqual(c) {
      if (typeof c == "string") {
        return !this._id.isEqual(c);
      } else if (c instanceof csmString) {
        return !this._id.isEqual(c.s);
      } else if (c instanceof _CubismId) {
        return !this._id.isEqual(c._id.s);
      }
      return false;
    }
    // ID
  };
  var Live2DCubismFramework3;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismId = CubismId;
  })(Live2DCubismFramework3 || (Live2DCubismFramework3 = {}));

  // src/Live2D/dist/id/cubismidmanager.js
  var CubismIdManager = class {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_ids");
      this._ids = new csmVector();
    }
    /**
     * 
     */
    release() {
      for (let i = 0; i < this._ids.getSize(); ++i) {
        this._ids.set(i, void 0);
      }
      this._ids = null;
    }
    /**
     * ID
     *
     * @param ids ID
     * @param count ID
     */
    registerIds(ids) {
      for (let i = 0; i < ids.length; i++) {
        this.registerId(ids[i]);
      }
    }
    /**
     * ID
     *
     * @param id ID
     */
    registerId(id) {
      let result = null;
      if ("string" == typeof id) {
        if ((result = this.findId(id)) != null) {
          return result;
        }
        result = CubismId.createIdInternal(id);
        this._ids.pushBack(result);
      } else {
        return this.registerId(id.s);
      }
      return result;
    }
    /**
     * IDID
     *
     * @param id ID
     */
    getId(id) {
      return this.registerId(id);
    }
    /**
     * IDID
     *
     * @return true 
     * @return false 
     */
    isExist(id) {
      if ("string" == typeof id) {
        return this.findId(id) != null;
      }
      return this.isExist(id.s);
    }
    /**
     * IDID
     *
     * @param id ID
     * @return IDNULL
     */
    findId(id) {
      for (let i = 0; i < this._ids.getSize(); ++i) {
        if (this._ids.at(i).getString().isEqual(id)) {
          return this._ids.at(i);
        }
      }
      return null;
    }
    // ID
  };
  var Live2DCubismFramework4;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismIdManager = CubismIdManager;
  })(Live2DCubismFramework4 || (Live2DCubismFramework4 = {}));

  // src/Live2D/dist/math/cubismmatrix44.js
  var CubismMatrix44 = class _CubismMatrix44 {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_tr");
      this._tr = new Float32Array(16);
      this.loadIdentity();
    }
    /**
     * 
     *
     * @param a a
     * @param b b
     * @return 
     */
    static multiply(a, b, dst) {
      const c = new Float32Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      const n = 4;
      for (let i = 0; i < n; ++i) {
        for (let j = 0; j < n; ++j) {
          for (let k = 0; k < n; ++k) {
            c[j + i * 4] += a[k + i * 4] * b[j + k * 4];
          }
        }
      }
      for (let i = 0; i < 16; ++i) {
        dst[i] = c[i];
      }
    }
    /**
     * 
     */
    loadIdentity() {
      const c = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
      this.setMatrix(c);
    }
    /**
     * 
     *
     * @param tr 164x4
     */
    setMatrix(tr) {
      for (let i = 0; i < 16; ++i) {
        this._tr[i] = tr[i];
      }
    }
    /**
     * 
     *
     * @return 164x4
     */
    getArray() {
      return this._tr;
    }
    /**
     * X
     * @return X
     */
    getScaleX() {
      return this._tr[0];
    }
    /**
     * Y
     *
     * @return Y
     */
    getScaleY() {
      return this._tr[5];
    }
    /**
     * X
     * @return X
     */
    getTranslateX() {
      return this._tr[12];
    }
    /**
     * Y
     * @return Y
     */
    getTranslateY() {
      return this._tr[13];
    }
    /**
     * X
     *
     * @param src X
     * @return X
     */
    transformX(src) {
      return this._tr[0] * src + this._tr[12];
    }
    /**
     * Y
     *
     * @param src Y
     * @return Y
     */
    transformY(src) {
      return this._tr[5] * src + this._tr[13];
    }
    /**
     * X
     */
    invertTransformX(src) {
      return (src - this._tr[12]) / this._tr[0];
    }
    /**
     * Y
     */
    invertTransformY(src) {
      return (src - this._tr[13]) / this._tr[5];
    }
    /**
     * 
     *
     * 
     *
     * @param x X
     * @param y Y
     */
    translateRelative(x, y) {
      const tr1 = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        x,
        y,
        0,
        1
      ]);
      _CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 
     *
     * 
     *
     * @param x X
     * @param y y
     */
    translate(x, y) {
      this._tr[12] = x;
      this._tr[13] = y;
    }
    /**
     * X
     *
     * @param x X
     */
    translateX(x) {
      this._tr[12] = x;
    }
    /**
     * Y
     *
     * @param y Y
     */
    translateY(y) {
      this._tr[13] = y;
    }
    /**
     * 
     *
     * @param x X
     * @param y Y
     */
    scaleRelative(x, y) {
      const tr1 = new Float32Array([
        x,
        0,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
      _CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 
     *
     * @param x X
     * @param y Y
     */
    scale(x, y) {
      this._tr[0] = x;
      this._tr[5] = y;
    }
    /**
     * 
     * () * ()
     *
     * @note 
     * @param m 
     */
    multiplyByMatrix(m) {
      _CubismMatrix44.multiply(m.getArray(), this._tr, this._tr);
    }
    /**
     * 
     */
    clone() {
      const cloneMatrix = new _CubismMatrix44();
      for (let i = 0; i < this._tr.length; i++) {
        cloneMatrix._tr[i] = this._tr[i];
      }
      return cloneMatrix;
    }
    // 4x4
  };
  var Live2DCubismFramework5;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMatrix44 = CubismMatrix44;
  })(Live2DCubismFramework5 || (Live2DCubismFramework5 = {}));

  // src/Live2D/dist/type/csmrectf.js
  var csmRect = class {
    /**
     * 
     * @param x X
     * @param y Y
     * @param w 
     * @param h 
     */
    constructor(x, y, w, h) {
      __publicField(this, "x");
      // X
      __publicField(this, "y");
      // Y
      __publicField(this, "width");
      // 
      __publicField(this, "height");
      this.x = x;
      this.y = y;
      this.width = w;
      this.height = h;
    }
    /**
     * X
     */
    getCenterX() {
      return this.x + 0.5 * this.width;
    }
    /**
     * Y
     */
    getCenterY() {
      return this.y + 0.5 * this.height;
    }
    /**
     * X
     */
    getRight() {
      return this.x + this.width;
    }
    /**
     * Y
     */
    getBottom() {
      return this.y + this.height;
    }
    /**
     * 
     * @param r 
     */
    setRect(r) {
      this.x = r.x;
      this.y = r.y;
      this.width = r.width;
      this.height = r.height;
    }
    /**
     * 
     * @param w 
     * @param h 
     */
    expand(w, h) {
      this.x -= w;
      this.y -= h;
      this.width += w * 2;
      this.height += h * 2;
    }
    // 
  };
  var Live2DCubismFramework6;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.csmRect = csmRect;
  })(Live2DCubismFramework6 || (Live2DCubismFramework6 = {}));

  // src/Live2D/dist/rendering/cubismrenderer.js
  var CubismRenderer = class {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_mvpMatrix4x4");
      // Model-View-Projection 
      __publicField(this, "_modelColor");
      // RGBA
      __publicField(this, "_isCulling");
      // true
      __publicField(this, "_isPremultipliedAlpha");
      // true
      __publicField(this, "_anisotropy");
      // 
      __publicField(this, "_model");
      // 
      __publicField(this, "_useHighPrecisionMask");
      this._isCulling = false;
      this._isPremultipliedAlpha = false;
      this._anisotropy = 0;
      this._model = null;
      this._modelColor = new CubismTextureColor();
      this._useHighPrecisionMask = false;
      this._mvpMatrix4x4 = new CubismMatrix44();
      this._mvpMatrix4x4.loadIdentity();
    }
    /**
     * 
     *
     * @return 
     */
    static create() {
      return null;
    }
    /**
     * 
     */
    static delete(renderer) {
      renderer = null;
    }
    /**
     * 
     * 
     * @param model 
     */
    initialize(model) {
      this._model = model;
    }
    /**
     * 
     */
    drawModel() {
      if (this.getModel() == null)
        return;
      this.saveProfile();
      this.doDrawModel();
      this.restoreProfile();
    }
    /**
     * Model-View-Projection 
     * 
     * @param matrix44 Model-View-Projection 
     */
    setMvpMatrix(matrix44) {
      this._mvpMatrix4x4.setMatrix(matrix44.getArray());
    }
    /**
     * Model-View-Projection 
     * @return Model-View-Projection 
     */
    getMvpMatrix() {
      return this._mvpMatrix4x4;
    }
    /**
     * 
     * 0.0~1.01.0
     * @param red 
     * @param green 
     * @param blue 
     * @param alpha 
     */
    setModelColor(red, green, blue, alpha) {
      if (red < 0) {
        red = 0;
      } else if (red > 1) {
        red = 1;
      }
      if (green < 0) {
        green = 0;
      } else if (green > 1) {
        green = 1;
      }
      if (blue < 0) {
        blue = 0;
      } else if (blue > 1) {
        blue = 1;
      }
      if (alpha < 0) {
        alpha = 0;
      } else if (alpha > 1) {
        alpha = 1;
      }
      this._modelColor.r = red;
      this._modelColor.g = green;
      this._modelColor.b = blue;
      this._modelColor.a = alpha;
    }
    /**
     * 
     * 0.0~1.0(1.0)
     *
     * @return RGBA
     */
    getModelColor() {
      return JSON.parse(JSON.stringify(this._modelColor));
    }
    /**
     * 
     *
     * @param opacity 
     *
     * @return RGBA
     */
    getModelColorWithOpacity(opacity) {
      const modelColorRGBA = this.getModelColor();
      modelColorRGBA.a *= opacity;
      if (this.isPremultipliedAlpha()) {
        modelColorRGBA.r *= modelColorRGBA.a;
        modelColorRGBA.g *= modelColorRGBA.a;
        modelColorRGBA.b *= modelColorRGBA.a;
      }
      return modelColorRGBA;
    }
    /**
     * 
     * truefalse
     */
    setIsPremultipliedAlpha(enable) {
      this._isPremultipliedAlpha = enable;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isPremultipliedAlpha() {
      return this._isPremultipliedAlpha;
    }
    /**
     * 
     * truefalse
     */
    setIsCulling(culling) {
      this._isCulling = culling;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isCulling() {
      return this._isCulling;
    }
    /**
     * 
     * 
     * @param n 
     */
    setAnisotropy(n) {
      this._anisotropy = n;
    }
    /**
     * 
     * @return 
     */
    getAnisotropy() {
      return this._anisotropy;
    }
    /**
     * 
     * @return 
     */
    getModel() {
      return this._model;
    }
    /**
     * 
     * false1
     * 36
     * true
     * 
     * @param high 
     */
    useHighPrecisionMask(high) {
      this._useHighPrecisionMask = high;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isUsingHighPrecisionMask() {
      return this._useHighPrecisionMask;
    }
    // false true
  };
  /**
   * 
   */
  __publicField(CubismRenderer, "staticRelease");
  var CubismBlendMode;
  (function(CubismBlendMode2) {
    CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Normal"] = 0] = "CubismBlendMode_Normal";
    CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Additive"] = 1] = "CubismBlendMode_Additive";
    CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Multiplicative"] = 2] = "CubismBlendMode_Multiplicative";
  })(CubismBlendMode || (CubismBlendMode = {}));
  var CubismTextureColor = class {
    /**
     * 
     */
    constructor(r = 1, g = 1, b = 1, a = 1) {
      __publicField(this, "r");
      // 
      __publicField(this, "g");
      // 
      __publicField(this, "b");
      // 
      __publicField(this, "a");
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }
    // 
  };
  var CubismClippingContext = class {
    /**
     * 
     */
    constructor(clippingDrawableIndices, clipCount) {
      __publicField(this, "_isUsing");
      // true
      __publicField(this, "_clippingIdList");
      // ID
      __publicField(this, "_clippingIdCount");
      // 
      __publicField(this, "_layoutChannelIndex");
      // RGBA0:R, 1:G, 2:B, 3:A
      __publicField(this, "_layoutBounds");
      // View-1~1, UV0~1
      __publicField(this, "_allClippedDrawRect");
      // 
      __publicField(this, "_matrixForMask");
      // 
      __publicField(this, "_matrixForDraw");
      // 
      __publicField(this, "_clippedDrawableIndexList");
      // 
      __publicField(this, "_bufferIndex");
      this._clippingIdList = clippingDrawableIndices;
      this._clippingIdCount = clipCount;
      this._allClippedDrawRect = new csmRect();
      this._layoutBounds = new csmRect();
      this._clippedDrawableIndexList = [];
      this._matrixForMask = new CubismMatrix44();
      this._matrixForDraw = new CubismMatrix44();
      this._bufferIndex = 0;
    }
    /**
     * 
     */
    release() {
      if (this._layoutBounds != null) {
        this._layoutBounds = null;
      }
      if (this._allClippedDrawRect != null) {
        this._allClippedDrawRect = null;
      }
      if (this._clippedDrawableIndexList != null) {
        this._clippedDrawableIndexList = null;
      }
    }
    /**
     * 
     *
     * @param drawableIndex 
     */
    addClippedDrawable(drawableIndex) {
      this._clippedDrawableIndexList.push(drawableIndex);
    }
    // 
  };
  var Live2DCubismFramework7;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismBlendMode = CubismBlendMode;
    Live2DCubismFramework42.CubismRenderer = CubismRenderer;
    Live2DCubismFramework42.CubismTextureColor = CubismTextureColor;
  })(Live2DCubismFramework7 || (Live2DCubismFramework7 = {}));

  // src/Live2D/dist/cubismframeworkconfig.js
  var CSM_LOG_LEVEL_VERBOSE = 0;
  var CSM_LOG_LEVEL_DEBUG = 1;
  var CSM_LOG_LEVEL_INFO = 2;
  var CSM_LOG_LEVEL_WARNING = 3;
  var CSM_LOG_LEVEL_ERROR = 4;
  var CSM_LOG_LEVEL = CSM_LOG_LEVEL_VERBOSE;

  // src/Live2D/dist/utils/cubismdebug.js
  var CubismLogPrint = (level, fmt, args) => {
    CubismDebug.print(level, "[CSM]" + fmt, args);
  };
  var CubismLogPrintIn = (level, fmt, args) => {
    CubismLogPrint(level, fmt + "\n", args);
  };
  var CSM_ASSERT = (expr) => {
    console.assert(expr);
  };
  var CubismLogVerbose;
  var CubismLogDebug;
  var CubismLogInfo;
  var CubismLogWarning;
  var CubismLogError;
  if (CSM_LOG_LEVEL <= CSM_LOG_LEVEL_VERBOSE) {
    CubismLogVerbose = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Verbose, "[V]" + fmt, args);
    };
    CubismLogDebug = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Debug, "[D]" + fmt, args);
    };
    CubismLogInfo = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Info, "[I]" + fmt, args);
    };
    CubismLogWarning = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
    };
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  } else if (CSM_LOG_LEVEL == CSM_LOG_LEVEL_DEBUG) {
    CubismLogDebug = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Debug, "[D]" + fmt, args);
    };
    CubismLogInfo = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Info, "[I]" + fmt, args);
    };
    CubismLogWarning = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
    };
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  } else if (CSM_LOG_LEVEL == CSM_LOG_LEVEL_INFO) {
    CubismLogInfo = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Info, "[I]" + fmt, args);
    };
    CubismLogWarning = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
    };
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  } else if (CSM_LOG_LEVEL == CSM_LOG_LEVEL_WARNING) {
    CubismLogWarning = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
    };
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  } else if (CSM_LOG_LEVEL == CSM_LOG_LEVEL_ERROR) {
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  }
  var CubismDebug = class {
    /**
     * 
     * CubismFramework.initialize()
     *
     * @param logLevel 
     * @param format 
     * @param args 
     */
    static print(logLevel, format, args) {
      if (logLevel < CubismFramework.getLoggingLevel()) {
        return;
      }
      const logPrint = CubismFramework.coreLogFunction;
      if (!logPrint)
        return;
      const buffer = format.replace(/\{(\d+)\}/g, (m, k) => {
        return args[k];
      });
      logPrint(buffer);
    }
    /**
     * 
     * CubismFramework.initialize()
     *
     * @param logLevel 
     * @param data 
     * @param length 
     */
    static dumpBytes(logLevel, data, length) {
      for (let i = 0; i < length; i++) {
        if (i % 16 == 0 && i > 0)
          this.print(logLevel, "\n");
        else if (i % 8 == 0 && i > 0)
          this.print(logLevel, "  ");
        this.print(logLevel, "{0} ", [data[i] & 255]);
      }
      this.print(logLevel, "\n");
    }
    /**
     * private 
     */
    constructor() {
    }
  };
  var Live2DCubismFramework8;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismDebug = CubismDebug;
  })(Live2DCubismFramework8 || (Live2DCubismFramework8 = {}));

  // src/Live2D/dist/type/csmmap.js
  var csmPair = class {
    /**
     * 
     * @param key Key
     * @param value Value
     */
    constructor(key, value) {
      __publicField(this, "first");
      // key
      __publicField(this, "second");
      this.first = key == void 0 ? null : key;
      this.second = value == void 0 ? null : value;
    }
    // value
  };
  var _csmMap = class _csmMap {
    /**
     * 
     * @param size 
     */
    constructor(size) {
      // 
      __publicField(this, "_keyValues");
      // key-value
      __publicField(this, "_dummyValue");
      // 
      __publicField(this, "_size");
      if (size != void 0) {
        if (size < 1) {
          this._keyValues = [];
          this._dummyValue = null;
          this._size = 0;
        } else {
          this._keyValues = new Array(size);
          this._size = size;
        }
      } else {
        this._keyValues = [];
        this._dummyValue = null;
        this._size = 0;
      }
    }
    /**
     * 
     */
    release() {
      this.clear();
    }
    /**
     * 
     * @param key 
     */
    appendKey(key) {
      this.prepareCapacity(this._size + 1, false);
      this._keyValues[this._size] = new csmPair(key);
      this._size += 1;
    }
    /**
     * [key](get)
     * @param key Value
     */
    getValue(key) {
      let found = -1;
      for (let i = 0; i < this._size; i++) {
        if (this._keyValues[i].first == key) {
          found = i;
          break;
        }
      }
      if (found >= 0) {
        return this._keyValues[found].second;
      } else {
        this.appendKey(key);
        return this._keyValues[this._size - 1].second;
      }
    }
    /**
     * [key](set)
     * @param key Value
     * @param value Value
     */
    setValue(key, value) {
      let found = -1;
      for (let i = 0; i < this._size; i++) {
        if (this._keyValues[i].first == key) {
          found = i;
          break;
        }
      }
      if (found >= 0) {
        this._keyValues[found].second = value;
      } else {
        this.appendKey(key);
        this._keyValues[this._size - 1].second = value;
      }
    }
    /**
     * Key
     * @param key key
     * @return true key
     * @return false key
     */
    isExist(key) {
      for (let i = 0; i < this._size; i++) {
        if (this._keyValues[i].first == key) {
          return true;
        }
      }
      return false;
    }
    /**
     * keyValue
     */
    clear() {
      this._keyValues = void 0;
      this._keyValues = null;
      this._keyValues = [];
      this._size = 0;
    }
    /**
     * 
     *
     * @return 
     */
    getSize() {
      return this._size;
    }
    /**
     * 
     * @param newSize 
     * @param fitToSize truefalse2
     */
    prepareCapacity(newSize, fitToSize) {
      if (newSize > this._keyValues.length) {
        if (this._keyValues.length == 0) {
          if (!fitToSize && newSize < _csmMap.DefaultSize)
            newSize = _csmMap.DefaultSize;
          this._keyValues.length = newSize;
        } else {
          if (!fitToSize && newSize < this._keyValues.length * 2)
            newSize = this._keyValues.length * 2;
          this._keyValues.length = newSize;
        }
      }
    }
    /**
     * 
     */
    begin() {
      const ite = new iterator2(this, 0);
      return ite;
    }
    /**
     * 
     */
    end() {
      const ite = new iterator2(this, this._size);
      return ite;
    }
    /**
     * 
     *
     * @param ite 
     */
    erase(ite) {
      const index = ite._index;
      if (index < 0 || this._size <= index) {
        return ite;
      }
      this._keyValues.splice(index, 1);
      --this._size;
      const ite2 = new iterator2(this, index);
      return ite2;
    }
    /**
     * 32
     */
    dumpAsInt() {
      for (let i = 0; i < this._size; i++) {
        CubismLogDebug("{0} ,", this._keyValues[i]);
        CubismLogDebug("\n");
      }
    }
    // 
  };
  __publicField(_csmMap, "DefaultSize", 10);
  var csmMap = _csmMap;
  var iterator2 = class _iterator {
    /**
     * 
     */
    constructor(v, idx) {
      __publicField(this, "_index");
      // 
      __publicField(this, "_map");
      this._map = v != void 0 ? v : new csmMap();
      this._index = idx != void 0 ? idx : 0;
    }
    /**
     * =
     */
    set(ite) {
      this._index = ite._index;
      this._map = ite._map;
      return this;
    }
    /**
     * ++
     */
    preIncrement() {
      ++this._index;
      return this;
    }
    /**
     * --
     */
    preDecrement() {
      --this._index;
      return this;
    }
    /**
     * ++
     */
    increment() {
      const iteold = new _iterator(this._map, this._index++);
      return iteold;
    }
    /**
     * --
     */
    decrement() {
      const iteold = new _iterator(this._map, this._index);
      this._map = iteold._map;
      this._index = iteold._index;
      return this;
    }
    /**
     * *
     */
    ptr() {
      return this._map._keyValues[this._index];
    }
    /**
     * !=
     */
    notEqual(ite) {
      return this._index != ite._index || this._map != ite._map;
    }
    // 
  };
  var Live2DCubismFramework9;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.csmMap = csmMap;
    Live2DCubismFramework42.csmPair = csmPair;
    Live2DCubismFramework42.iterator = iterator2;
  })(Live2DCubismFramework9 || (Live2DCubismFramework9 = {}));

  // src/Live2D/dist/utils/cubismjsonextension.js
  var CubismJsonExtension = class _CubismJsonExtension {
    static parseJsonObject(obj, map) {
      Object.keys(obj).forEach((key) => {
        if (typeof obj[key] == "boolean") {
          const convValue = Boolean(obj[key]);
          map.put(key, new JsonBoolean(convValue));
        } else if (typeof obj[key] == "string") {
          const convValue = String(obj[key]);
          map.put(key, new JsonString(convValue));
        } else if (typeof obj[key] == "number") {
          const convValue = Number(obj[key]);
          map.put(key, new JsonFloat(convValue));
        } else if (obj[key] instanceof Array) {
          map.put(key, _CubismJsonExtension.parseJsonArray(obj[key]));
        } else if (obj[key] instanceof Object) {
          map.put(key, _CubismJsonExtension.parseJsonObject(obj[key], new JsonMap()));
        } else if (obj[key] == null) {
          map.put(key, new JsonNullvalue());
        } else {
          map.put(key, obj[key]);
        }
      });
      return map;
    }
    static parseJsonArray(obj) {
      const arr = new JsonArray();
      Object.keys(obj).forEach((key) => {
        const convKey = Number(key);
        if (typeof convKey == "number") {
          if (typeof obj[key] == "boolean") {
            const convValue = Boolean(obj[key]);
            arr.add(new JsonBoolean(convValue));
          } else if (typeof obj[key] == "string") {
            const convValue = String(obj[key]);
            arr.add(new JsonString(convValue));
          } else if (typeof obj[key] == "number") {
            const convValue = Number(obj[key]);
            arr.add(new JsonFloat(convValue));
          } else if (obj[key] instanceof Array) {
            arr.add(this.parseJsonArray(obj[key]));
          } else if (obj[key] instanceof Object) {
            arr.add(this.parseJsonObject(obj[key], new JsonMap()));
          } else if (obj[key] == null) {
            arr.add(new JsonNullvalue());
          } else {
            arr.add(obj[key]);
          }
        } else if (obj[key] instanceof Array) {
          arr.add(this.parseJsonArray(obj[key]));
        } else if (obj[key] instanceof Object) {
          arr.add(this.parseJsonObject(obj[key], new JsonMap()));
        } else if (obj[key] == null) {
          arr.add(new JsonNullvalue());
        } else {
          const convValue = Array(obj[key]);
          for (let i = 0; i < convValue.length; i++) {
            arr.add(convValue[i]);
          }
        }
      });
      return arr;
    }
  };

  // src/Live2D/dist/utils/cubismjson.js
  var CSM_JSON_ERROR_TYPE_MISMATCH = "Error: type mismatch";
  var CSM_JSON_ERROR_INDEX_OF_BOUNDS = "Error: index out of bounds";
  var _Value = class _Value {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_stringBuffer");
    }
    /**
     * (string)
     */
    getRawString(defaultValue, indent) {
      return this.getString(defaultValue, indent);
    }
    /**
     * (number)
     */
    toInt(defaultValue = 0) {
      return defaultValue;
    }
    /**
     * (number)
     */
    toFloat(defaultValue = 0) {
      return defaultValue;
    }
    /**
     * (boolean)
     */
    toBoolean(defaultValue = false) {
      return defaultValue;
    }
    /**
     * 
     */
    getSize() {
      return 0;
    }
    /**
     * (Value[])
     */
    getArray(defaultValue = null) {
      return defaultValue;
    }
    /**
     * (array)
     */
    getVector(defaultValue = new csmVector()) {
      return defaultValue;
    }
    /**
     * (csmMap<csmString, Value>)
     */
    getMap(defaultValue) {
      return defaultValue;
    }
    /**
     * [index]
     */
    getValueByIndex(index) {
      return _Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);
    }
    /**
     * [string | csmString]
     */
    getValueByString(s) {
      return _Value.nullValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);
    }
    /**
     * 
     *
     * @return 
     */
    getKeys() {
      return _Value.dummyKeys;
    }
    /**
     * Valuetrue
     */
    isError() {
      return false;
    }
    /**
     * Valuenulltrue
     */
    isNull() {
      return false;
    }
    /**
     * Valuetrue
     */
    isBool() {
      return false;
    }
    /**
     * Valuetrue
     */
    isFloat() {
      return false;
    }
    /**
     * Valuetrue
     */
    isString() {
      return false;
    }
    /**
     * Valuetrue
     */
    isArray() {
      return false;
    }
    /**
     * Valuetrue
     */
    isMap() {
      return false;
    }
    equals(value) {
      return false;
    }
    /**
     * Valuetrue
     */
    isStatic() {
      return false;
    }
    /**
     * Value
     */
    setErrorNotForClientCall(errorStr) {
      return JsonError.errorValue;
    }
    /**
     * 
     */
    static staticInitializeNotForClientCall() {
      JsonBoolean.trueValue = new JsonBoolean(true);
      JsonBoolean.falseValue = new JsonBoolean(false);
      _Value.errorValue = new JsonError("ERROR", true);
      _Value.nullValue = new JsonNullvalue();
      _Value.dummyKeys = new csmVector();
    }
    /**
     * 
     */
    static staticReleaseNotForClientCall() {
      JsonBoolean.trueValue = null;
      JsonBoolean.falseValue = null;
      _Value.errorValue = null;
      _Value.nullValue = null;
      _Value.dummyKeys = null;
    }
    // NULL   CubismFramework::Disposedelete
  };
  // 
  __publicField(_Value, "dummyKeys");
  // 
  __publicField(_Value, "errorValue");
  //  CubismFramework::Disposedelete
  __publicField(_Value, "nullValue");
  var Value = _Value;
  var CubismJson = class _CubismJson {
    /**
     * 
     */
    constructor(buffer, length) {
      __publicField(this, "_parseCallback", CubismJsonExtension.parseJsonObject);
      // 
      __publicField(this, "_error");
      // 
      __publicField(this, "_lineCount");
      // 
      __publicField(this, "_root");
      this._error = null;
      this._lineCount = 0;
      this._root = null;
      if (buffer != void 0) {
        this.parseBytes(buffer, length, this._parseCallback);
      }
    }
    /**
     * 
     *
     * @param buffer 
     * @param size 
     * @return CubismJsonNULL
     */
    static create(buffer, size) {
      const json = new _CubismJson();
      const succeeded = json.parseBytes(buffer, size, json._parseCallback);
      if (!succeeded) {
        _CubismJson.delete(json);
        return null;
      } else {
        return json;
      }
    }
    /**
     * JSON
     *
     * @param instance CubismJson
     */
    static delete(instance) {
      instance = null;
    }
    /**
     * JSON
     */
    getRoot() {
      return this._root;
    }
    /**
     *  UnicodeString
     *
     * @param buffer 
     * @return 
     */
    static arrayBufferToString(buffer) {
      const uint8Array = new Uint8Array(buffer);
      let str = "";
      for (let i = 0, len = uint8Array.length; i < len; ++i) {
        str += "%" + this.pad(uint8Array[i].toString(16));
      }
      str = decodeURIComponent(str);
      return str;
    }
    /**
     * 
     */
    static pad(n) {
      return n.length < 2 ? "0" + n : n;
    }
    /**
     * JSON
     * @param buffer    
     * @param size      
     * return true : 
     * return false: 
     */
    parseBytes(buffer, size, parseCallback) {
      const endPos = new Array(1);
      const decodeBuffer = _CubismJson.arrayBufferToString(buffer);
      if (parseCallback == void 0) {
        this._root = this.parseValue(decodeBuffer, size, 0, endPos);
      } else {
        this._root = parseCallback(JSON.parse(decodeBuffer), new JsonMap());
      }
      if (this._error) {
        let strbuf = "\0";
        strbuf = "Json parse error : @line " + (this._lineCount + 1) + "\n";
        this._root = new JsonString(strbuf);
        CubismLogInfo("{0}", this._root.getRawString());
        return false;
      } else if (this._root == null) {
        this._root = new JsonError(new csmString(this._error), false);
        return false;
      }
      return true;
    }
    /**
     * 
     */
    getParseError() {
      return this._error;
    }
    /**
     * true
     */
    checkEndOfFile() {
      return this._root.getArray()[1].equals("EOF");
    }
    /**
     * JSONValue(float,String,Value*,Array,null,true,false)
     * ParseString(), ParseObject(), ParseArray()
     *
     * @param   buffer      JSON
     * @param   length      
     * @param   begin       
     * @param   outEndPos   
     * @return      Value
     */
    parseValue(buffer, length, begin, outEndPos) {
      if (this._error)
        return null;
      let o = null;
      let i = begin;
      let f;
      for (; i < length; i++) {
        const c = buffer[i];
        switch (c) {
          case "-":
          case ".":
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            const afterString = new Array(1);
            f = strtod(buffer.slice(i), afterString);
            outEndPos[0] = buffer.indexOf(afterString[0]);
            return new JsonFloat(f);
          }
          case '"':
            return new JsonString(this.parseString(buffer, length, i + 1, outEndPos));
          // \"
          case "[":
            o = this.parseArray(buffer, length, i + 1, outEndPos);
            return o;
          case "{":
            o = this.parseObject(buffer, length, i + 1, outEndPos);
            return o;
          case "n":
            if (i + 3 < length) {
              o = new JsonNullvalue();
              outEndPos[0] = i + 4;
            } else {
              this._error = "parse null";
            }
            return o;
          case "t":
            if (i + 3 < length) {
              o = JsonBoolean.trueValue;
              outEndPos[0] = i + 4;
            } else {
              this._error = "parse true";
            }
            return o;
          case "f":
            if (i + 4 < length) {
              o = JsonBoolean.falseValue;
              outEndPos[0] = i + 5;
            } else {
              this._error = "illegal ',' position";
            }
            return o;
          case ",":
            this._error = "illegal ',' position";
            return null;
          case "]":
            outEndPos[0] = i;
            return null;
          case "\n":
            this._lineCount++;
          // falls through
          case " ":
          case "	":
          case "\r":
          default:
            break;
        }
      }
      this._error = "illegal end of value";
      return null;
    }
    /**
     * "
     *
     * @param   string  ->  
     * @param   length  ->  
     * @param   begin   ->  
     * @param  outEndPos   ->  
     * @return      F
     */
    parseString(string, length, begin, outEndPos) {
      if (this._error) {
        return null;
      }
      if (!string) {
        this._error = "string is null";
        return null;
      }
      let i = begin;
      let c, c2;
      const ret = new csmString("");
      let bufStart = begin;
      for (; i < length; i++) {
        c = string[i];
        switch (c) {
          case '"': {
            outEndPos[0] = i + 1;
            ret.append(string.slice(bufStart), i - bufStart);
            return ret.s;
          }
          // falls through
          case "//": {
            i++;
            if (i - 1 > bufStart) {
              ret.append(string.slice(bufStart), i - bufStart);
            }
            bufStart = i + 1;
            if (i < length) {
              c2 = string[i];
              switch (c2) {
                case "\\":
                  ret.expansion(1, "\\");
                  break;
                case '"':
                  ret.expansion(1, '"');
                  break;
                case "/":
                  ret.expansion(1, "/");
                  break;
                case "b":
                  ret.expansion(1, "\b");
                  break;
                case "f":
                  ret.expansion(1, "\f");
                  break;
                case "n":
                  ret.expansion(1, "\n");
                  break;
                case "r":
                  ret.expansion(1, "\r");
                  break;
                case "t":
                  ret.expansion(1, "	");
                  break;
                case "u":
                  this._error = "parse string/unicord escape not supported";
                  break;
                default:
                  break;
              }
            } else {
              this._error = "parse string/escape error";
            }
          }
          // falls through
          default: {
            break;
          }
        }
      }
      this._error = "parse string/illegal end";
      return null;
    }
    /**
     * JSONValue
     *
     * @param buffer    JSON
     * @param length    
     * @param begin     
     * @param outEndPos 
     * @return Value
     */
    parseObject(buffer, length, begin, outEndPos) {
      if (this._error) {
        return null;
      }
      if (!buffer) {
        this._error = "buffer is null";
        return null;
      }
      const ret = new JsonMap();
      let key = "";
      let i = begin;
      let c = "";
      const localRetEndPos2 = Array(1);
      let ok = false;
      for (; i < length; i++) {
        FOR_LOOP: for (; i < length; i++) {
          c = buffer[i];
          switch (c) {
            case '"':
              key = this.parseString(buffer, length, i + 1, localRetEndPos2);
              if (this._error) {
                return null;
              }
              i = localRetEndPos2[0];
              ok = true;
              break FOR_LOOP;
            //-- loop
            case "}":
              outEndPos[0] = i + 1;
              return ret;
            // 
            case ":":
              this._error = "illegal ':' position";
              break;
            case "\n":
              this._lineCount++;
            // falls through
            default:
              break;
          }
        }
        if (!ok) {
          this._error = "key not found";
          return null;
        }
        ok = false;
        FOR_LOOP2: for (; i < length; i++) {
          c = buffer[i];
          switch (c) {
            case ":":
              ok = true;
              i++;
              break FOR_LOOP2;
            case "}":
              this._error = "illegal '}' position";
              break;
            // falls through
            case "\n":
              this._lineCount++;
            // case ' ': case '\t' : case '\r':
            // falls through
            default:
              break;
          }
        }
        if (!ok) {
          this._error = "':' not found";
          return null;
        }
        const value = this.parseValue(buffer, length, i, localRetEndPos2);
        if (this._error) {
          return null;
        }
        i = localRetEndPos2[0];
        ret.put(key, value);
        FOR_LOOP3: for (; i < length; i++) {
          c = buffer[i];
          switch (c) {
            case ",":
              break FOR_LOOP3;
            case "}":
              outEndPos[0] = i + 1;
              return ret;
            // 
            case "\n":
              this._lineCount++;
            // falls through
            default:
              break;
          }
        }
      }
      this._error = "illegal end of perseObject";
      return null;
    }
    /**
     * "
     * @param buffer    JSON
     * @param length    
     * @param begin     
     * @param outEndPos 
     * @return Value
     */
    parseArray(buffer, length, begin, outEndPos) {
      if (this._error) {
        return null;
      }
      if (!buffer) {
        this._error = "buffer is null";
        return null;
      }
      let ret = new JsonArray();
      let i = begin;
      let c;
      const localRetEndpos2 = new Array(1);
      for (; i < length; i++) {
        const value = this.parseValue(buffer, length, i, localRetEndpos2);
        if (this._error) {
          return null;
        }
        i = localRetEndpos2[0];
        if (value) {
          ret.add(value);
        }
        FOR_LOOP: for (; i < length; i++) {
          c = buffer[i];
          switch (c) {
            case ",":
              break FOR_LOOP;
            case "]":
              outEndPos[0] = i + 1;
              return ret;
            // 
            case "\n":
              ++this._lineCount;
            //case ' ': case '\t': case '\r':
            // falls through
            default:
              break;
          }
        }
      }
      ret = void 0;
      this._error = "illegal end of parseObject";
      return null;
    }
    // 
  };
  var JsonFloat = class extends Value {
    /**
     * 
     */
    constructor(v) {
      super();
      __publicField(this, "_value");
      this._value = v;
    }
    /**
     * Valuetrue
     */
    isFloat() {
      return true;
    }
    /**
     * (csmString)
     */
    getString(defaultValue, indent) {
      const strbuf = "\0";
      this._value = parseFloat(strbuf);
      this._stringBuffer = strbuf;
      return this._stringBuffer;
    }
    /**
     * (number)
     */
    toInt(defaultValue = 0) {
      return parseInt(this._value.toString());
    }
    /**
     * (number)
     */
    toFloat(defaultValue = 0) {
      return this._value;
    }
    equals(value) {
      if ("number" === typeof value) {
        if (Math.round(value)) {
          return false;
        } else {
          return value == this._value;
        }
      }
      return false;
    }
    // JSON
  };
  var JsonBoolean = class extends Value {
    /**
     * 
     */
    constructor(v) {
      super();
      // false
      __publicField(this, "_boolValue");
      this._boolValue = v;
    }
    /**
     * Valuetrue
     */
    isBool() {
      return true;
    }
    /**
     * (boolean)
     */
    toBoolean(defaultValue = false) {
      return this._boolValue;
    }
    /**
     * (csmString)
     */
    getString(defaultValue, indent) {
      this._stringBuffer = this._boolValue ? "true" : "false";
      return this._stringBuffer;
    }
    equals(value) {
      if ("boolean" === typeof value) {
        return value == this._boolValue;
      }
      return false;
    }
    /**
     * Valuetrue, 
     */
    isStatic() {
      return true;
    }
    // JSON
  };
  __publicField(JsonBoolean, "trueValue");
  // true
  __publicField(JsonBoolean, "falseValue");
  var JsonString = class extends Value {
    constructor(s) {
      super();
      if ("string" === typeof s) {
        this._stringBuffer = s;
      }
      if (s instanceof csmString) {
        this._stringBuffer = s.s;
      }
    }
    /**
     * Valuetrue
     */
    isString() {
      return true;
    }
    /**
     * (csmString)
     */
    getString(defaultValue, indent) {
      return this._stringBuffer;
    }
    equals(value) {
      if ("string" === typeof value) {
        return this._stringBuffer == value;
      }
      if (value instanceof csmString) {
        return this._stringBuffer == value.s;
      }
      return false;
    }
  };
  var JsonError = class extends JsonString {
    /**
     * 
     */
    constructor(s, isStatic) {
      var __super = (...args) => {
        super(...args);
        __publicField(this, "_isStatic");
        return this;
      };
      if ("string" === typeof s) {
        __super(s);
      } else {
        __super(s);
      }
      this._isStatic = isStatic;
    }
    /**
     * Valuetrue
     */
    isStatic() {
      return this._isStatic;
    }
    /**
     * 
     */
    setErrorNotForClientCall(s) {
      this._stringBuffer = s;
      return this;
    }
    /**
     * Valuetrue
     */
    isError() {
      return true;
    }
    // Value
  };
  var JsonNullvalue = class extends Value {
    /**
     * ValueNULLtrue
     */
    isNull() {
      return true;
    }
    /**
     * (csmString)
     */
    getString(defaultValue, indent) {
      return this._stringBuffer;
    }
    /**
     * Valuetrue, 
     */
    isStatic() {
      return true;
    }
    /**
     * Value
     */
    setErrorNotForClientCall(s) {
      this._stringBuffer = s;
      return JsonError.nullValue;
    }
    /**
     * 
     */
    constructor() {
      super();
      this._stringBuffer = "NullValue";
    }
  };
  var JsonArray = class extends Value {
    /**
     * 
     */
    constructor() {
      super();
      __publicField(this, "_array");
      this._array = new csmVector();
    }
    /**
     * 
     */
    release() {
      for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.preIncrement()) {
        let v = ite.ptr();
        if (v && !v.isStatic()) {
          v = void 0;
          v = null;
        }
      }
    }
    /**
     * Valuetrue
     */
    isArray() {
      return true;
    }
    /**
     * [index]
     */
    getValueByIndex(index) {
      if (index < 0 || this._array.getSize() <= index) {
        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_INDEX_OF_BOUNDS);
      }
      const v = this._array.at(index);
      if (v == null) {
        return Value.nullValue;
      }
      return v;
    }
    /**
     * [string | csmString]
     */
    getValueByString(s) {
      return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);
    }
    /**
     * (csmString)
     */
    getString(defaultValue, indent) {
      const stringBuffer = indent + "[\n";
      for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.increment()) {
        const v = ite.ptr();
        this._stringBuffer += indent + "" + v.getString(indent + " ") + "\n";
      }
      this._stringBuffer = stringBuffer + indent + "]\n";
      return this._stringBuffer;
    }
    /**
     * 
     * @param v 
     */
    add(v) {
      this._array.pushBack(v);
    }
    /**
     * (csmVector<Value>)
     */
    getVector(defaultValue = null) {
      return this._array;
    }
    /**
     * 
     */
    getSize() {
      return this._array.getSize();
    }
    // JSON
  };
  var JsonMap = class extends Value {
    /**
     * 
     */
    constructor() {
      super();
      __publicField(this, "_map");
      // JSON
      __publicField(this, "_keys");
      this._map = new csmMap();
    }
    /**
     * 
     */
    release() {
      const ite = this._map.begin();
      while (ite.notEqual(this._map.end())) {
        let v = ite.ptr().second;
        if (v && !v.isStatic()) {
          v = void 0;
          v = null;
        }
        ite.preIncrement();
      }
    }
    /**
     * ValueMaptrue
     */
    isMap() {
      return true;
    }
    /**
     * [string | csmString]
     */
    getValueByString(s) {
      if (s instanceof csmString) {
        const ret = this._map.getValue(s.s);
        if (ret == null) {
          return Value.nullValue;
        }
        return ret;
      }
      for (let iter = this._map.begin(); iter.notEqual(this._map.end()); iter.preIncrement()) {
        if (iter.ptr().first == s) {
          if (iter.ptr().second == null) {
            return Value.nullValue;
          }
          return iter.ptr().second;
        }
      }
      return Value.nullValue;
    }
    /**
     * [index]
     */
    getValueByIndex(index) {
      return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);
    }
    /**
     * (csmString)
     */
    getString(defaultValue, indent) {
      this._stringBuffer = indent + "{\n";
      const ite = this._map.begin();
      while (ite.notEqual(this._map.end())) {
        const key = ite.ptr().first;
        const v = ite.ptr().second;
        this._stringBuffer += indent + " " + key + " : " + v.getString(indent + "   ") + " \n";
        ite.preIncrement();
      }
      this._stringBuffer += indent + "}\n";
      return this._stringBuffer;
    }
    /**
     * Map
     */
    getMap(defaultValue) {
      return this._map;
    }
    /**
     * Map
     */
    put(key, v) {
      this._map.setValue(key, v);
    }
    /**
     * Map
     */
    getKeys() {
      if (!this._keys) {
        this._keys = new csmVector();
        const ite = this._map.begin();
        while (ite.notEqual(this._map.end())) {
          const key = ite.ptr().first;
          this._keys.pushBack(key);
          ite.preIncrement();
        }
      }
      return this._keys;
    }
    /**
     * Map
     */
    getSize() {
      return this._keys.getSize();
    }
    // JSON
  };
  var Live2DCubismFramework10;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismJson = CubismJson;
    Live2DCubismFramework42.JsonArray = JsonArray;
    Live2DCubismFramework42.JsonBoolean = JsonBoolean;
    Live2DCubismFramework42.JsonError = JsonError;
    Live2DCubismFramework42.JsonFloat = JsonFloat;
    Live2DCubismFramework42.JsonMap = JsonMap;
    Live2DCubismFramework42.JsonNullvalue = JsonNullvalue;
    Live2DCubismFramework42.JsonString = JsonString;
    Live2DCubismFramework42.Value = Value;
  })(Live2DCubismFramework10 || (Live2DCubismFramework10 = {}));

  // src/Live2D/dist/live2dcubismframework.js
  function strtod(s, endPtr) {
    let index = 0;
    for (let i = 1; ; i++) {
      const testC = s.slice(i - 1, i);
      if (testC == "e" || testC == "-" || testC == "E") {
        continue;
      }
      const test = s.substring(0, i);
      const number = Number(test);
      if (isNaN(number)) {
        break;
      }
      index = i;
    }
    let d = parseFloat(s);
    if (isNaN(d)) {
      d = NaN;
    }
    endPtr[0] = s.slice(index);
    return d;
  }
  var s_isStarted = false;
  var s_isInitialized = false;
  var s_option = null;
  var s_cubismIdManager = null;
  var Constant = Object.freeze({
    vertexOffset: 0,
    // 
    vertexStep: 2
    // 
  });
  function csmDelete(address) {
    if (!address) {
      return;
    }
    address = void 0;
  }
  var CubismFramework = class {
    /**
     * Cubism FrameworkAPI
     *  API
     *  
     *
     * @param    option      Option
     *
     * @return   true
     */
    static startUp(option = null) {
      if (s_isStarted) {
        CubismLogInfo("CubismFramework.startUp() is already done.");
        return s_isStarted;
      }
      s_option = option;
      if (s_option != null) {
        Live2DCubismCore.Logging.csmSetLogFunction(s_option.logFunction);
      }
      s_isStarted = true;
      if (s_isStarted) {
        const version = Live2DCubismCore.Version.csmGetVersion();
        const major = (version & 4278190080) >> 24;
        const minor = (version & 16711680) >> 16;
        const patch = version & 65535;
        const versionNumber = version;
        CubismLogInfo(`Live2D Cubism Core version: {0}.{1}.{2} ({3})`, ("00" + major).slice(-2), ("00" + minor).slice(-2), ("0000" + patch).slice(-4), versionNumber);
      }
      CubismLogInfo("CubismFramework.startUp() is complete.");
      return s_isStarted;
    }
    /**
     * StartUp()CubismFramework
     * Dispose()CubismFramework
     */
    static cleanUp() {
      s_isStarted = false;
      s_isInitialized = false;
      s_option = null;
      s_cubismIdManager = null;
    }
    /**
     * Cubism Framework<br>
     *     Initialize()Dispose()
     *
     * @param memorySize  [byte(s)]
     *    
     *    1024*1024*16 byte(16MB)
     *    1024*1024*16 byte
     */
    static initialize(memorySize = 0) {
      CSM_ASSERT(s_isStarted);
      if (!s_isStarted) {
        CubismLogWarning("CubismFramework is not started.");
        return;
      }
      if (s_isInitialized) {
        CubismLogWarning("CubismFramework.initialize() skipped, already initialized.");
        return;
      }
      Value.staticInitializeNotForClientCall();
      s_cubismIdManager = new CubismIdManager();
      Live2DCubismCore.Memory.initializeAmountOfMemory(memorySize);
      s_isInitialized = true;
      CubismLogInfo("CubismFramework.initialize() is complete.");
    }
    /**
     * Cubism Framework
     *      
     *      
     */
    static dispose() {
      CSM_ASSERT(s_isStarted);
      if (!s_isStarted) {
        CubismLogWarning("CubismFramework is not started.");
        return;
      }
      if (!s_isInitialized) {
        CubismLogWarning("CubismFramework.dispose() skipped, not initialized.");
        return;
      }
      Value.staticReleaseNotForClientCall();
      s_cubismIdManager.release();
      s_cubismIdManager = null;
      CubismRenderer.staticRelease();
      s_isInitialized = false;
      CubismLogInfo("CubismFramework.dispose() is complete.");
    }
    /**
     * Cubism FrameworkAPI
     * @return APItrue
     */
    static isStarted() {
      return s_isStarted;
    }
    /**
     * Cubism Framework
     * @return true
     */
    static isInitialized() {
      return s_isInitialized;
    }
    /**
     * Core API
     *
     * @praram message 
     */
    static coreLogFunction(message) {
      if (!Live2DCubismCore.Logging.csmGetLogFunction()) {
        return;
      }
      Live2DCubismCore.Logging.csmGetLogFunction()(message);
    }
    /**
     * 
     *
     * @return  
     */
    static getLoggingLevel() {
      if (s_option != null) {
        return s_option.loggingLevel;
      }
      return LogLevel.LogLevel_Off;
    }
    /**
     * ID
     * @return CubismManager
     */
    static getIdManager() {
      return s_cubismIdManager;
    }
    /**
     * 
     * 
     */
    constructor() {
    }
  };
  var Option = class {
    constructor() {
      __publicField(this, "logFunction");
      // 
      __publicField(this, "loggingLevel");
    }
    // 
  };
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["LogLevel_Verbose"] = 0] = "LogLevel_Verbose";
    LogLevel2[LogLevel2["LogLevel_Debug"] = 1] = "LogLevel_Debug";
    LogLevel2[LogLevel2["LogLevel_Info"] = 2] = "LogLevel_Info";
    LogLevel2[LogLevel2["LogLevel_Warning"] = 3] = "LogLevel_Warning";
    LogLevel2[LogLevel2["LogLevel_Error"] = 4] = "LogLevel_Error";
    LogLevel2[LogLevel2["LogLevel_Off"] = 5] = "LogLevel_Off";
  })(LogLevel || (LogLevel = {}));
  var Live2DCubismFramework11;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.Constant = Constant;
    Live2DCubismFramework42.csmDelete = csmDelete;
    Live2DCubismFramework42.CubismFramework = CubismFramework;
  })(Live2DCubismFramework11 || (Live2DCubismFramework11 = {}));

  // src/Live2D/dist/math/cubismviewmatrix.js
  var CubismViewMatrix = class extends CubismMatrix44 {
    /**
     * 
     */
    constructor() {
      super();
      __publicField(this, "_screenLeft");
      // X
      __publicField(this, "_screenRight");
      // X
      __publicField(this, "_screenTop");
      // Y
      __publicField(this, "_screenBottom");
      // Y
      __publicField(this, "_maxLeft");
      // X
      __publicField(this, "_maxRight");
      // X
      __publicField(this, "_maxTop");
      // Y
      __publicField(this, "_maxBottom");
      // Y
      __publicField(this, "_maxScale");
      // 
      __publicField(this, "_minScale");
      this._screenLeft = 0;
      this._screenRight = 0;
      this._screenTop = 0;
      this._screenBottom = 0;
      this._maxLeft = 0;
      this._maxRight = 0;
      this._maxTop = 0;
      this._maxBottom = 0;
      this._maxScale = 0;
      this._minScale = 0;
    }
    /**
     * 
     *
     * @param x X
     * @param y Y
     */
    adjustTranslate(x, y) {
      if (this._tr[0] * this._maxLeft + (this._tr[12] + x) > this._screenLeft) {
        x = this._screenLeft - this._tr[0] * this._maxLeft - this._tr[12];
      }
      if (this._tr[0] * this._maxRight + (this._tr[12] + x) < this._screenRight) {
        x = this._screenRight - this._tr[0] * this._maxRight - this._tr[12];
      }
      if (this._tr[5] * this._maxTop + (this._tr[13] + y) < this._screenTop) {
        y = this._screenTop - this._tr[5] * this._maxTop - this._tr[13];
      }
      if (this._tr[5] * this._maxBottom + (this._tr[13] + y) > this._screenBottom) {
        y = this._screenBottom - this._tr[5] * this._maxBottom - this._tr[13];
      }
      const tr1 = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        x,
        y,
        0,
        1
      ]);
      CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 
     *
     * @param cx X
     * @param cy Y
     * @param scale 
     */
    adjustScale(cx, cy, scale) {
      const maxScale = this.getMaxScale();
      const minScale = this.getMinScale();
      const targetScale = scale * this._tr[0];
      if (targetScale < minScale) {
        if (this._tr[0] > 0) {
          scale = minScale / this._tr[0];
        }
      } else if (targetScale > maxScale) {
        if (this._tr[0] > 0) {
          scale = maxScale / this._tr[0];
        }
      }
      const tr1 = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        cx,
        cy,
        0,
        1
      ]);
      const tr2 = new Float32Array([
        scale,
        0,
        0,
        0,
        0,
        scale,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
      const tr3 = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        -cx,
        -cy,
        0,
        1
      ]);
      CubismMatrix44.multiply(tr3, this._tr, this._tr);
      CubismMatrix44.multiply(tr2, this._tr, this._tr);
      CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 
     *
     * @param left      X
     * @param right     X
     * @param bottom    Y
     * @param top       Y
     */
    setScreenRect(left, right, bottom, top) {
      this._screenLeft = left;
      this._screenRight = right;
      this._screenBottom = bottom;
      this._screenTop = top;
    }
    /**
     * 
     * @param left      X
     * @param right     X
     * @param bottom    Y
     * @param top       Y
     */
    setMaxScreenRect(left, right, bottom, top) {
      this._maxLeft = left;
      this._maxRight = right;
      this._maxTop = top;
      this._maxBottom = bottom;
    }
    /**
     * 
     * @param maxScale 
     */
    setMaxScale(maxScale) {
      this._maxScale = maxScale;
    }
    /**
     * 
     * @param minScale 
     */
    setMinScale(minScale) {
      this._minScale = minScale;
    }
    /**
     * 
     * @return 
     */
    getMaxScale() {
      return this._maxScale;
    }
    /**
     * 
     * @return 
     */
    getMinScale() {
      return this._minScale;
    }
    /**
     * 
     *
     * @return true 
     * @return false 
     */
    isMaxScale() {
      return this.getScaleX() >= this._maxScale;
    }
    /**
     * 
     *
     * @return true 
     * @return false 
     */
    isMinScale() {
      return this.getScaleX() <= this._minScale;
    }
    /**
     * 
     * @return X
     */
    getScreenLeft() {
      return this._screenLeft;
    }
    /**
     * 
     * @return X
     */
    getScreenRight() {
      return this._screenRight;
    }
    /**
     * Y
     * @return Y
     */
    getScreenBottom() {
      return this._screenBottom;
    }
    /**
     * Y
     * @return Y
     */
    getScreenTop() {
      return this._screenTop;
    }
    /**
     * X
     * @return X
     */
    getMaxLeft() {
      return this._maxLeft;
    }
    /**
     * X
     * @return X
     */
    getMaxRight() {
      return this._maxRight;
    }
    /**
     * Y
     * @return Y
     */
    getMaxBottom() {
      return this._maxBottom;
    }
    /**
     * Y
     * @return Y
     */
    getMaxTop() {
      return this._maxTop;
    }
    // 
  };
  var Live2DCubismFramework12;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismViewMatrix = CubismViewMatrix;
  })(Live2DCubismFramework12 || (Live2DCubismFramework12 = {}));

  // src/Live2D/lappglmanager.js
  var s_instance = null;
  var LAppGlManager = class _LAppGlManager {
    /**
     * 
     * 
     *
     * @return 
     */
    static getInstance(canvas) {
      if (s_instance == null) {
        s_instance = new _LAppGlManager(canvas);
      }
      return s_instance;
    }
    /**
     * 
     */
    static releaseInstance() {
      if (s_instance != null) {
        s_instance.release();
      }
      s_instance = null;
    }
    constructor(canvas) {
      this.gl = canvas.getContext("webgl");
      if (!this.gl) {
        alert("[L2D] Cannot initialize WebGL. This browser does not support.");
        this.gl = null;
      }
    }
    /**
     * 
     */
    release() {
    }
  };

  // src/Live2D/lappdefine.js
  var ModelDir = [
    "Ver.7"
  ];
  var ModelDirSize = ModelDir.length;
  var MotionGroupIdle = "Idle";
  var PriorityIdle = 1;
  var PriorityForce = 3;
  var MOCConsistencyValidationEnable = true;
  var CubismLoggingLevel = LogLevel.LogLevel_Verbose;

  // src/Live2D/dist/cubismdefaultparameterid.js
  var CubismDefaultParameterId = Object.freeze({
    // ID
    HitAreaPrefix: "HitArea",
    HitAreaHead: "Head",
    HitAreaBody: "Body",
    PartsIdCore: "Parts01Core",
    PartsArmPrefix: "Parts01Arm_",
    PartsArmLPrefix: "Parts01ArmL_",
    PartsArmRPrefix: "Parts01ArmR_",
    // ID
    ParamAngleX: "ParamAngleX",
    ParamAngleY: "ParamAngleY",
    ParamAngleZ: "ParamAngleZ",
    ParamEyeLOpen: "ParamEyeLOpen",
    ParamEyeLSmile: "ParamEyeLSmile",
    ParamEyeROpen: "ParamEyeROpen",
    ParamEyeRSmile: "ParamEyeRSmile",
    ParamEyeBallX: "ParamEyeBallX",
    ParamEyeBallY: "ParamEyeBallY",
    ParamEyeBallForm: "ParamEyeBallForm",
    ParamBrowLY: "ParamBrowLY",
    ParamBrowRY: "ParamBrowRY",
    ParamBrowLX: "ParamBrowLX",
    ParamBrowRX: "ParamBrowRX",
    ParamBrowLAngle: "ParamBrowLAngle",
    ParamBrowRAngle: "ParamBrowRAngle",
    ParamBrowLForm: "ParamBrowLForm",
    ParamBrowRForm: "ParamBrowRForm",
    ParamMouthForm: "ParamMouthForm",
    ParamMouthOpenY: "ParamMouthOpenY",
    ParamCheek: "ParamCheek",
    ParamBodyAngleX: "ParamBodyAngleX",
    ParamBodyAngleY: "ParamBodyAngleY",
    ParamBodyAngleZ: "ParamBodyAngleZ",
    ParamBreath: "ParamBreath",
    ParamArmLA: "ParamArmLA",
    ParamArmRA: "ParamArmRA",
    ParamArmLB: "ParamArmLB",
    ParamArmRB: "ParamArmRB",
    ParamHandL: "ParamHandL",
    ParamHandR: "ParamHandR",
    ParamHairFront: "ParamHairFront",
    ParamHairSide: "ParamHairSide",
    ParamHairBack: "ParamHairBack",
    ParamHairFluffy: "ParamHairFluffy",
    ParamShoulderY: "ParamShoulderY",
    ParamBustX: "ParamBustX",
    ParamBustY: "ParamBustY",
    ParamBaseX: "ParamBaseX",
    ParamBaseY: "ParamBaseY",
    ParamNONE: "NONE:"
  });
  var Live2DCubismFramework13;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.HitAreaBody = CubismDefaultParameterId.HitAreaBody;
    Live2DCubismFramework42.HitAreaHead = CubismDefaultParameterId.HitAreaHead;
    Live2DCubismFramework42.HitAreaPrefix = CubismDefaultParameterId.HitAreaPrefix;
    Live2DCubismFramework42.ParamAngleX = CubismDefaultParameterId.ParamAngleX;
    Live2DCubismFramework42.ParamAngleY = CubismDefaultParameterId.ParamAngleY;
    Live2DCubismFramework42.ParamAngleZ = CubismDefaultParameterId.ParamAngleZ;
    Live2DCubismFramework42.ParamArmLA = CubismDefaultParameterId.ParamArmLA;
    Live2DCubismFramework42.ParamArmLB = CubismDefaultParameterId.ParamArmLB;
    Live2DCubismFramework42.ParamArmRA = CubismDefaultParameterId.ParamArmRA;
    Live2DCubismFramework42.ParamArmRB = CubismDefaultParameterId.ParamArmRB;
    Live2DCubismFramework42.ParamBaseX = CubismDefaultParameterId.ParamBaseX;
    Live2DCubismFramework42.ParamBaseY = CubismDefaultParameterId.ParamBaseY;
    Live2DCubismFramework42.ParamBodyAngleX = CubismDefaultParameterId.ParamBodyAngleX;
    Live2DCubismFramework42.ParamBodyAngleY = CubismDefaultParameterId.ParamBodyAngleY;
    Live2DCubismFramework42.ParamBodyAngleZ = CubismDefaultParameterId.ParamBodyAngleZ;
    Live2DCubismFramework42.ParamBreath = CubismDefaultParameterId.ParamBreath;
    Live2DCubismFramework42.ParamBrowLAngle = CubismDefaultParameterId.ParamBrowLAngle;
    Live2DCubismFramework42.ParamBrowLForm = CubismDefaultParameterId.ParamBrowLForm;
    Live2DCubismFramework42.ParamBrowLX = CubismDefaultParameterId.ParamBrowLX;
    Live2DCubismFramework42.ParamBrowLY = CubismDefaultParameterId.ParamBrowLY;
    Live2DCubismFramework42.ParamBrowRAngle = CubismDefaultParameterId.ParamBrowRAngle;
    Live2DCubismFramework42.ParamBrowRForm = CubismDefaultParameterId.ParamBrowRForm;
    Live2DCubismFramework42.ParamBrowRX = CubismDefaultParameterId.ParamBrowRX;
    Live2DCubismFramework42.ParamBrowRY = CubismDefaultParameterId.ParamBrowRY;
    Live2DCubismFramework42.ParamBustX = CubismDefaultParameterId.ParamBustX;
    Live2DCubismFramework42.ParamBustY = CubismDefaultParameterId.ParamBustY;
    Live2DCubismFramework42.ParamCheek = CubismDefaultParameterId.ParamCheek;
    Live2DCubismFramework42.ParamEyeBallForm = CubismDefaultParameterId.ParamEyeBallForm;
    Live2DCubismFramework42.ParamEyeBallX = CubismDefaultParameterId.ParamEyeBallX;
    Live2DCubismFramework42.ParamEyeBallY = CubismDefaultParameterId.ParamEyeBallY;
    Live2DCubismFramework42.ParamEyeLOpen = CubismDefaultParameterId.ParamEyeLOpen;
    Live2DCubismFramework42.ParamEyeLSmile = CubismDefaultParameterId.ParamEyeLSmile;
    Live2DCubismFramework42.ParamEyeROpen = CubismDefaultParameterId.ParamEyeROpen;
    Live2DCubismFramework42.ParamEyeRSmile = CubismDefaultParameterId.ParamEyeRSmile;
    Live2DCubismFramework42.ParamHairBack = CubismDefaultParameterId.ParamHairBack;
    Live2DCubismFramework42.ParamHairFluffy = CubismDefaultParameterId.ParamHairFluffy;
    Live2DCubismFramework42.ParamHairFront = CubismDefaultParameterId.ParamHairFront;
    Live2DCubismFramework42.ParamHairSide = CubismDefaultParameterId.ParamHairSide;
    Live2DCubismFramework42.ParamHandL = CubismDefaultParameterId.ParamHandL;
    Live2DCubismFramework42.ParamHandR = CubismDefaultParameterId.ParamHandR;
    Live2DCubismFramework42.ParamMouthForm = CubismDefaultParameterId.ParamMouthForm;
    Live2DCubismFramework42.ParamMouthOpenY = CubismDefaultParameterId.ParamMouthOpenY;
    Live2DCubismFramework42.ParamNONE = CubismDefaultParameterId.ParamNONE;
    Live2DCubismFramework42.ParamShoulderY = CubismDefaultParameterId.ParamShoulderY;
    Live2DCubismFramework42.PartsArmLPrefix = CubismDefaultParameterId.PartsArmLPrefix;
    Live2DCubismFramework42.PartsArmPrefix = CubismDefaultParameterId.PartsArmPrefix;
    Live2DCubismFramework42.PartsArmRPrefix = CubismDefaultParameterId.PartsArmRPrefix;
    Live2DCubismFramework42.PartsIdCore = CubismDefaultParameterId.PartsIdCore;
  })(Live2DCubismFramework13 || (Live2DCubismFramework13 = {}));

  // src/Live2D/dist/icubismmodelsetting.js
  var ICubismModelSetting = class {
  };
  var Live2DCubismFramework14;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.ICubismModelSetting = ICubismModelSetting;
  })(Live2DCubismFramework14 || (Live2DCubismFramework14 = {}));

  // src/Live2D/dist/cubismmodelsettingjson.js
  var FileReferences = "FileReferences";
  var Groups = "Groups";
  var Layout = "Layout";
  var HitAreas = "HitAreas";
  var Moc = "Moc";
  var Textures = "Textures";
  var Physics = "Physics";
  var Pose = "Pose";
  var Expressions = "Expressions";
  var Motions = "Motions";
  var UserData = "UserData";
  var Name = "Name";
  var FilePath = "File";
  var Id = "Id";
  var Ids = "Ids";
  var SoundPath = "Sound";
  var FadeInTime = "FadeInTime";
  var FadeOutTime = "FadeOutTime";
  var LipSync = "LipSync";
  var EyeBlink = "EyeBlink";
  var FrequestNode;
  (function(FrequestNode2) {
    FrequestNode2[FrequestNode2["FrequestNode_Groups"] = 0] = "FrequestNode_Groups";
    FrequestNode2[FrequestNode2["FrequestNode_Moc"] = 1] = "FrequestNode_Moc";
    FrequestNode2[FrequestNode2["FrequestNode_Motions"] = 2] = "FrequestNode_Motions";
    FrequestNode2[FrequestNode2["FrequestNode_Expressions"] = 3] = "FrequestNode_Expressions";
    FrequestNode2[FrequestNode2["FrequestNode_Textures"] = 4] = "FrequestNode_Textures";
    FrequestNode2[FrequestNode2["FrequestNode_Physics"] = 5] = "FrequestNode_Physics";
    FrequestNode2[FrequestNode2["FrequestNode_Pose"] = 6] = "FrequestNode_Pose";
    FrequestNode2[FrequestNode2["FrequestNode_HitAreas"] = 7] = "FrequestNode_HitAreas";
  })(FrequestNode || (FrequestNode = {}));
  var CubismModelSettingJson = class extends ICubismModelSetting {
    /**
     * 
     *
     * @param buffer    Model3Json
     * @param size      Model3Json
     */
    constructor(buffer, size) {
      super();
      __publicField(this, "_json");
      __publicField(this, "_jsonValue");
      this._json = CubismJson.create(buffer, size);
      if (this.getJson()) {
        this._jsonValue = new csmVector();
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(Groups));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Moc));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Motions));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Expressions));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Textures));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Physics));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Pose));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(HitAreas));
      }
    }
    /**
     * 
     */
    release() {
      CubismJson.delete(this._json);
      this._jsonValue = null;
    }
    /**
     * CubismJson
     *
     * @return CubismJson
     */
    getJson() {
      return this._json;
    }
    /**
     * Moc
     * @return Moc
     */
    getModelFileName() {
      if (!this.isExistModelFile()) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Moc).getRawString();
    }
    /**
     * 
     * 
     */
    getTextureCount() {
      if (!this.isExistTextureFiles()) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Textures).getSize();
    }
    /**
     * 
     * @return 
     */
    getTextureDirectory() {
      const texturePath = this._jsonValue.at(FrequestNode.FrequestNode_Textures).getValueByIndex(0).getRawString();
      const pathArray = texturePath.split("/");
      const arrayLength = pathArray.length - 1;
      let textureDirectoryStr = "";
      for (let i = 0; i < arrayLength; i++) {
        textureDirectoryStr += pathArray[i];
        if (i < arrayLength - 1) {
          textureDirectoryStr += "/";
        }
      }
      return textureDirectoryStr;
    }
    /**
     * 
     * @param index 
     * @return 
     */
    getTextureFileName(index) {
      return this._jsonValue.at(FrequestNode.FrequestNode_Textures).getValueByIndex(index).getRawString();
    }
    /**
     * 
     * @return 
     */
    getHitAreasCount() {
      if (!this.isExistHitAreas()) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_HitAreas).getSize();
    }
    /**
     * ID
     *
     * @param index index
     * @return ID
     */
    getHitAreaId(index) {
      return CubismFramework.getIdManager().getId(this._jsonValue.at(FrequestNode.FrequestNode_HitAreas).getValueByIndex(index).getValueByString(Id).getRawString());
    }
    /**
     * 
     * @param index 
     * @return 
     */
    getHitAreaName(index) {
      return this._jsonValue.at(FrequestNode.FrequestNode_HitAreas).getValueByIndex(index).getValueByString(Name).getRawString();
    }
    /**
     * 
     * @return 
     */
    getPhysicsFileName() {
      if (!this.isExistPhysicsFile()) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Physics).getRawString();
    }
    /**
     * 
     * @return 
     */
    getPoseFileName() {
      if (!this.isExistPoseFile()) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Pose).getRawString();
    }
    /**
     * 
     * @return 
     */
    getExpressionCount() {
      if (!this.isExistExpressionFile()) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Expressions).getSize();
    }
    /**
     * 
     * @param index 
     * @return 
     */
    getExpressionName(index) {
      return this._jsonValue.at(FrequestNode.FrequestNode_Expressions).getValueByIndex(index).getValueByString(Name).getRawString();
    }
    /**
     * 
     * @param index 
     * @return 
     */
    getExpressionFileName(index) {
      return this._jsonValue.at(FrequestNode.FrequestNode_Expressions).getValueByIndex(index).getValueByString(FilePath).getRawString();
    }
    /**
     * 
     * @return 
     */
    getMotionGroupCount() {
      if (!this.isExistMotionGroups()) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getKeys().getSize();
    }
    /**
     * 
     * @param index 
     * @return 
     */
    getMotionGroupName(index) {
      if (!this.isExistMotionGroups()) {
        return null;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getKeys().at(index);
    }
    /**
     * 
     * @param groupName 
     * @return 
     */
    getMotionCount(groupName) {
      if (!this.isExistMotionGroupName(groupName)) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getSize();
    }
    /**
     * 
     * @param groupName 
     * @param index     
     * @return 
     */
    getMotionFileName(groupName, index) {
      if (!this.isExistMotionGroupName(groupName)) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FilePath).getRawString();
    }
    /**
     * 
     * @param groupName 
     * @param index 
     * @return 
     */
    getMotionSoundFileName(groupName, index) {
      if (!this.isExistMotionSoundFile(groupName, index)) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(SoundPath).getRawString();
    }
    /**
     * 
     * @param groupName 
     * @param index 
     * @return []
     */
    getMotionFadeInTimeValue(groupName, index) {
      if (!this.isExistMotionFadeIn(groupName, index)) {
        return -1;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeInTime).toFloat();
    }
    /**
     * 
     * @param groupName 
     * @param index 
     * @return []
     */
    getMotionFadeOutTimeValue(groupName, index) {
      if (!this.isExistMotionFadeOut(groupName, index)) {
        return -1;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeOutTime).toFloat();
    }
    /**
     * 
     * @return 
     */
    getUserDataFile() {
      if (!this.isExistUserDataFile()) {
        return "";
      }
      return this.getJson().getRoot().getValueByString(FileReferences).getValueByString(UserData).getRawString();
    }
    /**
     * 
     * @param outLayoutMap csmMap
     * @return true 
     * @return false 
     */
    getLayoutMap(outLayoutMap) {
      const map = this.getJson().getRoot().getValueByString(Layout).getMap();
      if (map == null) {
        return false;
      }
      let ret = false;
      for (const ite = map.begin(); ite.notEqual(map.end()); ite.preIncrement()) {
        outLayoutMap.setValue(ite.ptr().first, ite.ptr().second.toFloat());
        ret = true;
      }
      return ret;
    }
    /**
     * 
     * @return 
     */
    getEyeBlinkParameterCount() {
      if (!this.isExistEyeBlinkParameters()) {
        return 0;
      }
      let num = 0;
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {
        const refI = this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i);
        if (refI.isNull() || refI.isError()) {
          continue;
        }
        if (refI.getValueByString(Name).getRawString() == EyeBlink) {
          num = refI.getValueByString(Ids).getVector().getSize();
          break;
        }
      }
      return num;
    }
    /**
     * ID
     * @param index 
     * @return ID
     */
    getEyeBlinkParameterId(index) {
      if (!this.isExistEyeBlinkParameters()) {
        return null;
      }
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {
        const refI = this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i);
        if (refI.isNull() || refI.isError()) {
          continue;
        }
        if (refI.getValueByString(Name).getRawString() == EyeBlink) {
          return CubismFramework.getIdManager().getId(refI.getValueByString(Ids).getValueByIndex(index).getRawString());
        }
      }
      return null;
    }
    /**
     * 
     * @return 
     */
    getLipSyncParameterCount() {
      if (!this.isExistLipSyncParameters()) {
        return 0;
      }
      let num = 0;
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {
        const refI = this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i);
        if (refI.isNull() || refI.isError()) {
          continue;
        }
        if (refI.getValueByString(Name).getRawString() == LipSync) {
          num = refI.getValueByString(Ids).getVector().getSize();
          break;
        }
      }
      return num;
    }
    /**
     * 
     * @param index 
     * @return ID
     */
    getLipSyncParameterId(index) {
      if (!this.isExistLipSyncParameters()) {
        return null;
      }
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {
        const refI = this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i);
        if (refI.isNull() || refI.isError()) {
          continue;
        }
        if (refI.getValueByString(Name).getRawString() == LipSync) {
          return CubismFramework.getIdManager().getId(refI.getValueByString(Ids).getValueByIndex(index).getRawString());
        }
      }
      return null;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistModelFile() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Moc);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistTextureFiles() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Textures);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistHitAreas() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_HitAreas);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistPhysicsFile() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Physics);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistPoseFile() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Pose);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistExpressionFile() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Expressions);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistMotionGroups() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @param groupName  
     * @return true 
     * @return false 
     */
    isExistMotionGroupName(groupName) {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @param groupName  
     * @param index 
     * @return true 
     * @return false 
     */
    isExistMotionSoundFile(groupName, index) {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(SoundPath);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @param groupName  
     * @param index 
     * @return true 
     * @return false 
     */
    isExistMotionFadeIn(groupName, index) {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeInTime);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @param groupName  
     * @param index 
     * @return true 
     * @return false 
     */
    isExistMotionFadeOut(groupName, index) {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeOutTime);
      return !node.isNull() && !node.isError();
    }
    /**
     * UserData
     * @return true 
     * @return false 
     */
    isExistUserDataFile() {
      const node = this.getJson().getRoot().getValueByString(FileReferences).getValueByString(UserData);
      return !node.isNull() && !node.isError();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistEyeBlinkParameters() {
      if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).isNull() || this._jsonValue.at(FrequestNode.FrequestNode_Groups).isError()) {
        return false;
      }
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); ++i) {
        if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i).getValueByString(Name).getRawString() == EyeBlink) {
          return true;
        }
      }
      return false;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistLipSyncParameters() {
      if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).isNull() || this._jsonValue.at(FrequestNode.FrequestNode_Groups).isError()) {
        return false;
      }
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); ++i) {
        if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i).getValueByString(Name).getRawString() == LipSync) {
          return true;
        }
      }
      return false;
    }
  };
  var Live2DCubismFramework15;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModelSettingJson = CubismModelSettingJson;
  })(Live2DCubismFramework15 || (Live2DCubismFramework15 = {}));

  // src/Live2D/dist/effect/cubismbreath.js
  var CubismBreath = class _CubismBreath {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_breathParameters");
      // 
      __publicField(this, "_currentTime");
      this._currentTime = 0;
    }
    /**
     * 
     */
    static create() {
      return new _CubismBreath();
    }
    /**
     * 
     * @param instance CubismBreath
     */
    static delete(instance) {
      if (instance != null) {
        instance = null;
      }
    }
    /**
     * 
     * @param breathParameters 
     */
    setParameters(breathParameters) {
      this._breathParameters = breathParameters;
    }
    /**
     * 
     * @return 
     */
    getParameters() {
      return this._breathParameters;
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     */
    updateParameters(model, deltaTimeSeconds) {
      this._currentTime += deltaTimeSeconds;
      const t2 = this._currentTime * 2 * 3.14159;
      for (let i = 0; i < this._breathParameters.getSize(); ++i) {
        const data = this._breathParameters.at(i);
        model.addParameterValueById(data.parameterId, data.offset + data.peak * Math.sin(t2 / data.cycle), data.weight);
      }
    }
    // []
  };
  var BreathParameterData = class {
    /**
     * 
     * @param parameterId   ID
     * @param offset        
     * @param peak          
     * @param cycle         
     * @param weight        
     */
    constructor(parameterId, offset, peak, cycle, weight) {
      __publicField(this, "parameterId");
      // ID\
      __publicField(this, "offset");
      // 
      __publicField(this, "peak");
      // 
      __publicField(this, "cycle");
      // 
      __publicField(this, "weight");
      this.parameterId = parameterId == void 0 ? null : parameterId;
      this.offset = offset == void 0 ? 0 : offset;
      this.peak = peak == void 0 ? 0 : peak;
      this.cycle = cycle == void 0 ? 0 : cycle;
      this.weight = weight == void 0 ? 0 : weight;
    }
    // 
  };
  var Live2DCubismFramework16;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.BreathParameterData = BreathParameterData;
    Live2DCubismFramework42.CubismBreath = CubismBreath;
  })(Live2DCubismFramework16 || (Live2DCubismFramework16 = {}));

  // src/Live2D/dist/effect/cubismeyeblink.js
  var _CubismEyeBlink = class _CubismEyeBlink {
    /**
     * 
     * @param modelSetting 
     */
    constructor(modelSetting) {
      __publicField(this, "_blinkingState");
      // 
      __publicField(this, "_parameterIds");
      // ID
      __publicField(this, "_nextBlinkingTime");
      // []
      __publicField(this, "_stateStartTimeSeconds");
      // []
      __publicField(this, "_blinkingIntervalSeconds");
      // []
      __publicField(this, "_closingSeconds");
      // []
      __publicField(this, "_closedSeconds");
      // []
      __publicField(this, "_openingSeconds");
      // []
      __publicField(this, "_userTimeSeconds");
      this._blinkingState = EyeState.EyeState_First;
      this._nextBlinkingTime = 0;
      this._stateStartTimeSeconds = 0;
      this._blinkingIntervalSeconds = 4;
      this._closingSeconds = 0.1;
      this._closedSeconds = 0.05;
      this._openingSeconds = 0.15;
      this._userTimeSeconds = 0;
      this._parameterIds = new csmVector();
      if (modelSetting == null) {
        return;
      }
      for (let i = 0; i < modelSetting.getEyeBlinkParameterCount(); ++i) {
        this._parameterIds.pushBack(modelSetting.getEyeBlinkParameterId(i));
      }
    }
    /**
     * 
     * @param modelSetting 
     * @return 
     * @note NULLID
     */
    static create(modelSetting = null) {
      return new _CubismEyeBlink(modelSetting);
    }
    /**
     * 
     * @param eyeBlink CubismEyeBlink
     */
    static delete(eyeBlink) {
      if (eyeBlink != null) {
        eyeBlink = null;
      }
    }
    /**
     * 
     * @param blinkingInterval []
     */
    setBlinkingInterval(blinkingInterval) {
      this._blinkingIntervalSeconds = blinkingInterval;
    }
    /**
     * 
     * @param closing   []
     * @param closed    []
     * @param opening   []
     */
    setBlinkingSetting(closing, closed, opening) {
      this._closingSeconds = closing;
      this._closedSeconds = closed;
      this._openingSeconds = opening;
    }
    /**
     * ID
     * @param parameterIds ID
     */
    setParameterIds(parameterIds) {
      this._parameterIds = parameterIds;
    }
    /**
     * ID
     * @return ID
     */
    getParameterIds() {
      return this._parameterIds;
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     */
    updateParameters(model, deltaTimeSeconds) {
      this._userTimeSeconds += deltaTimeSeconds;
      let parameterValue;
      let t2 = 0;
      const blinkingState = this._blinkingState;
      switch (blinkingState) {
        case EyeState.EyeState_Closing:
          t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closingSeconds;
          if (t2 >= 1) {
            t2 = 1;
            this._blinkingState = EyeState.EyeState_Closed;
            this._stateStartTimeSeconds = this._userTimeSeconds;
          }
          parameterValue = 1 - t2;
          break;
        case EyeState.EyeState_Closed:
          t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closedSeconds;
          if (t2 >= 1) {
            this._blinkingState = EyeState.EyeState_Opening;
            this._stateStartTimeSeconds = this._userTimeSeconds;
          }
          parameterValue = 0;
          break;
        case EyeState.EyeState_Opening:
          t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._openingSeconds;
          if (t2 >= 1) {
            t2 = 1;
            this._blinkingState = EyeState.EyeState_Interval;
            this._nextBlinkingTime = this.determinNextBlinkingTiming();
          }
          parameterValue = t2;
          break;
        case EyeState.EyeState_Interval:
          if (this._nextBlinkingTime < this._userTimeSeconds) {
            this._blinkingState = EyeState.EyeState_Closing;
            this._stateStartTimeSeconds = this._userTimeSeconds;
          }
          parameterValue = 1;
          break;
        case EyeState.EyeState_First:
        default:
          this._blinkingState = EyeState.EyeState_Interval;
          this._nextBlinkingTime = this.determinNextBlinkingTiming();
          parameterValue = 1;
          break;
      }
      if (!_CubismEyeBlink.CloseIfZero) {
        parameterValue = -parameterValue;
      }
      for (let i = 0; i < this._parameterIds.getSize(); ++i) {
        model.setParameterValueById(this._parameterIds.at(i), parameterValue);
      }
    }
    /**
     * 
     *
     * @return []
     */
    determinNextBlinkingTiming() {
      const r = Math.random();
      return this._userTimeSeconds + r * (2 * this._blinkingIntervalSeconds - 1);
    }
  };
  // []
  /**
   * ID0 true 1 false 
   */
  __publicField(_CubismEyeBlink, "CloseIfZero", true);
  var CubismEyeBlink = _CubismEyeBlink;
  var EyeState;
  (function(EyeState2) {
    EyeState2[EyeState2["EyeState_First"] = 0] = "EyeState_First";
    EyeState2[EyeState2["EyeState_Interval"] = 1] = "EyeState_Interval";
    EyeState2[EyeState2["EyeState_Closing"] = 2] = "EyeState_Closing";
    EyeState2[EyeState2["EyeState_Closed"] = 3] = "EyeState_Closed";
    EyeState2[EyeState2["EyeState_Opening"] = 4] = "EyeState_Opening";
  })(EyeState || (EyeState = {}));
  var Live2DCubismFramework17;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismEyeBlink = CubismEyeBlink;
    Live2DCubismFramework42.EyeState = EyeState;
  })(Live2DCubismFramework17 || (Live2DCubismFramework17 = {}));

  // src/Live2D/dist/effect/cubismpose.js
  var Epsilon = 1e-3;
  var DefaultFadeInSeconds = 0.5;
  var FadeIn = "FadeInTime";
  var Link = "Link";
  var Groups2 = "Groups";
  var Id2 = "Id";
  var CubismPose = class _CubismPose {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_partGroups");
      // 
      __publicField(this, "_partGroupCounts");
      // 
      __publicField(this, "_fadeTimeSeconds");
      // []
      __publicField(this, "_lastModel");
      this._fadeTimeSeconds = DefaultFadeInSeconds;
      this._lastModel = null;
      this._partGroups = new csmVector();
      this._partGroupCounts = new csmVector();
    }
    /**
     * 
     * @param pose3json pose3.json
     * @param size pose3.json[byte]
     * @return 
     */
    static create(pose3json, size) {
      const json = CubismJson.create(pose3json, size);
      if (!json) {
        return null;
      }
      const ret = new _CubismPose();
      const root = json.getRoot();
      if (!root.getValueByString(FadeIn).isNull()) {
        ret._fadeTimeSeconds = root.getValueByString(FadeIn).toFloat(DefaultFadeInSeconds);
        if (ret._fadeTimeSeconds <= 0) {
          ret._fadeTimeSeconds = DefaultFadeInSeconds;
        }
      }
      const poseListInfo = root.getValueByString(Groups2);
      const poseCount = poseListInfo.getSize();
      for (let poseIndex = 0; poseIndex < poseCount; ++poseIndex) {
        const idListInfo = poseListInfo.getValueByIndex(poseIndex);
        const idCount = idListInfo.getSize();
        let groupCount = 0;
        for (let groupIndex = 0; groupIndex < idCount; ++groupIndex) {
          const partInfo = idListInfo.getValueByIndex(groupIndex);
          const partData = new PartData();
          const parameterId = CubismFramework.getIdManager().getId(partInfo.getValueByString(Id2).getRawString());
          partData.partId = parameterId;
          if (!partInfo.getValueByString(Link).isNull()) {
            const linkListInfo = partInfo.getValueByString(Link);
            const linkCount = linkListInfo.getSize();
            for (let linkIndex = 0; linkIndex < linkCount; ++linkIndex) {
              const linkPart = new PartData();
              const linkId = CubismFramework.getIdManager().getId(linkListInfo.getValueByIndex(linkIndex).getString());
              linkPart.partId = linkId;
              partData.link.pushBack(linkPart);
            }
          }
          ret._partGroups.pushBack(partData.clone());
          ++groupCount;
        }
        ret._partGroupCounts.pushBack(groupCount);
      }
      CubismJson.delete(json);
      return ret;
    }
    /**
     * 
     * @param pose CubismPose
     */
    static delete(pose) {
      if (pose != null) {
        pose = null;
      }
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     */
    updateParameters(model, deltaTimeSeconds) {
      if (model != this._lastModel) {
        this.reset(model);
      }
      this._lastModel = model;
      if (deltaTimeSeconds < 0) {
        deltaTimeSeconds = 0;
      }
      let beginIndex = 0;
      for (let i = 0; i < this._partGroupCounts.getSize(); i++) {
        const partGroupCount = this._partGroupCounts.at(i);
        this.doFade(model, deltaTimeSeconds, beginIndex, partGroupCount);
        beginIndex += partGroupCount;
      }
      this.copyPartOpacities(model);
    }
    /**
     * 
     * @param model 
     * @note 0
     */
    reset(model) {
      let beginIndex = 0;
      for (let i = 0; i < this._partGroupCounts.getSize(); ++i) {
        const groupCount = this._partGroupCounts.at(i);
        for (let j = beginIndex; j < beginIndex + groupCount; ++j) {
          this._partGroups.at(j).initialize(model);
          const partsIndex = this._partGroups.at(j).partIndex;
          const paramIndex = this._partGroups.at(j).parameterIndex;
          if (partsIndex < 0) {
            continue;
          }
          model.setPartOpacityByIndex(partsIndex, j == beginIndex ? 1 : 0);
          model.setParameterValueByIndex(paramIndex, j == beginIndex ? 1 : 0);
          for (let k = 0; k < this._partGroups.at(j).link.getSize(); ++k) {
            this._partGroups.at(j).link.at(k).initialize(model);
          }
        }
        beginIndex += groupCount;
      }
    }
    /**
     * 
     *
     * @param model 
     */
    copyPartOpacities(model) {
      for (let groupIndex = 0; groupIndex < this._partGroups.getSize(); ++groupIndex) {
        const partData = this._partGroups.at(groupIndex);
        if (partData.link.getSize() == 0) {
          continue;
        }
        const partIndex = this._partGroups.at(groupIndex).partIndex;
        const opacity = model.getPartOpacityByIndex(partIndex);
        for (let linkIndex = 0; linkIndex < partData.link.getSize(); ++linkIndex) {
          const linkPart = partData.link.at(linkIndex);
          const linkPartIndex = linkPart.partIndex;
          if (linkPartIndex < 0) {
            continue;
          }
          model.setPartOpacityByIndex(linkPartIndex, opacity);
        }
      }
    }
    /**
     * 
     * @param model 
     * @param deltaTimeSeconds []
     * @param beginIndex 
     * @param partGroupCount 
     */
    doFade(model, deltaTimeSeconds, beginIndex, partGroupCount) {
      let visiblePartIndex = -1;
      let newOpacity = 1;
      const phi = 0.5;
      const backOpacityThreshold = 0.15;
      for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {
        const partIndex = this._partGroups.at(i).partIndex;
        const paramIndex = this._partGroups.at(i).parameterIndex;
        if (model.getParameterValueByIndex(paramIndex) > Epsilon) {
          if (visiblePartIndex >= 0) {
            break;
          }
          visiblePartIndex = i;
          newOpacity = model.getPartOpacityByIndex(partIndex);
          newOpacity += deltaTimeSeconds / this._fadeTimeSeconds;
          if (newOpacity > 1) {
            newOpacity = 1;
          }
        }
      }
      if (visiblePartIndex < 0) {
        visiblePartIndex = 0;
        newOpacity = 1;
      }
      for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {
        const partsIndex = this._partGroups.at(i).partIndex;
        if (visiblePartIndex == i) {
          model.setPartOpacityByIndex(partsIndex, newOpacity);
        } else {
          let opacity = model.getPartOpacityByIndex(partsIndex);
          let a1;
          if (newOpacity < phi) {
            a1 = newOpacity * (phi - 1) / phi + 1;
          } else {
            a1 = (1 - newOpacity) * phi / (1 - phi);
          }
          const backOpacity = (1 - a1) * (1 - newOpacity);
          if (backOpacity > backOpacityThreshold) {
            a1 = 1 - backOpacityThreshold / (1 - newOpacity);
          }
          if (opacity > a1) {
            opacity = a1;
          }
          model.setPartOpacityByIndex(partsIndex, opacity);
        }
      }
    }
    // 
  };
  var PartData = class _PartData {
    /**
     * 
     */
    constructor(v) {
      __publicField(this, "partId");
      // ID
      __publicField(this, "parameterIndex");
      // 
      __publicField(this, "partIndex");
      // 
      __publicField(this, "link");
      this.parameterIndex = 0;
      this.partIndex = 0;
      this.link = new csmVector();
      if (v != void 0) {
        this.partId = v.partId;
        for (const ite = v.link.begin(); ite.notEqual(v.link.end()); ite.preIncrement()) {
          this.link.pushBack(ite.ptr().clone());
        }
      }
    }
    /**
     * =
     */
    assignment(v) {
      this.partId = v.partId;
      for (const ite = v.link.begin(); ite.notEqual(v.link.end()); ite.preIncrement()) {
        this.link.pushBack(ite.ptr().clone());
      }
      return this;
    }
    /**
     * 
     * @param model 
     */
    initialize(model) {
      this.parameterIndex = model.getParameterIndex(this.partId);
      this.partIndex = model.getPartIndex(this.partId);
      model.setParameterValueByIndex(this.parameterIndex, 1);
    }
    /**
     * 
     */
    clone() {
      const clonePartData = new _PartData();
      clonePartData.partId = this.partId;
      clonePartData.parameterIndex = this.parameterIndex;
      clonePartData.partIndex = this.partIndex;
      clonePartData.link = new csmVector();
      for (let ite = this.link.begin(); ite.notEqual(this.link.end()); ite.increment()) {
        clonePartData.link.pushBack(ite.ptr().clone());
      }
      return clonePartData;
    }
    // 
  };
  var Live2DCubismFramework18;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismPose = CubismPose;
    Live2DCubismFramework42.PartData = PartData;
  })(Live2DCubismFramework18 || (Live2DCubismFramework18 = {}));

  // src/Live2D/dist/math/cubismmodelmatrix.js
  var CubismModelMatrix = class extends CubismMatrix44 {
    /**
     * 
     *
     * @param w 
     * @param h 
     */
    constructor(w, h) {
      super();
      __publicField(this, "_width");
      // 
      __publicField(this, "_height");
      this._width = w !== void 0 ? w : 0;
      this._height = h !== void 0 ? h : 0;
      this.setHeight(2);
    }
    /**
     * 
     *
     * @param w 
     */
    setWidth(w) {
      const scaleX = w / this._width;
      const scaleY = scaleX;
      this.scale(scaleX, scaleY);
    }
    /**
     * 
     * @param h 
     */
    setHeight(h) {
      const scaleX = h / this._height;
      const scaleY = scaleX;
      this.scale(scaleX, scaleY);
    }
    /**
     * 
     *
     * @param x X
     * @param y Y
     */
    setPosition(x, y) {
      this.translate(x, y);
    }
    /**
     * 
     *
     * @param x X
     * @param y Y
     *
     * @note widthheight
     */
    setCenterPosition(x, y) {
      this.centerX(x);
      this.centerY(y);
    }
    /**
     * 
     *
     * @param y Y
     */
    top(y) {
      this.setY(y);
    }
    /**
     * 
     *
     * @param y Y
     */
    bottom(y) {
      const h = this._height * this.getScaleY();
      this.translateY(y - h);
    }
    /**
     * 
     *
     * @param x X
     */
    left(x) {
      this.setX(x);
    }
    /**
     * 
     *
     * @param x X
     */
    right(x) {
      const w = this._width * this.getScaleX();
      this.translateX(x - w);
    }
    /**
     * X
     *
     * @param x X
     */
    centerX(x) {
      const w = this._width * this.getScaleX();
      this.translateX(x - w / 2);
    }
    /**
     * X
     *
     * @param x X
     */
    setX(x) {
      this.translateX(x);
    }
    /**
     * Y
     *
     * @param y Y
     */
    centerY(y) {
      const h = this._height * this.getScaleY();
      this.translateY(y - h / 2);
    }
    /**
     * Y
     *
     * @param y Y
     */
    setY(y) {
      this.translateY(y);
    }
    /**
     * 
     *
     * @param layout 
     */
    setupFromLayout(layout) {
      const keyWidth = "width";
      const keyHeight = "height";
      const keyX = "x";
      const keyY = "y";
      const keyCenterX = "center_x";
      const keyCenterY = "center_y";
      const keyTop = "top";
      const keyBottom = "bottom";
      const keyLeft = "left";
      const keyRight = "right";
      for (const ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {
        const key = ite.ptr().first;
        const value = ite.ptr().second;
        if (key == keyWidth) {
          this.setWidth(value);
        } else if (key == keyHeight) {
          this.setHeight(value);
        }
      }
      for (const ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {
        const key = ite.ptr().first;
        const value = ite.ptr().second;
        if (key == keyX) {
          this.setX(value);
        } else if (key == keyY) {
          this.setY(value);
        } else if (key == keyCenterX) {
          this.centerX(value);
        } else if (key == keyCenterY) {
          this.centerY(value);
        } else if (key == keyTop) {
          this.top(value);
        } else if (key == keyBottom) {
          this.bottom(value);
        } else if (key == keyLeft) {
          this.left(value);
        } else if (key == keyRight) {
          this.right(value);
        }
      }
    }
    // 
  };
  var Live2DCubismFramework19;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModelMatrix = CubismModelMatrix;
  })(Live2DCubismFramework19 || (Live2DCubismFramework19 = {}));

  // src/Live2D/dist/math/cubismvector2.js
  var CubismVector2 = class _CubismVector2 {
    /**
     * 
     */
    constructor(x, y) {
      __publicField(this, "x");
      __publicField(this, "y");
      this.x = x;
      this.y = y;
      this.x = x == void 0 ? 0 : x;
      this.y = y == void 0 ? 0 : y;
    }
    /**
     * 
     *
     * @param vector2 
     * @return  
     */
    add(vector2) {
      const ret = new _CubismVector2(0, 0);
      ret.x = this.x + vector2.x;
      ret.y = this.y + vector2.y;
      return ret;
    }
    /**
     * 
     *
     * @param vector2 
     * @return  
     */
    substract(vector2) {
      const ret = new _CubismVector2(0, 0);
      ret.x = this.x - vector2.x;
      ret.y = this.y - vector2.y;
      return ret;
    }
    /**
     * 
     *
     * @param vector2 
     * @return  
     */
    multiply(vector2) {
      const ret = new _CubismVector2(0, 0);
      ret.x = this.x * vector2.x;
      ret.y = this.y * vector2.y;
      return ret;
    }
    /**
     * ()
     *
     * @param scalar 
     * @return  
     */
    multiplyByScaler(scalar) {
      return this.multiply(new _CubismVector2(scalar, scalar));
    }
    /**
     * 
     *
     * @param vector2 
     * @return  
     */
    division(vector2) {
      const ret = new _CubismVector2(0, 0);
      ret.x = this.x / vector2.x;
      ret.y = this.y / vector2.y;
      return ret;
    }
    /**
     * ()
     *
     * @param scalar 
     * @return  
     */
    divisionByScalar(scalar) {
      return this.division(new _CubismVector2(scalar, scalar));
    }
    /**
     * 
     *
     * @return 
     */
    getLength() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * 
     *
     * @param a 
     * @return 
     */
    getDistanceWith(a) {
      return Math.sqrt((this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y));
    }
    /**
     * 
     *
     * @param a 
     * @return 
     */
    dot(a) {
      return this.x * a.x + this.y * a.y;
    }
    /**
     * 
     */
    normalize() {
      const length = Math.pow(this.x * this.x + this.y * this.y, 0.5);
      this.x = this.x / length;
      this.y = this.y / length;
    }
    /**
     * 
     *
     * 
     *
     * @param rhs 
     * @return true 
     * @return false 
     */
    isEqual(rhs) {
      return this.x == rhs.x && this.y == rhs.y;
    }
    /**
     * 
     *
     * 
     *
     * @param rhs 
     * @return true 
     * @return false 
     */
    isNotEqual(rhs) {
      return !this.isEqual(rhs);
    }
  };
  var Live2DCubismFramework20;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismVector2 = CubismVector2;
  })(Live2DCubismFramework20 || (Live2DCubismFramework20 = {}));

  // src/Live2D/dist/math/cubismmath.js
  var _CubismMath = class _CubismMath {
    /**
     * 
     *
     * @param value 
     * @param min   
     * @param max   
     * @return 
     */
    static range(value, min, max) {
      if (value < min) {
        value = min;
      } else if (value > max) {
        value = max;
      }
      return value;
    }
    /**
     * 
     *
     * @param x 
     * @return sin(x)
     */
    static sin(x) {
      return Math.sin(x);
    }
    /**
     * 
     *
     * @param x ()
     * @return cos(x)
     */
    static cos(x) {
      return Math.cos(x);
    }
    /**
     * 
     *
     * @param x 
     * @return 
     */
    static abs(x) {
      return Math.abs(x);
    }
    /**
     * ()
     * @param x -> 
     * @return 
     */
    static sqrt(x) {
      return Math.sqrt(x);
    }
    /**
     * 
     * @param x -> 
     * @return 
     */
    static cbrt(x) {
      if (x === 0) {
        return x;
      }
      let cx = x;
      const isNegativeNumber = cx < 0;
      if (isNegativeNumber) {
        cx = -cx;
      }
      let ret;
      if (cx === Infinity) {
        ret = Infinity;
      } else {
        ret = Math.exp(Math.log(cx) / 3);
        ret = (cx / (ret * ret) + 2 * ret) / 3;
      }
      return isNegativeNumber ? -ret : ret;
    }
    /**
     * 
     * 
     *
     * @param value 
     * @return 
     */
    static getEasingSine(value) {
      if (value < 0) {
        return 0;
      } else if (value > 1) {
        return 1;
      }
      return 0.5 - 0.5 * this.cos(value * Math.PI);
    }
    /**
     * 
     *
     * @param left 
     * @param right 
     * @return 
     */
    static max(left, right) {
      return left > right ? left : right;
    }
    /**
     * 
     *
     * @param left  
     * @param right 
     * @return 
     */
    static min(left, right) {
      return left > right ? right : left;
    }
    /**
     * 
     *
     * @param degrees   
     * @return 
     */
    static degreesToRadian(degrees) {
      return degrees / 180 * Math.PI;
    }
    /**
     * 
     *
     * @param radian    
     * @return 
     */
    static radianToDegrees(radian) {
      return radian * 180 / Math.PI;
    }
    /**
     * 
     *
     * @param from  
     * @param to    
     * @return 
     */
    static directionToRadian(from, to) {
      const q1 = Math.atan2(to.y, to.x);
      const q2 = Math.atan2(from.y, from.x);
      let ret = q1 - q2;
      while (ret < -Math.PI) {
        ret += Math.PI * 2;
      }
      while (ret > Math.PI) {
        ret -= Math.PI * 2;
      }
      return ret;
    }
    /**
     * 
     *
     * @param from  
     * @param to    
     * @return 
     */
    static directionToDegrees(from, to) {
      const radian = this.directionToRadian(from, to);
      let degree = this.radianToDegrees(radian);
      if (to.x - from.x > 0) {
        degree = -degree;
      }
      return degree;
    }
    /**
     * 
     *
     * @param totalAngle    
     * @return 
     */
    static radianToDirection(totalAngle) {
      const ret = new CubismVector2();
      ret.x = this.sin(totalAngle);
      ret.y = this.cos(totalAngle);
      return ret;
    }
    /**
     * 0
     * a * x^2 + b * x + c = 0
     *
     * @param   a -> 
     * @param   b -> 
     * @param   c -> 
     * @return  
     */
    static quadraticEquation(a, b, c) {
      if (this.abs(a) < _CubismMath.Epsilon) {
        if (this.abs(b) < _CubismMath.Epsilon) {
          return -c;
        }
        return -c / b;
      }
      return -(b + this.sqrt(b * b - 4 * a * c)) / (2 * a);
    }
    /**
     * t
     * 0.01.0
     *
     * a * x^3 + b * x^2 + c * x + d = 0
     *
     * @param   a -> 
     * @param   b -> 
     * @param   c -> 
     * @param   d -> 
     * @return  0.01.0
     */
    static cardanoAlgorithmForBezier(a, b, c, d) {
      if (this.sqrt(a) < _CubismMath.Epsilon) {
        return this.range(this.quadraticEquation(b, c, d), 0, 1);
      }
      const ba = b / a;
      const ca = c / a;
      const da = d / a;
      const p = (3 * ca - ba * ba) / 3;
      const p3 = p / 3;
      const q = (2 * ba * ba * ba - 9 * ba * ca + 27 * da) / 27;
      const q2 = q / 2;
      const discriminant = q2 * q2 + p3 * p3 * p3;
      const center = 0.5;
      const threshold = center + 0.01;
      if (discriminant < 0) {
        const mp3 = -p / 3;
        const mp33 = mp3 * mp3 * mp3;
        const r = this.sqrt(mp33);
        const t2 = -q / (2 * r);
        const cosphi = this.range(t2, -1, 1);
        const phi = Math.acos(cosphi);
        const crtr = this.cbrt(r);
        const t1 = 2 * crtr;
        const root12 = t1 * this.cos(phi / 3) - ba / 3;
        if (this.abs(root12 - center) < threshold) {
          return this.range(root12, 0, 1);
        }
        const root2 = t1 * this.cos((phi + 2 * Math.PI) / 3) - ba / 3;
        if (this.abs(root2 - center) < threshold) {
          return this.range(root2, 0, 1);
        }
        const root3 = t1 * this.cos((phi + 4 * Math.PI) / 3) - ba / 3;
        return this.range(root3, 0, 1);
      }
      if (discriminant == 0) {
        let u12;
        if (q2 < 0) {
          u12 = this.cbrt(-q2);
        } else {
          u12 = -this.cbrt(q2);
        }
        const root12 = 2 * u12 - ba / 3;
        if (this.abs(root12 - center) < threshold) {
          return this.range(root12, 0, 1);
        }
        const root2 = -u12 - ba / 3;
        return this.range(root2, 0, 1);
      }
      const sd = this.sqrt(discriminant);
      const u1 = this.cbrt(sd - q2);
      const v1 = this.cbrt(sd + q2);
      const root1 = u1 - v1 - ba / 3;
      return this.range(root1, 0, 1);
    }
    /**
     * 
     *
     * @param dividend 
     * @param divisor 
     * @returns 
     */
    static mod(dividend, divisor) {
      if (!isFinite(dividend) || divisor === 0 || isNaN(dividend) || isNaN(divisor)) {
        console.warn(`divided: ${dividend}, divisor: ${divisor} mod() returns 'NaN'.`);
        return NaN;
      }
      const absDividend = Math.abs(dividend);
      const absDivisor = Math.abs(divisor);
      let result = absDividend - Math.floor(absDividend / absDivisor) * absDivisor;
      result *= Math.sign(dividend);
      return result;
    }
    /**
     * 
     */
    constructor() {
    }
  };
  __publicField(_CubismMath, "Epsilon", 1e-5);
  var CubismMath = _CubismMath;
  var Live2DCubismFramework21;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMath = CubismMath;
  })(Live2DCubismFramework21 || (Live2DCubismFramework21 = {}));

  // src/Live2D/dist/math/cubismtargetpoint.js
  var FrameRate = 30;
  var Epsilon2 = 0.01;
  var CubismTargetPoint = class {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_faceTargetX");
      // X
      __publicField(this, "_faceTargetY");
      // Y
      __publicField(this, "_faceX");
      // X-1.0 ~ 1.0
      __publicField(this, "_faceY");
      // Y-1.0 ~ 1.0
      __publicField(this, "_faceVX");
      // X
      __publicField(this, "_faceVY");
      // Y
      __publicField(this, "_lastTimeSeconds");
      // []
      __publicField(this, "_userTimeSeconds");
      this._faceTargetX = 0;
      this._faceTargetY = 0;
      this._faceX = 0;
      this._faceY = 0;
      this._faceVX = 0;
      this._faceVY = 0;
      this._lastTimeSeconds = 0;
      this._userTimeSeconds = 0;
    }
    /**
     * 
     */
    update(deltaTimeSeconds) {
      this._userTimeSeconds += deltaTimeSeconds;
      const faceParamMaxV = 40 / 10;
      const maxV = faceParamMaxV * 1 / FrameRate;
      if (this._lastTimeSeconds == 0) {
        this._lastTimeSeconds = this._userTimeSeconds;
        return;
      }
      const deltaTimeWeight = (this._userTimeSeconds - this._lastTimeSeconds) * FrameRate;
      this._lastTimeSeconds = this._userTimeSeconds;
      const timeToMaxSpeed = 0.15;
      const frameToMaxSpeed = timeToMaxSpeed * FrameRate;
      const maxA = deltaTimeWeight * maxV / frameToMaxSpeed;
      const dx = this._faceTargetX - this._faceX;
      const dy = this._faceTargetY - this._faceY;
      if (CubismMath.abs(dx) <= Epsilon2 && CubismMath.abs(dy) <= Epsilon2) {
        return;
      }
      const d = CubismMath.sqrt(dx * dx + dy * dy);
      const vx = maxV * dx / d;
      const vy = maxV * dy / d;
      let ax = vx - this._faceVX;
      let ay = vy - this._faceVY;
      const a = CubismMath.sqrt(ax * ax + ay * ay);
      if (a < -maxA || a > maxA) {
        ax *= maxA / a;
        ay *= maxA / a;
      }
      this._faceVX += ax;
      this._faceVY += ay;
      {
        const maxV2 = 0.5 * (CubismMath.sqrt(maxA * maxA + 16 * maxA * d - 8 * maxA * d) - maxA);
        const curV = CubismMath.sqrt(this._faceVX * this._faceVX + this._faceVY * this._faceVY);
        if (curV > maxV2) {
          this._faceVX *= maxV2 / curV;
          this._faceVY *= maxV2 / curV;
        }
      }
      this._faceX += this._faceVX;
      this._faceY += this._faceVY;
    }
    /**
     * X
     *
     * @return X-1.0 ~ 1.0
     */
    getX() {
      return this._faceX;
    }
    /**
     * Y
     *
     * @return Y-1.0 ~ 1.0
     */
    getY() {
      return this._faceY;
    }
    /**
     * 
     *
     * @param x X-1.0 ~ 1.0
     * @param y Y-1.0 ~ 1.0
     */
    set(x, y) {
      this._faceTargetX = x;
      this._faceTargetY = y;
    }
    // []
  };
  var Live2DCubismFramework22;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismTargetPoint = CubismTargetPoint;
  })(Live2DCubismFramework22 || (Live2DCubismFramework22 = {}));

  // src/Live2D/dist/motion/acubismmotion.js
  var ACubismMotion = class {
    /**
     * 
     */
    constructor() {
      /**
       * 
       *
       * 
       * isFinished
       * :
       *   1. 
       *   2. 
       *
       * @param onFinishedMotionHandler 
       */
      __publicField(this, "setFinishedMotionHandler", (onFinishedMotionHandler) => this._onFinishedMotion = onFinishedMotionHandler);
      /**
       * 
       *
       * 
       *
       * @return 
       */
      __publicField(this, "getFinishedMotionHandler", () => this._onFinishedMotion);
      __publicField(this, "_fadeInSeconds");
      // []
      __publicField(this, "_fadeOutSeconds");
      // []
      __publicField(this, "_weight");
      // 
      __publicField(this, "_offsetSeconds");
      // []
      __publicField(this, "_firedEventValues");
      // 
      __publicField(this, "_onFinishedMotion");
      this._fadeInSeconds = -1;
      this._fadeOutSeconds = -1;
      this._weight = 1;
      this._offsetSeconds = 0;
      this._firedEventValues = new csmVector();
    }
    /**
     * 
     */
    static delete(motion) {
      motion.release();
      motion = null;
    }
    /**
     * 
     */
    release() {
      this._weight = 0;
    }
    /**
     * 
     * @param model 
     * @param motionQueueEntry CubismMotionQueueManager
     * @param userTimeSeconds []
     */
    updateParameters(model, motionQueueEntry, userTimeSeconds) {
      if (!motionQueueEntry.isAvailable() || motionQueueEntry.isFinished()) {
        return;
      }
      this.setupMotionQueueEntry(motionQueueEntry, userTimeSeconds);
      const fadeWeight = this.updateFadeWeight(motionQueueEntry, userTimeSeconds);
      this.doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry);
      if (motionQueueEntry.getEndTime() > 0 && motionQueueEntry.getEndTime() < userTimeSeconds) {
        motionQueueEntry.setIsFinished(true);
      }
    }
    /**
     * @brief 
     *
     * 
     *
     * @param[in]   motionQueueEntry    CubismMotionQueueManager
     * @param[in]   userTimeSeconds     []
     */
    setupMotionQueueEntry(motionQueueEntry, userTimeSeconds) {
      if (motionQueueEntry == null || motionQueueEntry.isStarted()) {
        return;
      }
      if (!motionQueueEntry.isAvailable()) {
        return;
      }
      motionQueueEntry.setIsStarted(true);
      motionQueueEntry.setStartTime(userTimeSeconds - this._offsetSeconds);
      motionQueueEntry.setFadeInStartTime(userTimeSeconds);
      const duration = this.getDuration();
      if (motionQueueEntry.getEndTime() < 0) {
        motionQueueEntry.setEndTime(duration <= 0 ? -1 : motionQueueEntry.getStartTime() + duration);
      }
    }
    /**
     * @brief 
     *
     * 
     *
     * @param[in]   motionQueueEntry    CubismMotionQueueManager
     * @param[in]   userTimeSeconds     []
     */
    updateFadeWeight(motionQueueEntry, userTimeSeconds) {
      if (motionQueueEntry == null) {
        CubismDebug.print(LogLevel.LogLevel_Error, "motionQueueEntry is null.");
      }
      let fadeWeight = this._weight;
      const fadeIn = this._fadeInSeconds == 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds);
      const fadeOut = this._fadeOutSeconds == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds);
      fadeWeight = fadeWeight * fadeIn * fadeOut;
      motionQueueEntry.setState(userTimeSeconds, fadeWeight);
      CSM_ASSERT(0 <= fadeWeight && fadeWeight <= 1);
      return fadeWeight;
    }
    /**
     * 
     * @param fadeInSeconds []
     */
    setFadeInTime(fadeInSeconds) {
      this._fadeInSeconds = fadeInSeconds;
    }
    /**
     * 
     * @param fadeOutSeconds []
     */
    setFadeOutTime(fadeOutSeconds) {
      this._fadeOutSeconds = fadeOutSeconds;
    }
    /**
     * 
     * @return []
     */
    getFadeOutTime() {
      return this._fadeOutSeconds;
    }
    /**
     * 
     * @return []
     */
    getFadeInTime() {
      return this._fadeInSeconds;
    }
    /**
     * 
     * @param weight 0.0 - 1.0
     */
    setWeight(weight) {
      this._weight = weight;
    }
    /**
     * 
     * @return 0.0 - 1.0
     */
    getWeight() {
      return this._weight;
    }
    /**
     * 
     * @return []
     *
     * @note -1
     *       
     *       
     *       -1
     */
    getDuration() {
      return -1;
    }
    /**
     * 1
     * @return []
     *
     * @note getDuration()
     *       ()-1
     */
    getLoopDuration() {
      return -1;
    }
    /**
     * 
     * @param offsetSeconds []
     */
    setOffsetTime(offsetSeconds) {
      this._offsetSeconds = offsetSeconds;
    }
    /**
     * 
     *
     * 
     * 
     *
     * @param beforeCheckTimeSeconds []
     * @param motionTimeSeconds []
     */
    getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
      return this._firedEventValues;
    }
    /**
     * 
     *
     * @returns true  -> 
     *          false -> 
     */
    isExistModelOpacity() {
      return false;
    }
    /**
     * 
     *
     * @returns success:
     */
    getModelOpacityIndex() {
      return -1;
    }
    /**
     * Id
     *
     * @param index 
     * @returns success:Id
     */
    getModelOpacityId(index) {
      return null;
    }
    /**
     * 
     *
     * @returns success:Opacity
     *
     * @note  UpdateParameters() 
     */
    getModelOpacityValue() {
      return 1;
    }
  };
  var Live2DCubismFramework23;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.ACubismMotion = ACubismMotion;
  })(Live2DCubismFramework23 || (Live2DCubismFramework23 = {}));

  // src/Live2D/dist/motion/cubismexpressionmotion.js
  var ExpressionKeyFadeIn = "FadeInTime";
  var ExpressionKeyFadeOut = "FadeOutTime";
  var ExpressionKeyParameters = "Parameters";
  var ExpressionKeyId = "Id";
  var ExpressionKeyValue = "Value";
  var ExpressionKeyBlend = "Blend";
  var BlendValueAdd = "Add";
  var BlendValueMultiply = "Multiply";
  var BlendValueOverwrite = "Overwrite";
  var DefaultFadeTime = 1;
  var _CubismExpressionMotion = class _CubismExpressionMotion extends ACubismMotion {
    /**
     * 
     */
    constructor() {
      super();
      __publicField(this, "_parameters");
      // 
      /**
       * 
       *
       * @deprecated 
       */
      __publicField(this, "_fadeWeight");
      this._parameters = new csmVector();
      this._fadeWeight = 0;
    }
    // 
    /**
     * 
     * @param buffer exp
     * @param size 
     * @return 
     */
    static create(buffer, size) {
      const expression = new _CubismExpressionMotion();
      expression.parse(buffer, size);
      return expression;
    }
    /**
     * 
     * @param model 
     * @param userTimeSeconds []
     * @param weight 
     * @param motionQueueEntry CubismMotionQueueManager
     */
    doUpdateParameters(model, userTimeSeconds, weight, motionQueueEntry) {
      for (let i = 0; i < this._parameters.getSize(); ++i) {
        const parameter = this._parameters.at(i);
        switch (parameter.blendType) {
          case ExpressionBlendType.Additive: {
            model.addParameterValueById(parameter.parameterId, parameter.value, weight);
            break;
          }
          case ExpressionBlendType.Multiply: {
            model.multiplyParameterValueById(parameter.parameterId, parameter.value, weight);
            break;
          }
          case ExpressionBlendType.Overwrite: {
            model.setParameterValueById(parameter.parameterId, parameter.value, weight);
            break;
          }
          default:
            break;
        }
      }
    }
    /**
     * @brief 
     *
     * 
     *
     * @param[in]   model                        
     * @param[in]   userTimeSeconds              []
     * @param[in]   motionQueueEntry             CubismMotionQueueManager
     * @param[in]   expressionParameterValues    
     * @param[in]   expressionIndex              
     * @param[in]   fadeWeight                   
     */
    calculateExpressionParameters(model, userTimeSeconds, motionQueueEntry, expressionParameterValues, expressionIndex, fadeWeight) {
      if (motionQueueEntry == null || expressionParameterValues == null) {
        return;
      }
      if (!motionQueueEntry.isAvailable()) {
        return;
      }
      this._fadeWeight = this.updateFadeWeight(motionQueueEntry, userTimeSeconds);
      for (let i = 0; i < expressionParameterValues.getSize(); ++i) {
        const expressionParameterValue = expressionParameterValues.at(i);
        if (expressionParameterValue.parameterId == null) {
          continue;
        }
        const currentParameterValue = expressionParameterValue.overwriteValue = model.getParameterValueById(expressionParameterValue.parameterId);
        const expressionParameters = this.getExpressionParameters();
        let parameterIndex = -1;
        for (let j = 0; j < expressionParameters.getSize(); ++j) {
          if (expressionParameterValue.parameterId != expressionParameters.at(j).parameterId) {
            continue;
          }
          parameterIndex = j;
          break;
        }
        if (parameterIndex < 0) {
          if (expressionIndex == 0) {
            expressionParameterValue.additiveValue = _CubismExpressionMotion.DefaultAdditiveValue;
            expressionParameterValue.multiplyValue = _CubismExpressionMotion.DefaultMultiplyValue;
            expressionParameterValue.overwriteValue = currentParameterValue;
          } else {
            expressionParameterValue.additiveValue = this.calculateValue(expressionParameterValue.additiveValue, _CubismExpressionMotion.DefaultAdditiveValue, fadeWeight);
            expressionParameterValue.multiplyValue = this.calculateValue(expressionParameterValue.multiplyValue, _CubismExpressionMotion.DefaultMultiplyValue, fadeWeight);
            expressionParameterValue.overwriteValue = this.calculateValue(expressionParameterValue.overwriteValue, currentParameterValue, fadeWeight);
          }
          continue;
        }
        const value = expressionParameters.at(parameterIndex).value;
        let newAdditiveValue, newMultiplyValue, newOverwriteValue;
        switch (expressionParameters.at(parameterIndex).blendType) {
          case ExpressionBlendType.Additive:
            newAdditiveValue = value;
            newMultiplyValue = _CubismExpressionMotion.DefaultMultiplyValue;
            newOverwriteValue = currentParameterValue;
            break;
          case ExpressionBlendType.Multiply:
            newAdditiveValue = _CubismExpressionMotion.DefaultAdditiveValue;
            newMultiplyValue = value;
            newOverwriteValue = currentParameterValue;
            break;
          case ExpressionBlendType.Overwrite:
            newAdditiveValue = _CubismExpressionMotion.DefaultAdditiveValue;
            newMultiplyValue = _CubismExpressionMotion.DefaultMultiplyValue;
            newOverwriteValue = value;
            break;
          default:
            return;
        }
        if (expressionIndex == 0) {
          expressionParameterValue.additiveValue = newAdditiveValue;
          expressionParameterValue.multiplyValue = newMultiplyValue;
          expressionParameterValue.overwriteValue = newOverwriteValue;
        } else {
          expressionParameterValue.additiveValue = expressionParameterValue.additiveValue * (1 - fadeWeight) + newAdditiveValue * fadeWeight;
          expressionParameterValue.multiplyValue = expressionParameterValue.multiplyValue * (1 - fadeWeight) + newMultiplyValue * fadeWeight;
          expressionParameterValue.overwriteValue = expressionParameterValue.overwriteValue * (1 - fadeWeight) + newOverwriteValue * fadeWeight;
        }
      }
    }
    /**
     * @brief 
     *
     * 
     *
     * @return 
     */
    getExpressionParameters() {
      return this._parameters;
    }
    /**
     * @brief 
     *
     * 
     *
     * @returns 
     *
     * @deprecated CubismExpressionMotion.fadeWeight
     * CubismExpressionMotionManager.getFadeWeight(index: number): number 
     * @see CubismExpressionMotionManager#getFadeWeight(index: number)
     */
    getFadeWeight() {
      return this._fadeWeight;
    }
    parse(buffer, size) {
      const json = CubismJson.create(buffer, size);
      if (!json) {
        return;
      }
      const root = json.getRoot();
      this.setFadeInTime(root.getValueByString(ExpressionKeyFadeIn).toFloat(DefaultFadeTime));
      this.setFadeOutTime(root.getValueByString(ExpressionKeyFadeOut).toFloat(DefaultFadeTime));
      const parameterCount = root.getValueByString(ExpressionKeyParameters).getSize();
      this._parameters.prepareCapacity(parameterCount);
      for (let i = 0; i < parameterCount; ++i) {
        const param = root.getValueByString(ExpressionKeyParameters).getValueByIndex(i);
        const parameterId = CubismFramework.getIdManager().getId(param.getValueByString(ExpressionKeyId).getRawString());
        const value = param.getValueByString(ExpressionKeyValue).toFloat();
        let blendType;
        if (param.getValueByString(ExpressionKeyBlend).isNull() || param.getValueByString(ExpressionKeyBlend).getString() == BlendValueAdd) {
          blendType = ExpressionBlendType.Additive;
        } else if (param.getValueByString(ExpressionKeyBlend).getString() == BlendValueMultiply) {
          blendType = ExpressionBlendType.Multiply;
        } else if (param.getValueByString(ExpressionKeyBlend).getString() == BlendValueOverwrite) {
          blendType = ExpressionBlendType.Overwrite;
        } else {
          blendType = ExpressionBlendType.Additive;
        }
        const item = new ExpressionParameter();
        item.parameterId = parameterId;
        item.blendType = blendType;
        item.value = value;
        this._parameters.pushBack(item);
      }
      CubismJson.delete(json);
    }
    /**
     * @brief 
     *
     * 
     *
     * @param source 
     * @param destination 
     * @param weight 
     * @returns 
     */
    calculateValue(source2, destination, fadeWeight) {
      return source2 * (1 - fadeWeight) + destination * fadeWeight;
    }
  };
  __publicField(_CubismExpressionMotion, "DefaultAdditiveValue", 0);
  // 
  __publicField(_CubismExpressionMotion, "DefaultMultiplyValue", 1);
  var CubismExpressionMotion = _CubismExpressionMotion;
  var ExpressionBlendType;
  (function(ExpressionBlendType2) {
    ExpressionBlendType2[ExpressionBlendType2["Additive"] = 0] = "Additive";
    ExpressionBlendType2[ExpressionBlendType2["Multiply"] = 1] = "Multiply";
    ExpressionBlendType2[ExpressionBlendType2["Overwrite"] = 2] = "Overwrite";
  })(ExpressionBlendType || (ExpressionBlendType = {}));
  var ExpressionParameter = class {
    constructor() {
      __publicField(this, "parameterId");
      // ID
      __publicField(this, "blendType");
      // 
      __publicField(this, "value");
    }
    // 
  };
  var Live2DCubismFramework24;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismExpressionMotion = CubismExpressionMotion;
    Live2DCubismFramework42.ExpressionBlendType = ExpressionBlendType;
    Live2DCubismFramework42.ExpressionParameter = ExpressionParameter;
  })(Live2DCubismFramework24 || (Live2DCubismFramework24 = {}));

  // src/Live2D/dist/motion/cubismmotionqueueentry.js
  var CubismMotionQueueEntry = class {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_autoDelete");
      // 
      __publicField(this, "_motion");
      // 
      __publicField(this, "_available");
      // 
      __publicField(this, "_finished");
      // 
      __publicField(this, "_started");
      // 
      __publicField(this, "_startTimeSeconds");
      // []
      __publicField(this, "_fadeInStartTimeSeconds");
      // []
      __publicField(this, "_endTimeSeconds");
      // []
      __publicField(this, "_stateTimeSeconds");
      // []
      __publicField(this, "_stateWeight");
      // 
      __publicField(this, "_lastEventCheckSeconds");
      // Motion
      __publicField(this, "_fadeOutSeconds");
      // []
      __publicField(this, "_isTriggeredFadeOut");
      // 
      __publicField(this, "_motionQueueEntryHandle");
      this._autoDelete = false;
      this._motion = null;
      this._available = true;
      this._finished = false;
      this._started = false;
      this._startTimeSeconds = -1;
      this._fadeInStartTimeSeconds = 0;
      this._endTimeSeconds = -1;
      this._stateTimeSeconds = 0;
      this._stateWeight = 0;
      this._lastEventCheckSeconds = 0;
      this._motionQueueEntryHandle = this;
      this._fadeOutSeconds = 0;
      this._isTriggeredFadeOut = false;
    }
    /**
     * 
     */
    release() {
      if (this._autoDelete && this._motion) {
        ACubismMotion.delete(this._motion);
      }
    }
    /**
     * 
     * @param fadeOutSeconds []
     */
    setFadeOut(fadeOutSeconds) {
      this._fadeOutSeconds = fadeOutSeconds;
      this._isTriggeredFadeOut = true;
    }
    /**
     * 
     * @param fadeOutSeconds []
     * @param userTimeSeconds []
     */
    startFadeOut(fadeOutSeconds, userTimeSeconds) {
      const newEndTimeSeconds = userTimeSeconds + fadeOutSeconds;
      this._isTriggeredFadeOut = true;
      if (this._endTimeSeconds < 0 || newEndTimeSeconds < this._endTimeSeconds) {
        this._endTimeSeconds = newEndTimeSeconds;
      }
    }
    /**
     * 
     *
     * @return true 
     * @return false 
     */
    isFinished() {
      return this._finished;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isStarted() {
      return this._started;
    }
    /**
     * 
     * @return []
     */
    getStartTime() {
      return this._startTimeSeconds;
    }
    /**
     * 
     * @return []
     */
    getFadeInStartTime() {
      return this._fadeInStartTimeSeconds;
    }
    /**
     * 
     * @return 
     */
    getEndTime() {
      return this._endTimeSeconds;
    }
    /**
     * 
     * @param startTime 
     */
    setStartTime(startTime) {
      this._startTimeSeconds = startTime;
    }
    /**
     * 
     * @param startTime []
     */
    setFadeInStartTime(startTime) {
      this._fadeInStartTimeSeconds = startTime;
    }
    /**
     * 
     * @param endTime []
     */
    setEndTime(endTime) {
      this._endTimeSeconds = endTime;
    }
    /**
     * 
     * @param f true
     */
    setIsFinished(f) {
      this._finished = f;
    }
    /**
     * 
     * @param f true
     */
    setIsStarted(f) {
      this._started = f;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isAvailable() {
      return this._available;
    }
    /**
     * 
     * @param v true
     */
    setIsAvailable(v) {
      this._available = v;
    }
    /**
     * 
     * @param timeSeconds []
     * @param weight 
     */
    setState(timeSeconds, weight) {
      this._stateTimeSeconds = timeSeconds;
      this._stateWeight = weight;
    }
    /**
     * 
     * @return []
     */
    getStateTime() {
      return this._stateTimeSeconds;
    }
    /**
     * 
     * @return 
     */
    getStateWeight() {
      return this._stateWeight;
    }
    /**
     * 
     *
     * @return []
     */
    getLastCheckEventSeconds() {
      return this._lastEventCheckSeconds;
    }
    /**
     * 
     * @param checkSeconds []
     */
    setLastCheckEventSeconds(checkSeconds) {
      this._lastEventCheckSeconds = checkSeconds;
    }
    /**
     * 
     * @return 
     */
    isTriggeredFadeOut() {
      return this._isTriggeredFadeOut;
    }
    /**
     * 
     * @return []
     */
    getFadeOutSeconds() {
      return this._fadeOutSeconds;
    }
    /**
     * 
     *
     * @return 
     */
    getCubismMotion() {
      return this._motion;
    }
    // 
  };
  var Live2DCubismFramework25;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionQueueEntry = CubismMotionQueueEntry;
  })(Live2DCubismFramework25 || (Live2DCubismFramework25 = {}));

  // src/Live2D/dist/motion/cubismmotionqueuemanager.js
  var CubismMotionQueueManager = class {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_userTimeSeconds");
      // []
      __publicField(this, "_motions");
      // 
      __publicField(this, "_eventCallBack");
      // 
      __publicField(this, "_eventCustomData");
      this._userTimeSeconds = 0;
      this._eventCallBack = null;
      this._eventCustomData = null;
      this._motions = new csmVector();
    }
    /**
     * 
     */
    release() {
      for (let i = 0; i < this._motions.getSize(); ++i) {
        if (this._motions.at(i)) {
          this._motions.at(i).release();
          this._motions.set(i, null);
        }
      }
      this._motions = null;
    }
    /**
     * 
     *
     * 
     *
     * @param   motion          
     * @param   autoDelete       true
     * @param   userTimeSeconds Deprecated: [] 
     * @return                      IsFinished()-1
     */
    startMotion(motion, autoDelete, userTimeSeconds) {
      if (motion == null) {
        return InvalidMotionQueueEntryHandleValue;
      }
      let motionQueueEntry = null;
      for (let i = 0; i < this._motions.getSize(); ++i) {
        motionQueueEntry = this._motions.at(i);
        if (motionQueueEntry == null) {
          continue;
        }
        motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime());
      }
      motionQueueEntry = new CubismMotionQueueEntry();
      motionQueueEntry._autoDelete = autoDelete;
      motionQueueEntry._motion = motion;
      this._motions.pushBack(motionQueueEntry);
      return motionQueueEntry._motionQueueEntryHandle;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isFinished() {
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
        let motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          ite = this._motions.erase(ite);
          continue;
        }
        const motion = motionQueueEntry._motion;
        if (motion == null) {
          motionQueueEntry.release();
          motionQueueEntry = null;
          ite = this._motions.erase(ite);
          continue;
        }
        if (!motionQueueEntry.isFinished()) {
          return false;
        } else {
          ite.preIncrement();
        }
      }
      return true;
    }
    /**
     * 
     * @param motionQueueEntryNumber 
     * @return true 
     * @return false 
     */
    isFinishedByHandle(motionQueueEntryNumber) {
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.increment()) {
        const motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          continue;
        }
        if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber && !motionQueueEntry.isFinished()) {
          return false;
        }
      }
      return true;
    }
    /**
     * 
     */
    stopAllMotions() {
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
        let motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          ite = this._motions.erase(ite);
          continue;
        }
        motionQueueEntry.release();
        motionQueueEntry = null;
        ite = this._motions.erase(ite);
      }
    }
    /**
     * @brief CubismMotionQueueEntry
     *
     * CubismMotionQueueEntry
     *
     * @return  CubismMotionQueueEntry
     * @retval  NULL   
     */
    getCubismMotionQueueEntries() {
      return this._motions;
    }
    /**
       * CubismMotionQueueEntry
    
       * @param   motionQueueEntryNumber  
       * @return  CubismMotionQueueEntry
       * @return  null   
       */
    getCubismMotionQueueEntry(motionQueueEntryNumber) {
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.preIncrement()) {
        const motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          continue;
        }
        if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber) {
          return motionQueueEntry;
        }
      }
      return null;
    }
    /**
     * Callback
     *
     * @param callback 
     * @param customData 
     */
    setEventCallback(callback, customData = null) {
      this._eventCallBack = callback;
      this._eventCustomData = customData;
    }
    /**
     * 
     *
     * @param   model   
     * @param   userTimeSeconds   []
     * @return  true    
     * @return  false   ()
     */
    doUpdateMotion(model, userTimeSeconds) {
      let updated = false;
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
        let motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          ite = this._motions.erase(ite);
          continue;
        }
        const motion = motionQueueEntry._motion;
        if (motion == null) {
          motionQueueEntry.release();
          motionQueueEntry = null;
          ite = this._motions.erase(ite);
          continue;
        }
        motion.updateParameters(model, motionQueueEntry, userTimeSeconds);
        updated = true;
        const firedList = motion.getFiredEvent(motionQueueEntry.getLastCheckEventSeconds() - motionQueueEntry.getStartTime(), userTimeSeconds - motionQueueEntry.getStartTime());
        for (let i = 0; i < firedList.getSize(); ++i) {
          this._eventCallBack(this, firedList.at(i), this._eventCustomData);
        }
        motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);
        if (motionQueueEntry.isFinished()) {
          motionQueueEntry.release();
          motionQueueEntry = null;
          ite = this._motions.erase(ite);
        } else {
          if (motionQueueEntry.isTriggeredFadeOut()) {
            motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), userTimeSeconds);
          }
          ite.preIncrement();
        }
      }
      return updated;
    }
    // 
  };
  var InvalidMotionQueueEntryHandleValue = -1;
  var Live2DCubismFramework26;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionQueueManager = CubismMotionQueueManager;
    Live2DCubismFramework42.InvalidMotionQueueEntryHandleValue = InvalidMotionQueueEntryHandleValue;
  })(Live2DCubismFramework26 || (Live2DCubismFramework26 = {}));

  // src/Live2D/dist/motion/cubismexpressionmotionmanager.js
  var ExpressionParameterValue = class {
    constructor() {
      __publicField(this, "parameterId");
      // ID
      __publicField(this, "additiveValue");
      // 
      __publicField(this, "multiplyValue");
      // 
      __publicField(this, "overwriteValue");
    }
    // 
  };
  var CubismExpressionMotionManager = class extends CubismMotionQueueManager {
    /**
     * 
     */
    constructor() {
      super();
      __publicField(this, "_expressionParameterValues");
      ///< 
      __publicField(this, "_fadeWeights");
      ///< 
      __publicField(this, "_currentPriority");
      ///< 
      __publicField(this, "_reservePriority");
      ///< 0
      __publicField(this, "_startExpressionTime");
      this._currentPriority = 0;
      this._reservePriority = 0;
      this._expressionParameterValues = new csmVector();
      this._fadeWeights = new csmVector();
    }
    /**
     * 
     */
    release() {
      if (this._expressionParameterValues) {
        csmDelete(this._expressionParameterValues);
        this._expressionParameterValues = null;
      }
      if (this._fadeWeights) {
        csmDelete(this._fadeWeights);
        this._fadeWeights = null;
      }
    }
    /**
     * @brief 
     *
     * 
     *
     * @returns 
     */
    getCurrentPriority() {
      return this._currentPriority;
    }
    /**
     * @brief 
     *
     * 
     *
     * @return  
     */
    getReservePriority() {
      return this._reservePriority;
    }
    /**
     * @brief 
     *
     * @param[in]    index    
     * @returns               
     */
    getFadeWeight(index) {
      return this._fadeWeights.at(index);
    }
    /**
     * @brief 
     *
     * 
     *
     * @param[in]   priority     
     */
    setReservePriority(priority) {
      this._reservePriority = priority;
    }
    /**
     * @brief 
     *
     * 
     *
     * @param[in]   motion          
     * @param[in]   autoDelete      true
     * @param[in]   priority        
     * @return                      IsFinished()-1
     */
    startMotionPriority(motion, autoDelete, priority) {
      if (priority == this.getReservePriority()) {
        this.setReservePriority(0);
      }
      this._currentPriority = priority;
      this._fadeWeights.pushBack(0);
      return this.startMotion(motion, autoDelete);
    }
    /**
     * @brief 
     *
     * 
     *
     * @param[in]   model   
     * @param[in]   deltaTimeSeconds    []
     * @retval  true    
     * @retval  false   
     */
    updateMotion(model, deltaTimeSeconds) {
      this._userTimeSeconds += deltaTimeSeconds;
      let updated = false;
      const motions = this.getCubismMotionQueueEntries();
      let expressionWeight = 0;
      let expressionIndex = 0;
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
        const motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          ite = motions.erase(ite);
          continue;
        }
        const expressionMotion = motionQueueEntry.getCubismMotion();
        if (expressionMotion == null) {
          csmDelete(motionQueueEntry);
          ite = motions.erase(ite);
          continue;
        }
        const expressionParameters = expressionMotion.getExpressionParameters();
        if (motionQueueEntry.isAvailable()) {
          for (let i = 0; i < expressionParameters.getSize(); ++i) {
            if (expressionParameters.at(i).parameterId == null) {
              continue;
            }
            let index = -1;
            for (let j = 0; j < this._expressionParameterValues.getSize(); ++j) {
              if (this._expressionParameterValues.at(j).parameterId != expressionParameters.at(i).parameterId) {
                continue;
              }
              index = j;
              break;
            }
            if (index >= 0) {
              continue;
            }
            const item = new ExpressionParameterValue();
            item.parameterId = expressionParameters.at(i).parameterId;
            item.additiveValue = CubismExpressionMotion.DefaultAdditiveValue;
            item.multiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
            item.overwriteValue = model.getParameterValueById(item.parameterId);
            this._expressionParameterValues.pushBack(item);
          }
        }
        expressionMotion.setupMotionQueueEntry(motionQueueEntry, this._userTimeSeconds);
        this._fadeWeights.set(expressionIndex, expressionMotion.updateFadeWeight(motionQueueEntry, this._userTimeSeconds));
        expressionMotion.calculateExpressionParameters(model, this._userTimeSeconds, motionQueueEntry, this._expressionParameterValues, expressionIndex, this._fadeWeights.at(expressionIndex));
        expressionWeight += expressionMotion.getFadeInTime() == 0 ? 1 : CubismMath.getEasingSine((this._userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / expressionMotion.getFadeInTime());
        updated = true;
        if (motionQueueEntry.isTriggeredFadeOut()) {
          motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), this._userTimeSeconds);
        }
        ite.preIncrement();
        ++expressionIndex;
      }
      if (motions.getSize() > 1) {
        const expressionMotion = motions.at(motions.getSize() - 1).getCubismMotion();
        const latestFadeWeight = this._fadeWeights.at(this._fadeWeights.getSize() - 1);
        if (latestFadeWeight >= 1) {
          for (let i = motions.getSize() - 2; i >= 0; --i) {
            const motionQueueEntry = motions.at(i);
            csmDelete(motionQueueEntry);
            motions.remove(i);
            this._fadeWeights.remove(i);
          }
        }
      }
      if (expressionWeight > 1) {
        expressionWeight = 1;
      }
      for (let i = 0; i < this._expressionParameterValues.getSize(); ++i) {
        const expressionParameterValue = this._expressionParameterValues.at(i);
        model.setParameterValueById(expressionParameterValue.parameterId, (expressionParameterValue.overwriteValue + expressionParameterValue.additiveValue) * expressionParameterValue.multiplyValue, expressionWeight);
        expressionParameterValue.additiveValue = CubismExpressionMotion.DefaultAdditiveValue;
        expressionParameterValue.multiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
      }
      return updated;
    }
    ///< 
  };
  var Live2DCubismFramework27;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismExpressionMotionManager = CubismExpressionMotionManager;
  })(Live2DCubismFramework27 || (Live2DCubismFramework27 = {}));

  // src/Live2D/dist/motion/cubismmotioninternal.js
  var CubismMotionCurveTarget;
  (function(CubismMotionCurveTarget2) {
    CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_Model"] = 0] = "CubismMotionCurveTarget_Model";
    CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_Parameter"] = 1] = "CubismMotionCurveTarget_Parameter";
    CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_PartOpacity"] = 2] = "CubismMotionCurveTarget_PartOpacity";
  })(CubismMotionCurveTarget || (CubismMotionCurveTarget = {}));
  var CubismMotionSegmentType;
  (function(CubismMotionSegmentType2) {
    CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Linear"] = 0] = "CubismMotionSegmentType_Linear";
    CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Bezier"] = 1] = "CubismMotionSegmentType_Bezier";
    CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Stepped"] = 2] = "CubismMotionSegmentType_Stepped";
    CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_InverseStepped"] = 3] = "CubismMotionSegmentType_InverseStepped";
  })(CubismMotionSegmentType || (CubismMotionSegmentType = {}));
  var CubismMotionPoint = class {
    constructor() {
      __publicField(this, "time", 0);
      // []
      __publicField(this, "value", 0);
    }
    // 
  };
  var CubismMotionSegment = class {
    /**
     * @brief 
     *
     * 
     */
    constructor() {
      __publicField(this, "evaluate");
      // 
      __publicField(this, "basePointIndex");
      // 
      __publicField(this, "segmentType");
      this.evaluate = null;
      this.basePointIndex = 0;
      this.segmentType = 0;
    }
    // 
  };
  var CubismMotionCurve = class {
    constructor() {
      __publicField(this, "type");
      // 
      __publicField(this, "id");
      // ID
      __publicField(this, "segmentCount");
      // 
      __publicField(this, "baseSegmentIndex");
      // 
      __publicField(this, "fadeInTime");
      // []
      __publicField(this, "fadeOutTime");
      this.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;
      this.segmentCount = 0;
      this.baseSegmentIndex = 0;
      this.fadeInTime = 0;
      this.fadeOutTime = 0;
    }
    // []
  };
  var CubismMotionEvent = class {
    constructor() {
      __publicField(this, "fireTime", 0);
      __publicField(this, "value");
    }
  };
  var CubismMotionData = class {
    constructor() {
      __publicField(this, "duration");
      // []
      __publicField(this, "loop");
      // 
      __publicField(this, "curveCount");
      // 
      __publicField(this, "eventCount");
      // UserData
      __publicField(this, "fps");
      // 
      __publicField(this, "curves");
      // 
      __publicField(this, "segments");
      // 
      __publicField(this, "points");
      // 
      __publicField(this, "events");
      this.duration = 0;
      this.loop = false;
      this.curveCount = 0;
      this.eventCount = 0;
      this.fps = 0;
      this.curves = new csmVector();
      this.segments = new csmVector();
      this.points = new csmVector();
      this.events = new csmVector();
    }
    // 
  };
  var Live2DCubismFramework28;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionCurve = CubismMotionCurve;
    Live2DCubismFramework42.CubismMotionCurveTarget = CubismMotionCurveTarget;
    Live2DCubismFramework42.CubismMotionData = CubismMotionData;
    Live2DCubismFramework42.CubismMotionEvent = CubismMotionEvent;
    Live2DCubismFramework42.CubismMotionPoint = CubismMotionPoint;
    Live2DCubismFramework42.CubismMotionSegment = CubismMotionSegment;
    Live2DCubismFramework42.CubismMotionSegmentType = CubismMotionSegmentType;
  })(Live2DCubismFramework28 || (Live2DCubismFramework28 = {}));

  // src/Live2D/dist/motion/cubismmotionjson.js
  var Meta = "Meta";
  var Duration = "Duration";
  var Loop = "Loop";
  var AreBeziersRestricted = "AreBeziersRestricted";
  var CurveCount = "CurveCount";
  var Fps = "Fps";
  var TotalSegmentCount = "TotalSegmentCount";
  var TotalPointCount = "TotalPointCount";
  var Curves = "Curves";
  var Target = "Target";
  var Id3 = "Id";
  var FadeInTime2 = "FadeInTime";
  var FadeOutTime2 = "FadeOutTime";
  var Segments = "Segments";
  var UserData2 = "UserData";
  var UserDataCount = "UserDataCount";
  var TotalUserDataSize = "TotalUserDataSize";
  var Time = "Time";
  var Value2 = "Value";
  var CubismMotionJson = class {
    /**
     * 
     * @param buffer motion3.json
     * @param size 
     */
    constructor(buffer, size) {
      __publicField(this, "_json");
      this._json = CubismJson.create(buffer, size);
    }
    /**
     * 
     */
    release() {
      CubismJson.delete(this._json);
    }
    /**
     * 
     * @return []
     */
    getMotionDuration() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(Duration).toFloat();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isMotionLoop() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(Loop).toBoolean();
    }
    getEvaluationOptionFlag(flagType) {
      if (EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted == flagType) {
        return this._json.getRoot().getValueByString(Meta).getValueByString(AreBeziersRestricted).toBoolean();
      }
      return false;
    }
    /**
     * 
     * @return 
     */
    getMotionCurveCount() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(CurveCount).toInt();
    }
    /**
     * 
     * @return [FPS]
     */
    getMotionFps() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(Fps).toFloat();
    }
    /**
     * 
     * @return 
     */
    getMotionTotalSegmentCount() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(TotalSegmentCount).toInt();
    }
    /**
     * 
     * @return 
     */
    getMotionTotalPointCount() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(TotalPointCount).toInt();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistMotionFadeInTime() {
      return !this._json.getRoot().getValueByString(Meta).getValueByString(FadeInTime2).isNull();
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isExistMotionFadeOutTime() {
      return !this._json.getRoot().getValueByString(Meta).getValueByString(FadeOutTime2).isNull();
    }
    /**
     * 
     * @return []
     */
    getMotionFadeInTime() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(FadeInTime2).toFloat();
    }
    /**
     * 
     * @return []
     */
    getMotionFadeOutTime() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(FadeOutTime2).toFloat();
    }
    /**
     * 
     * @param curveIndex 
     * @return 
     */
    getMotionCurveTarget(curveIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Target).getRawString();
    }
    /**
     * ID
     * @param curveIndex 
     * @return ID
     */
    getMotionCurveId(curveIndex) {
      return CubismFramework.getIdManager().getId(this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Id3).getRawString());
    }
    /**
     * 
     * @param curveIndex 
     * @return true 
     * @return false 
     */
    isExistMotionCurveFadeInTime(curveIndex) {
      return !this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeInTime2).isNull();
    }
    /**
     * 
     * @param curveIndex 
     * @return true 
     * @return false 
     */
    isExistMotionCurveFadeOutTime(curveIndex) {
      return !this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeOutTime2).isNull();
    }
    /**
     * 
     * @param curveIndex 
     * @return []
     */
    getMotionCurveFadeInTime(curveIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeInTime2).toFloat();
    }
    /**
     * 
     * @param curveIndex 
     * @return []
     */
    getMotionCurveFadeOutTime(curveIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeOutTime2).toFloat();
    }
    /**
     * 
     * @param curveIndex 
     * @return 
     */
    getMotionCurveSegmentCount(curveIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Segments).getVector().getSize();
    }
    /**
     * 
     * @param curveIndex 
     * @param segmentIndex 
     * @return 
     */
    getMotionCurveSegment(curveIndex, segmentIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Segments).getValueByIndex(segmentIndex).toFloat();
    }
    /**
     * 
     * @return 
     */
    getEventCount() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(UserDataCount).toInt();
    }
    /**
     *  
     * @return 
     */
    getTotalEventValueSize() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(TotalUserDataSize).toInt();
    }
    /**
     * 
     * @param userDataIndex 
     * @return []
     */
    getEventTime(userDataIndex) {
      return this._json.getRoot().getValueByString(UserData2).getValueByIndex(userDataIndex).getValueByString(Time).toFloat();
    }
    /**
     * 
     * @param userDataIndex 
     * @return 
     */
    getEventValue(userDataIndex) {
      return new csmString(this._json.getRoot().getValueByString(UserData2).getValueByIndex(userDataIndex).getValueByString(Value2).getRawString());
    }
    // motion3.json
  };
  var EvaluationOptionFlag;
  (function(EvaluationOptionFlag2) {
    EvaluationOptionFlag2[EvaluationOptionFlag2["EvaluationOptionFlag_AreBeziersRistricted"] = 0] = "EvaluationOptionFlag_AreBeziersRistricted";
  })(EvaluationOptionFlag || (EvaluationOptionFlag = {}));
  var Live2DCubismFramework29;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionJson = CubismMotionJson;
  })(Live2DCubismFramework29 || (Live2DCubismFramework29 = {}));

  // src/Live2D/dist/motion/cubismmotion.js
  var EffectNameEyeBlink = "EyeBlink";
  var EffectNameLipSync = "LipSync";
  var TargetNameModel = "Model";
  var TargetNameParameter = "Parameter";
  var TargetNamePartOpacity = "PartOpacity";
  var IdNameOpacity = "Opacity";
  var UseOldBeziersCurveMotion = false;
  function lerpPoints(a, b, t2) {
    const result = new CubismMotionPoint();
    result.time = a.time + (b.time - a.time) * t2;
    result.value = a.value + (b.value - a.value) * t2;
    return result;
  }
  function linearEvaluate(points, time) {
    let t2 = (time - points[0].time) / (points[1].time - points[0].time);
    if (t2 < 0) {
      t2 = 0;
    }
    return points[0].value + (points[1].value - points[0].value) * t2;
  }
  function bezierEvaluate(points, time) {
    let t2 = (time - points[0].time) / (points[3].time - points[0].time);
    if (t2 < 0) {
      t2 = 0;
    }
    const p01 = lerpPoints(points[0], points[1], t2);
    const p12 = lerpPoints(points[1], points[2], t2);
    const p23 = lerpPoints(points[2], points[3], t2);
    const p012 = lerpPoints(p01, p12, t2);
    const p123 = lerpPoints(p12, p23, t2);
    return lerpPoints(p012, p123, t2).value;
  }
  function bezierEvaluateCardanoInterpretation(points, time) {
    const x = time;
    const x1 = points[0].time;
    const x2 = points[3].time;
    const cx1 = points[1].time;
    const cx2 = points[2].time;
    const a = x2 - 3 * cx2 + 3 * cx1 - x1;
    const b = 3 * cx2 - 6 * cx1 + 3 * x1;
    const c = 3 * cx1 - 3 * x1;
    const d = x1 - x;
    const t2 = CubismMath.cardanoAlgorithmForBezier(a, b, c, d);
    const p01 = lerpPoints(points[0], points[1], t2);
    const p12 = lerpPoints(points[1], points[2], t2);
    const p23 = lerpPoints(points[2], points[3], t2);
    const p012 = lerpPoints(p01, p12, t2);
    const p123 = lerpPoints(p12, p23, t2);
    return lerpPoints(p012, p123, t2).value;
  }
  function steppedEvaluate(points, time) {
    return points[0].value;
  }
  function inverseSteppedEvaluate(points, time) {
    return points[1].value;
  }
  function evaluateCurve(motionData, index, time) {
    const curve = motionData.curves.at(index);
    let target = -1;
    const totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;
    let pointPosition = 0;
    for (let i = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {
      pointPosition = motionData.segments.at(i).basePointIndex + (motionData.segments.at(i).segmentType == CubismMotionSegmentType.CubismMotionSegmentType_Bezier ? 3 : 1);
      if (motionData.points.at(pointPosition).time > time) {
        target = i;
        break;
      }
    }
    if (target == -1) {
      return motionData.points.at(pointPosition).value;
    }
    const segment = motionData.segments.at(target);
    return segment.evaluate(motionData.points.get(segment.basePointIndex), time);
  }
  var CubismMotion = class _CubismMotion extends ACubismMotion {
    /**
     * 
     */
    constructor() {
      super();
      __publicField(this, "_sourceFrameRate");
      // FPS15fps
      __publicField(this, "_loopDurationSeconds");
      // mtn
      __publicField(this, "_isLoop");
      // ?
      __publicField(this, "_isLoopFadeIn");
      // 
      __publicField(this, "_lastWeight");
      // 
      __publicField(this, "_motionData");
      // 
      __publicField(this, "_eyeBlinkParameterIds");
      // ID  
      __publicField(this, "_lipSyncParameterIds");
      // ID  
      __publicField(this, "_modelCurveIdEyeBlink");
      // ID  
      __publicField(this, "_modelCurveIdLipSync");
      // ID  
      __publicField(this, "_modelCurveIdOpacity");
      // ID  
      __publicField(this, "_modelOpacity");
      this._sourceFrameRate = 30;
      this._loopDurationSeconds = -1;
      this._isLoop = false;
      this._isLoopFadeIn = true;
      this._lastWeight = 0;
      this._motionData = null;
      this._modelCurveIdEyeBlink = null;
      this._modelCurveIdLipSync = null;
      this._modelCurveIdOpacity = null;
      this._eyeBlinkParameterIds = null;
      this._lipSyncParameterIds = null;
      this._modelOpacity = 1;
    }
    /**
     * 
     *
     * @param buffer motion3.json
     * @param size 
     * @param onFinishedMotionHandler 
     * @return 
     */
    static create(buffer, size, onFinishedMotionHandler) {
      const ret = new _CubismMotion();
      ret.parse(buffer, size);
      ret._sourceFrameRate = ret._motionData.fps;
      ret._loopDurationSeconds = ret._motionData.duration;
      ret._onFinishedMotion = onFinishedMotionHandler;
      return ret;
    }
    /**
     * 
     * @param model             
     * @param userTimeSeconds   []
     * @param fadeWeight        
     * @param motionQueueEntry  CubismMotionQueueManager
     */
    doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry) {
      if (this._modelCurveIdEyeBlink == null) {
        this._modelCurveIdEyeBlink = CubismFramework.getIdManager().getId(EffectNameEyeBlink);
      }
      if (this._modelCurveIdLipSync == null) {
        this._modelCurveIdLipSync = CubismFramework.getIdManager().getId(EffectNameLipSync);
      }
      if (this._modelCurveIdOpacity == null) {
        this._modelCurveIdOpacity = CubismFramework.getIdManager().getId(IdNameOpacity);
      }
      let timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();
      if (timeOffsetSeconds < 0) {
        timeOffsetSeconds = 0;
      }
      let lipSyncValue = Number.MAX_VALUE;
      let eyeBlinkValue = Number.MAX_VALUE;
      const maxTargetSize = 64;
      let lipSyncFlags = 0;
      let eyeBlinkFlags = 0;
      if (this._eyeBlinkParameterIds.getSize() > maxTargetSize) {
        CubismLogDebug("too many eye blink targets : {0}", this._eyeBlinkParameterIds.getSize());
      }
      if (this._lipSyncParameterIds.getSize() > maxTargetSize) {
        CubismLogDebug("too many lip sync targets : {0}", this._lipSyncParameterIds.getSize());
      }
      const tmpFadeIn = this._fadeInSeconds <= 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds);
      const tmpFadeOut = this._fadeOutSeconds <= 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds);
      let value;
      let c, parameterIndex;
      let time = timeOffsetSeconds;
      if (this._isLoop) {
        while (time > this._motionData.duration) {
          time -= this._motionData.duration;
        }
      }
      const curves = this._motionData.curves;
      for (c = 0; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c) {
        value = evaluateCurve(this._motionData, c, time);
        if (curves.at(c).id == this._modelCurveIdEyeBlink) {
          eyeBlinkValue = value;
        } else if (curves.at(c).id == this._modelCurveIdLipSync) {
          lipSyncValue = value;
        } else if (curves.at(c).id == this._modelCurveIdOpacity) {
          this._modelOpacity = value;
          model.setModelOapcity(this.getModelOpacityValue());
        }
      }
      let parameterMotionCurveCount = 0;
      for (; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c) {
        parameterMotionCurveCount++;
        parameterIndex = model.getParameterIndex(curves.at(c).id);
        if (parameterIndex == -1) {
          continue;
        }
        const sourceValue = model.getParameterValueByIndex(parameterIndex);
        value = evaluateCurve(this._motionData, c, time);
        if (eyeBlinkValue != Number.MAX_VALUE) {
          for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < maxTargetSize; ++i) {
            if (this._eyeBlinkParameterIds.at(i) == curves.at(c).id) {
              value *= eyeBlinkValue;
              eyeBlinkFlags |= 1 << i;
              break;
            }
          }
        }
        if (lipSyncValue != Number.MAX_VALUE) {
          for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < maxTargetSize; ++i) {
            if (this._lipSyncParameterIds.at(i) == curves.at(c).id) {
              value += lipSyncValue;
              lipSyncFlags |= 1 << i;
              break;
            }
          }
        }
        let v;
        if (curves.at(c).fadeInTime < 0 && curves.at(c).fadeOutTime < 0) {
          v = sourceValue + (value - sourceValue) * fadeWeight;
        } else {
          let fin;
          let fout;
          if (curves.at(c).fadeInTime < 0) {
            fin = tmpFadeIn;
          } else {
            fin = curves.at(c).fadeInTime == 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / curves.at(c).fadeInTime);
          }
          if (curves.at(c).fadeOutTime < 0) {
            fout = tmpFadeOut;
          } else {
            fout = curves.at(c).fadeOutTime == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / curves.at(c).fadeOutTime);
          }
          const paramWeight = this._weight * fin * fout;
          v = sourceValue + (value - sourceValue) * paramWeight;
        }
        model.setParameterValueByIndex(parameterIndex, v, 1);
      }
      {
        if (eyeBlinkValue != Number.MAX_VALUE) {
          for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < maxTargetSize; ++i) {
            const sourceValue = model.getParameterValueById(this._eyeBlinkParameterIds.at(i));
            if (eyeBlinkFlags >> i & 1) {
              continue;
            }
            const v = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;
            model.setParameterValueById(this._eyeBlinkParameterIds.at(i), v);
          }
        }
        if (lipSyncValue != Number.MAX_VALUE) {
          for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < maxTargetSize; ++i) {
            const sourceValue = model.getParameterValueById(this._lipSyncParameterIds.at(i));
            if (lipSyncFlags >> i & 1) {
              continue;
            }
            const v = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;
            model.setParameterValueById(this._lipSyncParameterIds.at(i), v);
          }
        }
      }
      for (; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c) {
        parameterIndex = model.getParameterIndex(curves.at(c).id);
        if (parameterIndex == -1) {
          continue;
        }
        value = evaluateCurve(this._motionData, c, time);
        model.setParameterValueByIndex(parameterIndex, value);
      }
      if (timeOffsetSeconds >= this._motionData.duration) {
        if (this._isLoop) {
          motionQueueEntry.setStartTime(userTimeSeconds);
          if (this._isLoopFadeIn) {
            motionQueueEntry.setFadeInStartTime(userTimeSeconds);
          }
        } else {
          if (this._onFinishedMotion) {
            this._onFinishedMotion(this);
          }
          motionQueueEntry.setIsFinished(true);
        }
      }
      this._lastWeight = fadeWeight;
    }
    /**
     * 
     * @param loop 
     */
    setIsLoop(loop) {
      this._isLoop = loop;
    }
    /**
     * 
     * @return true 
     * @return false 
     */
    isLoop() {
      return this._isLoop;
    }
    /**
     * 
     * @param loopFadeIn  
     */
    setIsLoopFadeIn(loopFadeIn) {
      this._isLoopFadeIn = loopFadeIn;
    }
    /**
     * 
     *
     * @return  true    
     * @return  false   
     */
    isLoopFadeIn() {
      return this._isLoopFadeIn;
    }
    /**
     * 
     *
     * @return  []
     */
    getDuration() {
      return this._isLoop ? -1 : this._loopDurationSeconds;
    }
    /**
     * 
     *
     * @return  []
     */
    getLoopDuration() {
      return this._loopDurationSeconds;
    }
    /**
     * 
     *
     * @param parameterId     ID
     * @param value           []
     */
    setParameterFadeInTime(parameterId, value) {
      const curves = this._motionData.curves;
      for (let i = 0; i < this._motionData.curveCount; ++i) {
        if (parameterId == curves.at(i).id) {
          curves.at(i).fadeInTime = value;
          return;
        }
      }
    }
    /**
     * 
     * @param parameterId     ID
     * @param value           []
     */
    setParameterFadeOutTime(parameterId, value) {
      const curves = this._motionData.curves;
      for (let i = 0; i < this._motionData.curveCount; ++i) {
        if (parameterId == curves.at(i).id) {
          curves.at(i).fadeOutTime = value;
          return;
        }
      }
    }
    /**
     * 
     * @param    parameterId     ID
     * @return   []
     */
    getParameterFadeInTime(parameterId) {
      const curves = this._motionData.curves;
      for (let i = 0; i < this._motionData.curveCount; ++i) {
        if (parameterId == curves.at(i).id) {
          return curves.at(i).fadeInTime;
        }
      }
      return -1;
    }
    /**
     * 
     *
     * @param   parameterId     ID
     * @return   []
     */
    getParameterFadeOutTime(parameterId) {
      const curves = this._motionData.curves;
      for (let i = 0; i < this._motionData.curveCount; ++i) {
        if (parameterId == curves.at(i).id) {
          return curves.at(i).fadeOutTime;
        }
      }
      return -1;
    }
    /**
     * ID
     * @param eyeBlinkParameterIds    ID
     * @param lipSyncParameterIds     ID
     */
    setEffectIds(eyeBlinkParameterIds, lipSyncParameterIds) {
      this._eyeBlinkParameterIds = eyeBlinkParameterIds;
      this._lipSyncParameterIds = lipSyncParameterIds;
    }
    /**
     * 
     */
    release() {
      this._motionData = void 0;
      this._motionData = null;
    }
    /**
     * motion3.json
     *
     * @param motionJson  motion3.json
     * @param size        
     */
    parse(motionJson, size) {
      this._motionData = new CubismMotionData();
      let json = new CubismMotionJson(motionJson, size);
      if (!json) {
        json.release();
        json = void 0;
        return;
      }
      this._motionData.duration = json.getMotionDuration();
      this._motionData.loop = json.isMotionLoop();
      this._motionData.curveCount = json.getMotionCurveCount();
      this._motionData.fps = json.getMotionFps();
      this._motionData.eventCount = json.getEventCount();
      const areBeziersRestructed = json.getEvaluationOptionFlag(EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted);
      if (json.isExistMotionFadeInTime()) {
        this._fadeInSeconds = json.getMotionFadeInTime() < 0 ? 1 : json.getMotionFadeInTime();
      } else {
        this._fadeInSeconds = 1;
      }
      if (json.isExistMotionFadeOutTime()) {
        this._fadeOutSeconds = json.getMotionFadeOutTime() < 0 ? 1 : json.getMotionFadeOutTime();
      } else {
        this._fadeOutSeconds = 1;
      }
      this._motionData.curves.updateSize(this._motionData.curveCount, CubismMotionCurve, true);
      this._motionData.segments.updateSize(json.getMotionTotalSegmentCount(), CubismMotionSegment, true);
      this._motionData.points.updateSize(json.getMotionTotalPointCount(), CubismMotionPoint, true);
      this._motionData.events.updateSize(this._motionData.eventCount, CubismMotionEvent, true);
      let totalPointCount = 0;
      let totalSegmentCount = 0;
      for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {
        if (json.getMotionCurveTarget(curveCount) == TargetNameModel) {
          this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;
        } else if (json.getMotionCurveTarget(curveCount) == TargetNameParameter) {
          this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;
        } else if (json.getMotionCurveTarget(curveCount) == TargetNamePartOpacity) {
          this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;
        } else {
          CubismLogWarning('Warning : Unable to get segment type from Curve! The number of "CurveCount" may be incorrect!');
        }
        this._motionData.curves.at(curveCount).id = json.getMotionCurveId(curveCount);
        this._motionData.curves.at(curveCount).baseSegmentIndex = totalSegmentCount;
        this._motionData.curves.at(curveCount).fadeInTime = json.isExistMotionCurveFadeInTime(curveCount) ? json.getMotionCurveFadeInTime(curveCount) : -1;
        this._motionData.curves.at(curveCount).fadeOutTime = json.isExistMotionCurveFadeOutTime(curveCount) ? json.getMotionCurveFadeOutTime(curveCount) : -1;
        for (let segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount); ) {
          if (segmentPosition == 0) {
            this._motionData.segments.at(totalSegmentCount).basePointIndex = totalPointCount;
            this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition);
            this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
            totalPointCount += 1;
            segmentPosition += 2;
          } else {
            this._motionData.segments.at(totalSegmentCount).basePointIndex = totalPointCount - 1;
          }
          const segment = json.getMotionCurveSegment(curveCount, segmentPosition);
          const segmentType = segment;
          switch (segmentType) {
            case CubismMotionSegmentType.CubismMotionSegmentType_Linear: {
              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Linear;
              this._motionData.segments.at(totalSegmentCount).evaluate = linearEvaluate;
              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
              totalPointCount += 1;
              segmentPosition += 3;
              break;
            }
            case CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {
              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Bezier;
              if (areBeziersRestructed || UseOldBeziersCurveMotion) {
                this._motionData.segments.at(totalSegmentCount).evaluate = bezierEvaluate;
              } else {
                this._motionData.segments.at(totalSegmentCount).evaluate = bezierEvaluateCardanoInterpretation;
              }
              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
              this._motionData.points.at(totalPointCount + 1).time = json.getMotionCurveSegment(curveCount, segmentPosition + 3);
              this._motionData.points.at(totalPointCount + 1).value = json.getMotionCurveSegment(curveCount, segmentPosition + 4);
              this._motionData.points.at(totalPointCount + 2).time = json.getMotionCurveSegment(curveCount, segmentPosition + 5);
              this._motionData.points.at(totalPointCount + 2).value = json.getMotionCurveSegment(curveCount, segmentPosition + 6);
              totalPointCount += 3;
              segmentPosition += 7;
              break;
            }
            case CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {
              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Stepped;
              this._motionData.segments.at(totalSegmentCount).evaluate = steppedEvaluate;
              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
              totalPointCount += 1;
              segmentPosition += 3;
              break;
            }
            case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {
              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;
              this._motionData.segments.at(totalSegmentCount).evaluate = inverseSteppedEvaluate;
              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
              totalPointCount += 1;
              segmentPosition += 3;
              break;
            }
            default: {
              CSM_ASSERT(0);
              break;
            }
          }
          ++this._motionData.curves.at(curveCount).segmentCount;
          ++totalSegmentCount;
        }
      }
      for (let userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {
        this._motionData.events.at(userdatacount).fireTime = json.getEventTime(userdatacount);
        this._motionData.events.at(userdatacount).value = json.getEventValue(userdatacount);
      }
      json.release();
      json = void 0;
      json = null;
    }
    /**
     * 
     *
     * 
     * 
     *
     * @param beforeCheckTimeSeconds   []
     * @param motionTimeSeconds        []
     */
    getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
      this._firedEventValues.updateSize(0);
      for (let u = 0; u < this._motionData.eventCount; ++u) {
        if (this._motionData.events.at(u).fireTime > beforeCheckTimeSeconds && this._motionData.events.at(u).fireTime <= motionTimeSeconds) {
          this._firedEventValues.pushBack(new csmString(this._motionData.events.at(u).value.s));
        }
      }
      return this._firedEventValues;
    }
    /**
     * 
     *
     * @returns true  -> 
     *          false -> 
     */
    isExistModelOpacity() {
      for (let i = 0; i < this._motionData.curveCount; i++) {
        const curve = this._motionData.curves.at(i);
        if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
          continue;
        }
        if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
          return true;
        }
      }
      return false;
    }
    /**
     * 
     *
     * @returns success:
     */
    getModelOpacityIndex() {
      if (this.isExistModelOpacity()) {
        for (let i = 0; i < this._motionData.curveCount; i++) {
          const curve = this._motionData.curves.at(i);
          if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
            continue;
          }
          if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
            return i;
          }
        }
      }
      return -1;
    }
    /**
     * Id
     *
     * @param index 
     * @returns success:
     */
    getModelOpacityId(index) {
      if (index != -1) {
        const curve = this._motionData.curves.at(index);
        if (curve.type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
          if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
            return CubismFramework.getIdManager().getId(curve.id.getString().s);
          }
        }
      }
      return null;
    }
    /**
     * 
     *
     * @returns success:Opacity
     */
    getModelOpacityValue() {
      return this._modelOpacity;
    }
    // 
  };
  var Live2DCubismFramework30;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotion = CubismMotion;
  })(Live2DCubismFramework30 || (Live2DCubismFramework30 = {}));

  // src/Live2D/dist/motion/cubismmotionmanager.js
  var CubismMotionManager = class extends CubismMotionQueueManager {
    /**
     * 
     */
    constructor() {
      super();
      __publicField(this, "_currentPriority");
      // 
      __publicField(this, "_reservePriority");
      this._currentPriority = 0;
      this._reservePriority = 0;
    }
    /**
     * 
     * @return  
     */
    getCurrentPriority() {
      return this._currentPriority;
    }
    /**
     * 
     * @return  
     */
    getReservePriority() {
      return this._reservePriority;
    }
    /**
     * 
     * @param   val     
     */
    setReservePriority(val) {
      this._reservePriority = val;
    }
    /**
     * 
     *
     * @param motion          
     * @param autoDelete      true
     * @param priority        
     * @return                IsFinished()-1
     */
    startMotionPriority(motion, autoDelete, priority) {
      if (priority == this._reservePriority) {
        this._reservePriority = 0;
      }
      this._currentPriority = priority;
      return super.startMotion(motion, autoDelete);
    }
    /**
     * 
     *
     * @param model   
     * @param deltaTimeSeconds    []
     * @return  true    
     * @return  false   
     */
    updateMotion(model, deltaTimeSeconds) {
      this._userTimeSeconds += deltaTimeSeconds;
      const updated = super.doUpdateMotion(model, this._userTimeSeconds);
      if (this.isFinished()) {
        this._currentPriority = 0;
      }
      return updated;
    }
    /**
     * 
     *
     * @param   priority    
     * @return  true    
     * @return  false   
     */
    reserveMotion(priority) {
      if (priority <= this._reservePriority || priority <= this._currentPriority) {
        return false;
      }
      this._reservePriority = priority;
      return true;
    }
    // 0
  };
  var Live2DCubismFramework31;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionManager = CubismMotionManager;
  })(Live2DCubismFramework31 || (Live2DCubismFramework31 = {}));

  // src/Live2D/dist/physics/cubismphysicsinternal.js
  var CubismPhysicsTargetType;
  (function(CubismPhysicsTargetType2) {
    CubismPhysicsTargetType2[CubismPhysicsTargetType2["CubismPhysicsTargetType_Parameter"] = 0] = "CubismPhysicsTargetType_Parameter";
  })(CubismPhysicsTargetType || (CubismPhysicsTargetType = {}));
  var CubismPhysicsSource;
  (function(CubismPhysicsSource2) {
    CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_X"] = 0] = "CubismPhysicsSource_X";
    CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_Y"] = 1] = "CubismPhysicsSource_Y";
    CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_Angle"] = 2] = "CubismPhysicsSource_Angle";
  })(CubismPhysicsSource || (CubismPhysicsSource = {}));
  var PhysicsJsonEffectiveForces = class {
    constructor() {
      __publicField(this, "gravity");
      // 
      __publicField(this, "wind");
      this.gravity = new CubismVector2(0, 0);
      this.wind = new CubismVector2(0, 0);
    }
    // 
  };
  var CubismPhysicsParameter = class {
    constructor() {
      __publicField(this, "id");
      // 
      __publicField(this, "targetType");
    }
    // 
  };
  var CubismPhysicsNormalization = class {
    constructor() {
      __publicField(this, "minimum");
      // 
      __publicField(this, "maximum");
      // 
      __publicField(this, "defalut");
    }
    // 
  };
  var CubismPhysicsParticle = class {
    constructor() {
      __publicField(this, "initialPosition");
      // 
      __publicField(this, "mobility");
      // 
      __publicField(this, "delay");
      // 
      __publicField(this, "acceleration");
      // 
      __publicField(this, "radius");
      // 
      __publicField(this, "position");
      // 
      __publicField(this, "lastPosition");
      // 
      __publicField(this, "lastGravity");
      // 
      __publicField(this, "force");
      // 
      __publicField(this, "velocity");
      this.initialPosition = new CubismVector2(0, 0);
      this.position = new CubismVector2(0, 0);
      this.lastPosition = new CubismVector2(0, 0);
      this.lastGravity = new CubismVector2(0, 0);
      this.force = new CubismVector2(0, 0);
      this.velocity = new CubismVector2(0, 0);
    }
    // 
  };
  var CubismPhysicsSubRig = class {
    constructor() {
      __publicField(this, "inputCount");
      // 
      __publicField(this, "outputCount");
      // 
      __publicField(this, "particleCount");
      // 
      __publicField(this, "baseInputIndex");
      // 
      __publicField(this, "baseOutputIndex");
      // 
      __publicField(this, "baseParticleIndex");
      // 
      __publicField(this, "normalizationPosition");
      // 
      __publicField(this, "normalizationAngle");
      this.normalizationPosition = new CubismPhysicsNormalization();
      this.normalizationAngle = new CubismPhysicsNormalization();
    }
    // 
  };
  var CubismPhysicsInput = class {
    constructor() {
      __publicField(this, "source");
      // 
      __publicField(this, "sourceParameterIndex");
      // 
      __publicField(this, "weight");
      // 
      __publicField(this, "type");
      // 
      __publicField(this, "reflect");
      // 
      __publicField(this, "getNormalizedParameterValue");
      this.source = new CubismPhysicsParameter();
    }
    // 
  };
  var CubismPhysicsOutput = class {
    constructor() {
      __publicField(this, "destination");
      // 
      __publicField(this, "destinationParameterIndex");
      // 
      __publicField(this, "vertexIndex");
      // 
      __publicField(this, "translationScale");
      // 
      __publicField(this, "angleScale");
      // 
      __publicField(this, "weight");
      // 
      __publicField(this, "type");
      // 
      __publicField(this, "reflect");
      // 
      __publicField(this, "valueBelowMinimum");
      // 
      __publicField(this, "valueExceededMaximum");
      // 
      __publicField(this, "getValue");
      // 
      __publicField(this, "getScale");
      this.destination = new CubismPhysicsParameter();
      this.translationScale = new CubismVector2(0, 0);
    }
    // 
  };
  var CubismPhysicsRig = class {
    constructor() {
      __publicField(this, "subRigCount");
      // 
      __publicField(this, "settings");
      // 
      __publicField(this, "inputs");
      // 
      __publicField(this, "outputs");
      // 
      __publicField(this, "particles");
      // 
      __publicField(this, "gravity");
      // 
      __publicField(this, "wind");
      // 
      __publicField(this, "fps");
      this.settings = new csmVector();
      this.inputs = new csmVector();
      this.outputs = new csmVector();
      this.particles = new csmVector();
      this.gravity = new CubismVector2(0, 0);
      this.wind = new CubismVector2(0, 0);
      this.fps = 0;
    }
    //FPS
  };
  var Live2DCubismFramework32;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismPhysicsInput = CubismPhysicsInput;
    Live2DCubismFramework42.CubismPhysicsNormalization = CubismPhysicsNormalization;
    Live2DCubismFramework42.CubismPhysicsOutput = CubismPhysicsOutput;
    Live2DCubismFramework42.CubismPhysicsParameter = CubismPhysicsParameter;
    Live2DCubismFramework42.CubismPhysicsParticle = CubismPhysicsParticle;
    Live2DCubismFramework42.CubismPhysicsRig = CubismPhysicsRig;
    Live2DCubismFramework42.CubismPhysicsSource = CubismPhysicsSource;
    Live2DCubismFramework42.CubismPhysicsSubRig = CubismPhysicsSubRig;
    Live2DCubismFramework42.CubismPhysicsTargetType = CubismPhysicsTargetType;
    Live2DCubismFramework42.PhysicsJsonEffectiveForces = PhysicsJsonEffectiveForces;
  })(Live2DCubismFramework32 || (Live2DCubismFramework32 = {}));

  // src/Live2D/dist/physics/cubismphysicsjson.js
  var Position = "Position";
  var X = "X";
  var Y = "Y";
  var Angle = "Angle";
  var Type = "Type";
  var Id4 = "Id";
  var Meta2 = "Meta";
  var EffectiveForces = "EffectiveForces";
  var TotalInputCount = "TotalInputCount";
  var TotalOutputCount = "TotalOutputCount";
  var PhysicsSettingCount = "PhysicsSettingCount";
  var Gravity = "Gravity";
  var Wind = "Wind";
  var VertexCount = "VertexCount";
  var Fps2 = "Fps";
  var PhysicsSettings = "PhysicsSettings";
  var Normalization = "Normalization";
  var Minimum = "Minimum";
  var Maximum = "Maximum";
  var Default = "Default";
  var Reflect2 = "Reflect";
  var Weight = "Weight";
  var Input = "Input";
  var Source = "Source";
  var Output = "Output";
  var Scale = "Scale";
  var VertexIndex = "VertexIndex";
  var Destination = "Destination";
  var Vertices = "Vertices";
  var Mobility = "Mobility";
  var Delay = "Delay";
  var Radius = "Radius";
  var Acceleration = "Acceleration";
  var CubismPhysicsJson = class {
    /**
     * 
     * @param buffer physics3.json
     * @param size 
     */
    constructor(buffer, size) {
      __publicField(this, "_json");
      this._json = CubismJson.create(buffer, size);
    }
    /**
     * 
     */
    release() {
      CubismJson.delete(this._json);
    }
    /**
     * 
     * @return 
     */
    getGravity() {
      const ret = new CubismVector2(0, 0);
      ret.x = this._json.getRoot().getValueByString(Meta2).getValueByString(EffectiveForces).getValueByString(Gravity).getValueByString(X).toFloat();
      ret.y = this._json.getRoot().getValueByString(Meta2).getValueByString(EffectiveForces).getValueByString(Gravity).getValueByString(Y).toFloat();
      return ret;
    }
    /**
     * 
     * @return 
     */
    getWind() {
      const ret = new CubismVector2(0, 0);
      ret.x = this._json.getRoot().getValueByString(Meta2).getValueByString(EffectiveForces).getValueByString(Wind).getValueByString(X).toFloat();
      ret.y = this._json.getRoot().getValueByString(Meta2).getValueByString(EffectiveForces).getValueByString(Wind).getValueByString(Y).toFloat();
      return ret;
    }
    /**
     * FPS
     * @return FPS
     */
    getFps() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(Fps2).toFloat(0);
    }
    /**
     * 
     * @return 
     */
    getSubRigCount() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(PhysicsSettingCount).toInt();
    }
    /**
     * 
     * @return 
     */
    getTotalInputCount() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(TotalInputCount).toInt();
    }
    /**
     * 
     * @return 
     */
    getTotalOutputCount() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(TotalOutputCount).toInt();
    }
    /**
     * 
     * @return 
     */
    getVertexCount() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(VertexCount).toInt();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationPositionMinimumValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Minimum).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationPositionMaximumValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Maximum).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationPositionDefaultValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Default).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationAngleMinimumValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Minimum).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex
     * @return 
     */
    getNormalizationAngleMaximumValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Maximum).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getNormalizationAngleDefaultValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Default).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getInputCount(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getVector().getSize();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param inputIndex 
     * @return 
     */
    getInputWeight(physicsSettingIndex, inputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Weight).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param inputIndex 
     * @return 
     */
    getInputReflect(physicsSettingIndex, inputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Reflect2).toBoolean();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param inputIndex 
     * @return 
     */
    getInputType(physicsSettingIndex, inputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Type).getRawString();
    }
    /**
     * ID
     * @param physicsSettingIndex 
     * @param inputIndex 
     * @return ID
     */
    getInputSourceId(physicsSettingIndex, inputIndex) {
      return CubismFramework.getIdManager().getId(this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Source).getValueByString(Id4).getRawString());
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getOutputCount(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getVector().getSize();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputVertexIndex(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(VertexIndex).toInt();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputAngleScale(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Scale).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputWeight(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Weight).toFloat();
    }
    /**
     * ID
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return ID
     */
    getOutputDestinationId(physicsSettingIndex, outputIndex) {
      return CubismFramework.getIdManager().getId(this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Destination).getValueByString(Id4).getRawString());
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputType(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Type).getRawString();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param outputIndex 
     * @return 
     */
    getOutputReflect(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Reflect2).toBoolean();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @return 
     */
    getParticleCount(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getVector().getSize();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticleMobility(physicsSettingIndex, vertexIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Mobility).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticleDelay(physicsSettingIndex, vertexIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Delay).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticleAcceleration(physicsSettingIndex, vertexIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Acceleration).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexIndex 
     * @return 
     */
    getParticleRadius(physicsSettingIndex, vertexIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Radius).toFloat();
    }
    /**
     * 
     * @param physicsSettingIndex 
     * @param vertexInde 
     * @return 
     */
    getParticlePosition(physicsSettingIndex, vertexIndex) {
      const ret = new CubismVector2(0, 0);
      ret.x = this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Position).getValueByString(X).toFloat();
      ret.y = this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Position).getValueByString(Y).toFloat();
      return ret;
    }
    // physics3.json
  };
  var Live2DCubismFramework33;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismPhysicsJson = CubismPhysicsJson;
  })(Live2DCubismFramework33 || (Live2DCubismFramework33 = {}));

  // src/Live2D/dist/physics/cubismphysics.js
  var PhysicsTypeTagX = "X";
  var PhysicsTypeTagY = "Y";
  var PhysicsTypeTagAngle = "Angle";
  var AirResistance = 5;
  var MaximumWeight = 100;
  var MovementThreshold = 1e-3;
  var MaxDeltaTime = 5;
  var CubismPhysics = class _CubismPhysics {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_physicsRig");
      // 
      __publicField(this, "_options");
      // 
      __publicField(this, "_currentRigOutputs");
      ///< 
      __publicField(this, "_previousRigOutputs");
      ///< 
      __publicField(this, "_currentRemainTime");
      ///< 
      __publicField(this, "_parameterCaches");
      ///< Evaluate
      __publicField(this, "_parameterInputCaches");
      this._physicsRig = null;
      this._options = new Options();
      this._options.gravity.y = -1;
      this._options.gravity.x = 0;
      this._options.wind.x = 0;
      this._options.wind.y = 0;
      this._currentRigOutputs = new csmVector();
      this._previousRigOutputs = new csmVector();
      this._currentRemainTime = 0;
      this._parameterCaches = null;
      this._parameterInputCaches = null;
    }
    /**
     * 
     * @param buffer    physics3.json
     * @param size      
     * @return 
     */
    static create(buffer, size) {
      const ret = new _CubismPhysics();
      ret.parse(buffer, size);
      ret._physicsRig.gravity.y = 0;
      return ret;
    }
    /**
     * 
     * @param physics 
     */
    static delete(physics) {
      if (physics != null) {
        physics.release();
        physics = null;
      }
    }
    /**
     * physics3.json
     * @param physicsJson physics3.json
     * @param size 
     */
    parse(physicsJson, size) {
      this._physicsRig = new CubismPhysicsRig();
      let json = new CubismPhysicsJson(physicsJson, size);
      this._physicsRig.gravity = json.getGravity();
      this._physicsRig.wind = json.getWind();
      this._physicsRig.subRigCount = json.getSubRigCount();
      this._physicsRig.fps = json.getFps();
      this._physicsRig.settings.updateSize(this._physicsRig.subRigCount, CubismPhysicsSubRig, true);
      this._physicsRig.inputs.updateSize(json.getTotalInputCount(), CubismPhysicsInput, true);
      this._physicsRig.outputs.updateSize(json.getTotalOutputCount(), CubismPhysicsOutput, true);
      this._physicsRig.particles.updateSize(json.getVertexCount(), CubismPhysicsParticle, true);
      this._currentRigOutputs.clear();
      this._previousRigOutputs.clear();
      let inputIndex = 0, outputIndex = 0, particleIndex = 0;
      for (let i = 0; i < this._physicsRig.settings.getSize(); ++i) {
        this._physicsRig.settings.at(i).normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(i);
        this._physicsRig.settings.at(i).normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(i);
        this._physicsRig.settings.at(i).normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(i);
        this._physicsRig.settings.at(i).normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(i);
        this._physicsRig.settings.at(i).normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(i);
        this._physicsRig.settings.at(i).normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(i);
        this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);
        this._physicsRig.settings.at(i).baseInputIndex = inputIndex;
        for (let j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {
          this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;
          this._physicsRig.inputs.at(inputIndex + j).weight = json.getInputWeight(i, j);
          this._physicsRig.inputs.at(inputIndex + j).reflect = json.getInputReflect(i, j);
          if (json.getInputType(i, j) == PhysicsTypeTagX) {
            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;
            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;
          } else if (json.getInputType(i, j) == PhysicsTypeTagY) {
            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;
            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;
          } else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {
            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;
            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;
          }
          this._physicsRig.inputs.at(inputIndex + j).source.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
          this._physicsRig.inputs.at(inputIndex + j).source.id = json.getInputSourceId(i, j);
        }
        inputIndex += this._physicsRig.settings.at(i).inputCount;
        this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);
        this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;
        const currentRigOutput = new PhysicsOutput();
        currentRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);
        const previousRigOutput = new PhysicsOutput();
        previousRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);
        for (let j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {
          currentRigOutput.outputs.set(j, 0);
          previousRigOutput.outputs.set(j, 0);
          this._physicsRig.outputs.at(outputIndex + j).destinationParameterIndex = -1;
          this._physicsRig.outputs.at(outputIndex + j).vertexIndex = json.getOutputVertexIndex(i, j);
          this._physicsRig.outputs.at(outputIndex + j).angleScale = json.getOutputAngleScale(i, j);
          this._physicsRig.outputs.at(outputIndex + j).weight = json.getOutputWeight(i, j);
          this._physicsRig.outputs.at(outputIndex + j).destination.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
          this._physicsRig.outputs.at(outputIndex + j).destination.id = json.getOutputDestinationId(i, j);
          if (json.getOutputType(i, j) == PhysicsTypeTagX) {
            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;
            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationX;
            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationX;
          } else if (json.getOutputType(i, j) == PhysicsTypeTagY) {
            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;
            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationY;
            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationY;
          } else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {
            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;
            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputAngle;
            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleAngle;
          }
          this._physicsRig.outputs.at(outputIndex + j).reflect = json.getOutputReflect(i, j);
        }
        this._currentRigOutputs.pushBack(currentRigOutput);
        this._previousRigOutputs.pushBack(previousRigOutput);
        outputIndex += this._physicsRig.settings.at(i).outputCount;
        this._physicsRig.settings.at(i).particleCount = json.getParticleCount(i);
        this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;
        for (let j = 0; j < this._physicsRig.settings.at(i).particleCount; ++j) {
          this._physicsRig.particles.at(particleIndex + j).mobility = json.getParticleMobility(i, j);
          this._physicsRig.particles.at(particleIndex + j).delay = json.getParticleDelay(i, j);
          this._physicsRig.particles.at(particleIndex + j).acceleration = json.getParticleAcceleration(i, j);
          this._physicsRig.particles.at(particleIndex + j).radius = json.getParticleRadius(i, j);
          this._physicsRig.particles.at(particleIndex + j).position = json.getParticlePosition(i, j);
        }
        particleIndex += this._physicsRig.settings.at(i).particleCount;
      }
      this.initialize();
      json.release();
      json = void 0;
      json = null;
    }
    /**
     * 
     * @param model 
     */
    stabilization(model) {
      var _a, _b, _c, _d;
      let totalAngle;
      let weight;
      let radAngle;
      let outputValue;
      const totalTranslation = new CubismVector2();
      let currentSetting;
      let currentInputs;
      let currentOutputs;
      let currentParticles;
      const parameterValues = model.getModel().parameters.values;
      const parameterMaximumValues = model.getModel().parameters.maximumValues;
      const parameterMinimumValues = model.getModel().parameters.minimumValues;
      const parameterDefaultValues = model.getModel().parameters.defaultValues;
      if (((_b = (_a = this._parameterCaches) == null ? void 0 : _a.length) != null ? _b : 0) < model.getParameterCount()) {
        this._parameterCaches = new Float32Array(model.getParameterCount());
      }
      if (((_d = (_c = this._parameterInputCaches) == null ? void 0 : _c.length) != null ? _d : 0) < model.getParameterCount()) {
        this._parameterInputCaches = new Float32Array(model.getParameterCount());
      }
      for (let j = 0; j < model.getParameterCount(); ++j) {
        this._parameterCaches[j] = parameterValues[j];
        this._parameterInputCaches[j] = parameterValues[j];
      }
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        totalAngle = { angle: 0 };
        totalTranslation.x = 0;
        totalTranslation.y = 0;
        currentSetting = this._physicsRig.settings.at(settingIndex);
        currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);
        currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);
        currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);
        for (let i = 0; i < currentSetting.inputCount; ++i) {
          weight = currentInputs[i].weight / MaximumWeight;
          if (currentInputs[i].sourceParameterIndex == -1) {
            currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);
          }
          currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, parameterValues[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);
          this._parameterCaches[currentInputs[i].sourceParameterIndex] = parameterValues[currentInputs[i].sourceParameterIndex];
        }
        radAngle = CubismMath.degreesToRadian(-totalAngle.angle);
        totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);
        totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);
        updateParticlesForStabilization(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum);
        for (let i = 0; i < currentSetting.outputCount; ++i) {
          const particleIndex = currentOutputs[i].vertexIndex;
          if (currentOutputs[i].destinationParameterIndex == -1) {
            currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);
          }
          if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {
            continue;
          }
          let translation = new CubismVector2();
          translation = currentParticles[particleIndex].position.substract(currentParticles[particleIndex - 1].position);
          outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);
          this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);
          this._previousRigOutputs.at(settingIndex).outputs.set(i, outputValue);
          const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
          const outParameterCaches = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) : parameterValues.slice(destinationParameterIndex);
          updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);
          for (let offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {
            parameterValues[offset] = this._parameterCaches[offset] = outParameterCaches[outParamIndex];
          }
        }
      }
    }
    /**
     * 
     *
     * Pendulum interpolation weights
     *
     * 
     * The result of the pendulum calculation is saved and
     * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.
     *
     * [1][2]
     * The figure shows the interpolation between [1] and [2].
     *
     * 
     * The weight of the interpolation are determined by the current time seen between
     * the latest pendulum calculation timing and the next timing.
     *
     * [2][4](3)
     * Figure shows the weight of position (3) as seen between [2] and [4].
     *
     * 
     * As an interpretation, the pendulum calculation and weights are misaligned.
     *
     * physics3.jsonFPS
     * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.
     *
     * 
     * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.
     *
     * ------------ time -------------->
     *
     *                 |+++++|------| <- weight
     * ==[1]====#=====[2]---(3)----(4)
     *          ^ output contents
     *
     * 1:_previousRigOutputs
     * 2:_currentRigOutputs
     * 3:_currentRemainTime (now rendering)
     * 4:next particles timing
     * @param model 
     * @param deltaTimeSeconds []
     */
    evaluate(model, deltaTimeSeconds) {
      var _a, _b, _c, _d;
      let totalAngle;
      let weight;
      let radAngle;
      let outputValue;
      const totalTranslation = new CubismVector2();
      let currentSetting;
      let currentInputs;
      let currentOutputs;
      let currentParticles;
      if (0 >= deltaTimeSeconds) {
        return;
      }
      const parameterValues = model.getModel().parameters.values;
      const parameterMaximumValues = model.getModel().parameters.maximumValues;
      const parameterMinimumValues = model.getModel().parameters.minimumValues;
      const parameterDefaultValues = model.getModel().parameters.defaultValues;
      let physicsDeltaTime;
      this._currentRemainTime += deltaTimeSeconds;
      if (this._currentRemainTime > MaxDeltaTime) {
        this._currentRemainTime = 0;
      }
      if (((_b = (_a = this._parameterCaches) == null ? void 0 : _a.length) != null ? _b : 0) < model.getParameterCount()) {
        this._parameterCaches = new Float32Array(model.getParameterCount());
      }
      if (((_d = (_c = this._parameterInputCaches) == null ? void 0 : _c.length) != null ? _d : 0) < model.getParameterCount()) {
        this._parameterInputCaches = new Float32Array(model.getParameterCount());
        for (let j = 0; j < model.getParameterCount(); ++j) {
          this._parameterInputCaches[j] = parameterValues[j];
        }
      }
      if (this._physicsRig.fps > 0) {
        physicsDeltaTime = 1 / this._physicsRig.fps;
      } else {
        physicsDeltaTime = deltaTimeSeconds;
      }
      while (this._currentRemainTime >= physicsDeltaTime) {
        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
          currentSetting = this._physicsRig.settings.at(settingIndex);
          currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);
          for (let i = 0; i < currentSetting.outputCount; ++i) {
            this._previousRigOutputs.at(settingIndex).outputs.set(i, this._currentRigOutputs.at(settingIndex).outputs.at(i));
          }
        }
        const inputWeight = physicsDeltaTime / this._currentRemainTime;
        for (let j = 0; j < model.getParameterCount(); ++j) {
          this._parameterCaches[j] = this._parameterInputCaches[j] * (1 - inputWeight) + parameterValues[j] * inputWeight;
          this._parameterInputCaches[j] = this._parameterCaches[j];
        }
        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
          totalAngle = { angle: 0 };
          totalTranslation.x = 0;
          totalTranslation.y = 0;
          currentSetting = this._physicsRig.settings.at(settingIndex);
          currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);
          currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);
          currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);
          for (let i = 0; i < currentSetting.inputCount; ++i) {
            weight = currentInputs[i].weight / MaximumWeight;
            if (currentInputs[i].sourceParameterIndex == -1) {
              currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);
            }
            currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, this._parameterCaches[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);
          }
          radAngle = CubismMath.degreesToRadian(-totalAngle.angle);
          totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);
          totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);
          updateParticles(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum, physicsDeltaTime, AirResistance);
          for (let i = 0; i < currentSetting.outputCount; ++i) {
            const particleIndex = currentOutputs[i].vertexIndex;
            if (currentOutputs[i].destinationParameterIndex == -1) {
              currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);
            }
            if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {
              continue;
            }
            const translation = new CubismVector2();
            translation.x = currentParticles[particleIndex].position.x - currentParticles[particleIndex - 1].position.x;
            translation.y = currentParticles[particleIndex].position.y - currentParticles[particleIndex - 1].position.y;
            outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);
            this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);
            const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
            const outParameterCaches = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(JSON.stringify(this._parameterCaches.subarray(destinationParameterIndex))) : this._parameterCaches.slice(destinationParameterIndex);
            updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);
            for (let offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {
              this._parameterCaches[offset] = outParameterCaches[outParamIndex];
            }
          }
        }
        this._currentRemainTime -= physicsDeltaTime;
      }
      const alpha = this._currentRemainTime / physicsDeltaTime;
      this.interpolate(model, alpha);
    }
    /**
     * 
     * 
     * @param model 
     * @param weight 
     */
    interpolate(model, weight) {
      let currentOutputs;
      let currentSetting;
      const parameterValues = model.getModel().parameters.values;
      const parameterMaximumValues = model.getModel().parameters.maximumValues;
      const parameterMinimumValues = model.getModel().parameters.minimumValues;
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        currentSetting = this._physicsRig.settings.at(settingIndex);
        currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);
        for (let i = 0; i < currentSetting.outputCount; ++i) {
          if (currentOutputs[i].destinationParameterIndex == -1) {
            continue;
          }
          const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
          const outParameterValues = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) : parameterValues.slice(destinationParameterIndex);
          updateOutputParameterValue(outParameterValues, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], this._previousRigOutputs.at(settingIndex).outputs.at(i) * (1 - weight) + this._currentRigOutputs.at(settingIndex).outputs.at(i) * weight, currentOutputs[i]);
          for (let offset = destinationParameterIndex, outParamIndex = 0; offset < parameterValues.length; offset++, outParamIndex++) {
            parameterValues[offset] = outParameterValues[outParamIndex];
          }
        }
      }
    }
    /**
     * 
     * @param options 
     */
    setOptions(options) {
      this._options = options;
    }
    /**
     * 
     * @return 
     */
    getOption() {
      return this._options;
    }
    /**
     * 
     */
    release() {
      this._physicsRig = void 0;
      this._physicsRig = null;
    }
    /**
     * 
     */
    initialize() {
      let strand;
      let currentSetting;
      let radius;
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        currentSetting = this._physicsRig.settings.at(settingIndex);
        strand = this._physicsRig.particles.get(currentSetting.baseParticleIndex);
        strand[0].initialPosition = new CubismVector2(0, 0);
        strand[0].lastPosition = new CubismVector2(strand[0].initialPosition.x, strand[0].initialPosition.y);
        strand[0].lastGravity = new CubismVector2(0, -1);
        strand[0].lastGravity.y *= -1;
        strand[0].velocity = new CubismVector2(0, 0);
        strand[0].force = new CubismVector2(0, 0);
        for (let i = 1; i < currentSetting.particleCount; ++i) {
          radius = new CubismVector2(0, 0);
          radius.y = strand[i].radius;
          strand[i].initialPosition = new CubismVector2(strand[i - 1].initialPosition.x + radius.x, strand[i - 1].initialPosition.y + radius.y);
          strand[i].position = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);
          strand[i].lastPosition = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);
          strand[i].lastGravity = new CubismVector2(0, -1);
          strand[i].lastGravity.y *= -1;
          strand[i].velocity = new CubismVector2(0, 0);
          strand[i].force = new CubismVector2(0, 0);
        }
      }
    }
    ///< UpdateParticles
  };
  var Options = class {
    constructor() {
      __publicField(this, "gravity");
      // 
      __publicField(this, "wind");
      this.gravity = new CubismVector2(0, 0);
      this.wind = new CubismVector2(0, 0);
    }
    // 
  };
  var PhysicsOutput = class {
    constructor() {
      __publicField(this, "outputs");
      this.outputs = new csmVector(0);
    }
    // 
  };
  function sign(value) {
    let ret = 0;
    if (value > 0) {
      ret = 1;
    } else if (value < 0) {
      ret = -1;
    }
    return ret;
  }
  function getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
    targetTranslation.x += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;
  }
  function getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
    targetTranslation.y += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;
  }
  function getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {
    targetAngle.angle += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationAngle.minimum, normalizationAngle.maximum, normalizationAngle.defalut, isInverted) * weight;
  }
  function getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue = translation.x;
    if (isInverted) {
      outputValue *= -1;
    }
    return outputValue;
  }
  function getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue = translation.y;
    if (isInverted) {
      outputValue *= -1;
    }
    return outputValue;
  }
  function getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue;
    if (particleIndex >= 2) {
      parentGravity = particles[particleIndex - 1].position.substract(particles[particleIndex - 2].position);
    } else {
      parentGravity = parentGravity.multiplyByScaler(-1);
    }
    outputValue = CubismMath.directionToRadian(parentGravity, translation);
    if (isInverted) {
      outputValue *= -1;
    }
    return outputValue;
  }
  function getRangeValue(min, max) {
    const maxValue = CubismMath.max(min, max);
    const minValue = CubismMath.min(min, max);
    return CubismMath.abs(maxValue - minValue);
  }
  function getDefaultValue(min, max) {
    const minValue = CubismMath.min(min, max);
    return minValue + getRangeValue(min, max) / 2;
  }
  function getOutputScaleTranslationX(translationScale, angleScale) {
    return JSON.parse(JSON.stringify(translationScale.x));
  }
  function getOutputScaleTranslationY(translationScale, angleScale) {
    return JSON.parse(JSON.stringify(translationScale.y));
  }
  function getOutputScaleAngle(translationScale, angleScale) {
    return JSON.parse(JSON.stringify(angleScale));
  }
  function updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {
    let delay;
    let radian;
    let direction = new CubismVector2(0, 0);
    let velocity = new CubismVector2(0, 0);
    let force = new CubismVector2(0, 0);
    let newDirection = new CubismVector2(0, 0);
    strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);
    const totalRadian = CubismMath.degreesToRadian(totalAngle);
    const currentGravity = CubismMath.radianToDirection(totalRadian);
    currentGravity.normalize();
    for (let i = 1; i < strandCount; ++i) {
      strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);
      strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);
      delay = strand[i].delay * deltaTimeSeconds * 30;
      direction = strand[i].position.substract(strand[i - 1].position);
      radian = CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) / airResistance;
      direction.x = CubismMath.cos(radian) * direction.x - direction.y * CubismMath.sin(radian);
      direction.y = CubismMath.sin(radian) * direction.x + direction.y * CubismMath.cos(radian);
      strand[i].position = strand[i - 1].position.add(direction);
      velocity = strand[i].velocity.multiplyByScaler(delay);
      force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);
      strand[i].position = strand[i].position.add(velocity).add(force);
      newDirection = strand[i].position.substract(strand[i - 1].position);
      newDirection.normalize();
      strand[i].position = strand[i - 1].position.add(newDirection.multiplyByScaler(strand[i].radius));
      if (CubismMath.abs(strand[i].position.x) < thresholdValue) {
        strand[i].position.x = 0;
      }
      if (delay != 0) {
        strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);
        strand[i].velocity = strand[i].velocity.divisionByScalar(delay);
        strand[i].velocity = strand[i].velocity.multiplyByScaler(strand[i].mobility);
      }
      strand[i].force = new CubismVector2(0, 0);
      strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);
    }
  }
  function updateParticlesForStabilization(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue) {
    let force = new CubismVector2(0, 0);
    strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);
    const totalRadian = CubismMath.degreesToRadian(totalAngle);
    const currentGravity = CubismMath.radianToDirection(totalRadian);
    currentGravity.normalize();
    for (let i = 1; i < strandCount; ++i) {
      strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);
      strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);
      strand[i].velocity = new CubismVector2(0, 0);
      force = strand[i].force;
      force.normalize();
      force = force.multiplyByScaler(strand[i].radius);
      strand[i].position = strand[i - 1].position.add(force);
      if (CubismMath.abs(strand[i].position.x) < thresholdValue) {
        strand[i].position.x = 0;
      }
      strand[i].force = new CubismVector2(0, 0);
      strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);
    }
  }
  function updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {
    let value;
    const outputScale = output.getScale(output.translationScale, output.angleScale);
    value = translation * outputScale;
    if (value < parameterValueMinimum) {
      if (value < output.valueBelowMinimum) {
        output.valueBelowMinimum = value;
      }
      value = parameterValueMinimum;
    } else if (value > parameterValueMaximum) {
      if (value > output.valueExceededMaximum) {
        output.valueExceededMaximum = value;
      }
      value = parameterValueMaximum;
    }
    const weight = output.weight / MaximumWeight;
    if (weight >= 1) {
      parameterValue[0] = value;
    } else {
      value = parameterValue[0] * (1 - weight) + value * weight;
      parameterValue[0] = value;
    }
  }
  function normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {
    let result = 0;
    const maxValue = CubismMath.max(parameterMaximum, parameterMinimum);
    if (maxValue < value) {
      value = maxValue;
    }
    const minValue = CubismMath.min(parameterMaximum, parameterMinimum);
    if (minValue > value) {
      value = minValue;
    }
    const minNormValue = CubismMath.min(normalizedMinimum, normalizedMaximum);
    const maxNormValue = CubismMath.max(normalizedMinimum, normalizedMaximum);
    const middleNormValue = normalizedDefault;
    const middleValue = getDefaultValue(minValue, maxValue);
    const paramValue = value - middleValue;
    switch (sign(paramValue)) {
      case 1: {
        const nLength = maxNormValue - middleNormValue;
        const pLength = maxValue - middleValue;
        if (pLength != 0) {
          result = paramValue * (nLength / pLength);
          result += middleNormValue;
        }
        break;
      }
      case -1: {
        const nLength = minNormValue - middleNormValue;
        const pLength = minValue - middleValue;
        if (pLength != 0) {
          result = paramValue * (nLength / pLength);
          result += middleNormValue;
        }
        break;
      }
      case 0: {
        result = middleNormValue;
        break;
      }
      default: {
        break;
      }
    }
    return isInverted ? result : result * -1;
  }
  var Live2DCubismFramework34;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismPhysics = CubismPhysics;
    Live2DCubismFramework42.Options = Options;
  })(Live2DCubismFramework34 || (Live2DCubismFramework34 = {}));

  // src/Live2D/dist/rendering/cubismclippingmanager.js
  var ColorChannelCount = 4;
  var ClippingMaskMaxCountOnDefault = 36;
  var ClippingMaskMaxCountOnMultiRenderTexture = 32;
  var CubismClippingManager = class {
    /**
     * 
     */
    constructor(clippingContextFactory) {
      __publicField(this, "_clearedFrameBufferFlags");
      //
      __publicField(this, "_channelColors");
      __publicField(this, "_clippingContextListForMask");
      // 
      __publicField(this, "_clippingContextListForDraw");
      // 
      __publicField(this, "_clippingMaskBufferSize");
      // :256
      __publicField(this, "_renderTextureCount");
      // 
      __publicField(this, "_tmpMatrix");
      // 
      __publicField(this, "_tmpMatrixForMask");
      // 
      __publicField(this, "_tmpMatrixForDraw");
      // 
      __publicField(this, "_tmpBoundsOnModel");
      // 
      __publicField(this, "_clippingContexttConstructor");
      this._renderTextureCount = 0;
      this._clippingMaskBufferSize = 256;
      this._clippingContextListForMask = new csmVector();
      this._clippingContextListForDraw = new csmVector();
      this._channelColors = new csmVector();
      this._tmpBoundsOnModel = new csmRect();
      this._tmpMatrix = new CubismMatrix44();
      this._tmpMatrixForMask = new CubismMatrix44();
      this._tmpMatrixForDraw = new CubismMatrix44();
      this._clippingContexttConstructor = clippingContextFactory;
      let tmp = new CubismTextureColor();
      tmp.r = 1;
      tmp.g = 0;
      tmp.b = 0;
      tmp.a = 0;
      this._channelColors.pushBack(tmp);
      tmp = new CubismTextureColor();
      tmp.r = 0;
      tmp.g = 1;
      tmp.b = 0;
      tmp.a = 0;
      this._channelColors.pushBack(tmp);
      tmp = new CubismTextureColor();
      tmp.r = 0;
      tmp.g = 0;
      tmp.b = 1;
      tmp.a = 0;
      this._channelColors.pushBack(tmp);
      tmp = new CubismTextureColor();
      tmp.r = 0;
      tmp.g = 0;
      tmp.b = 0;
      tmp.a = 1;
      this._channelColors.pushBack(tmp);
    }
    /**
     * 
     */
    release() {
      for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {
        if (this._clippingContextListForMask.at(i)) {
          this._clippingContextListForMask.at(i).release();
          this._clippingContextListForMask.set(i, void 0);
        }
        this._clippingContextListForMask.set(i, null);
      }
      this._clippingContextListForMask = null;
      for (let i = 0; i < this._clippingContextListForDraw.getSize(); i++) {
        this._clippingContextListForDraw.set(i, null);
      }
      this._clippingContextListForDraw = null;
      for (let i = 0; i < this._channelColors.getSize(); i++) {
        this._channelColors.set(i, null);
      }
      this._channelColors = null;
      if (this._clearedFrameBufferFlags != null) {
        this._clearedFrameBufferFlags.clear();
      }
      this._clearedFrameBufferFlags = null;
    }
    /**
     * 
     * 
     * @param model 
     * @param renderTextureCount 
     */
    initialize(model, renderTextureCount) {
      if (renderTextureCount % 1 != 0) {
        CubismLogWarning("The number of render textures must be specified as an integer. The decimal point is rounded down and corrected to an integer.");
        renderTextureCount = ~~renderTextureCount;
      }
      if (renderTextureCount < 1) {
        CubismLogWarning("The number of render textures must be an integer greater than or equal to 1. Set the number of render textures to 1.");
      }
      this._renderTextureCount = renderTextureCount < 1 ? 1 : renderTextureCount;
      this._clearedFrameBufferFlags = new csmVector(this._renderTextureCount);
      for (let i = 0; i < model.getDrawableCount(); i++) {
        if (model.getDrawableMaskCounts()[i] <= 0) {
          this._clippingContextListForDraw.pushBack(null);
          continue;
        }
        let clippingContext = this.findSameClip(model.getDrawableMasks()[i], model.getDrawableMaskCounts()[i]);
        if (clippingContext == null) {
          clippingContext = new this._clippingContexttConstructor(this, model.getDrawableMasks()[i], model.getDrawableMaskCounts()[i]);
          this._clippingContextListForMask.pushBack(clippingContext);
        }
        clippingContext.addClippedDrawable(i);
        this._clippingContextListForDraw.pushBack(clippingContext);
      }
    }
    /**
     * 
     * 
     * NULL
     * @param drawableMasks 
     * @param drawableMaskCounts 
     * @return NULL
     */
    findSameClip(drawableMasks, drawableMaskCounts) {
      for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {
        const clippingContext = this._clippingContextListForMask.at(i);
        const count = clippingContext._clippingIdCount;
        if (count != drawableMaskCounts) {
          continue;
        }
        let sameCount = 0;
        for (let j = 0; j < count; j++) {
          const clipId = clippingContext._clippingIdList[j];
          for (let k = 0; k < count; k++) {
            if (drawableMasks[k] == clipId) {
              sameCount++;
              break;
            }
          }
        }
        if (sameCount == count) {
          return clippingContext;
        }
      }
      return null;
    }
    /**
     * 
     * @param model 
     * @param isRightHanded 
     */
    setupMatrixForHighPrecision(model, isRightHanded) {
      let usingClipCount = 0;
      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
        const cc = this._clippingContextListForMask.at(clipIndex);
        this.calcClippedDrawTotalBounds(model, cc);
        if (cc._isUsing) {
          usingClipCount++;
        }
      }
      if (usingClipCount > 0) {
        this.setupLayoutBounds(0);
        if (this._clearedFrameBufferFlags.getSize() != this._renderTextureCount) {
          this._clearedFrameBufferFlags.clear();
          for (let i = 0; i < this._renderTextureCount; i++) {
            this._clearedFrameBufferFlags.pushBack(false);
          }
        } else {
          for (let i = 0; i < this._renderTextureCount; i++) {
            this._clearedFrameBufferFlags.set(i, false);
          }
        }
        for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
          const clipContext = this._clippingContextListForMask.at(clipIndex);
          const allClippedDrawRect = clipContext._allClippedDrawRect;
          const layoutBoundsOnTex01 = clipContext._layoutBounds;
          const margin = 0.05;
          let scaleX = 0;
          let scaleY = 0;
          const ppu = model.getPixelsPerUnit();
          const maskPixelSize = clipContext.getClippingManager().getClippingMaskBufferSize();
          const physicalMaskWidth = layoutBoundsOnTex01.width * maskPixelSize;
          const physicalMaskHeight = layoutBoundsOnTex01.height * maskPixelSize;
          this._tmpBoundsOnModel.setRect(allClippedDrawRect);
          if (this._tmpBoundsOnModel.width * ppu > physicalMaskWidth) {
            this._tmpBoundsOnModel.expand(allClippedDrawRect.width * margin, 0);
            scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
          } else {
            scaleX = ppu / physicalMaskWidth;
          }
          if (this._tmpBoundsOnModel.height * ppu > physicalMaskHeight) {
            this._tmpBoundsOnModel.expand(0, allClippedDrawRect.height * margin);
            scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
          } else {
            scaleY = ppu / physicalMaskHeight;
          }
          this.createMatrixForMask(isRightHanded, layoutBoundsOnTex01, scaleX, scaleY);
          clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());
          clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());
        }
      }
    }
    /**
     * 
     * @param isRightHanded 
     * @param layoutBoundsOnTex01 
     * @param scaleX 
     * @param scaleY 
     */
    createMatrixForMask(isRightHanded, layoutBoundsOnTex01, scaleX, scaleY) {
      this._tmpMatrix.loadIdentity();
      {
        this._tmpMatrix.translateRelative(-1, -1);
        this._tmpMatrix.scaleRelative(2, 2);
      }
      {
        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);
        this._tmpMatrix.scaleRelative(scaleX, scaleY);
        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
      }
      this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());
      this._tmpMatrix.loadIdentity();
      {
        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y * (isRightHanded ? -1 : 1));
        this._tmpMatrix.scaleRelative(scaleX, scaleY * (isRightHanded ? -1 : 1));
        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
      }
      this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());
    }
    /**
     * 
     * 
     * 4RGBA56RGBA2,2,1,1
     *
     * @param usingClipCount 
     */
    setupLayoutBounds(usingClipCount) {
      const useClippingMaskMaxCount = this._renderTextureCount <= 1 ? ClippingMaskMaxCountOnDefault : ClippingMaskMaxCountOnMultiRenderTexture * this._renderTextureCount;
      if (usingClipCount <= 0 || usingClipCount > useClippingMaskMaxCount) {
        if (usingClipCount > useClippingMaskMaxCount) {
          CubismLogError("not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}", usingClipCount - useClippingMaskMaxCount, this._renderTextureCount, usingClipCount);
        }
        for (let index = 0; index < this._clippingContextListForMask.getSize(); index++) {
          const clipContext = this._clippingContextListForMask.at(index);
          clipContext._layoutChannelIndex = 0;
          clipContext._layoutBounds.x = 0;
          clipContext._layoutBounds.y = 0;
          clipContext._layoutBounds.width = 1;
          clipContext._layoutBounds.height = 1;
          clipContext._bufferIndex = 0;
        }
        return;
      }
      const layoutCountMaxValue = this._renderTextureCount <= 1 ? 9 : 8;
      let countPerSheetDiv = usingClipCount / this._renderTextureCount;
      const reduceLayoutTextureCount = usingClipCount % this._renderTextureCount;
      countPerSheetDiv = Math.ceil(countPerSheetDiv);
      let divCount = countPerSheetDiv / ColorChannelCount;
      const modCount = countPerSheetDiv % ColorChannelCount;
      divCount = ~~divCount;
      let curClipIndex = 0;
      for (let renderTextureIndex = 0; renderTextureIndex < this._renderTextureCount; renderTextureIndex++) {
        for (let channelIndex = 0; channelIndex < ColorChannelCount; channelIndex++) {
          let layoutCount = divCount + (channelIndex < modCount ? 1 : 0);
          const checkChannelIndex = modCount + (divCount < 1 ? -1 : 0);
          if (channelIndex == checkChannelIndex && reduceLayoutTextureCount > 0) {
            layoutCount -= !(renderTextureIndex < reduceLayoutTextureCount) ? 1 : 0;
          }
          if (layoutCount == 0) {
          } else if (layoutCount == 1) {
            const clipContext = this._clippingContextListForMask.at(curClipIndex++);
            clipContext._layoutChannelIndex = channelIndex;
            clipContext._layoutBounds.x = 0;
            clipContext._layoutBounds.y = 0;
            clipContext._layoutBounds.width = 1;
            clipContext._layoutBounds.height = 1;
            clipContext._bufferIndex = renderTextureIndex;
          } else if (layoutCount == 2) {
            for (let i = 0; i < layoutCount; i++) {
              let xpos = i % 2;
              xpos = ~~xpos;
              const cc = this._clippingContextListForMask.at(curClipIndex++);
              cc._layoutChannelIndex = channelIndex;
              cc._layoutBounds.x = xpos * 0.5;
              cc._layoutBounds.y = 0;
              cc._layoutBounds.width = 0.5;
              cc._layoutBounds.height = 1;
              cc._bufferIndex = renderTextureIndex;
            }
          } else if (layoutCount <= 4) {
            for (let i = 0; i < layoutCount; i++) {
              let xpos = i % 2;
              let ypos = i / 2;
              xpos = ~~xpos;
              ypos = ~~ypos;
              const cc = this._clippingContextListForMask.at(curClipIndex++);
              cc._layoutChannelIndex = channelIndex;
              cc._layoutBounds.x = xpos * 0.5;
              cc._layoutBounds.y = ypos * 0.5;
              cc._layoutBounds.width = 0.5;
              cc._layoutBounds.height = 0.5;
              cc._bufferIndex = renderTextureIndex;
            }
          } else if (layoutCount <= layoutCountMaxValue) {
            for (let i = 0; i < layoutCount; i++) {
              let xpos = i % 3;
              let ypos = i / 3;
              xpos = ~~xpos;
              ypos = ~~ypos;
              const cc = this._clippingContextListForMask.at(curClipIndex++);
              cc._layoutChannelIndex = channelIndex;
              cc._layoutBounds.x = xpos / 3;
              cc._layoutBounds.y = ypos / 3;
              cc._layoutBounds.width = 1 / 3;
              cc._layoutBounds.height = 1 / 3;
              cc._bufferIndex = renderTextureIndex;
            }
          } else {
            CubismLogError("not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}", usingClipCount - useClippingMaskMaxCount, this._renderTextureCount, usingClipCount);
            for (let index = 0; index < layoutCount; index++) {
              const cc = this._clippingContextListForMask.at(curClipIndex++);
              cc._layoutChannelIndex = 0;
              cc._layoutBounds.x = 0;
              cc._layoutBounds.y = 0;
              cc._layoutBounds.width = 1;
              cc._layoutBounds.height = 1;
              cc._bufferIndex = 0;
            }
          }
        }
      }
    }
    /**
     * 
     * @param model 
     * @param clippingContext 
     */
    calcClippedDrawTotalBounds(model, clippingContext) {
      let clippedDrawTotalMinX = Number.MAX_VALUE;
      let clippedDrawTotalMinY = Number.MAX_VALUE;
      let clippedDrawTotalMaxX = Number.MIN_VALUE;
      let clippedDrawTotalMaxY = Number.MIN_VALUE;
      const clippedDrawCount = clippingContext._clippedDrawableIndexList.length;
      for (let clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {
        const drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];
        const drawableVertexCount = model.getDrawableVertexCount(drawableIndex);
        const drawableVertexes = model.getDrawableVertices(drawableIndex);
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        let maxX = -Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;
        const loop = drawableVertexCount * Constant.vertexStep;
        for (let pi = Constant.vertexOffset; pi < loop; pi += Constant.vertexStep) {
          const x = drawableVertexes[pi];
          const y = drawableVertexes[pi + 1];
          if (x < minX) {
            minX = x;
          }
          if (x > maxX) {
            maxX = x;
          }
          if (y < minY) {
            minY = y;
          }
          if (y > maxY) {
            maxY = y;
          }
        }
        if (minX == Number.MAX_VALUE) {
          continue;
        }
        if (minX < clippedDrawTotalMinX) {
          clippedDrawTotalMinX = minX;
        }
        if (minY < clippedDrawTotalMinY) {
          clippedDrawTotalMinY = minY;
        }
        if (maxX > clippedDrawTotalMaxX) {
          clippedDrawTotalMaxX = maxX;
        }
        if (maxY > clippedDrawTotalMaxY) {
          clippedDrawTotalMaxY = maxY;
        }
        if (clippedDrawTotalMinX == Number.MAX_VALUE) {
          clippingContext._allClippedDrawRect.x = 0;
          clippingContext._allClippedDrawRect.y = 0;
          clippingContext._allClippedDrawRect.width = 0;
          clippingContext._allClippedDrawRect.height = 0;
          clippingContext._isUsing = false;
        } else {
          clippingContext._isUsing = true;
          const w = clippedDrawTotalMaxX - clippedDrawTotalMinX;
          const h = clippedDrawTotalMaxY - clippedDrawTotalMinY;
          clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;
          clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;
          clippingContext._allClippedDrawRect.width = w;
          clippingContext._allClippedDrawRect.height = h;
        }
      }
    }
    /**
     * 
     * @return 
     */
    getClippingContextListForDraw() {
      return this._clippingContextListForDraw;
    }
    /**
     * 
     * @return 
     */
    getClippingMaskBufferSize() {
      return this._clippingMaskBufferSize;
    }
    /**
     * 
     * @return 
     */
    getRenderTextureCount() {
      return this._renderTextureCount;
    }
    /**
     * RGBA
     * @param channelNo RGBA0:R, 1:G, 2:B, 3:A
     */
    getChannelFlagAsColor(channelNo) {
      return this._channelColors.at(channelNo);
    }
    /**
     * 
     * @param size 
     */
    setClippingMaskBufferSize(size) {
      this._clippingMaskBufferSize = size;
    }
  };

  // src/Live2D/dist/rendering/cubismshader_webgl.js
  var s_instance2;
  var ShaderCount = 10;
  var CubismShader_WebGL = class _CubismShader_WebGL {
    /**
     * private
     */
    constructor() {
      __publicField(this, "_shaderSets");
      // 
      __publicField(this, "gl");
      this._shaderSets = new csmVector();
    }
    /**
     * 
     * @return 
     */
    static getInstance() {
      if (s_instance2 == null) {
        s_instance2 = new _CubismShader_WebGL();
        return s_instance2;
      }
      return s_instance2;
    }
    /**
     * 
     */
    static deleteInstance() {
      if (s_instance2) {
        s_instance2.release();
        s_instance2 = null;
      }
    }
    /**
     * 
     */
    release() {
      this.releaseShaderProgram();
    }
    /**
     * 
     * @param renderer 
     * @param model 
     * @param index 
     */
    setupShaderProgramForDraw(renderer, model, index) {
      if (!renderer.isPremultipliedAlpha()) {
        CubismLogError("NoPremultipliedAlpha is not allowed");
      }
      if (this._shaderSets.getSize() == 0) {
        this.generateShaders();
      }
      let srcColor;
      let dstColor;
      let srcAlpha;
      let dstAlpha;
      const masked = renderer.getClippingContextBufferForDraw() != null;
      const invertedMask = model.getDrawableInvertedMaskBit(index);
      const offset = masked ? invertedMask ? 2 : 1 : 0;
      let shaderSet;
      switch (model.getDrawableBlendMode(index)) {
        case CubismBlendMode.CubismBlendMode_Normal:
        default:
          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_NormalPremultipliedAlpha + offset);
          srcColor = this.gl.ONE;
          dstColor = this.gl.ONE_MINUS_SRC_ALPHA;
          srcAlpha = this.gl.ONE;
          dstAlpha = this.gl.ONE_MINUS_SRC_ALPHA;
          break;
        case CubismBlendMode.CubismBlendMode_Additive:
          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_AddPremultipliedAlpha + offset);
          srcColor = this.gl.ONE;
          dstColor = this.gl.ONE;
          srcAlpha = this.gl.ZERO;
          dstAlpha = this.gl.ONE;
          break;
        case CubismBlendMode.CubismBlendMode_Multiplicative:
          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_MultPremultipliedAlpha + offset);
          srcColor = this.gl.DST_COLOR;
          dstColor = this.gl.ONE_MINUS_SRC_ALPHA;
          srcAlpha = this.gl.ZERO;
          dstAlpha = this.gl.ONE;
          break;
      }
      this.gl.useProgram(shaderSet.shaderProgram);
      if (renderer._bufferData.vertex == null) {
        renderer._bufferData.vertex = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.vertex);
      const vertexArray = model.getDrawableVertices(index);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
      this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);
      if (renderer._bufferData.uv == null) {
        renderer._bufferData.uv = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
      const uvArray = model.getDrawableVertexUvs(index);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
      this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
      if (masked) {
        this.gl.activeTexture(this.gl.TEXTURE1);
        const tex = renderer.getClippingContextBufferForDraw().getClippingManager().getColorBuffer().at(renderer.getClippingContextBufferForDraw()._bufferIndex);
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);
        this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForDraw()._matrixForDraw.getArray());
        const channelIndex = renderer.getClippingContextBufferForDraw()._layoutChannelIndex;
        const colorChannel = renderer.getClippingContextBufferForDraw().getClippingManager().getChannelFlagAsColor(channelIndex);
        this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.r, colorChannel.g, colorChannel.b, colorChannel.a);
      }
      const textureNo = model.getDrawableTextureIndex(index);
      const textureId = renderer.getBindedTextures().getValue(textureNo);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
      const matrix4x4 = renderer.getMvpMatrix();
      this.gl.uniformMatrix4fv(shaderSet.uniformMatrixLocation, false, matrix4x4.getArray());
      const baseColor = renderer.getModelColorWithOpacity(model.getDrawableOpacity(index));
      const multiplyColor = model.getMultiplyColor(index);
      const screenColor = model.getScreenColor(index);
      this.gl.uniform4f(shaderSet.uniformBaseColorLocation, baseColor.r, baseColor.g, baseColor.b, baseColor.a);
      this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.r, multiplyColor.g, multiplyColor.b, multiplyColor.a);
      this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.r, screenColor.g, screenColor.b, screenColor.a);
      if (renderer._bufferData.index == null) {
        renderer._bufferData.index = this.gl.createBuffer();
      }
      const indexArray = model.getDrawableVertexIndices(index);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, renderer._bufferData.index);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);
      this.gl.blendFuncSeparate(srcColor, dstColor, srcAlpha, dstAlpha);
    }
    /**
     * 
     * @param renderer 
     * @param model 
     * @param index 
     */
    setupShaderProgramForMask(renderer, model, index) {
      if (!renderer.isPremultipliedAlpha()) {
        CubismLogError("NoPremultipliedAlpha is not allowed");
      }
      if (this._shaderSets.getSize() == 0) {
        this.generateShaders();
      }
      const shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_SetupMask);
      this.gl.useProgram(shaderSet.shaderProgram);
      if (renderer._bufferData.vertex == null) {
        renderer._bufferData.vertex = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.vertex);
      const vertexArray = model.getDrawableVertices(index);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
      this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);
      if (renderer._bufferData.uv == null) {
        renderer._bufferData.uv = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
      const textureNo = model.getDrawableTextureIndex(index);
      const textureId = renderer.getBindedTextures().getValue(textureNo);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
      if (renderer._bufferData.uv == null) {
        renderer._bufferData.uv = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
      const uvArray = model.getDrawableVertexUvs(index);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
      this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
      const context = renderer.getClippingContextBufferForMask();
      const channelIndex = renderer.getClippingContextBufferForMask()._layoutChannelIndex;
      const colorChannel = renderer.getClippingContextBufferForMask().getClippingManager().getChannelFlagAsColor(channelIndex);
      this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.r, colorChannel.g, colorChannel.b, colorChannel.a);
      this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForMask()._matrixForMask.getArray());
      const rect = renderer.getClippingContextBufferForMask()._layoutBounds;
      this.gl.uniform4f(shaderSet.uniformBaseColorLocation, rect.x * 2 - 1, rect.y * 2 - 1, rect.getRight() * 2 - 1, rect.getBottom() * 2 - 1);
      const multiplyColor = model.getMultiplyColor(index);
      const screenColor = model.getScreenColor(index);
      this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.r, multiplyColor.g, multiplyColor.b, multiplyColor.a);
      this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.r, screenColor.g, screenColor.b, screenColor.a);
      const srcColor = this.gl.ZERO;
      const dstColor = this.gl.ONE_MINUS_SRC_COLOR;
      const srcAlpha = this.gl.ZERO;
      const dstAlpha = this.gl.ONE_MINUS_SRC_ALPHA;
      if (renderer._bufferData.index == null) {
        renderer._bufferData.index = this.gl.createBuffer();
      }
      const indexArray = model.getDrawableVertexIndices(index);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, renderer._bufferData.index);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);
      this.gl.blendFuncSeparate(srcColor, dstColor, srcAlpha, dstAlpha);
    }
    /**
     * 
     */
    releaseShaderProgram() {
      for (let i = 0; i < this._shaderSets.getSize(); i++) {
        this.gl.deleteProgram(this._shaderSets.at(i).shaderProgram);
        this._shaderSets.at(i).shaderProgram = 0;
        this._shaderSets.set(i, void 0);
        this._shaderSets.set(i, null);
      }
    }
    /**
     * 
     * @param vertShaderSrc 
     * @param fragShaderSrc 
     */
    generateShaders() {
      for (let i = 0; i < ShaderCount; i++) {
        this._shaderSets.pushBack(new CubismShaderSet());
      }
      this._shaderSets.at(0).shaderProgram = this.loadShaderProgram(vertexShaderSrcSetupMask, fragmentShaderSrcsetupMask);
      this._shaderSets.at(1).shaderProgram = this.loadShaderProgram(vertexShaderSrc, fragmentShaderSrcPremultipliedAlpha);
      this._shaderSets.at(2).shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskPremultipliedAlpha);
      this._shaderSets.at(3).shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskInvertedPremultipliedAlpha);
      this._shaderSets.at(4).shaderProgram = this._shaderSets.at(1).shaderProgram;
      this._shaderSets.at(5).shaderProgram = this._shaderSets.at(2).shaderProgram;
      this._shaderSets.at(6).shaderProgram = this._shaderSets.at(3).shaderProgram;
      this._shaderSets.at(7).shaderProgram = this._shaderSets.at(1).shaderProgram;
      this._shaderSets.at(8).shaderProgram = this._shaderSets.at(2).shaderProgram;
      this._shaderSets.at(9).shaderProgram = this._shaderSets.at(3).shaderProgram;
      this._shaderSets.at(0).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, "a_position");
      this._shaderSets.at(0).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, "a_texCoord");
      this._shaderSets.at(0).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "s_texture0");
      this._shaderSets.at(0).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(0).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_channelFlag");
      this._shaderSets.at(0).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_baseColor");
      this._shaderSets.at(0).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(0).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_screenColor");
      this._shaderSets.at(1).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, "a_position");
      this._shaderSets.at(1).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, "a_texCoord");
      this._shaderSets.at(1).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "s_texture0");
      this._shaderSets.at(1).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "u_matrix");
      this._shaderSets.at(1).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "u_baseColor");
      this._shaderSets.at(1).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(1).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "u_screenColor");
      this._shaderSets.at(2).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, "a_position");
      this._shaderSets.at(2).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, "a_texCoord");
      this._shaderSets.at(2).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "s_texture0");
      this._shaderSets.at(2).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "s_texture1");
      this._shaderSets.at(2).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_matrix");
      this._shaderSets.at(2).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(2).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_channelFlag");
      this._shaderSets.at(2).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_baseColor");
      this._shaderSets.at(2).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(2).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_screenColor");
      this._shaderSets.at(3).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, "a_position");
      this._shaderSets.at(3).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, "a_texCoord");
      this._shaderSets.at(3).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "s_texture0");
      this._shaderSets.at(3).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "s_texture1");
      this._shaderSets.at(3).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_matrix");
      this._shaderSets.at(3).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(3).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_channelFlag");
      this._shaderSets.at(3).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_baseColor");
      this._shaderSets.at(3).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(3).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_screenColor");
      this._shaderSets.at(4).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, "a_position");
      this._shaderSets.at(4).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, "a_texCoord");
      this._shaderSets.at(4).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "s_texture0");
      this._shaderSets.at(4).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "u_matrix");
      this._shaderSets.at(4).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "u_baseColor");
      this._shaderSets.at(4).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(4).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "u_screenColor");
      this._shaderSets.at(5).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, "a_position");
      this._shaderSets.at(5).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, "a_texCoord");
      this._shaderSets.at(5).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "s_texture0");
      this._shaderSets.at(5).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "s_texture1");
      this._shaderSets.at(5).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_matrix");
      this._shaderSets.at(5).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(5).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_channelFlag");
      this._shaderSets.at(5).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_baseColor");
      this._shaderSets.at(5).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(5).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_screenColor");
      this._shaderSets.at(6).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, "a_position");
      this._shaderSets.at(6).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, "a_texCoord");
      this._shaderSets.at(6).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "s_texture0");
      this._shaderSets.at(6).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "s_texture1");
      this._shaderSets.at(6).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_matrix");
      this._shaderSets.at(6).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(6).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_channelFlag");
      this._shaderSets.at(6).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_baseColor");
      this._shaderSets.at(6).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(6).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_screenColor");
      this._shaderSets.at(7).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, "a_position");
      this._shaderSets.at(7).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, "a_texCoord");
      this._shaderSets.at(7).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "s_texture0");
      this._shaderSets.at(7).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "u_matrix");
      this._shaderSets.at(7).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "u_baseColor");
      this._shaderSets.at(7).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(7).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "u_screenColor");
      this._shaderSets.at(8).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, "a_position");
      this._shaderSets.at(8).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, "a_texCoord");
      this._shaderSets.at(8).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "s_texture0");
      this._shaderSets.at(8).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "s_texture1");
      this._shaderSets.at(8).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_matrix");
      this._shaderSets.at(8).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(8).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_channelFlag");
      this._shaderSets.at(8).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_baseColor");
      this._shaderSets.at(8).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(8).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_screenColor");
      this._shaderSets.at(9).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, "a_position");
      this._shaderSets.at(9).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, "a_texCoord");
      this._shaderSets.at(9).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "s_texture0");
      this._shaderSets.at(9).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "s_texture1");
      this._shaderSets.at(9).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_matrix");
      this._shaderSets.at(9).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(9).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_channelFlag");
      this._shaderSets.at(9).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_baseColor");
      this._shaderSets.at(9).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(9).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_screenColor");
    }
    /**
     * 
     * @param vertexShaderSource    
     * @param fragmentShaderSource  
     * @return 
     */
    loadShaderProgram(vertexShaderSource, fragmentShaderSource) {
      let shaderProgram = this.gl.createProgram();
      let vertShader = this.compileShaderSource(this.gl.VERTEX_SHADER, vertexShaderSource);
      if (!vertShader) {
        CubismLogError("Vertex shader compile error!");
        return 0;
      }
      let fragShader = this.compileShaderSource(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
      if (!fragShader) {
        CubismLogError("Vertex shader compile error!");
        return 0;
      }
      this.gl.attachShader(shaderProgram, vertShader);
      this.gl.attachShader(shaderProgram, fragShader);
      this.gl.linkProgram(shaderProgram);
      const linkStatus = this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS);
      if (!linkStatus) {
        CubismLogError("Failed to link program: {0}", shaderProgram);
        this.gl.deleteShader(vertShader);
        vertShader = 0;
        this.gl.deleteShader(fragShader);
        fragShader = 0;
        if (shaderProgram) {
          this.gl.deleteProgram(shaderProgram);
          shaderProgram = 0;
        }
        return 0;
      }
      this.gl.deleteShader(vertShader);
      this.gl.deleteShader(fragShader);
      return shaderProgram;
    }
    /**
     * 
     * @param shaderType (Vertex/Fragment)
     * @param shaderSource 
     *
     * @return 
     */
    compileShaderSource(shaderType, shaderSource) {
      const source2 = shaderSource;
      const shader = this.gl.createShader(shaderType);
      this.gl.shaderSource(shader, source2);
      this.gl.compileShader(shader);
      if (!shader) {
        const log = this.gl.getShaderInfoLog(shader);
        CubismLogError("Shader compile log: {0} ", log);
      }
      const status = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);
      if (!status) {
        this.gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    setGl(gl) {
      this.gl = gl;
    }
    // webgl
  };
  var CubismShaderSet = class {
    constructor() {
      __publicField(this, "shaderProgram");
      // 
      __publicField(this, "attributePositionLocation");
      // Position
      __publicField(this, "attributeTexCoordLocation");
      // TexCoord
      __publicField(this, "uniformMatrixLocation");
      // Matrix
      __publicField(this, "uniformClipMatrixLocation");
      // ClipMatrix
      __publicField(this, "samplerTexture0Location");
      // Texture0
      __publicField(this, "samplerTexture1Location");
      // Texture1
      __publicField(this, "uniformBaseColorLocation");
      // BaseColor
      __publicField(this, "uniformChannelFlagLocation");
      // ChannelFlag
      __publicField(this, "uniformMultiplyColorLocation");
      // MultiplyColor
      __publicField(this, "uniformScreenColorLocation");
    }
    // ScreenColor
  };
  var ShaderNames;
  (function(ShaderNames2) {
    ShaderNames2[ShaderNames2["ShaderNames_SetupMask"] = 0] = "ShaderNames_SetupMask";
    ShaderNames2[ShaderNames2["ShaderNames_NormalPremultipliedAlpha"] = 1] = "ShaderNames_NormalPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_NormalMaskedPremultipliedAlpha"] = 2] = "ShaderNames_NormalMaskedPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_NomralMaskedInvertedPremultipliedAlpha"] = 3] = "ShaderNames_NomralMaskedInvertedPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_AddPremultipliedAlpha"] = 4] = "ShaderNames_AddPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_AddMaskedPremultipliedAlpha"] = 5] = "ShaderNames_AddMaskedPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_AddMaskedPremultipliedAlphaInverted"] = 6] = "ShaderNames_AddMaskedPremultipliedAlphaInverted";
    ShaderNames2[ShaderNames2["ShaderNames_MultPremultipliedAlpha"] = 7] = "ShaderNames_MultPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_MultMaskedPremultipliedAlpha"] = 8] = "ShaderNames_MultMaskedPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_MultMaskedPremultipliedAlphaInverted"] = 9] = "ShaderNames_MultMaskedPremultipliedAlphaInverted";
  })(ShaderNames || (ShaderNames = {}));
  var vertexShaderSrcSetupMask = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_myPos;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_clipMatrix * a_position;   v_myPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
  var fragmentShaderSrcsetupMask = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_myPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;void main(){   float isInside =        step(u_baseColor.x, v_myPos.x/v_myPos.w)       * step(u_baseColor.y, v_myPos.y/v_myPos.w)       * step(v_myPos.x/v_myPos.w, u_baseColor.z)       * step(v_myPos.y/v_myPos.w, u_baseColor.w);   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;}";
  var vertexShaderSrc = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;uniform mat4       u_matrix;void main(){   gl_Position = u_matrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
  var vertexShaderSrcMasked = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform mat4       u_matrix;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_matrix * a_position;   v_clipPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
  var fragmentShaderSrcPremultipliedAlpha = "precision mediump float;varying vec2       v_texCoord;uniform vec4       u_baseColor;uniform sampler2D  s_texture0;uniform vec4       u_multiplyColor;uniform vec4       u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 color = texColor * u_baseColor;   gl_FragColor = vec4(color.rgb, color.a);}";
  var fragmentShaderSrcMaskPremultipliedAlpha = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;uniform sampler2D  s_texture1;uniform vec4       u_multiplyColor;uniform vec4       u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 col_formask = texColor * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * maskVal;   gl_FragColor = col_formask;}";
  var fragmentShaderSrcMaskInvertedPremultipliedAlpha = "precision mediump float;varying vec2      v_texCoord;varying vec4      v_clipPos;uniform sampler2D s_texture0;uniform sampler2D s_texture1;uniform vec4      u_channelFlag;uniform vec4      u_baseColor;uniform vec4      u_multiplyColor;uniform vec4      u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 col_formask = texColor * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * (1.0 - maskVal);   gl_FragColor = col_formask;}";
  var Live2DCubismFramework35;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismShaderSet = CubismShaderSet;
    Live2DCubismFramework42.CubismShader_WebGL = CubismShader_WebGL;
    Live2DCubismFramework42.ShaderNames = ShaderNames;
  })(Live2DCubismFramework35 || (Live2DCubismFramework35 = {}));

  // src/Live2D/dist/rendering/cubismrenderer_webgl.js
  var s_viewport;
  var s_fbo;
  var CubismClippingManager_WebGL = class extends CubismClippingManager {
    /**
     * 
     */
    constructor() {
      super(CubismClippingContext_WebGL);
      __publicField(this, "_currentMaskRenderTexture");
      // 
      __publicField(this, "_maskRenderTextures");
      // 
      __publicField(this, "_maskColorBuffers");
      // 
      __publicField(this, "_currentFrameNo");
      // 
      __publicField(this, "_maskTexture");
      // 
      __publicField(this, "gl");
    }
    /**
     * 
     * FrameBufferObject
     *
     * @return 
     */
    getMaskRenderTexture() {
      if (this._maskTexture && this._maskTexture.textures != null) {
        this._maskTexture.frameNo = this._currentFrameNo;
      } else {
        if (this._maskRenderTextures != null) {
          this._maskRenderTextures.clear();
        }
        this._maskRenderTextures = new csmVector();
        if (this._maskColorBuffers != null) {
          this._maskColorBuffers.clear();
        }
        this._maskColorBuffers = new csmVector();
        const size = this._clippingMaskBufferSize;
        for (let index = 0; index < this._renderTextureCount; index++) {
          this._maskColorBuffers.pushBack(this.gl.createTexture());
          this.gl.bindTexture(this.gl.TEXTURE_2D, this._maskColorBuffers.at(index));
          this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, size, size, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
          this.gl.bindTexture(this.gl.TEXTURE_2D, null);
          this._maskRenderTextures.pushBack(this.gl.createFramebuffer());
          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._maskRenderTextures.at(index));
          this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this._maskColorBuffers.at(index), 0);
        }
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
        this._maskTexture = new CubismRenderTextureResource(this._currentFrameNo, this._maskRenderTextures);
      }
      return this._maskTexture.textures;
    }
    /**
     * WebGL
     * @param gl WebGL
     */
    setGL(gl) {
      this.gl = gl;
    }
    /**
     * 
     * @param model 
     * @param renderer 
     */
    setupClippingContext(model, renderer) {
      this._currentFrameNo++;
      let usingClipCount = 0;
      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
        const cc = this._clippingContextListForMask.at(clipIndex);
        this.calcClippedDrawTotalBounds(model, cc);
        if (cc._isUsing) {
          usingClipCount++;
        }
      }
      if (usingClipCount > 0) {
        this.gl.viewport(0, 0, this._clippingMaskBufferSize, this._clippingMaskBufferSize);
        this._currentMaskRenderTexture = this.getMaskRenderTexture().at(0);
        renderer.preDraw();
        this.setupLayoutBounds(usingClipCount);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._currentMaskRenderTexture);
        if (this._clearedFrameBufferFlags.getSize() != this._renderTextureCount) {
          this._clearedFrameBufferFlags.clear();
          this._clearedFrameBufferFlags = new csmVector(this._renderTextureCount);
        }
        for (let index = 0; index < this._clearedFrameBufferFlags.getSize(); index++) {
          this._clearedFrameBufferFlags.set(index, false);
        }
        for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
          const clipContext = this._clippingContextListForMask.at(clipIndex);
          const allClipedDrawRect = clipContext._allClippedDrawRect;
          const layoutBoundsOnTex01 = clipContext._layoutBounds;
          const margin = 0.05;
          let scaleX = 0;
          let scaleY = 0;
          const clipContextRenderTexture = this.getMaskRenderTexture().at(clipContext._bufferIndex);
          if (this._currentMaskRenderTexture != clipContextRenderTexture) {
            this._currentMaskRenderTexture = clipContextRenderTexture;
            renderer.preDraw();
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._currentMaskRenderTexture);
          }
          this._tmpBoundsOnModel.setRect(allClipedDrawRect);
          this._tmpBoundsOnModel.expand(allClipedDrawRect.width * margin, allClipedDrawRect.height * margin);
          scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
          scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
          {
            this._tmpMatrix.loadIdentity();
            {
              this._tmpMatrix.translateRelative(-1, -1);
              this._tmpMatrix.scaleRelative(2, 2);
            }
            {
              this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);
              this._tmpMatrix.scaleRelative(scaleX, scaleY);
              this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
            }
            this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());
          }
          {
            this._tmpMatrix.loadIdentity();
            {
              this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);
              this._tmpMatrix.scaleRelative(scaleX, scaleY);
              this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
            }
            this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());
          }
          clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());
          clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());
          const clipDrawCount = clipContext._clippingIdCount;
          for (let i = 0; i < clipDrawCount; i++) {
            const clipDrawIndex = clipContext._clippingIdList[i];
            if (!model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {
              continue;
            }
            renderer.setIsCulling(model.getDrawableCulling(clipDrawIndex) != false);
            if (!this._clearedFrameBufferFlags.at(clipContext._bufferIndex)) {
              this.gl.clearColor(1, 1, 1, 1);
              this.gl.clear(this.gl.COLOR_BUFFER_BIT);
              this._clearedFrameBufferFlags.set(clipContext._bufferIndex, true);
            }
            renderer.setClippingContextBufferForMask(clipContext);
            renderer.drawMeshWebGL(model, clipDrawIndex);
          }
        }
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
        renderer.setClippingContextBufferForMask(null);
        this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);
      }
    }
    /**
     * 
     * @return 
     */
    getColorBuffer() {
      return this._maskColorBuffers;
    }
    /**
     * 
     * @returns
     */
    getClippingMaskCount() {
      return this._clippingContextListForMask.getSize();
    }
    // WebGL
  };
  var CubismRenderTextureResource = class {
    /**
     * 
     * @param frameNo 
     * @param texture 
     */
    constructor(frameNo, texture) {
      __publicField(this, "frameNo");
      // 
      __publicField(this, "textures");
      this.frameNo = frameNo;
      this.textures = texture;
    }
    // 
  };
  var CubismClippingContext_WebGL = class extends CubismClippingContext {
    /**
     * 
     */
    constructor(manager, clippingDrawableIndices, clipCount) {
      super(clippingDrawableIndices, clipCount);
      __publicField(this, "_owner");
      this._owner = manager;
    }
    /**
     * 
     * @return 
     */
    getClippingManager() {
      return this._owner;
    }
    setGl(gl) {
      this._owner.setGL(gl);
    }
    // 
  };
  var CubismRendererProfile_WebGL = class {
    constructor() {
      __publicField(this, "_lastArrayBufferBinding");
      ///< 
      __publicField(this, "_lastElementArrayBufferBinding");
      ///< Element
      __publicField(this, "_lastProgram");
      ///< 
      __publicField(this, "_lastActiveTexture");
      ///< 
      __publicField(this, "_lastTexture0Binding2D");
      ///< 0
      __publicField(this, "_lastTexture1Binding2D");
      ///< 1
      __publicField(this, "_lastVertexAttribArrayEnabled");
      ///< 1
      __publicField(this, "_lastScissorTest");
      ///< GL_VERTEX_ATTRIB_ARRAY_ENABLED
      __publicField(this, "_lastBlend");
      ///< GL_SCISSOR_TEST
      __publicField(this, "_lastStencilTest");
      ///< GL_STENCIL_TEST
      __publicField(this, "_lastDepthTest");
      ///< GL_DEPTH_TEST
      __publicField(this, "_lastCullFace");
      ///< GL_CULL_FACE
      __publicField(this, "_lastFrontFace");
      ///< GL_CULL_FACE
      __publicField(this, "_lastColorMask");
      ///< GL_COLOR_WRITEMASK
      __publicField(this, "_lastBlending");
      ///< 
      __publicField(this, "_lastFBO");
      ///< 
      __publicField(this, "_lastViewport");
      ///< 
      __publicField(this, "gl");
      this._lastVertexAttribArrayEnabled = new Array(4);
      this._lastColorMask = new Array(4);
      this._lastBlending = new Array(4);
      this._lastViewport = new Array(4);
    }
    setGlEnable(index, enabled) {
      if (enabled)
        this.gl.enable(index);
      else
        this.gl.disable(index);
    }
    setGlEnableVertexAttribArray(index, enabled) {
      if (enabled)
        this.gl.enableVertexAttribArray(index);
      else
        this.gl.disableVertexAttribArray(index);
    }
    save() {
      if (this.gl == null) {
        CubismLogError("'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function.");
        return;
      }
      this._lastArrayBufferBinding = this.gl.getParameter(this.gl.ARRAY_BUFFER_BINDING);
      this._lastElementArrayBufferBinding = this.gl.getParameter(this.gl.ELEMENT_ARRAY_BUFFER_BINDING);
      this._lastProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);
      this._lastActiveTexture = this.gl.getParameter(this.gl.ACTIVE_TEXTURE);
      this.gl.activeTexture(this.gl.TEXTURE1);
      this._lastTexture1Binding2D = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this._lastTexture0Binding2D = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
      this._lastVertexAttribArrayEnabled[0] = this.gl.getVertexAttrib(0, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);
      this._lastVertexAttribArrayEnabled[1] = this.gl.getVertexAttrib(1, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);
      this._lastVertexAttribArrayEnabled[2] = this.gl.getVertexAttrib(2, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);
      this._lastVertexAttribArrayEnabled[3] = this.gl.getVertexAttrib(3, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);
      this._lastScissorTest = this.gl.isEnabled(this.gl.SCISSOR_TEST);
      this._lastStencilTest = this.gl.isEnabled(this.gl.STENCIL_TEST);
      this._lastDepthTest = this.gl.isEnabled(this.gl.DEPTH_TEST);
      this._lastCullFace = this.gl.isEnabled(this.gl.CULL_FACE);
      this._lastBlend = this.gl.isEnabled(this.gl.BLEND);
      this._lastFrontFace = this.gl.getParameter(this.gl.FRONT_FACE);
      this._lastColorMask = this.gl.getParameter(this.gl.COLOR_WRITEMASK);
      this._lastBlending[0] = this.gl.getParameter(this.gl.BLEND_SRC_RGB);
      this._lastBlending[1] = this.gl.getParameter(this.gl.BLEND_DST_RGB);
      this._lastBlending[2] = this.gl.getParameter(this.gl.BLEND_SRC_ALPHA);
      this._lastBlending[3] = this.gl.getParameter(this.gl.BLEND_DST_ALPHA);
      this._lastFBO = this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
      this._lastViewport = this.gl.getParameter(this.gl.VIEWPORT);
    }
    restore() {
      if (this.gl == null) {
        CubismLogError("'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function.");
        return;
      }
      this.gl.useProgram(this._lastProgram);
      this.setGlEnableVertexAttribArray(0, this._lastVertexAttribArrayEnabled[0]);
      this.setGlEnableVertexAttribArray(1, this._lastVertexAttribArrayEnabled[1]);
      this.setGlEnableVertexAttribArray(2, this._lastVertexAttribArrayEnabled[2]);
      this.setGlEnableVertexAttribArray(3, this._lastVertexAttribArrayEnabled[3]);
      this.setGlEnable(this.gl.SCISSOR_TEST, this._lastScissorTest);
      this.setGlEnable(this.gl.STENCIL_TEST, this._lastStencilTest);
      this.setGlEnable(this.gl.DEPTH_TEST, this._lastDepthTest);
      this.setGlEnable(this.gl.CULL_FACE, this._lastCullFace);
      this.setGlEnable(this.gl.BLEND, this._lastBlend);
      this.gl.frontFace(this._lastFrontFace);
      this.gl.colorMask(this._lastColorMask[0], this._lastColorMask[1], this._lastColorMask[2], this._lastColorMask[3]);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._lastArrayBufferBinding);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this._lastElementArrayBufferBinding);
      this.gl.activeTexture(this.gl.TEXTURE1);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture1Binding2D);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture0Binding2D);
      this.gl.activeTexture(this._lastActiveTexture);
      this.gl.blendFuncSeparate(this._lastBlending[0], this._lastBlending[1], this._lastBlending[2], this._lastBlending[3]);
    }
    setGl(gl) {
      this.gl = gl;
    }
  };
  var CubismRenderer_WebGL = class extends CubismRenderer {
    /**
     * 
     */
    constructor() {
      super();
      __publicField(this, "_textures");
      // 
      __publicField(this, "_sortedDrawableIndexList");
      // 
      __publicField(this, "_clippingManager");
      // 
      __publicField(this, "_clippingContextBufferForMask");
      // 
      __publicField(this, "_clippingContextBufferForDraw");
      // 
      __publicField(this, "_rendererProfile");
      __publicField(this, "firstDraw");
      __publicField(this, "_bufferData");
      // 
      __publicField(this, "_extension");
      // 
      __publicField(this, "gl");
      this._clippingContextBufferForMask = null;
      this._clippingContextBufferForDraw = null;
      this._rendererProfile = new CubismRendererProfile_WebGL();
      this.firstDraw = true;
      this._textures = new csmMap();
      this._sortedDrawableIndexList = new csmVector();
      this._bufferData = {
        vertex: WebGLBuffer = null,
        uv: WebGLBuffer = null,
        index: WebGLBuffer = null
      };
      this._textures.prepareCapacity(32, true);
    }
    /**
     * 
     * 
     *
     * @param model 
     * @param maskBufferCount 
     */
    initialize(model, maskBufferCount = 1) {
      if (model.isUsingMasking()) {
        this._clippingManager = new CubismClippingManager_WebGL();
        this._clippingManager.initialize(model, maskBufferCount);
      }
      this._sortedDrawableIndexList.resize(model.getDrawableCount(), 0);
      super.initialize(model);
    }
    /**
     * WebGL
     * CubismRendererCubismRendererIndex
     * @param modelTextureNo 
     * @param glTextureNo WebGL
     */
    bindTexture(modelTextureNo, glTexture) {
      this._textures.setValue(modelTextureNo, glTexture);
    }
    /**
     * WebGL
     * @return 
     */
    getBindedTextures() {
      return this._textures;
    }
    /**
     * 
     * FrameBuffer
     * @param size 
     */
    setClippingMaskBufferSize(size) {
      if (!this._model.isUsingMasking()) {
        return;
      }
      const renderTextureCount = this._clippingManager.getRenderTextureCount();
      this._clippingManager.release();
      this._clippingManager = void 0;
      this._clippingManager = null;
      this._clippingManager = new CubismClippingManager_WebGL();
      this._clippingManager.setClippingMaskBufferSize(size);
      this._clippingManager.initialize(
        this.getModel(),
        renderTextureCount
        // 
      );
    }
    /**
     * 
     * @return 
     */
    getClippingMaskBufferSize() {
      return this._model.isUsingMasking() ? this._clippingManager.getClippingMaskBufferSize() : -1;
    }
    /**
     * 
     * @return 
     */
    getRenderTextureCount() {
      return this._model.isUsingMasking() ? this._clippingManager.getRenderTextureCount() : -1;
    }
    /**
     * 
     */
    release() {
      if (this._clippingManager) {
        this._clippingManager.release();
        this._clippingManager = void 0;
        this._clippingManager = null;
      }
      if (this.gl == null) {
        return;
      }
      this.gl.deleteBuffer(this._bufferData.vertex);
      this._bufferData.vertex = null;
      this.gl.deleteBuffer(this._bufferData.uv);
      this._bufferData.uv = null;
      this.gl.deleteBuffer(this._bufferData.index);
      this._bufferData.index = null;
      this._bufferData = null;
      this._textures = null;
    }
    /**
     * 
     */
    doDrawModel() {
      if (this.gl == null) {
        CubismLogError("'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function.");
        return;
      }
      if (this._clippingManager != null) {
        this.preDraw();
        if (this.isUsingHighPrecisionMask()) {
          this._clippingManager.setupMatrixForHighPrecision(this.getModel(), false);
        } else {
          this._clippingManager.setupClippingContext(this.getModel(), this);
        }
      }
      this.preDraw();
      const drawableCount = this.getModel().getDrawableCount();
      const renderOrder = this.getModel().getDrawableRenderOrders();
      for (let i = 0; i < drawableCount; ++i) {
        const order = renderOrder[i];
        this._sortedDrawableIndexList.set(order, i);
      }
      for (let i = 0; i < drawableCount; ++i) {
        const drawableIndex = this._sortedDrawableIndexList.at(i);
        if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {
          continue;
        }
        const clipContext = this._clippingManager != null ? this._clippingManager.getClippingContextListForDraw().at(drawableIndex) : null;
        if (clipContext != null && this.isUsingHighPrecisionMask()) {
          if (clipContext._isUsing) {
            this.gl.viewport(0, 0, this._clippingManager.getClippingMaskBufferSize(), this._clippingManager.getClippingMaskBufferSize());
            this.preDraw();
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, clipContext.getClippingManager().getMaskRenderTexture().at(clipContext._bufferIndex));
            this.gl.clearColor(1, 1, 1, 1);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
          }
          {
            const clipDrawCount = clipContext._clippingIdCount;
            for (let index = 0; index < clipDrawCount; index++) {
              const clipDrawIndex = clipContext._clippingIdList[index];
              if (!this._model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {
                continue;
              }
              this.setIsCulling(this._model.getDrawableCulling(clipDrawIndex) != false);
              this.setClippingContextBufferForMask(clipContext);
              this.drawMeshWebGL(this._model, clipDrawIndex);
            }
          }
          {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
            this.setClippingContextBufferForMask(null);
            this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);
            this.preDraw();
          }
        }
        this.setClippingContextBufferForDraw(clipContext);
        this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));
        this.drawMeshWebGL(this._model, drawableIndex);
      }
    }
    /**
     * 
     * @param model 
     * @param index 
     */
    drawMeshWebGL(model, index) {
      if (this.isCulling()) {
        this.gl.enable(this.gl.CULL_FACE);
      } else {
        this.gl.disable(this.gl.CULL_FACE);
      }
      this.gl.frontFace(this.gl.CCW);
      if (this.isGeneratingMask()) {
        CubismShader_WebGL.getInstance().setupShaderProgramForMask(this, model, index);
      } else {
        CubismShader_WebGL.getInstance().setupShaderProgramForDraw(this, model, index);
      }
      {
        const indexCount = model.getDrawableVertexIndexCount(index);
        this.gl.drawElements(this.gl.TRIANGLES, indexCount, this.gl.UNSIGNED_SHORT, 0);
      }
      this.gl.useProgram(null);
      this.setClippingContextBufferForDraw(null);
      this.setClippingContextBufferForMask(null);
    }
    saveProfile() {
      this._rendererProfile.save();
    }
    restoreProfile() {
      this._rendererProfile.restore();
    }
    /**
     * 
     * WebGL
     */
    static doStaticRelease() {
      CubismShader_WebGL.deleteInstance();
    }
    /**
     * 
     * @param fbo 
     * @param viewport 
     */
    setRenderState(fbo, viewport) {
      s_fbo = fbo;
      s_viewport = viewport;
    }
    /**
     * 
     * 
     */
    preDraw() {
      if (this.firstDraw) {
        this.firstDraw = false;
      }
      this.gl.disable(this.gl.SCISSOR_TEST);
      this.gl.disable(this.gl.STENCIL_TEST);
      this.gl.disable(this.gl.DEPTH_TEST);
      this.gl.frontFace(this.gl.CW);
      this.gl.enable(this.gl.BLEND);
      this.gl.colorMask(true, true, true, true);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
      if (this.getAnisotropy() > 0 && this._extension) {
        for (let i = 0; i < this._textures.getSize(); ++i) {
          this.gl.bindTexture(this.gl.TEXTURE_2D, this._textures.getValue(i));
          this.gl.texParameterf(this.gl.TEXTURE_2D, this._extension.TEXTURE_MAX_ANISOTROPY_EXT, this.getAnisotropy());
        }
      }
    }
    /**
     * 
     */
    setClippingContextBufferForMask(clip) {
      this._clippingContextBufferForMask = clip;
    }
    /**
     * 
     * @return 
     */
    getClippingContextBufferForMask() {
      return this._clippingContextBufferForMask;
    }
    /**
     * 
     */
    setClippingContextBufferForDraw(clip) {
      this._clippingContextBufferForDraw = clip;
    }
    /**
     * 
     * @return 
     */
    getClippingContextBufferForDraw() {
      return this._clippingContextBufferForDraw;
    }
    /**
     * 
     * @returns 
     */
    isGeneratingMask() {
      return this.getClippingContextBufferForMask() != null;
    }
    /**
     * gl
     */
    startUp(gl) {
      this.gl = gl;
      if (this._clippingManager) {
        this._clippingManager.setGL(gl);
      }
      CubismShader_WebGL.getInstance().setGl(gl);
      this._rendererProfile.setGl(gl);
      this._extension = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic");
    }
    // webgl
  };
  CubismRenderer.staticRelease = () => {
    CubismRenderer_WebGL.doStaticRelease();
  };
  var Live2DCubismFramework36;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismClippingContext = CubismClippingContext_WebGL;
    Live2DCubismFramework42.CubismClippingManager_WebGL = CubismClippingManager_WebGL;
    Live2DCubismFramework42.CubismRenderTextureResource = CubismRenderTextureResource;
    Live2DCubismFramework42.CubismRenderer_WebGL = CubismRenderer_WebGL;
  })(Live2DCubismFramework36 || (Live2DCubismFramework36 = {}));

  // src/Live2D/dist/model/cubismmodel.js
  var DrawableColorData = class {
    constructor(isOverwritten = false, color = new CubismTextureColor()) {
      __publicField(this, "isOverwritten");
      __publicField(this, "color");
      this.isOverwritten = isOverwritten;
      this.color = color;
    }
  };
  var PartColorData = class {
    constructor(isOverwritten = false, color = new CubismTextureColor()) {
      __publicField(this, "isOverwritten");
      __publicField(this, "color");
      this.isOverwritten = isOverwritten;
      this.color = color;
    }
  };
  var DrawableCullingData = class {
    /**
     * 
     *
     * @param isOverwritten
     * @param isCulling
     */
    constructor(isOverwritten = false, isCulling = false) {
      __publicField(this, "isOverwritten");
      __publicField(this, "isCulling");
      this.isOverwritten = isOverwritten;
      this.isCulling = isCulling;
    }
  };
  var CubismModel = class {
    /**
     * 
     * @param model 
     */
    constructor(model) {
      __publicField(this, "_notExistPartOpacities");
      // 
      __publicField(this, "_notExistPartId");
      // ID
      __publicField(this, "_notExistParameterValues");
      // 
      __publicField(this, "_notExistParameterId");
      // ID
      __publicField(this, "_savedParameters");
      // 
      __publicField(this, "_isOverwrittenModelMultiplyColors");
      // SDK
      __publicField(this, "_isOverwrittenModelScreenColors");
      // SDK
      __publicField(this, "_userMultiplyColors");
      // Drawable
      __publicField(this, "_userScreenColors");
      // Drawable
      __publicField(this, "_userPartScreenColors");
      // Part 
      __publicField(this, "_userPartMultiplyColors");
      // Part 
      __publicField(this, "_partChildDrawables");
      // PartDrawableIndex
      __publicField(this, "_model");
      // 
      __publicField(this, "_parameterValues");
      // 
      __publicField(this, "_parameterMaximumValues");
      // 
      __publicField(this, "_parameterMinimumValues");
      // 
      __publicField(this, "_partOpacities");
      // 
      __publicField(this, "_modelOpacity");
      // 
      __publicField(this, "_parameterIds");
      __publicField(this, "_partIds");
      __publicField(this, "_drawableIds");
      __publicField(this, "_isOverwrittenCullings");
      // 
      __publicField(this, "_userCullings");
      this._model = model;
      this._parameterValues = null;
      this._parameterMaximumValues = null;
      this._parameterMinimumValues = null;
      this._partOpacities = null;
      this._savedParameters = new csmVector();
      this._parameterIds = new csmVector();
      this._drawableIds = new csmVector();
      this._partIds = new csmVector();
      this._isOverwrittenModelMultiplyColors = false;
      this._isOverwrittenModelScreenColors = false;
      this._isOverwrittenCullings = false;
      this._modelOpacity = 1;
      this._userMultiplyColors = new csmVector();
      this._userScreenColors = new csmVector();
      this._userCullings = new csmVector();
      this._userPartMultiplyColors = new csmVector();
      this._userPartScreenColors = new csmVector();
      this._partChildDrawables = new csmVector();
      this._notExistPartId = new csmMap();
      this._notExistParameterId = new csmMap();
      this._notExistParameterValues = new csmMap();
      this._notExistPartOpacities = new csmMap();
    }
    /**
     * 
     */
    update() {
      this._model.update();
      this._model.drawables.resetDynamicFlags();
    }
    /**
     * PixelsPerUnit
     * @returns PixelsPerUnit
     */
    getPixelsPerUnit() {
      if (this._model == null) {
        return 0;
      }
      return this._model.canvasinfo.PixelsPerUnit;
    }
    /**
     * 
     */
    getCanvasWidth() {
      if (this._model == null) {
        return 0;
      }
      return this._model.canvasinfo.CanvasWidth / this._model.canvasinfo.PixelsPerUnit;
    }
    /**
     * 
     */
    getCanvasHeight() {
      if (this._model == null) {
        return 0;
      }
      return this._model.canvasinfo.CanvasHeight / this._model.canvasinfo.PixelsPerUnit;
    }
    /**
     * 
     */
    saveParameters() {
      const parameterCount = this._model.parameters.count;
      const savedParameterCount = this._savedParameters.getSize();
      for (let i = 0; i < parameterCount; ++i) {
        if (i < savedParameterCount) {
          this._savedParameters.set(i, this._parameterValues[i]);
        } else {
          this._savedParameters.pushBack(this._parameterValues[i]);
        }
      }
    }
    /**
     * 
     * @param index Drawables
     * @returns drawable(RGBA)
     */
    getMultiplyColor(index) {
      if (this.getOverwriteFlagForModelMultiplyColors() || this.getOverwriteFlagForDrawableMultiplyColors(index)) {
        return this._userMultiplyColors.at(index).color;
      }
      const color = this.getDrawableMultiplyColor(index);
      return color;
    }
    /**
     * 
     * @param index Drawables
     * @returns drawable(RGBA)
     */
    getScreenColor(index) {
      if (this.getOverwriteFlagForModelScreenColors() || this.getOverwriteFlagForDrawableScreenColors(index)) {
        return this._userScreenColors.at(index).color;
      }
      const color = this.getDrawableScreenColor(index);
      return color;
    }
    /**
     * 
     * @param index Drawables
     * @param color (CubismTextureColor)
     */
    setMultiplyColorByTextureColor(index, color) {
      this.setMultiplyColorByRGBA(index, color.r, color.g, color.b, color.a);
    }
    /**
     * 
     * @param index Drawables
     * @param r R
     * @param g G
     * @param b B
     * @param a A
     */
    setMultiplyColorByRGBA(index, r, g, b, a = 1) {
      this._userMultiplyColors.at(index).color.r = r;
      this._userMultiplyColors.at(index).color.g = g;
      this._userMultiplyColors.at(index).color.b = b;
      this._userMultiplyColors.at(index).color.a = a;
    }
    /**
     * 
     * @param index Drawables
     * @param color (CubismTextureColor)
     */
    setScreenColorByTextureColor(index, color) {
      this.setScreenColorByRGBA(index, color.r, color.g, color.b, color.a);
    }
    /**
     * 
     * @param index Drawables
     * @param r R
     * @param g G
     * @param b B
     * @param a A
     */
    setScreenColorByRGBA(index, r, g, b, a = 1) {
      this._userScreenColors.at(index).color.r = r;
      this._userScreenColors.at(index).color.g = g;
      this._userScreenColors.at(index).color.b = b;
      this._userScreenColors.at(index).color.a = a;
    }
    /**
     * part
     * @param partIndex part
     * @returns part
     */
    getPartMultiplyColor(partIndex) {
      return this._userPartMultiplyColors.at(partIndex).color;
    }
    /**
     * part
     * @param partIndex part
     * @returns part
     */
    getPartScreenColor(partIndex) {
      return this._userPartScreenColors.at(partIndex).color;
    }
    /**
     * partOverwriteColor setter
     * @param partIndex part
     * @param r R
     * @param g G
     * @param b B
     * @param a A
     * @param partColors part
     * @param drawableColors partDrawable
     */
    setPartColor(partIndex, r, g, b, a, partColors, drawableColors) {
      partColors.at(partIndex).color.r = r;
      partColors.at(partIndex).color.g = g;
      partColors.at(partIndex).color.b = b;
      partColors.at(partIndex).color.a = a;
      if (partColors.at(partIndex).isOverwritten) {
        for (let i = 0; i < this._partChildDrawables.at(partIndex).getSize(); ++i) {
          const drawableIndex = this._partChildDrawables.at(partIndex).at(i);
          drawableColors.at(drawableIndex).color.r = r;
          drawableColors.at(drawableIndex).color.g = g;
          drawableColors.at(drawableIndex).color.b = b;
          drawableColors.at(drawableIndex).color.a = a;
        }
      }
    }
    /**
     * 
     * @param partIndex part
     * @param color (CubismTextureColor)
     */
    setPartMultiplyColorByTextureColor(partIndex, color) {
      this.setPartMultiplyColorByRGBA(partIndex, color.r, color.g, color.b, color.a);
    }
    /**
     * 
     * @param partIndex part
     * @param r R
     * @param g G
     * @param b B
     * @param a A
     */
    setPartMultiplyColorByRGBA(partIndex, r, g, b, a) {
      this.setPartColor(partIndex, r, g, b, a, this._userPartMultiplyColors, this._userMultiplyColors);
    }
    /**
     * 
     * @param partIndex part
     * @param color (CubismTextureColor)
     */
    setPartScreenColorByTextureColor(partIndex, color) {
      this.setPartScreenColorByRGBA(partIndex, color.r, color.g, color.b, color.a);
    }
    /**
     * 
     * @param partIndex part
     * @param r R
     * @param g G
     * @param b B
     * @param a A
     */
    setPartScreenColorByRGBA(partIndex, r, g, b, a) {
      this.setPartColor(partIndex, r, g, b, a, this._userPartScreenColors, this._userScreenColors);
    }
    /**
     * SDK
     * @returns true -> SDK
     *          false -> 
     */
    getOverwriteFlagForModelMultiplyColors() {
      return this._isOverwrittenModelMultiplyColors;
    }
    /**
     * SDK
     * @returns true -> SDK
     *          false -> 
     */
    getOverwriteFlagForModelScreenColors() {
      return this._isOverwrittenModelScreenColors;
    }
    /**
     * SDK
     * @param value true -> SDK
     *              false -> 
     */
    setOverwriteFlagForModelMultiplyColors(value) {
      this._isOverwrittenModelMultiplyColors = value;
    }
    /**
     * SDK
     * @param value true -> SDK
     *              false -> 
     */
    setOverwriteFlagForModelScreenColors(value) {
      this._isOverwrittenModelScreenColors = value;
    }
    /**
     * SDKDrawableIndex
     * @returns true -> SDK
     *          false -> 
     */
    getOverwriteFlagForDrawableMultiplyColors(drawableindex) {
      return this._userMultiplyColors.at(drawableindex).isOverwritten;
    }
    /**
     * SDKDrawableIndex
     * @returns true -> SDK
     *          false -> 
     */
    getOverwriteFlagForDrawableScreenColors(drawableindex) {
      return this._userScreenColors.at(drawableindex).isOverwritten;
    }
    /**
     * SDKDrawableIndex
     * @param value true -> SDK
     *              false -> 
     */
    setOverwriteFlagForDrawableMultiplyColors(drawableindex, value) {
      this._userMultiplyColors.at(drawableindex).isOverwritten = value;
    }
    /**
     * SDKDrawableIndex
     * @param value true -> SDK
     *              false -> 
     */
    setOverwriteFlagForDrawableScreenColors(drawableindex, value) {
      this._userScreenColors.at(drawableindex).isOverwritten = value;
    }
    /**
     * SDKpart
     * @param partIndex part
     * @returns true    ->  SDK
     *          false   ->  
     */
    getOverwriteColorForPartMultiplyColors(partIndex) {
      return this._userPartMultiplyColors.at(partIndex).isOverwritten;
    }
    /**
     * SDKpart
     * @param partIndex part
     * @returns true    ->  SDK
     *          false   ->  
     */
    getOverwriteColorForPartScreenColors(partIndex) {
      return this._userPartScreenColors.at(partIndex).isOverwritten;
    }
    /**
     * partOverwriteFlag setter
     * @param partIndex part
     * @param value true -> SDK
     *              false -> 
     * @param partColors part
     * @param drawableColors partDrawable
     */
    setOverwriteColorForPartColors(partIndex, value, partColors, drawableColors) {
      partColors.at(partIndex).isOverwritten = value;
      for (let i = 0; i < this._partChildDrawables.at(partIndex).getSize(); ++i) {
        const drawableIndex = this._partChildDrawables.at(partIndex).at(i);
        drawableColors.at(drawableIndex).isOverwritten = value;
        if (value) {
          drawableColors.at(drawableIndex).color.r = partColors.at(partIndex).color.r;
          drawableColors.at(drawableIndex).color.g = partColors.at(partIndex).color.g;
          drawableColors.at(drawableIndex).color.b = partColors.at(partIndex).color.b;
          drawableColors.at(drawableIndex).color.a = partColors.at(partIndex).color.a;
        }
      }
    }
    /**
     * SDKpart
     * @param partIndex part
     * @param value true -> SDK
     *              false -> 
     */
    setOverwriteColorForPartMultiplyColors(partIndex, value) {
      this._userPartMultiplyColors.at(partIndex).isOverwritten = value;
      this.setOverwriteColorForPartColors(partIndex, value, this._userPartMultiplyColors, this._userMultiplyColors);
    }
    /**
     * SDKpart
     * @param partIndex part
     * @param value true -> SDK
     *              false -> 
     */
    setOverwriteColorForPartScreenColors(partIndex, value) {
      this._userPartScreenColors.at(partIndex).isOverwritten = value;
      this.setOverwriteColorForPartColors(partIndex, value, this._userPartScreenColors, this._userScreenColors);
    }
    /**
     * Drawable
     *
     * @param   drawableIndex   Drawable
     * @return  Drawable
     */
    getDrawableCulling(drawableIndex) {
      if (this.getOverwriteFlagForModelCullings() || this.getOverwriteFlagForDrawableCullings(drawableIndex)) {
        return this._userCullings.at(drawableIndex).isCulling;
      }
      const constantFlags = this._model.drawables.constantFlags;
      return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(constantFlags[drawableIndex]);
    }
    /**
     * Drawable
     *
     * @param drawableIndex Drawable
     * @param isCulling 
     */
    setDrawableCulling(drawableIndex, isCulling) {
      this._userCullings.at(drawableIndex).isCulling = isCulling;
    }
    /**
     * SDK
     *
     * @retval  true    ->  SDK
     * @retval  false   ->  
     */
    getOverwriteFlagForModelCullings() {
      return this._isOverwrittenCullings;
    }
    /**
     * SDK
     *
     * @param isOverwrittenCullings SDKtruefalse
     */
    setOverwriteFlagForModelCullings(isOverwrittenCullings) {
      this._isOverwrittenCullings = isOverwrittenCullings;
    }
    /**
     *
     * @param drawableIndex Drawable
     * @retval  true    ->  SDK
     * @retval  false   ->  
     */
    getOverwriteFlagForDrawableCullings(drawableIndex) {
      return this._userCullings.at(drawableIndex).isOverwritten;
    }
    /**
     *
     * @param drawableIndex Drawable
     * @param isOverwrittenCullings SDKtruefalse
     */
    setOverwriteFlagForDrawableCullings(drawableIndex, isOverwrittenCullings) {
      this._userCullings.at(drawableIndex).isOverwritten = isOverwrittenCullings;
    }
    /**
     * 
     *
     * @returns 
     */
    getModelOapcity() {
      return this._modelOpacity;
    }
    /**
     * 
     *
     * @param value 
     */
    setModelOapcity(value) {
      this._modelOpacity = value;
    }
    /**
     * 
     */
    getModel() {
      return this._model;
    }
    /**
     * 
     * @param partId ID
     * @return 
     */
    getPartIndex(partId) {
      let partIndex;
      const partCount = this._model.parts.count;
      for (partIndex = 0; partIndex < partCount; ++partIndex) {
        if (partId == this._partIds.at(partIndex)) {
          return partIndex;
        }
      }
      if (this._notExistPartId.isExist(partId)) {
        return this._notExistPartId.getValue(partId);
      }
      partIndex = partCount + this._notExistPartId.getSize();
      this._notExistPartId.setValue(partId, partIndex);
      this._notExistPartOpacities.appendKey(partIndex);
      return partIndex;
    }
    /**
     * ID
     *
     * @param partIndex 
     * @return ID
     */
    getPartId(partIndex) {
      const partId = this._model.parts.ids[partIndex];
      return CubismFramework.getIdManager().getId(partId);
    }
    /**
     * 
     * @return 
     */
    getPartCount() {
      const partCount = this._model.parts.count;
      return partCount;
    }
    /**
     * (Index)
     * @param partIndex 
     * @param opacity 
     */
    setPartOpacityByIndex(partIndex, opacity) {
      if (this._notExistPartOpacities.isExist(partIndex)) {
        this._notExistPartOpacities.setValue(partIndex, opacity);
        return;
      }
      CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
      this._partOpacities[partIndex] = opacity;
    }
    /**
     * (Id)
     * @param partId ID
     * @param opacity 
     */
    setPartOpacityById(partId, opacity) {
      const index = this.getPartIndex(partId);
      if (index < 0) {
        return;
      }
      this.setPartOpacityByIndex(index, opacity);
    }
    /**
     * (index)
     * @param partIndex 
     * @return 
     */
    getPartOpacityByIndex(partIndex) {
      if (this._notExistPartOpacities.isExist(partIndex)) {
        return this._notExistPartOpacities.getValue(partIndex);
      }
      CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
      return this._partOpacities[partIndex];
    }
    /**
     * (id)
     * @param partId 
     * @return 
     */
    getPartOpacityById(partId) {
      const index = this.getPartIndex(partId);
      if (index < 0) {
        return 0;
      }
      return this.getPartOpacityByIndex(index);
    }
    /**
     * 
     * @param ID
     * @return 
     */
    getParameterIndex(parameterId) {
      let parameterIndex;
      const idCount = this._model.parameters.count;
      for (parameterIndex = 0; parameterIndex < idCount; ++parameterIndex) {
        if (parameterId != this._parameterIds.at(parameterIndex)) {
          continue;
        }
        return parameterIndex;
      }
      if (this._notExistParameterId.isExist(parameterId)) {
        return this._notExistParameterId.getValue(parameterId);
      }
      parameterIndex = this._model.parameters.count + this._notExistParameterId.getSize();
      this._notExistParameterId.setValue(parameterId, parameterIndex);
      this._notExistParameterValues.appendKey(parameterIndex);
      return parameterIndex;
    }
    /**
     * 
     * @return 
     */
    getParameterCount() {
      return this._model.parameters.count;
    }
    /**
     * 
     * @param parameterIndex 
     * @return csmParameterType_Normal -> 
     *          csmParameterType_BlendShape -> 
     */
    getParameterType(parameterIndex) {
      return this._model.parameters.types[parameterIndex];
    }
    /**
     * 
     * @param parameterIndex 
     * @return 
     */
    getParameterMaximumValue(parameterIndex) {
      return this._model.parameters.maximumValues[parameterIndex];
    }
    /**
     * 
     * @param parameterIndex 
     * @return 
     */
    getParameterMinimumValue(parameterIndex) {
      return this._model.parameters.minimumValues[parameterIndex];
    }
    /**
     * 
     * @param parameterIndex 
     * @return 
     */
    getParameterDefaultValue(parameterIndex) {
      return this._model.parameters.defaultValues[parameterIndex];
    }
    /**
     * indexID
     *
     * @param parameterIndex 
     * @returns ID
     */
    getParameterId(parameterIndex) {
      return CubismFramework.getIdManager().getId(this._model.parameters.ids[parameterIndex]);
    }
    /**
     * 
     * @param parameterIndex    
     * @return 
     */
    getParameterValueByIndex(parameterIndex) {
      if (this._notExistParameterValues.isExist(parameterIndex)) {
        return this._notExistParameterValues.getValue(parameterIndex);
      }
      CSM_ASSERT(0 <= parameterIndex && parameterIndex < this.getParameterCount());
      return this._parameterValues[parameterIndex];
    }
    /**
     * 
     * @param parameterId    ID
     * @return 
     */
    getParameterValueById(parameterId) {
      const parameterIndex = this.getParameterIndex(parameterId);
      return this.getParameterValueByIndex(parameterIndex);
    }
    /**
     * 
     * @param parameterIndex 
     * @param value 
     * @param weight 
     */
    setParameterValueByIndex(parameterIndex, value, weight = 1) {
      if (this._notExistParameterValues.isExist(parameterIndex)) {
        this._notExistParameterValues.setValue(parameterIndex, weight == 1 ? value : this._notExistParameterValues.getValue(parameterIndex) * (1 - weight) + value * weight);
        return;
      }
      CSM_ASSERT(0 <= parameterIndex && parameterIndex < this.getParameterCount());
      if (this._model.parameters.maximumValues[parameterIndex] < value) {
        value = this._model.parameters.maximumValues[parameterIndex];
      }
      if (this._model.parameters.minimumValues[parameterIndex] > value) {
        value = this._model.parameters.minimumValues[parameterIndex];
      }
      this._parameterValues[parameterIndex] = weight == 1 ? value : this._parameterValues[parameterIndex] = this._parameterValues[parameterIndex] * (1 - weight) + value * weight;
    }
    /**
     * 
     * @param parameterId ID
     * @param value 
     * @param weight 
     */
    setParameterValueById(parameterId, value, weight = 1) {
      const index = this.getParameterIndex(parameterId);
      this.setParameterValueByIndex(index, value, weight);
    }
    /**
     * (index)
     * @param parameterIndex 
     * @param value 
     * @param weight 
     */
    addParameterValueByIndex(parameterIndex, value, weight = 1) {
      this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) + value * weight);
    }
    /**
     * (id)
     * @param parameterId 
     * @param value 
     * @param weight 
     */
    addParameterValueById(parameterId, value, weight = 1) {
      const index = this.getParameterIndex(parameterId);
      this.addParameterValueByIndex(index, value, weight);
    }
    /**
     * 
     * @param parameterId ID
     * @param value 
     * @param weight 
     */
    multiplyParameterValueById(parameterId, value, weight = 1) {
      const index = this.getParameterIndex(parameterId);
      this.multiplyParameterValueByIndex(index, value, weight);
    }
    /**
     * 
     * @param parameterIndex 
     * @param value 
     * @param weight 
     */
    multiplyParameterValueByIndex(parameterIndex, value, weight = 1) {
      this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) * (1 + (value - 1) * weight));
    }
    /**
     * Drawable
     * @param drawableId DrawableID
     * @return Drawable
     */
    getDrawableIndex(drawableId) {
      const drawableCount = this._model.drawables.count;
      for (let drawableIndex = 0; drawableIndex < drawableCount; ++drawableIndex) {
        if (this._drawableIds.at(drawableIndex) == drawableId) {
          return drawableIndex;
        }
      }
      return -1;
    }
    /**
     * Drawable
     * @return drawable
     */
    getDrawableCount() {
      const drawableCount = this._model.drawables.count;
      return drawableCount;
    }
    /**
     * DrawableID
     * @param drawableIndex Drawable
     * @return drawableID
     */
    getDrawableId(drawableIndex) {
      const parameterIds = this._model.drawables.ids;
      return CubismFramework.getIdManager().getId(parameterIds[drawableIndex]);
    }
    /**
     * Drawable
     * @return Drawable
     */
    getDrawableRenderOrders() {
      const renderOrders = this._model.drawables.renderOrders;
      return renderOrders;
    }
    /**
     * @deprecated
     *  getDrawableTextureIndex 
     *
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableTextureIndices(drawableIndex) {
      return this.getDrawableTextureIndex(drawableIndex);
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableTextureIndex(drawableIndex) {
      const textureIndices = this._model.drawables.textureIndices;
      return textureIndices[drawableIndex];
    }
    /**
     * DrawableVertexPositions
     *
     * CubismModel.updateDrawable
     *
     * @param   drawableIndex   Drawable
     * @retval  true    DrawableCubismModel.update
     * @retval  false   DrawableCubismModel.update
     */
    getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableVertexIndexCount(drawableIndex) {
      const indexCounts = this._model.drawables.indexCounts;
      return indexCounts[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableVertexCount(drawableIndex) {
      const vertexCounts = this._model.drawables.vertexCounts;
      return vertexCounts[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex drawable
     * @return drawable
     */
    getDrawableVertices(drawableIndex) {
      return this.getDrawableVertexPositions(drawableIndex);
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableVertexIndices(drawableIndex) {
      const indicesArray = this._model.drawables.indices;
      return indicesArray[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableVertexPositions(drawableIndex) {
      const verticesArray = this._model.drawables.vertexPositions;
      return verticesArray[drawableIndex];
    }
    /**
     * DrawableUV
     * @param drawableIndex Drawable
     * @return drawableUV
     */
    getDrawableVertexUvs(drawableIndex) {
      const uvsArray = this._model.drawables.vertexUvs;
      return uvsArray[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableOpacity(drawableIndex) {
      const opacities = this._model.drawables.opacities;
      return opacities[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable(RGBA)
     * RGBAA0
     */
    getDrawableMultiplyColor(drawableIndex) {
      const multiplyColors = this._model.drawables.multiplyColors;
      const index = drawableIndex * 4;
      const multiplyColor = new CubismTextureColor();
      multiplyColor.r = multiplyColors[index];
      multiplyColor.g = multiplyColors[index + 1];
      multiplyColor.b = multiplyColors[index + 2];
      multiplyColor.a = multiplyColors[index + 3];
      return multiplyColor;
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable(RGBA)
     * RGBAA0
     */
    getDrawableScreenColor(drawableIndex) {
      const screenColors = this._model.drawables.screenColors;
      const index = drawableIndex * 4;
      const screenColor = new CubismTextureColor();
      screenColor.r = screenColors[index];
      screenColor.g = screenColors[index + 1];
      screenColor.b = screenColors[index + 2];
      screenColor.a = screenColors[index + 3];
      return screenColor;
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableParentPartIndex(drawableIndex) {
      return this._model.drawables.parentPartIndices[drawableIndex];
    }
    /**
     * Drawable
     * @param drawableIndex Drawable
     * @return drawable
     */
    getDrawableBlendMode(drawableIndex) {
      const constantFlags = this._model.drawables.constantFlags;
      return Live2DCubismCore.Utils.hasBlendAdditiveBit(constantFlags[drawableIndex]) ? CubismBlendMode.CubismBlendMode_Additive : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(constantFlags[drawableIndex]) ? CubismBlendMode.CubismBlendMode_Multiplicative : CubismBlendMode.CubismBlendMode_Normal;
    }
    /**
     * Drawable
     *
     * Drawable
     * 
     *
     * @param drawableIndex Drawable
     * @return Drawable
     */
    getDrawableInvertedMaskBit(drawableIndex) {
      const constantFlags = this._model.drawables.constantFlags;
      return Live2DCubismCore.Utils.hasIsInvertedMaskBit(constantFlags[drawableIndex]);
    }
    /**
     * Drawable
     * @return Drawable
     */
    getDrawableMasks() {
      const masks = this._model.drawables.masks;
      return masks;
    }
    /**
     * Drawable
     * @return Drawable
     */
    getDrawableMaskCounts() {
      const maskCounts = this._model.drawables.maskCounts;
      return maskCounts;
    }
    /**
     * 
     *
     * @return true 
     * @return false 
     */
    isUsingMasking() {
      for (let d = 0; d < this._model.drawables.count; ++d) {
        if (this._model.drawables.maskCounts[d] <= 0) {
          continue;
        }
        return true;
      }
      return false;
    }
    /**
     * Drawable
     *
     * @param drawableIndex Drawable
     * @return true Drawable
     * @return false Drawable
     */
    getDrawableDynamicFlagIsVisible(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasIsVisibleBit(dynamicFlags[drawableIndex]);
    }
    /**
     * DrawableDrawOrder
     *
     * CubismModel.updatedrawabledrawOrder
     * drawOrderartMesh01000
     * @param drawableIndex drawable
     * @return true drawableCubismModel.update
     * @return false drawableCubismModel.update
     */
    getDrawableDynamicFlagVisibilityDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawable
     *
     * CubismModel.updatedrawable
     *
     * @param drawableIndex drawable
     * @return true DrawableCubismModel.update
     * @return false DrawableCubismModel.update
     */
    getDrawableDynamicFlagOpacityDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasOpacityDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawable
     *
     * CubismModel.updateDrawable
     *
     * @param drawableIndex Drawable
     * @return true DrawableCubismModel.update
     * @return false DrawableCubismModel.update
     */
    getDrawableDynamicFlagRenderOrderDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawable
     *
     * CubismModel.updateDrawable
     *
     * @param drawableIndex Drawable
     * @return true DrawableCubismModel.update
     * @return false DrawableCubismModel.update
     */
    getDrawableDynamicFlagBlendColorDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasBlendColorDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * 
     */
    loadParameters() {
      let parameterCount = this._model.parameters.count;
      const savedParameterCount = this._savedParameters.getSize();
      if (parameterCount > savedParameterCount) {
        parameterCount = savedParameterCount;
      }
      for (let i = 0; i < parameterCount; ++i) {
        this._parameterValues[i] = this._savedParameters.at(i);
      }
    }
    /**
     * 
     */
    initialize() {
      CSM_ASSERT(this._model);
      this._parameterValues = this._model.parameters.values;
      this._partOpacities = this._model.parts.opacities;
      this._parameterMaximumValues = this._model.parameters.maximumValues;
      this._parameterMinimumValues = this._model.parameters.minimumValues;
      {
        const parameterIds = this._model.parameters.ids;
        const parameterCount = this._model.parameters.count;
        this._parameterIds.prepareCapacity(parameterCount);
        for (let i = 0; i < parameterCount; ++i) {
          this._parameterIds.pushBack(CubismFramework.getIdManager().getId(parameterIds[i]));
        }
      }
      const partCount = this._model.parts.count;
      {
        const partIds = this._model.parts.ids;
        this._partIds.prepareCapacity(partCount);
        for (let i = 0; i < partCount; ++i) {
          this._partIds.pushBack(CubismFramework.getIdManager().getId(partIds[i]));
        }
        this._userPartMultiplyColors.prepareCapacity(partCount);
        this._userPartScreenColors.prepareCapacity(partCount);
        this._partChildDrawables.prepareCapacity(partCount);
      }
      {
        const drawableIds = this._model.drawables.ids;
        const drawableCount = this._model.drawables.count;
        this._userMultiplyColors.prepareCapacity(drawableCount);
        this._userScreenColors.prepareCapacity(drawableCount);
        this._userCullings.prepareCapacity(drawableCount);
        const userCulling = new DrawableCullingData(false, false);
        {
          for (let i = 0; i < partCount; ++i) {
            const multiplyColor = new CubismTextureColor(1, 1, 1, 1);
            const screenColor = new CubismTextureColor(0, 0, 0, 1);
            const userMultiplyColor = new PartColorData(false, multiplyColor);
            const userScreenColor = new PartColorData(false, screenColor);
            this._userPartMultiplyColors.pushBack(userMultiplyColor);
            this._userPartScreenColors.pushBack(userScreenColor);
            this._partChildDrawables.pushBack(new csmVector());
            this._partChildDrawables.at(i).prepareCapacity(drawableCount);
          }
        }
        {
          for (let i = 0; i < drawableCount; ++i) {
            const multiplyColor = new CubismTextureColor(1, 1, 1, 1);
            const screenColor = new CubismTextureColor(0, 0, 0, 1);
            const userMultiplyColor = new DrawableColorData(false, multiplyColor);
            const userScreenColor = new DrawableColorData(false, screenColor);
            this._drawableIds.pushBack(CubismFramework.getIdManager().getId(drawableIds[i]));
            this._userMultiplyColors.pushBack(userMultiplyColor);
            this._userScreenColors.pushBack(userScreenColor);
            this._userCullings.pushBack(userCulling);
            const parentIndex = this.getDrawableParentPartIndex(i);
            if (parentIndex >= 0) {
              this._partChildDrawables.at(parentIndex).pushBack(i);
            }
          }
        }
      }
    }
    /**
     * 
     */
    release() {
      this._model.release();
      this._model = null;
    }
    // 
  };
  var Live2DCubismFramework37;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModel = CubismModel;
  })(Live2DCubismFramework37 || (Live2DCubismFramework37 = {}));

  // src/Live2D/dist/model/cubismmoc.js
  var CubismMoc = class _CubismMoc {
    /**
     * 
     */
    constructor(moc) {
      __publicField(this, "_moc");
      // Moc
      __publicField(this, "_modelCount");
      // Moc
      __publicField(this, "_mocVersion");
      this._moc = moc;
      this._modelCount = 0;
      this._mocVersion = 0;
    }
    /**
     * Moc
     */
    static create(mocBytes, shouldCheckMocConsistency) {
      let cubismMoc = null;
      if (shouldCheckMocConsistency) {
        const consistency = this.hasMocConsistency(mocBytes);
        if (!consistency) {
          CubismLogError(`Inconsistent MOC3.`);
          return cubismMoc;
        }
      }
      const moc = Live2DCubismCore.Moc.fromArrayBuffer(mocBytes);
      if (moc) {
        cubismMoc = new _CubismMoc(moc);
        cubismMoc._mocVersion = Live2DCubismCore.Version.csmGetMocVersion(moc, mocBytes);
      }
      return cubismMoc;
    }
    /**
     * Moc
     *
     * Moc
     */
    static delete(moc) {
      moc._moc._release();
      moc._moc = null;
      moc = null;
    }
    /**
     * 
     *
     * @return Moc
     */
    createModel() {
      let cubismModel = null;
      const model = Live2DCubismCore.Model.fromMoc(this._moc);
      if (model) {
        cubismModel = new CubismModel(model);
        cubismModel.initialize();
        ++this._modelCount;
      }
      return cubismModel;
    }
    /**
     * 
     */
    deleteModel(model) {
      if (model != null) {
        model.release();
        model = null;
        --this._modelCount;
      }
    }
    /**
     * 
     */
    release() {
      CSM_ASSERT(this._modelCount == 0);
      this._moc._release();
      this._moc = null;
    }
    /**
     * .moc3 Version
     */
    getLatestMocVersion() {
      return Live2DCubismCore.Version.csmGetLatestMocVersion();
    }
    /**
     * .moc3 Version
     */
    getMocVersion() {
      return this._mocVersion;
    }
    /**
     * .moc3 
     */
    static hasMocConsistency(mocBytes) {
      const isConsistent = Live2DCubismCore.Moc.prototype.hasMocConsistency(mocBytes);
      return isConsistent === 1 ? true : false;
    }
    // .moc3 Version
  };
  var Live2DCubismFramework38;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMoc = CubismMoc;
  })(Live2DCubismFramework38 || (Live2DCubismFramework38 = {}));

  // src/Live2D/dist/model/cubismmodeluserdatajson.js
  var Meta3 = "Meta";
  var UserDataCount2 = "UserDataCount";
  var TotalUserDataSize2 = "TotalUserDataSize";
  var UserData3 = "UserData";
  var Target2 = "Target";
  var Id5 = "Id";
  var Value3 = "Value";
  var CubismModelUserDataJson = class {
    /**
     * 
     * @param buffer    userdata3.json
     * @param size      
     */
    constructor(buffer, size) {
      __publicField(this, "_json");
      this._json = CubismJson.create(buffer, size);
    }
    /**
     * 
     */
    release() {
      CubismJson.delete(this._json);
    }
    /**
     * 
     * @return 
     */
    getUserDataCount() {
      return this._json.getRoot().getValueByString(Meta3).getValueByString(UserDataCount2).toInt();
    }
    /**
     * 
     *
     * @return 
     */
    getTotalUserDataSize() {
      return this._json.getRoot().getValueByString(Meta3).getValueByString(TotalUserDataSize2).toInt();
    }
    /**
     * 
     *
     * @return 
     */
    getUserDataTargetType(i) {
      return this._json.getRoot().getValueByString(UserData3).getValueByIndex(i).getValueByString(Target2).getRawString();
    }
    /**
     * ID
     *
     * @param i 
     * @return ID
     */
    getUserDataId(i) {
      return CubismFramework.getIdManager().getId(this._json.getRoot().getValueByString(UserData3).getValueByIndex(i).getValueByString(Id5).getRawString());
    }
    /**
     * 
     *
     * @param i 
     * @return 
     */
    getUserDataValue(i) {
      return this._json.getRoot().getValueByString(UserData3).getValueByIndex(i).getValueByString(Value3).getRawString();
    }
  };
  var Live2DCubismFramework39;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModelUserDataJson = CubismModelUserDataJson;
  })(Live2DCubismFramework39 || (Live2DCubismFramework39 = {}));

  // src/Live2D/dist/model/cubismmodeluserdata.js
  var ArtMesh = "ArtMesh";
  var CubismModelUserDataNode = class {
    constructor() {
      __publicField(this, "targetType");
      // 
      __publicField(this, "targetId");
      // ID
      __publicField(this, "value");
    }
    // 
  };
  var CubismModelUserData = class _CubismModelUserData {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_userDataNodes");
      // 
      __publicField(this, "_artMeshUserDataNode");
      this._userDataNodes = new csmVector();
      this._artMeshUserDataNode = new csmVector();
    }
    /**
     * 
     *
     * @param buffer    userdata3.json
     * @param size      
     * @return 
     */
    static create(buffer, size) {
      const ret = new _CubismModelUserData();
      ret.parseUserData(buffer, size);
      return ret;
    }
    /**
     * 
     *
     * @param modelUserData 
     */
    static delete(modelUserData) {
      if (modelUserData != null) {
        modelUserData.release();
        modelUserData = null;
      }
    }
    /**
     * ArtMesh
     *
     * @return 
     */
    getArtMeshUserDatas() {
      return this._artMeshUserDataNode;
    }
    /**
     * userdata3.json
     *
     * @param buffer    userdata3.json
     * @param size      
     */
    parseUserData(buffer, size) {
      let json = new CubismModelUserDataJson(buffer, size);
      if (!json) {
        json.release();
        json = void 0;
        return;
      }
      const typeOfArtMesh = CubismFramework.getIdManager().getId(ArtMesh);
      const nodeCount = json.getUserDataCount();
      for (let i = 0; i < nodeCount; i++) {
        const addNode = new CubismModelUserDataNode();
        addNode.targetId = json.getUserDataId(i);
        addNode.targetType = CubismFramework.getIdManager().getId(json.getUserDataTargetType(i));
        addNode.value = new csmString(json.getUserDataValue(i));
        this._userDataNodes.pushBack(addNode);
        if (addNode.targetType == typeOfArtMesh) {
          this._artMeshUserDataNode.pushBack(addNode);
        }
      }
      json.release();
      json = void 0;
    }
    /**
     * 
     *
     * 
     */
    release() {
      for (let i = 0; i < this._userDataNodes.getSize(); ++i) {
        this._userDataNodes.set(i, null);
      }
      this._userDataNodes = null;
    }
    // 
  };
  var Live2DCubismFramework40;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModelUserData = CubismModelUserData;
    Live2DCubismFramework42.CubismModelUserDataNode = CubismModelUserDataNode;
  })(Live2DCubismFramework40 || (Live2DCubismFramework40 = {}));

  // src/Live2D/dist/model/cubismusermodel.js
  var CubismUserModel = class _CubismUserModel {
    /**
     * 
     */
    constructor() {
      __publicField(this, "_moc");
      // Moc
      __publicField(this, "_model");
      // Model
      __publicField(this, "_motionManager");
      // 
      __publicField(this, "_expressionManager");
      // 
      __publicField(this, "_eyeBlink");
      // 
      __publicField(this, "_breath");
      // 
      __publicField(this, "_modelMatrix");
      // 
      __publicField(this, "_pose");
      // 
      __publicField(this, "_dragManager");
      // 
      __publicField(this, "_physics");
      // 
      __publicField(this, "_modelUserData");
      // 
      __publicField(this, "_initialized");
      // 
      __publicField(this, "_updating");
      // 
      __publicField(this, "_opacity");
      // 
      __publicField(this, "_lipsync");
      // 
      __publicField(this, "_lastLipSyncValue");
      // 
      __publicField(this, "_dragX");
      // X
      __publicField(this, "_dragY");
      // Y
      __publicField(this, "_accelerationX");
      // X
      __publicField(this, "_accelerationY");
      // Y
      __publicField(this, "_accelerationZ");
      // Z
      __publicField(this, "_mocConsistency");
      // MOC3
      __publicField(this, "_debugMode");
      // 
      __publicField(this, "_renderer");
      this._moc = null;
      this._model = null;
      this._motionManager = null;
      this._expressionManager = null;
      this._eyeBlink = null;
      this._breath = null;
      this._modelMatrix = null;
      this._pose = null;
      this._dragManager = null;
      this._physics = null;
      this._modelUserData = null;
      this._initialized = false;
      this._updating = false;
      this._opacity = 1;
      this._lipsync = true;
      this._lastLipSyncValue = 0;
      this._dragX = 0;
      this._dragY = 0;
      this._accelerationX = 0;
      this._accelerationY = 0;
      this._accelerationZ = 0;
      this._mocConsistency = false;
      this._debugMode = false;
      this._renderer = null;
      this._motionManager = new CubismMotionManager();
      this._motionManager.setEventCallback(_CubismUserModel.cubismDefaultMotionEventCallback, this);
      this._expressionManager = new CubismExpressionMotionManager();
      this._dragManager = new CubismTargetPoint();
    }
    /**
     * 
     *
     * 
     *
     * @return true     
     * @return false    
     */
    isInitialized() {
      return this._initialized;
    }
    /**
     * 
     *
     * 
     *
     * @param v 
     */
    setInitialized(v) {
      this._initialized = v;
    }
    /**
     * 
     *
     * 
     *
     * @return true     
     * @return false    
     */
    isUpdating() {
      return this._updating;
    }
    /**
     * 
     *
     * 
     *
     * @param v 
     */
    setUpdating(v) {
      this._updating = v;
    }
    /**
     * 
     * @param X
     * @param Y
     */
    setDragging(x, y) {
      this._dragManager.set(x, y);
    }
    /**
     * 
     * @param x X
     * @param y Y
     * @param z Z
     */
    setAcceleration(x, y, z) {
      this._accelerationX = x;
      this._accelerationY = y;
      this._accelerationZ = z;
    }
    /**
     * 
     * @return 
     */
    getModelMatrix() {
      return this._modelMatrix;
    }
    /**
     * 
     * @param a 
     */
    setOpacity(a) {
      this._opacity = a;
    }
    /**
     * 
     * @return 
     */
    getOpacity() {
      return this._opacity;
    }
    /**
     * 
     *
     * @param buffer    moc3
     */
    loadModel(buffer, shouldCheckMocConsistency = false) {
      this._moc = CubismMoc.create(buffer, shouldCheckMocConsistency);
      if (this._moc == null) {
        CubismLogError("Failed to CubismMoc.create().");
        return;
      }
      this._model = this._moc.createModel();
      if (this._model == null) {
        CubismLogError("Failed to CreateModel().");
        return;
      }
      this._model.saveParameters();
      this._modelMatrix = new CubismModelMatrix(this._model.getCanvasWidth(), this._model.getCanvasHeight());
    }
    /**
     * 
     * @param buffer motion3.json
     * @param size 
     * @param name 
     * @param onFinishedMotionHandler 
     * @return 
     */
    loadMotion(buffer, size, name, onFinishedMotionHandler) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadMotion().");
        return null;
      }
      return CubismMotion.create(buffer, size, onFinishedMotionHandler);
    }
    /**
     * 
     * @param buffer exp
     * @param size 
     * @param name 
     */
    loadExpression(buffer, size, name) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadExpression().");
        return null;
      }
      return CubismExpressionMotion.create(buffer, size);
    }
    /**
     * 
     * @param buffer pose3.json
     * @param size 
     */
    loadPose(buffer, size) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadPose().");
        return;
      }
      this._pose = CubismPose.create(buffer, size);
    }
    /**
     * 
     * @param buffer userdata3.json
     * @param size 
     */
    loadUserData(buffer, size) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadUserData().");
        return;
      }
      this._modelUserData = CubismModelUserData.create(buffer, size);
    }
    /**
     * 
     * @param buffer  physics3.json
     * @param size    
     */
    loadPhysics(buffer, size) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadPhysics().");
        return;
      }
      this._physics = CubismPhysics.create(buffer, size);
    }
    /**
     * 
     * @param drawableId DrawableID
     * @param pointX X
     * @param pointY Y
     * @return true 
     * @return false 
     */
    isHit(drawableId, pointX, pointY) {
      const drawIndex = this._model.getDrawableIndex(drawableId);
      if (drawIndex < 0) {
        return false;
      }
      const count = this._model.getDrawableVertexCount(drawIndex);
      const vertices = this._model.getDrawableVertices(drawIndex);
      let left = vertices[0];
      let right = vertices[0];
      let top = vertices[1];
      let bottom = vertices[1];
      for (let j = 1; j < count; ++j) {
        const x = vertices[Constant.vertexOffset + j * Constant.vertexStep];
        const y = vertices[Constant.vertexOffset + j * Constant.vertexStep + 1];
        if (x < left) {
          left = x;
        }
        if (x > right) {
          right = x;
        }
        if (y < top) {
          top = y;
        }
        if (y > bottom) {
          bottom = y;
        }
      }
      const tx = this._modelMatrix.invertTransformX(pointX);
      const ty = this._modelMatrix.invertTransformY(pointY);
      return left <= tx && tx <= right && top <= ty && ty <= bottom;
    }
    /**
     * 
     * @return 
     */
    getModel() {
      return this._model;
    }
    /**
     * 
     * @return 
     */
    getRenderer() {
      return this._renderer;
    }
    /**
     * 
     * @param maskBufferCount 
     */
    createRenderer(maskBufferCount = 1) {
      if (this._renderer) {
        this.deleteRenderer();
      }
      this._renderer = new CubismRenderer_WebGL();
      this._renderer.initialize(this._model, maskBufferCount);
    }
    /**
     * 
     */
    deleteRenderer() {
      if (this._renderer != null) {
        this._renderer.release();
        this._renderer = null;
      }
    }
    /**
     * 
     *
     * Event
     * 
     * 
     *
     * @param eventValue 
     */
    motionEventFired(eventValue) {
      CubismLogInfo("{0}", eventValue.s);
    }
    /**
     * 
     *
     * CubismMotionQueueManagerCallback
     * CubismUserModelEventFired
     *
     * @param caller 
     * @param eventValue 
     * @param customData CubismUserModel
     */
    static cubismDefaultMotionEventCallback(caller, eventValue, customData) {
      const model = customData;
      if (model != null) {
        model.motionEventFired(eventValue);
      }
    }
    /**
     * 
     */
    release() {
      if (this._motionManager != null) {
        this._motionManager.release();
        this._motionManager = null;
      }
      if (this._expressionManager != null) {
        this._expressionManager.release();
        this._expressionManager = null;
      }
      if (this._moc != null) {
        this._moc.deleteModel(this._model);
        this._moc.release();
        this._moc = null;
      }
      this._modelMatrix = null;
      CubismPose.delete(this._pose);
      CubismEyeBlink.delete(this._eyeBlink);
      CubismBreath.delete(this._breath);
      this._dragManager = null;
      CubismPhysics.delete(this._physics);
      CubismModelUserData.delete(this._modelUserData);
      this.deleteRenderer();
    }
    // 
  };
  var Live2DCubismFramework41;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismUserModel = CubismUserModel;
  })(Live2DCubismFramework41 || (Live2DCubismFramework41 = {}));

  // src/Live2D/lapppal.js
  var LAppPal = class {
    /**
     * 
     *
     * @param filePath 
     * @return
     * {
     *      buffer,   
     *      size        
     * }
     */
    static loadFileAsBytes(filePath, callback) {
      fetch(filePath).then((response) => response.arrayBuffer()).then((arrayBuffer) => callback(arrayBuffer, arrayBuffer.byteLength));
    }
    /**
     * 
     * @return [ms]
     */
    static getDeltaTime() {
      return this.s_deltaTime;
    }
    static updateTime() {
      this.s_currentFrame = Date.now();
      this.s_deltaTime = (this.s_currentFrame - this.s_lastFrame) / 1e3;
      this.s_lastFrame = this.s_currentFrame;
    }
    /**
     * 
     * @param message 
     */
    static printMessage(message) {
      console.log(message);
    }
  };
  LAppPal.lastUpdate = Date.now();
  LAppPal.s_currentFrame = 0;
  LAppPal.s_lastFrame = 0;
  LAppPal.s_deltaTime = 0;

  // src/Live2D/lappwavfilehandler.js
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var s_instance3 = null;
  var LAppWavFileHandler = class _LAppWavFileHandler {
    /**
     * 
     * 
     *
     * @return 
     * @deprecated  new LAppWavFileHandler() 
     */
    static getInstance() {
      if (s_instance3 == null) {
        s_instance3 = new _LAppWavFileHandler();
      }
      return s_instance3;
    }
    /**
     * 
     *
     * @deprecated  getInstance() 
     */
    static releaseInstance() {
      if (s_instance3 != null) {
        s_instance3 = void 0;
      }
      s_instance3 = null;
    }
    update(deltaTimeSeconds) {
      let goalOffset;
      let rms;
      if (this._pcmData == null || this._sampleOffset >= this._wavFileInfo._samplesPerChannel) {
        this._lastRms = 0;
        return false;
      }
      this._userTimeSeconds += deltaTimeSeconds;
      goalOffset = Math.floor(this._userTimeSeconds * this._wavFileInfo._samplingRate);
      if (goalOffset > this._wavFileInfo._samplesPerChannel) {
        goalOffset = this._wavFileInfo._samplesPerChannel;
      }
      rms = 0;
      for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
        for (let sampleCount = this._sampleOffset; sampleCount < goalOffset; sampleCount++) {
          const pcm = this._pcmData[channelCount][sampleCount];
          rms += pcm * pcm;
        }
      }
      rms = Math.sqrt(rms / (this._wavFileInfo._numberOfChannels * (goalOffset - this._sampleOffset)));
      this._lastRms = rms;
      this._sampleOffset = goalOffset;
      return true;
    }
    start(filePath) {
      this._sampleOffset = 0;
      this._userTimeSeconds = 0;
      this._lastRms = 0;
      this.loadWavFile(filePath);
    }
    getRms() {
      return this._lastRms;
    }
    loadWavFile(filePath) {
      return new Promise((resolveValue) => {
        let ret = false;
        if (this._pcmData != null) {
          this.releasePcmData();
        }
        const asyncFileLoad = () => __awaiter(this, void 0, void 0, function* () {
          return fetch(filePath).then((responce) => {
            return responce.arrayBuffer();
          });
        });
        const asyncWavFileManager = (() => __awaiter(this, void 0, void 0, function* () {
          this._byteReader._fileByte = yield asyncFileLoad();
          this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);
          this._byteReader._fileSize = this._byteReader._fileByte.byteLength;
          this._byteReader._readOffset = 0;
          if (this._byteReader._fileByte == null || this._byteReader._fileSize < 4) {
            resolveValue(false);
            return;
          }
          this._wavFileInfo._fileName = filePath;
          try {
            if (!this._byteReader.getCheckSignature("RIFF")) {
              ret = false;
              throw new Error('Cannot find Signeture "RIFF".');
            }
            this._byteReader.get32LittleEndian();
            if (!this._byteReader.getCheckSignature("WAVE")) {
              ret = false;
              throw new Error('Cannot find Signeture "WAVE".');
            }
            if (!this._byteReader.getCheckSignature("fmt ")) {
              ret = false;
              throw new Error('Cannot find Signeture "fmt".');
            }
            const fmtChunkSize = this._byteReader.get32LittleEndian();
            if (this._byteReader.get16LittleEndian() != 1) {
              ret = false;
              throw new Error("File is not linear PCM.");
            }
            this._wavFileInfo._numberOfChannels = this._byteReader.get16LittleEndian();
            this._wavFileInfo._samplingRate = this._byteReader.get32LittleEndian();
            this._byteReader.get32LittleEndian();
            this._byteReader.get16LittleEndian();
            this._wavFileInfo._bitsPerSample = this._byteReader.get16LittleEndian();
            if (fmtChunkSize > 16) {
              this._byteReader._readOffset += fmtChunkSize - 16;
            }
            while (!this._byteReader.getCheckSignature("data") && this._byteReader._readOffset < this._byteReader._fileSize) {
              this._byteReader._readOffset += this._byteReader.get32LittleEndian() + 4;
            }
            if (this._byteReader._readOffset >= this._byteReader._fileSize) {
              ret = false;
              throw new Error('Cannot find "data" Chunk.');
            }
            {
              const dataChunkSize = this._byteReader.get32LittleEndian();
              this._wavFileInfo._samplesPerChannel = dataChunkSize * 8 / (this._wavFileInfo._bitsPerSample * this._wavFileInfo._numberOfChannels);
            }
            this._pcmData = new Array(this._wavFileInfo._numberOfChannels);
            for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
              this._pcmData[channelCount] = new Float32Array(this._wavFileInfo._samplesPerChannel);
            }
            for (let sampleCount = 0; sampleCount < this._wavFileInfo._samplesPerChannel; sampleCount++) {
              for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
                this._pcmData[channelCount][sampleCount] = this.getPcmSample();
              }
            }
            ret = true;
            resolveValue(ret);
          } catch (e) {
            console.log(e);
          }
        }))().then(() => {
          resolveValue(ret);
        });
      });
    }
    getPcmSample() {
      let pcm32;
      switch (this._wavFileInfo._bitsPerSample) {
        case 8:
          pcm32 = this._byteReader.get8() - 128;
          pcm32 <<= 24;
          break;
        case 16:
          pcm32 = this._byteReader.get16LittleEndian() << 16;
          break;
        case 24:
          pcm32 = this._byteReader.get24LittleEndian() << 8;
          break;
        default:
          pcm32 = 0;
          break;
      }
      return pcm32 / 2147483647;
    }
    /**
     * 
     *
     * @param usechannel 
     * @returns 
     */
    getPcmDataChannel(usechannel) {
      if (!this._pcmData || !(usechannel < this._pcmData.length)) {
        return null;
      }
      return Float32Array.from(this._pcmData[usechannel]);
    }
    /**
     * 
     *
     * @returns 
     */
    getWavSamplingRate() {
      if (!this._wavFileInfo || this._wavFileInfo._samplingRate < 1) {
        return null;
      }
      return this._wavFileInfo._samplingRate;
    }
    releasePcmData() {
      for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
        delete this._pcmData[channelCount];
      }
      delete this._pcmData;
      this._pcmData = null;
    }
    constructor() {
      this._loadFiletoBytes = (arrayBuffer, length) => {
        this._byteReader._fileByte = arrayBuffer;
        this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);
        this._byteReader._fileSize = length;
      };
      this._pcmData = null;
      this._userTimeSeconds = 0;
      this._lastRms = 0;
      this._sampleOffset = 0;
      this._wavFileInfo = new WavFileInfo();
      this._byteReader = new ByteReader();
    }
  };
  var WavFileInfo = class {
    constructor() {
      this._fileName = "";
      this._numberOfChannels = 0;
      this._bitsPerSample = 0;
      this._samplingRate = 0;
      this._samplesPerChannel = 0;
    }
  };
  var ByteReader = class {
    constructor() {
      this._fileByte = null;
      this._fileDataView = null;
      this._fileSize = 0;
      this._readOffset = 0;
    }
    /**
     * @brief 8
     * @return Csm::csmUint8 8
     */
    get8() {
      const ret = this._fileDataView.getUint8(this._readOffset);
      this._readOffset++;
      return ret;
    }
    /**
     * @brief 16
     * @return Csm::csmUint16 16
     */
    get16LittleEndian() {
      const ret = this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
      this._readOffset += 2;
      return ret;
    }
    /**
     * @brief 24
     * @return Csm::csmUint32 2424
     */
    get24LittleEndian() {
      const ret = this._fileDataView.getUint8(this._readOffset + 2) << 16 | this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
      this._readOffset += 3;
      return ret;
    }
    /**
     * @brief 32
     * @return Csm::csmUint32 32
     */
    get32LittleEndian() {
      const ret = this._fileDataView.getUint8(this._readOffset + 3) << 24 | this._fileDataView.getUint8(this._readOffset + 2) << 16 | this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
      this._readOffset += 4;
      return ret;
    }
    /**
     * @brief 
     * @param[in] reference 
     * @retval  true    
     * @retval  false   
     */
    getCheckSignature(reference) {
      const getSignature = new Uint8Array(4);
      const referenceString = new TextEncoder().encode(reference);
      if (reference.length != 4) {
        return false;
      }
      for (let signatureOffset = 0; signatureOffset < 4; signatureOffset++) {
        getSignature[signatureOffset] = this.get8();
      }
      return getSignature[0] == referenceString[0] && getSignature[1] == referenceString[1] && getSignature[2] == referenceString[2] && getSignature[3] == referenceString[3];
    }
  };

  // src/Live2D/lappmodel.js
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var LoadStep;
  (function(LoadStep2) {
    LoadStep2[LoadStep2["LoadAssets"] = 0] = "LoadAssets";
    LoadStep2[LoadStep2["LoadModel"] = 1] = "LoadModel";
    LoadStep2[LoadStep2["WaitLoadModel"] = 2] = "WaitLoadModel";
    LoadStep2[LoadStep2["LoadExpression"] = 3] = "LoadExpression";
    LoadStep2[LoadStep2["WaitLoadExpression"] = 4] = "WaitLoadExpression";
    LoadStep2[LoadStep2["LoadPhysics"] = 5] = "LoadPhysics";
    LoadStep2[LoadStep2["WaitLoadPhysics"] = 6] = "WaitLoadPhysics";
    LoadStep2[LoadStep2["LoadPose"] = 7] = "LoadPose";
    LoadStep2[LoadStep2["WaitLoadPose"] = 8] = "WaitLoadPose";
    LoadStep2[LoadStep2["SetupEyeBlink"] = 9] = "SetupEyeBlink";
    LoadStep2[LoadStep2["SetupBreath"] = 10] = "SetupBreath";
    LoadStep2[LoadStep2["LoadUserData"] = 11] = "LoadUserData";
    LoadStep2[LoadStep2["WaitLoadUserData"] = 12] = "WaitLoadUserData";
    LoadStep2[LoadStep2["SetupEyeBlinkIds"] = 13] = "SetupEyeBlinkIds";
    LoadStep2[LoadStep2["SetupLipSyncIds"] = 14] = "SetupLipSyncIds";
    LoadStep2[LoadStep2["SetupLayout"] = 15] = "SetupLayout";
    LoadStep2[LoadStep2["LoadMotion"] = 16] = "LoadMotion";
    LoadStep2[LoadStep2["WaitLoadMotion"] = 17] = "WaitLoadMotion";
    LoadStep2[LoadStep2["CompleteInitialize"] = 18] = "CompleteInitialize";
    LoadStep2[LoadStep2["CompleteSetupModel"] = 19] = "CompleteSetupModel";
    LoadStep2[LoadStep2["LoadTexture"] = 20] = "LoadTexture";
    LoadStep2[LoadStep2["WaitLoadTexture"] = 21] = "WaitLoadTexture";
    LoadStep2[LoadStep2["CompleteSetup"] = 22] = "CompleteSetup";
  })(LoadStep || (LoadStep = {}));
  var LAppModel = class extends CubismUserModel {
    /**
     * model3.json
     * @param dir
     * @param fileName
     */
    loadAssets(dir, fileName, callback = null) {
      this._modelHomeDir = dir;
      fetch(`${this._modelHomeDir}${fileName}`).then((response) => response.arrayBuffer()).then((arrayBuffer) => {
        const setting = new CubismModelSettingJson(arrayBuffer, arrayBuffer.byteLength);
        this._state = LoadStep.LoadModel;
        this.setupModel(setting);
        if (callback) {
          callback();
        }
      }).catch((error) => {
        CubismLogError(`Failed to load file ${this._modelHomeDir}${fileName}`);
      });
    }
    /**
     * model3.json
     * model3.json
     *
     * @param setting ICubismModelSetting
     */
    setupModel(setting) {
      this._updating = true;
      this._initialized = false;
      this._modelSetting = setting;
      if (this._modelSetting.getModelFileName() != "") {
        const modelFileName = this._modelSetting.getModelFileName();
        fetch(`${this._modelHomeDir}${modelFileName}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(`Failed to load file ${this._modelHomeDir}${modelFileName}`);
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          this.loadModel(arrayBuffer, this._mocConsistency);
          this._state = LoadStep.LoadExpression;
          loadCubismExpression();
        });
        this._state = LoadStep.WaitLoadModel;
      } else {
        LAppPal.printMessage("Model data does not exist.");
      }
      const loadCubismExpression = () => {
        if (this._modelSetting.getExpressionCount() > 0) {
          const count = this._modelSetting.getExpressionCount();
          for (let i = 0; i < count; i++) {
            const expressionName = this._modelSetting.getExpressionName(i);
            const expressionFileName = this._modelSetting.getExpressionFileName(i);
            fetch(`${this._modelHomeDir}${expressionFileName}`).then((response) => {
              if (response.ok) {
                return response.arrayBuffer();
              } else if (response.status >= 400) {
                CubismLogError(`Failed to load file ${this._modelHomeDir}${expressionFileName}`);
                return new ArrayBuffer(0);
              }
            }).then((arrayBuffer) => {
              const motion = this.loadExpression(arrayBuffer, arrayBuffer.byteLength, expressionName);
              if (this._expressions.getValue(expressionName) != null) {
                ACubismMotion.delete(this._expressions.getValue(expressionName));
                this._expressions.setValue(expressionName, null);
              }
              this._expressions.setValue(expressionName, motion);
              this._expressionCount++;
              if (this._expressionCount >= count) {
                this._state = LoadStep.LoadPhysics;
                loadCubismPhysics();
              }
            });
          }
          this._state = LoadStep.WaitLoadExpression;
        } else {
          this._state = LoadStep.LoadPhysics;
          loadCubismPhysics();
        }
      };
      const loadCubismPhysics = () => {
        if (this._modelSetting.getPhysicsFileName() != "") {
          const physicsFileName = this._modelSetting.getPhysicsFileName();
          fetch(`${this._modelHomeDir}${physicsFileName}`).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            } else if (response.status >= 400) {
              CubismLogError(`Failed to load file ${this._modelHomeDir}${physicsFileName}`);
              return new ArrayBuffer(0);
            }
          }).then((arrayBuffer) => {
            this.loadPhysics(arrayBuffer, arrayBuffer.byteLength);
            this._state = LoadStep.LoadPose;
            loadCubismPose();
          });
          this._state = LoadStep.WaitLoadPhysics;
        } else {
          this._state = LoadStep.LoadPose;
          loadCubismPose();
        }
      };
      const loadCubismPose = () => {
        if (this._modelSetting.getPoseFileName() != "") {
          const poseFileName = this._modelSetting.getPoseFileName();
          fetch(`${this._modelHomeDir}${poseFileName}`).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            } else if (response.status >= 400) {
              CubismLogError(`Failed to load file ${this._modelHomeDir}${poseFileName}`);
              return new ArrayBuffer(0);
            }
          }).then((arrayBuffer) => {
            this.loadPose(arrayBuffer, arrayBuffer.byteLength);
            this._state = LoadStep.SetupEyeBlink;
            setupEyeBlink();
          });
          this._state = LoadStep.WaitLoadPose;
        } else {
          this._state = LoadStep.SetupEyeBlink;
          setupEyeBlink();
        }
      };
      const setupEyeBlink = () => {
        if (this._modelSetting.getEyeBlinkParameterCount() > 0) {
          this._eyeBlink = CubismEyeBlink.create(this._modelSetting);
          this._state = LoadStep.SetupBreath;
        }
        setupBreath();
      };
      const setupBreath = () => {
        this._breath = CubismBreath.create();
        const breathParameters = new csmVector();
        breathParameters.pushBack(new BreathParameterData(this._idParamAngleX, 0, 15, 6.5345, 0.5));
        breathParameters.pushBack(new BreathParameterData(this._idParamAngleY, 0, 8, 3.5345, 0.5));
        breathParameters.pushBack(new BreathParameterData(this._idParamAngleZ, 0, 10, 5.5345, 0.5));
        breathParameters.pushBack(new BreathParameterData(this._idParamBodyAngleX, 0, 4, 15.5345, 0.5));
        breathParameters.pushBack(new BreathParameterData(CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamBreath), 0.5, 0.5, 3.2345, 1));
        this._breath.setParameters(breathParameters);
        this._state = LoadStep.LoadUserData;
        loadUserData();
      };
      const loadUserData = () => {
        if (this._modelSetting.getUserDataFile() != "") {
          const userDataFile = this._modelSetting.getUserDataFile();
          fetch(`${this._modelHomeDir}${userDataFile}`).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            } else if (response.status >= 400) {
              CubismLogError(`Failed to load file ${this._modelHomeDir}${userDataFile}`);
              return new ArrayBuffer(0);
            }
          }).then((arrayBuffer) => {
            this.loadUserData(arrayBuffer, arrayBuffer.byteLength);
            this._state = LoadStep.SetupEyeBlinkIds;
            setupEyeBlinkIds();
          });
          this._state = LoadStep.WaitLoadUserData;
        } else {
          this._state = LoadStep.SetupEyeBlinkIds;
          setupEyeBlinkIds();
        }
      };
      const setupEyeBlinkIds = () => {
        const eyeBlinkIdCount = this._modelSetting.getEyeBlinkParameterCount();
        for (let i = 0; i < eyeBlinkIdCount; ++i) {
          this._eyeBlinkIds.pushBack(this._modelSetting.getEyeBlinkParameterId(i));
        }
        this._state = LoadStep.SetupLipSyncIds;
        setupLipSyncIds();
      };
      const setupLipSyncIds = () => {
        const lipSyncIdCount = this._modelSetting.getLipSyncParameterCount();
        for (let i = 0; i < lipSyncIdCount; ++i) {
          this._lipSyncIds.pushBack(this._modelSetting.getLipSyncParameterId(i));
        }
        this._state = LoadStep.SetupLayout;
        setupLayout();
      };
      const setupLayout = () => {
        const layout = new csmMap();
        if (this._modelSetting == null || this._modelMatrix == null) {
          CubismLogError("Failed to setupLayout().");
          return;
        }
        this._modelSetting.getLayoutMap(layout);
        this._modelMatrix.setupFromLayout(layout);
        this._state = LoadStep.LoadMotion;
        loadCubismMotion();
      };
      const loadCubismMotion = () => {
        this._state = LoadStep.WaitLoadMotion;
        this._model.saveParameters();
        this._allMotionCount = 0;
        this._motionCount = 0;
        const group = [];
        const motionGroupCount = this._modelSetting.getMotionGroupCount();
        for (let i = 0; i < motionGroupCount; i++) {
          group[i] = this._modelSetting.getMotionGroupName(i);
          this._allMotionCount += this._modelSetting.getMotionCount(group[i]);
        }
        for (let i = 0; i < motionGroupCount; i++) {
          this.preLoadMotionGroup(group[i]);
        }
        if (motionGroupCount == 0) {
          this._state = LoadStep.LoadTexture;
          this._motionManager.stopAllMotions();
          this._updating = false;
          this._initialized = true;
          this.createRenderer();
          this.setupTextures();
          this.getRenderer().startUp(this.gl);
        }
      };
    }
    /**
     * 
     */
    setupTextures() {
      const usePremultiply = true;
      if (this._state == LoadStep.LoadTexture) {
        const textureCount = this._modelSetting.getTextureCount();
        for (let modelTextureNumber = 0; modelTextureNumber < textureCount; modelTextureNumber++) {
          if (this._modelSetting.getTextureFileName(modelTextureNumber) == "") {
            console.log("getTextureFileName null");
            continue;
          }
          let texturePath = this._modelSetting.getTextureFileName(modelTextureNumber);
          texturePath = this._modelHomeDir + texturePath;
          const onLoad = (textureInfo) => {
            this.getRenderer().bindTexture(modelTextureNumber, textureInfo.id);
            this._textureCount++;
            if (this._textureCount >= textureCount) {
              this._state = LoadStep.CompleteSetup;
            }
          };
          this._textureManager.createTextureFromPngFile(texturePath, usePremultiply, onLoad);
          this.getRenderer().setIsPremultipliedAlpha(usePremultiply);
        }
        this._state = LoadStep.WaitLoadTexture;
      }
    }
    /**
     * 
     */
    reloadRenderer() {
      this.deleteRenderer();
      this.createRenderer();
      this.setupTextures();
    }
    /**
     * 
     */
    update() {
      if (this._state != LoadStep.CompleteSetup)
        return;
      const deltaTimeSeconds = LAppPal.getDeltaTime();
      this._userTimeSeconds += deltaTimeSeconds;
      this._dragManager.update(deltaTimeSeconds);
      this._dragX = this._dragManager.getX();
      this._dragY = this._dragManager.getY();
      let motionUpdated = false;
      this._model.loadParameters();
      if (this._motionManager.isFinished()) {
        this.startRandomMotion(MotionGroupIdle, PriorityIdle);
      } else {
        motionUpdated = this._motionManager.updateMotion(this._model, deltaTimeSeconds);
      }
      this._model.saveParameters();
      if (!motionUpdated) {
        if (this._eyeBlink != null) {
          this._eyeBlink.updateParameters(this._model, deltaTimeSeconds);
        }
      }
      if (this._expressionManager != null) {
        this._expressionManager.updateMotion(this._model, deltaTimeSeconds);
      }
      this._model.addParameterValueById(this._idParamAngleX, this._dragX * 30);
      this._model.addParameterValueById(this._idParamAngleY, this._dragY * 30);
      this._model.addParameterValueById(this._idParamAngleZ, this._dragX * this._dragY * -30);
      this._model.addParameterValueById(this._idParamBodyAngleX, this._dragX * 10);
      this._model.addParameterValueById(this._idParamEyeBallX, this._dragX);
      this._model.addParameterValueById(this._idParamEyeBallY, this._dragY);
      if (this._breath != null) {
        this._breath.updateParameters(this._model, deltaTimeSeconds);
      }
      if (this._physics != null) {
        this._physics.evaluate(this._model, deltaTimeSeconds);
      }
      if (this._lipsync) {
        let value = 0;
        this._wavFileHandler.update(deltaTimeSeconds);
        value = this._wavFileHandler.getRms();
        for (let i = 0; i < this._lipSyncIds.getSize(); ++i) {
          this._model.addParameterValueById(this._lipSyncIds.at(i), value, 0.8);
        }
      }
      if (this._pose != null) {
        this._pose.updateParameters(this._model, deltaTimeSeconds);
      }
      this._model.update();
    }
    /**
     * 
     * @param group 
     * @param no 
     * @param priority 
     * @param onFinishedMotionHandler 
     * @return isFinished()[-1]
     */
    startMotion(group, no, priority, onFinishedMotionHandler) {
      if (priority == PriorityForce) {
        this._motionManager.setReservePriority(priority);
      } else if (!this._motionManager.reserveMotion(priority)) {
        if (this._debugMode) {
          LAppPal.printMessage("[APP]can't start motion.");
        }
        return InvalidMotionQueueEntryHandleValue;
      }
      const motionFileName = this._modelSetting.getMotionFileName(group, no);
      const name = `${group}_${no}`;
      let motion = this._motions.getValue(name);
      let autoDelete = false;
      if (motion == null) {
        fetch(`${this._modelHomeDir}${motionFileName}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(`Failed to load file ${this._modelHomeDir}${motionFileName}`);
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          motion = this.loadMotion(arrayBuffer, arrayBuffer.byteLength, null, onFinishedMotionHandler);
          if (motion == null) {
            return;
          }
          let fadeTime = this._modelSetting.getMotionFadeInTimeValue(group, no);
          if (fadeTime >= 0) {
            motion.setFadeInTime(fadeTime);
          }
          fadeTime = this._modelSetting.getMotionFadeOutTimeValue(group, no);
          if (fadeTime >= 0) {
            motion.setFadeOutTime(fadeTime);
          }
          motion.setEffectIds(this._eyeBlinkIds, this._lipSyncIds);
          autoDelete = true;
        });
      } else {
        motion.setFinishedMotionHandler(onFinishedMotionHandler);
      }
      const voice = this._modelSetting.getMotionSoundFileName(group, no);
      if (voice.localeCompare("") != 0) {
        let path = voice;
        path = this._modelHomeDir + path;
        this._wavFileHandler.start(path);
      }
      if (this._debugMode) {
        LAppPal.printMessage(`[APP]start motion: [${group}_${no}`);
      }
      return this._motionManager.startMotionPriority(motion, autoDelete, priority);
    }
    /**
     * 
     * @param group 
     * @param priority 
     * @param onFinishedMotionHandler 
     * @return isFinished()[-1]
     */
    startRandomMotion(group, priority, onFinishedMotionHandler) {
      if (this._modelSetting.getMotionCount(group) == 0) {
        return InvalidMotionQueueEntryHandleValue;
      }
      const no = Math.floor(Math.random() * this._modelSetting.getMotionCount(group));
      return this.startMotion(group, no, priority, onFinishedMotionHandler);
    }
    endMotion() {
      this._motionManager.stopAllMotions();
    }
    /**
     * 
     *
     * @param expressionId ID
     */
    setExpression(expressionId) {
      const motion = this._expressions.getValue(expressionId);
      if (this._debugMode) {
        LAppPal.printMessage(`[APP]expression: [${expressionId}]`);
      }
      if (motion != null) {
        this._expressionManager.startMotionPriority(motion, false, PriorityForce);
      } else {
        if (this._debugMode) {
          LAppPal.printMessage(`[APP]expression[${expressionId}] is null`);
        }
      }
    }
    /**
     * 
     */
    setRandomExpression() {
      if (this._expressions.getSize() == 0) {
        return;
      }
      const no = Math.floor(Math.random() * this._expressions.getSize());
      for (let i = 0; i < this._expressions.getSize(); i++) {
        if (i == no) {
          const name = this._expressions._keyValues[i].first;
          this.setExpression(name);
          return;
        }
      }
    }
    unsetExpression() {
      this._expressionManager.stopAllMotions();
    }
    /**
     * 
     */
    motionEventFired(eventValue) {
      CubismLogInfo("{0} is fired on LAppModel!!", eventValue.s);
    }
    /**
     * 
     * 
     *
     * @param hitArenaName  ID
     * @param x             X
     * @param y             Y
     */
    hitTest(hitArenaName, x, y) {
      if (this._opacity < 1) {
        return false;
      }
      const count = this._modelSetting.getHitAreasCount();
      for (let i = 0; i < count; i++) {
        if (this._modelSetting.getHitAreaName(i) == hitArenaName) {
          const drawId = this._modelSetting.getHitAreaId(i);
          return this.isHit(drawId, x, y);
        }
      }
      return false;
    }
    /**
     * 
     * ModelSetting
     *
     * @param group 
     */
    preLoadMotionGroup(group) {
      for (let i = 0; i < this._modelSetting.getMotionCount(group); i++) {
        const motionFileName = this._modelSetting.getMotionFileName(group, i);
        const name = `${group}_${i}`;
        if (this._debugMode) {
          LAppPal.printMessage(`[APP]load motion: ${motionFileName} => [${name}]`);
        }
        fetch(`${this._modelHomeDir}${motionFileName}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(`Failed to load file ${this._modelHomeDir}${motionFileName}`);
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          const tmpMotion = this.loadMotion(arrayBuffer, arrayBuffer.byteLength, name);
          if (tmpMotion != null) {
            let fadeTime = this._modelSetting.getMotionFadeInTimeValue(group, i);
            if (fadeTime >= 0) {
              tmpMotion.setFadeInTime(fadeTime);
            }
            fadeTime = this._modelSetting.getMotionFadeOutTimeValue(group, i);
            if (fadeTime >= 0) {
              tmpMotion.setFadeOutTime(fadeTime);
            }
            tmpMotion.setEffectIds(this._eyeBlinkIds, this._lipSyncIds);
            if (this._motions.getValue(name) != null) {
              ACubismMotion.delete(this._motions.getValue(name));
            }
            this._motions.setValue(name, tmpMotion);
            this._motionCount++;
            if (this._motionCount >= this._allMotionCount) {
              this._state = LoadStep.LoadTexture;
              this._motionManager.stopAllMotions();
              this._updating = false;
              this._initialized = true;
              this.createRenderer();
              this.setupTextures();
              this.getRenderer().startUp(this.gl);
            }
          } else {
            this._allMotionCount--;
          }
        });
      }
    }
    /**
     * 
     */
    releaseMotions() {
      this._motions.clear();
    }
    /**
     * 
     */
    releaseExpressions() {
      this._expressions.clear();
    }
    /**
     * View-Projection
     */
    doDraw() {
      if (this._model == null)
        return;
      this.getRenderer().setRenderState(this.frameBuffer, this.viewport);
      this.getRenderer().drawModel();
    }
    /**
     * View-Projection
     */
    draw(matrix) {
      if (this._model == null) {
        return;
      }
      if (this._state == LoadStep.CompleteSetup) {
        matrix.multiplyByMatrix(this._modelMatrix);
        this.getRenderer().setMvpMatrix(matrix);
        this.doDraw();
      }
    }
    hasMocConsistencyFromFile() {
      return __awaiter2(this, void 0, void 0, function* () {
        CSM_ASSERT(this._modelSetting.getModelFileName().localeCompare(``));
        if (this._modelSetting.getModelFileName() != "") {
          const modelFileName = this._modelSetting.getModelFileName();
          const response = yield fetch(`${this._modelHomeDir}${modelFileName}`);
          const arrayBuffer = yield response.arrayBuffer();
          this._consistency = CubismMoc.hasMocConsistency(arrayBuffer);
          if (!this._consistency) {
            CubismLogInfo("Inconsistent MOC3.");
          } else {
            CubismLogInfo("Consistent MOC3.");
          }
          return this._consistency;
        } else {
          LAppPal.printMessage("Model data does not exist.");
        }
      });
    }
    /**
     * 
     */
    constructor(canvas_gl, textureMgr, cvs, viewport, frameBuffer) {
      super();
      this.viewport = viewport;
      this.frameBuffer = frameBuffer;
      this._textureManager = textureMgr;
      this.gl = canvas_gl;
      this.canvas = cvs;
      this._modelSetting = null;
      this._modelHomeDir = null;
      this._userTimeSeconds = 0;
      this._eyeBlinkIds = new csmVector();
      this._lipSyncIds = new csmVector();
      this._motions = new csmMap();
      this._expressions = new csmMap();
      this._hitArea = new csmVector();
      this._userArea = new csmVector();
      this._idParamAngleX = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamAngleX);
      this._idParamAngleY = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamAngleY);
      this._idParamAngleZ = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamAngleZ);
      this._idParamEyeBallX = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamEyeBallX);
      this._idParamEyeBallY = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamEyeBallY);
      this._idParamBodyAngleX = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamBodyAngleX);
      if (MOCConsistencyValidationEnable) {
        this._mocConsistency = true;
      }
      this._state = LoadStep.LoadAssets;
      this._expressionCount = 0;
      this._textureCount = 0;
      this._motionCount = 0;
      this._allMotionCount = 0;
      this._wavFileHandler = new LAppWavFileHandler();
      this._consistency = false;
    }
  };

  // src/Live2D/lapptexturemanager.js
  var LAppTextureManager = class {
    /**
     * 
     */
    constructor(canvas_gl) {
      this.gl = canvas_gl;
      this._textures = new csmVector();
    }
    /**
     * 
     */
    release() {
      for (let ite = this._textures.begin(); ite.notEqual(this._textures.end()); ite.preIncrement()) {
        this.gl.deleteTexture(ite.ptr().id);
      }
      this._textures = null;
    }
    /**
     * 
     *
     * @param fileName 
     * @param usePremultiply Premult
     * @return null
     */
    createTextureFromPngFile(fileName, usePremultiply, callback) {
      for (let ite = this._textures.begin(); ite.notEqual(this._textures.end()); ite.preIncrement()) {
        if (ite.ptr().fileName == fileName && ite.ptr().usePremultply == usePremultiply) {
          ite.ptr().img = new Image();
          ite.ptr().img.addEventListener("load", () => callback(ite.ptr()), {
            passive: true
          });
          ite.ptr().img.src = fileName;
          return;
        }
      }
      const img = new Image();
      img.addEventListener("load", () => {
        const tex = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        if (usePremultiply) {
          this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
        }
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
        this.gl.generateMipmap(this.gl.TEXTURE_2D);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        const textureInfo = new TextureInfo();
        if (textureInfo != null) {
          textureInfo.fileName = fileName;
          textureInfo.width = img.width;
          textureInfo.height = img.height;
          textureInfo.id = tex;
          textureInfo.img = img;
          textureInfo.usePremultply = usePremultiply;
          this._textures.pushBack(textureInfo);
        }
        callback(textureInfo);
      }, { passive: true });
      img.src = fileName;
    }
    /**
     * 
     *
     * 
     */
    releaseTextures() {
      for (let i = 0; i < this._textures.getSize(); i++) {
        this._textures.set(i, null);
      }
      this._textures.clear();
    }
    /**
     * 
     *
     * 
     * @param texture 
     */
    releaseTextureByTexture(texture) {
      for (let i = 0; i < this._textures.getSize(); i++) {
        if (this._textures.at(i).id != texture) {
          continue;
        }
        this._textures.set(i, null);
        this._textures.remove(i);
        break;
      }
    }
    /**
     * 
     *
     * 
     * @param fileName 
     */
    releaseTextureByFilePath(fileName) {
      for (let i = 0; i < this._textures.getSize(); i++) {
        if (this._textures.at(i).fileName == fileName) {
          this._textures.set(i, null);
          this._textures.remove(i);
          break;
        }
      }
    }
  };
  var TextureInfo = class {
    constructor() {
      this.id = null;
      this.width = 0;
      this.height = 0;
    }
  };

  // src/Live2D/Live2D.js
  var _s_instance;
  var _Live2D = class _Live2D {
    static getInstance(canvas) {
      if (__privateGet(_Live2D, _s_instance) == null) {
        __privateSet(_Live2D, _s_instance, new _Live2D(canvas));
      } else {
        console.log("releasing old instance");
        __privateGet(_Live2D, _s_instance).release();
        __privateSet(_Live2D, _s_instance, new _Live2D(canvas));
      }
      console.log("instance created");
      return __privateGet(_Live2D, _s_instance);
    }
    constructor(canvas) {
      this._canvas = canvas;
      this._cubismOption = new Option();
      this._viewMatrix = new CubismViewMatrix();
      this.debugMode = false;
    }
    pjsToModern(pjs) {
      var oldCanvas = pjs.externals.canvas;
      var width = oldCanvas.width;
      var height = oldCanvas.height;
      this._pgraphics = pjs.createGraphics(width, height, 2);
      this._pjs = pjs;
      this._canvas = this._pgraphics.externals.canvas;
    }
    // get context
    _getCtx() {
      return this._LAppGlManager.gl;
    }
    initialize(x, y, width, height, modelDir, modelFile) {
      this._LAppGlManager = new LAppGlManager(this._canvas);
      this._gl = this._getCtx();
      if (!this._frameBuffer) {
        this._frameBuffer = this._gl.getParameter(this._gl.FRAMEBUFFER_BINDING);
      }
      this._textureManager = new LAppTextureManager(this._gl);
      this._gl.enable(this._gl.BLEND);
      this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
      this._initializeCubism();
      this._viewMatrix.setScreenRect(x, width, y, height);
      this._viewport = [x, y, width, height];
      this.loadModel(modelDir, modelFile);
      return true;
    }
    // initialize cubism
    _initializeCubism() {
      this._cubismOption.logFunction = LAppPal.printMessage;
      this._cubismOption.loggingLevel = CubismLoggingLevel;
      CubismFramework.startUp(this._cubismOption);
      CubismFramework.initialize();
      LAppPal.updateTime();
    }
    // create shader
    _createShader() {
      const vertexShaderId = this._gl.createShader(this._gl.VERTEX_SHADER);
      if (vertexShaderId == null) {
        LAppPal.printMessage("failed to create vertexShader");
        return null;
      }
      const vertexShader = "precision mediump float;attribute vec3 position;attribute vec2 uv;varying vec2 vuv;void main(void){   gl_Position = vec4(position, 1.0);   vuv = uv;}";
      this._gl.shaderSource(vertexShaderId, vertexShader);
      this._gl.compileShader(vertexShaderId);
      const fragmentShaderId = this._gl.createShader(this._gl.FRAGMENT_SHADER);
      if (fragmentShaderId == null) {
        LAppPal.printMessage("failed to create fragmentShader");
        return null;
      }
      const fragmentShader = "precision mediump float;varying vec2 vuv;uniform sampler2D texture;void main(void){   gl_FragColor = texture2D(texture, vuv);}";
      this._gl.shaderSource(fragmentShaderId, fragmentShader);
      this._gl.compileShader(fragmentShaderId);
      const programId = this._gl.createProgram();
      this._gl.attachShader(programId, vertexShaderId);
      this._gl.attachShader(programId, fragmentShaderId);
      this._gl.deleteShader(vertexShaderId);
      this._gl.deleteShader(fragmentShaderId);
      this._gl.linkProgram(programId);
      this._gl.useProgram(programId);
      return programId;
    }
    // release everything
    release() {
      this._textureManager.release();
      this._textureManager = null;
      this._model = null;
      CubismFramework.dispose();
    }
    // load model
    loadModel(modelDir, modelFile, callback = null) {
      if (this._model) {
        this._model.release();
        this._model = null;
      }
      this._model = new LAppModel(
        this._gl,
        this._textureManager,
        this.canvas,
        this._viewport,
        this._frameBuffer
      );
      this._model.loadAssets(modelDir, modelFile, callback);
    }
    _preRender() {
      this._gl.clearColor(0, 0, 0, 1);
      this._gl.enable(this._gl.DEPTH_TEST);
      this._gl.depthFunc(this._gl.LEQUAL);
      this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
      this._gl.clearDepth(1);
      this._gl.enable(this._gl.BLEND);
      this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
    }
    // update + draw model
    updateModel() {
      if (!this._model) {
        return;
      }
      LAppPal.updateTime();
      const projection = new CubismMatrix44();
      const width = this._viewport[2];
      const height = this._viewport[3];
      if (this._model.getModel()) {
        if (this._model.getModel().getCanvasWidth() > 1 && width < height) {
          this._model.getModelMatrix().setWidth(2);
          projection.scale(1, width / height);
        } else {
          projection.scale(height / width, 1);
        }
        if (this._viewMatrix != null) {
          projection.multiplyByMatrix(this._viewMatrix);
        }
      }
      this._model.update();
      this._pgraphics.background(0, 0);
      this._pgraphics.beginDraw();
      this._model.draw(projection);
      this._pgraphics.endDraw();
      this._pjs.image(this._pgraphics, 0, 0);
    }
    // translate model (x, y) range of 0 to width/height of canvas
    // first translate canvas position to model position
    // note: the default model position is a the center of the canvas
    setModelCanvasPosition(x, y, width, height) {
      this._viewport = [x, y, width, height];
      this._viewMatrix.setScreenRect(x, width, y, height);
      if (this._model) {
        this._model.viewport = this._viewport;
      }
    }
    // set model position (x, y) range of -1.0 to 1.0
    setModelPosition(x, y) {
      if (this._model) {
        this._viewMatrix.translate(x, y);
      }
    }
    // set model scale
    setModelScale(scale) {
      if (this._model) {
        this._viewMatrix.scale(scale, scale);
      }
    }
    // start motion
    startMotion(group_name, id) {
      this._model.startMotion(group_name, id);
    }
    // end motion
    stopMotion() {
      this._model.endMotion();
    }
    // set expression
    setExpression(expression_name) {
      this._model.setExpression(expression_name);
    }
    // unset expression
    unsetExpression() {
      this._model.unsetExpression();
    }
    // set parameter
    setParameter(name, value, weight = 1) {
      this._model.getModel().setParameterValueById(name, value, weight);
    }
    // look at (x, y) range of -1.0 to 1.0
    lookAt(x, y) {
      this._model.setDragging(x, y);
    }
  };
  _s_instance = new WeakMap();
  __privateAdd(_Live2D, _s_instance, null);
  var Live2D = _Live2D;

  // src/P5Functions/Math.js
  function withMath(p, undef) {
    var internalRandomGenerator = function() {
      return Math.random();
    };
    p.abs = Math.abs;
    p.ceil = Math.ceil;
    p.exp = Math.exp;
    p.floor = Math.floor;
    p.log = Math.log;
    p.pow = Math.pow;
    p.round = Math.round;
    p.sqrt = Math.sqrt;
    p.acos = Math.acos;
    p.asin = Math.asin;
    p.atan = Math.atan;
    p.atan2 = Math.atan2;
    p.cos = Math.cos;
    p.sin = Math.sin;
    p.tan = Math.tan;
    p.constrain = function(aNumber, aMin, aMax) {
      return aNumber > aMax ? aMax : aNumber < aMin ? aMin : aNumber;
    };
    p.dist = function() {
      var dx, dy, dz;
      if (arguments.length === 4) {
        dx = arguments[0] - arguments[2];
        dy = arguments[1] - arguments[3];
        return Math.sqrt(dx * dx + dy * dy);
      }
      if (arguments.length === 6) {
        dx = arguments[0] - arguments[3];
        dy = arguments[1] - arguments[4];
        dz = arguments[2] - arguments[5];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      }
    };
    p.lerp = function(value1, value2, amt) {
      return (value2 - value1) * amt + value1;
    };
    p.mag = function(a, b, c) {
      if (c) {
        return Math.sqrt(a * a + b * b + c * c);
      }
      return Math.sqrt(a * a + b * b);
    };
    p.map = function(value, istart, istop, ostart, ostop) {
      return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
    };
    p.max = function() {
      if (arguments.length === 2) {
        return arguments[0] < arguments[1] ? arguments[1] : arguments[0];
      }
      var numbers = arguments.length === 1 ? arguments[0] : arguments;
      if (!("length" in numbers && numbers.length > 0)) {
        throw "Non-empty array is expected";
      }
      var max = numbers[0], count = numbers.length;
      for (var i = 1; i < count; ++i) {
        if (max < numbers[i]) {
          max = numbers[i];
        }
      }
      return max;
    };
    p.min = function() {
      if (arguments.length === 2) {
        return arguments[0] < arguments[1] ? arguments[0] : arguments[1];
      }
      var numbers = arguments.length === 1 ? arguments[0] : arguments;
      if (!("length" in numbers && numbers.length > 0)) {
        throw "Non-empty array is expected";
      }
      var min = numbers[0], count = numbers.length;
      for (var i = 1; i < count; ++i) {
        if (min > numbers[i]) {
          min = numbers[i];
        }
      }
      return min;
    };
    p.norm = function(aNumber, low, high) {
      return (aNumber - low) / (high - low);
    };
    p.sq = function(aNumber) {
      return aNumber * aNumber;
    };
    p.degrees = function(aAngle) {
      return aAngle * 180 / Math.PI;
    };
    p.random = function(aMin, aMax) {
      if (arguments.length === 0) {
        aMax = 1;
        aMin = 0;
      } else if (arguments.length === 1) {
        aMax = aMin;
        aMin = 0;
      }
      if (aMin === aMax) {
        return aMin;
      }
      for (var i = 0; i < 100; i++) {
        var ir = internalRandomGenerator();
        var result = ir * (aMax - aMin) + aMin;
        if (result !== aMax) {
          return result;
        }
      }
      return aMin;
    };
    function Marsaglia(i1, i2) {
      var z = i1 || 362436069, w = i2 || 521288629;
      var intGenerator = function() {
        z = 36969 * (z & 65535) + (z >>> 16) & 4294967295;
        w = 18e3 * (w & 65535) + (w >>> 16) & 4294967295;
        return ((z & 65535) << 16 | w & 65535) & 4294967295;
      };
      this.doubleGenerator = function() {
        var i = intGenerator() / 4294967296;
        return i < 0 ? 1 + i : i;
      };
      this.intGenerator = intGenerator;
    }
    Marsaglia.createRandomized = function() {
      var now = /* @__PURE__ */ new Date();
      return new Marsaglia(now / 6e4 & 4294967295, now & 4294967295);
    };
    p.randomSeed = function(seed) {
      internalRandomGenerator = new Marsaglia(seed, (seed << 16) + (seed >> 16)).doubleGenerator;
      this.haveNextNextGaussian = false;
    };
    p.randomGaussian = function() {
      if (this.haveNextNextGaussian) {
        this.haveNextNextGaussian = false;
        return this.nextNextGaussian;
      }
      var v1, v2, s;
      do {
        v1 = 2 * internalRandomGenerator() - 1;
        v2 = 2 * internalRandomGenerator() - 1;
        s = v1 * v1 + v2 * v2;
      } while (s >= 1 || s === 0);
      var multiplier = Math.sqrt(-2 * Math.log(s) / s);
      this.nextNextGaussian = v2 * multiplier;
      this.haveNextNextGaussian = true;
      return v1 * multiplier;
    };
    function PerlinNoise(seed) {
      var rnd = seed !== undef ? new Marsaglia(seed, (seed << 16) + (seed >> 16)) : Marsaglia.createRandomized();
      var i, j;
      var perm = new Uint8Array(512);
      for (i = 0; i < 256; ++i) {
        perm[i] = i;
      }
      for (i = 0; i < 256; ++i) {
        var t2 = perm[j = rnd.intGenerator() & 255];
        perm[j] = perm[i];
        perm[i] = t2;
      }
      for (i = 0; i < 256; ++i) {
        perm[i + 256] = perm[i];
      }
      function grad3d(i2, x, y, z) {
        var h = i2 & 15;
        var u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
      }
      function grad2d(i2, x, y) {
        var v = (i2 & 1) === 0 ? x : y;
        return (i2 & 2) === 0 ? -v : v;
      }
      function grad1d(i2, x) {
        return (i2 & 1) === 0 ? -x : x;
      }
      function lerp(t3, a, b) {
        return a + t3 * (b - a);
      }
      this.noise3d = function(x, y, z) {
        var X2 = Math.floor(x) & 255, Y2 = Math.floor(y) & 255, Z = Math.floor(z) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);
        var fx = (3 - 2 * x) * x * x, fy = (3 - 2 * y) * y * y, fz = (3 - 2 * z) * z * z;
        var p0 = perm[X2] + Y2, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z, p1 = perm[X2 + 1] + Y2, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;
        return lerp(
          fz,
          lerp(
            fy,
            lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x - 1, y, z)),
            lerp(fx, grad3d(perm[p01], x, y - 1, z), grad3d(perm[p11], x - 1, y - 1, z))
          ),
          lerp(
            fy,
            lerp(fx, grad3d(perm[p00 + 1], x, y, z - 1), grad3d(perm[p10 + 1], x - 1, y, z - 1)),
            lerp(fx, grad3d(perm[p01 + 1], x, y - 1, z - 1), grad3d(perm[p11 + 1], x - 1, y - 1, z - 1))
          )
        );
      };
      this.noise2d = function(x, y) {
        var X2 = Math.floor(x) & 255, Y2 = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        var fx = (3 - 2 * x) * x * x, fy = (3 - 2 * y) * y * y;
        var p0 = perm[X2] + Y2, p1 = perm[X2 + 1] + Y2;
        return lerp(
          fy,
          lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x - 1, y)),
          lerp(fx, grad2d(perm[p0 + 1], x, y - 1), grad2d(perm[p1 + 1], x - 1, y - 1))
        );
      };
      this.noise1d = function(x) {
        var X2 = Math.floor(x) & 255;
        x -= Math.floor(x);
        var fx = (3 - 2 * x) * x * x;
        return lerp(fx, grad1d(perm[X2], x), grad1d(perm[X2 + 1], x - 1));
      };
    }
    var noiseProfile = { generator: undef, octaves: 4, fallout: 0.5, seed: undef };
    p.noise = function(x, y, z) {
      if (noiseProfile.generator === undef) {
        noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
      }
      var generator = noiseProfile.generator;
      var effect = 1, k = 1, sum = 0;
      for (var i = 0; i < noiseProfile.octaves; ++i) {
        effect *= noiseProfile.fallout;
        switch (arguments.length) {
          case 1:
            sum += effect * (1 + generator.noise1d(k * x)) / 2;
            break;
          case 2:
            sum += effect * (1 + generator.noise2d(k * x, k * y)) / 2;
            break;
          case 3:
            sum += effect * (1 + generator.noise3d(k * x, k * y, k * z)) / 2;
            break;
        }
        k *= 2;
      }
      return sum;
    };
    p.noiseDetail = function(octaves, fallout) {
      noiseProfile.octaves = octaves;
      if (fallout !== undef) {
        noiseProfile.fallout = fallout;
      }
    };
    p.noiseSeed = function(seed) {
      noiseProfile.seed = seed;
      noiseProfile.generator = undef;
    };
  }

  // src/P5Functions/JavaProxyFunctions.js
  function withProxyFunctions(virtHashCode2, virtEquals2, undef) {
    return function withProxyFunctions2(p, removeFirstArgument) {
      p.__contains = function(subject, subStr) {
        if (typeof subject !== "string") {
          return subject.contains.apply(subject, removeFirstArgument(arguments));
        }
        return subject !== null && subStr !== null && typeof subStr === "string" && subject.indexOf(subStr) > -1;
      };
      p.__replaceAll = function(subject, regex, replacement) {
        if (typeof subject !== "string") {
          return subject.replaceAll.apply(subject, removeFirstArgument(arguments));
        }
        return subject.replace(new RegExp(regex, "g"), replacement);
      };
      p.__replaceFirst = function(subject, regex, replacement) {
        if (typeof subject !== "string") {
          return subject.replaceFirst.apply(subject, removeFirstArgument(arguments));
        }
        return subject.replace(new RegExp(regex, ""), replacement);
      };
      p.__replace = function(subject, what, replacement) {
        if (typeof subject !== "string") {
          return subject.replace.apply(subject, removeFirstArgument(arguments));
        }
        if (what instanceof RegExp) {
          return subject.replace(what, replacement);
        }
        if (typeof what !== "string") {
          what = what.toString();
        }
        if (what === "") {
          return subject;
        }
        var i = subject.indexOf(what);
        if (i < 0) {
          return subject;
        }
        var j = 0, result = "";
        do {
          result += subject.substring(j, i) + replacement;
          j = i + what.length;
        } while ((i = subject.indexOf(what, j)) >= 0);
        return result + subject.substring(j);
      };
      p.__equals = function(subject, other) {
        if (subject.equals instanceof Function) {
          return subject.equals.apply(subject, removeFirstArgument(arguments));
        }
        return virtEquals2(subject, other);
      };
      p.__equalsIgnoreCase = function(subject, other) {
        if (typeof subject !== "string") {
          return subject.equalsIgnoreCase.apply(subject, removeFirstArgument(arguments));
        }
        return subject.toLowerCase() === other.toLowerCase();
      };
      p.__toCharArray = function(subject) {
        if (typeof subject !== "string") {
          return subject.toCharArray.apply(subject, removeFirstArgument(arguments));
        }
        var chars = [];
        for (var i = 0, len = subject.length; i < len; ++i) {
          chars[i] = new Char_default(subject.charAt(i));
        }
        return chars;
      };
      p.__split = function(subject, regex, limit) {
        if (typeof subject !== "string") {
          return subject.split.apply(subject, removeFirstArgument(arguments));
        }
        var pattern = new RegExp(regex);
        if (limit === undef || limit < 1) {
          return subject.split(pattern);
        }
        var result = [], currSubject = subject, pos;
        while ((pos = currSubject.search(pattern)) !== -1 && result.length < limit - 1) {
          var match = pattern.exec(currSubject).toString();
          result.push(currSubject.substring(0, pos));
          currSubject = currSubject.substring(pos + match.length);
        }
        if (pos !== -1 || currSubject !== "") {
          result.push(currSubject);
        }
        return result;
      };
      p.__codePointAt = function(subject, idx) {
        var code = subject.charCodeAt(idx), hi, low;
        if (55296 <= code && code <= 56319) {
          hi = code;
          low = subject.charCodeAt(idx + 1);
          return (hi - 55296) * 1024 + (low - 56320) + 65536;
        }
        return code;
      };
      p.__matches = function(str, regexp) {
        return new RegExp(regexp).test(str);
      };
      p.__startsWith = function(subject, prefix, toffset) {
        if (typeof subject !== "string") {
          return subject.startsWith.apply(subject, removeFirstArgument(arguments));
        }
        toffset = toffset || 0;
        if (toffset < 0 || toffset > subject.length) {
          return false;
        }
        return prefix === "" || prefix === subject ? true : subject.indexOf(prefix) === toffset;
      };
      p.__endsWith = function(subject, suffix) {
        if (typeof subject !== "string") {
          return subject.endsWith.apply(subject, removeFirstArgument(arguments));
        }
        var suffixLen = suffix ? suffix.length : 0;
        return suffix === "" || suffix === subject ? true : subject.indexOf(suffix) === subject.length - suffixLen;
      };
      p.__hashCode = function(subject) {
        if (subject.hashCode instanceof Function) {
          return subject.hashCode.apply(subject, removeFirstArgument(arguments));
        }
        return virtHashCode2(subject);
      };
      p.__printStackTrace = function(subject) {
        p.println("Exception: " + subject.toString());
      };
    };
  }
  var JavaProxyFunctions_default = withProxyFunctions;

  // src/P5Functions/touchmouse.js
  function withTouch(p, curElement, attachEventHandler, detachEventHandlersByType, document2, PConstants3, undef) {
    var mouseTypes = ["mouseout", "mousemove", "mousedown", "mouseup", "DOMMouseScroll", "mousewheel", "touchstart"];
    function calculateOffset(curElement2, event) {
      var element = curElement2, offsetX = 0, offsetY = 0;
      p.pmouseX = p.mouseX;
      p.pmouseY = p.mouseY;
      if (element.offsetParent) {
        do {
          offsetX += element.offsetLeft;
          offsetY += element.offsetTop;
        } while (!!(element = element.offsetParent));
      }
      element = curElement2;
      do {
        offsetX -= element.scrollLeft || 0;
        offsetY -= element.scrollTop || 0;
      } while (!!(element = element.parentNode));
      var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;
      if (document2.defaultView && document2.defaultView.getComputedStyle) {
        stylePaddingLeft = parseInt(document2.defaultView.getComputedStyle(curElement2, null).paddingLeft, 10) || 0;
        stylePaddingTop = parseInt(document2.defaultView.getComputedStyle(curElement2, null).paddingTop, 10) || 0;
        styleBorderLeft = parseInt(document2.defaultView.getComputedStyle(curElement2, null).borderLeftWidth, 10) || 0;
        styleBorderTop = parseInt(document2.defaultView.getComputedStyle(curElement2, null).borderTopWidth, 10) || 0;
      }
      offsetX += stylePaddingLeft;
      offsetY += stylePaddingTop;
      offsetX += styleBorderLeft;
      offsetY += styleBorderTop;
      offsetX += window.pageXOffset;
      offsetY += window.pageYOffset;
      return { "X": offsetX, "Y": offsetY };
    }
    function updateMousePosition(curElement2, event) {
      var offset = calculateOffset(curElement2, event);
      p.mouseX = event.pageX - offset.X;
      p.mouseY = event.pageY - offset.Y;
    }
    function addTouchEventOffset(t2) {
      var offset = calculateOffset(t2.changedTouches[0].target, t2.changedTouches[0]), i;
      for (i = 0; i < t2.touches.length; i++) {
        var touch = t2.touches[i];
        touch.offsetX = touch.pageX - offset.X;
        touch.offsetY = touch.pageY - offset.Y;
      }
      for (i = 0; i < t2.targetTouches.length; i++) {
        var targetTouch = t2.targetTouches[i];
        targetTouch.offsetX = targetTouch.pageX - offset.X;
        targetTouch.offsetY = targetTouch.pageY - offset.Y;
      }
      for (i = 0; i < t2.changedTouches.length; i++) {
        var changedTouch = t2.changedTouches[i];
        changedTouch.offsetX = changedTouch.pageX - offset.X;
        changedTouch.offsetY = changedTouch.pageY - offset.Y;
      }
      return t2;
    }
    attachEventHandler(curElement, "touchstart", function(t2) {
      curElement.setAttribute("style", "-webkit-user-select: none");
      curElement.setAttribute("onclick", "void(0)");
      curElement.setAttribute("style", "-webkit-tap-highlight-color:rgba(0,0,0,0)");
      detachEventHandlersByType(curElement, mouseTypes);
      if (p.touchStart !== undef || p.touchMove !== undef || p.touchEnd !== undef || p.touchCancel !== undef) {
        attachEventHandler(curElement, "touchstart", function(t3) {
          if (p.touchStart !== undef) {
            t3 = addTouchEventOffset(t3);
            p.touchStart(t3);
          }
        });
        attachEventHandler(curElement, "touchmove", function(t3) {
          if (p.touchMove !== undef) {
            t3.preventDefault();
            t3 = addTouchEventOffset(t3);
            p.touchMove(t3);
          }
        });
        attachEventHandler(curElement, "touchend", function(t3) {
          if (p.touchEnd !== undef) {
            t3 = addTouchEventOffset(t3);
            p.touchEnd(t3);
          }
        });
        attachEventHandler(curElement, "touchcancel", function(t3) {
          if (p.touchCancel !== undef) {
            t3 = addTouchEventOffset(t3);
            p.touchCancel(t3);
          }
        });
      } else {
        attachEventHandler(curElement, "touchstart", function(e) {
          updateMousePosition(curElement, e.touches[0]);
          p.__mousePressed = true;
          p.mouseDragging = false;
          p.mouseButton = PConstants3.LEFT;
          if (typeof p.mousePressed === "function") {
            p.mousePressed();
          }
        });
        attachEventHandler(curElement, "touchmove", function(e) {
          e.preventDefault();
          updateMousePosition(curElement, e.touches[0]);
          if (typeof p.mouseMoved === "function" && !p.__mousePressed) {
            p.mouseMoved();
          }
          if (typeof p.mouseDragged === "function" && p.__mousePressed) {
            p.mouseDragged();
            p.mouseDragging = true;
          }
        });
        attachEventHandler(curElement, "touchend", function(e) {
          p.__mousePressed = false;
          if (typeof p.mouseClicked === "function" && !p.mouseDragging) {
            p.mouseClicked();
          }
          if (typeof p.mouseReleased === "function") {
            p.mouseReleased();
          }
        });
      }
    });
    (function() {
      var enabled = true, contextMenu = function(e) {
        e.preventDefault();
        e.stopPropagation();
      };
      p.disableContextMenu = function() {
        if (!enabled) {
          return;
        }
        attachEventHandler(curElement, "contextmenu", contextMenu);
        enabled = false;
      };
      p.enableContextMenu = function() {
        if (enabled) {
          return;
        }
        detachEventHandler({ elem: curElement, type: "contextmenu", fn: contextMenu });
        enabled = true;
      };
    })();
    attachEventHandler(curElement, "mousemove", function(e) {
      updateMousePosition(curElement, e);
      if (typeof p.mouseMoved === "function" && !p.__mousePressed) {
        p.mouseMoved();
      }
      if (typeof p.mouseDragged === "function" && p.__mousePressed) {
        p.mouseDragged();
        p.mouseDragging = true;
      }
    });
    attachEventHandler(curElement, "mouseout", function(e) {
      if (typeof p.mouseOut === "function") {
        p.mouseOut();
      }
    });
    attachEventHandler(curElement, "mouseover", function(e) {
      updateMousePosition(curElement, e);
      if (typeof p.mouseOver === "function") {
        p.mouseOver();
      }
    });
    curElement.onmousedown = function() {
      curElement.focus();
      return false;
    };
    attachEventHandler(curElement, "mousedown", function(e) {
      p.__mousePressed = true;
      p.mouseDragging = false;
      switch (e.which) {
        case 1:
          p.mouseButton = PConstants3.LEFT;
          break;
        case 2:
          p.mouseButton = PConstants3.CENTER;
          break;
        case 3:
          p.mouseButton = PConstants3.RIGHT;
          break;
      }
      if (typeof p.mousePressed === "function") {
        p.mousePressed();
      }
    });
    attachEventHandler(curElement, "mouseup", function(e) {
      p.__mousePressed = false;
      if (typeof p.mouseClicked === "function" && !p.mouseDragging) {
        p.mouseClicked();
      }
      if (typeof p.mouseReleased === "function") {
        p.mouseReleased();
      }
    });
    var mouseWheelHandler = function(e) {
      if (e.target !== curElement) return;
      var delta = 0;
      if (e.wheelDelta) {
        delta = e.wheelDelta / 120;
        if (window.opera) {
          delta = -delta;
        }
      } else if (e.detail) {
        delta = -e.detail / 3;
      }
      p.mouseScroll = delta;
      if (delta && typeof p.mouseScrolled === "function") {
        e.stopPropagation();
        e.preventDefault();
        p.mouseScrolled();
      }
    };
    attachEventHandler(document2, "DOMMouseScroll", mouseWheelHandler);
    attachEventHandler(document2, "mousewheel", mouseWheelHandler);
  }

  // src/index.js
  var source = {
    virtEquals,
    virtHashCode,
    ObjectIterator,
    PConstants: PConstants_default,
    ArrayList: ArrayList_default,
    HashMap: HashMap_default,
    PVector: PVector_default,
    PFont: PFont_default,
    Char: Char_default,
    XMLAttribute: XMLAttribute_default,
    XMLElement: XMLElement_default,
    PMatrix2D: PMatrix2D_default,
    PMatrix3D: PMatrix3D_default,
    PShape: PShape_default,
    colors: webcolors_default,
    PShapeSVG: PShapeSVG_default,
    CommonFunctions: commonFunctions,
    defaultScope: defaultScope_default,
    Processing: Processing_default,
    setupParser,
    finalize: finalizeProcessing,
    Live2D
  };
  var withProxyFunctionsFn = JavaProxyFunctions_default(source.virtHashCode, source.virtEquals);
  source.extend = {
    withMath,
    withProxyFunctions: withProxyFunctionsFn,
    withTouch,
    withCommonFunctions: source.CommonFunctions().withCommonFunctions
  };
  function buildProcessingJS(Browser2, testHarness) {
    var noop = function() {
    }, virtEquals2 = source.virtEquals, virtHashCode2 = source.virtHashCode, PConstants3 = source.PConstants, CommonFunctions = source.CommonFunctions, ObjectIterator2 = source.ObjectIterator, Char2 = source.Char, XMLAttribute = source.XMLAttribute(), ArrayList = source.ArrayList({
      virtHashCode: virtHashCode2,
      virtEquals: virtEquals2
    }), HashMap3 = source.HashMap({
      virtHashCode: virtHashCode2,
      virtEquals: virtEquals2
    }), PVector3 = source.PVector({
      PConstants: PConstants3
    }), PFont3 = source.PFont({
      Browser: Browser2,
      noop
    }), XMLElement = source.XMLElement({
      Browser: Browser2,
      XMLAttribute
    }), PMatrix2D2 = source.PMatrix2D({
      p: CommonFunctions
    }), PMatrix3D2 = source.PMatrix3D({
      p: CommonFunctions
    }), PShape = source.PShape({
      PConstants: PConstants3,
      PMatrix2D: PMatrix2D2,
      PMatrix3D: PMatrix3D2
    }), PShapeSVG2 = source.PShapeSVG({
      CommonFunctions,
      PConstants: PConstants3,
      PShape,
      XMLElement,
      colors: source.colors
    }), defaultScope2 = source.defaultScope({
      ArrayList,
      HashMap: HashMap3,
      PVector: PVector3,
      PFont: PFont3,
      PShapeSVG: PShapeSVG2,
      ObjectIterator: ObjectIterator2,
      PConstants: PConstants3,
      Char: Char2,
      XMLElement,
      XML: XMLElement,
      Live2D: source.Live2D
    }), Processing3 = source.Processing({
      defaultScope: defaultScope2,
      Browser: Browser2,
      extend: source.extend,
      noop
    });
    Processing3 = source.setupParser(Processing3, {
      Browser: Browser2,
      aFunctions: testHarness,
      defaultScope: defaultScope2
    });
    Processing3 = source.finalize(Processing3, {
      version: "1.6.6+live2d",
      isDomPresent: Browser2.isDomPresent,
      window: Browser2.window,
      document: Browser2.document,
      noop
    });
    window.PFont = PFont3;
    return Processing3;
  }
  var src_default = buildProcessingJS;

  // src/Live2D/live2dcubismcore.js
  var Live2DCubismCore2;
  (function(Live2DCubismCore3) {
    var _csm = (
      /** @class */
      function() {
        function _csm2() {
        }
        _csm2.getVersion = function() {
          return _em.ccall("csmGetVersion", "number", [], []);
        };
        _csm2.getLatestMocVersion = function() {
          return _em.ccall("csmGetLatestMocVersion", "number", [], []);
        };
        _csm2.getMocVersion = function(moc, mocSize) {
          return _em.ccall("csmGetMocVersion", "number", ["number", "number"], [moc, mocSize]);
        };
        _csm2.getSizeofModel = function(moc) {
          return _em.ccall("csmGetSizeofModel", "number", ["number"], [moc]);
        };
        _csm2.reviveMocInPlace = function(memory, mocSize) {
          return _em.ccall("csmReviveMocInPlace", "number", ["number", "number"], [memory, mocSize]);
        };
        _csm2.initializeModelInPlace = function(moc, memory, modelSize) {
          return _em.ccall("csmInitializeModelInPlace", "number", ["number", "number", "number"], [moc, memory, modelSize]);
        };
        _csm2.hasMocConsistency = function(memory, mocSize) {
          return _em.ccall("csmHasMocConsistency", "number", ["number", "number"], [memory, mocSize]);
        };
        _csm2.getParameterCount = function(model) {
          return _em.ccall("csmGetParameterCount", "number", ["number"], [model]);
        };
        _csm2.getParameterIds = function(model) {
          return _em.ccall("csmGetParameterIds", "number", ["number"], [model]);
        };
        _csm2.getParameterMinimumValues = function(model) {
          return _em.ccall("csmGetParameterMinimumValues", "number", ["number"], [model]);
        };
        _csm2.getParameterTypes = function(model) {
          return _em.ccall("csmGetParameterTypes", "number", ["number"], [model]);
        };
        _csm2.getParameterMaximumValues = function(model) {
          return _em.ccall("csmGetParameterMaximumValues", "number", ["number"], [model]);
        };
        _csm2.getParameterDefaultValues = function(model) {
          return _em.ccall("csmGetParameterDefaultValues", "number", ["number"], [model]);
        };
        _csm2.getParameterValues = function(model) {
          return _em.ccall("csmGetParameterValues", "number", ["number"], [model]);
        };
        _csm2.getParameterKeyCounts = function(model) {
          return _em.ccall("csmGetParameterKeyCounts", "number", ["number"], [model]);
        };
        _csm2.getParameterKeyValues = function(model) {
          return _em.ccall("csmGetParameterKeyValues", "number", ["number"], [model]);
        };
        _csm2.getPartCount = function(model) {
          return _em.ccall("csmGetPartCount", "number", ["number"], [model]);
        };
        _csm2.getPartIds = function(model) {
          return _em.ccall("csmGetPartIds", "number", ["number"], [model]);
        };
        _csm2.getPartOpacities = function(model) {
          return _em.ccall("csmGetPartOpacities", "number", ["number"], [model]);
        };
        _csm2.getPartParentPartIndices = function(model) {
          return _em.ccall("csmGetPartParentPartIndices", "number", ["number"], [model]);
        };
        _csm2.getDrawableCount = function(model) {
          return _em.ccall("csmGetDrawableCount", "number", ["number"], [model]);
        };
        _csm2.getDrawableIds = function(model) {
          return _em.ccall("csmGetDrawableIds", "number", ["number"], [model]);
        };
        _csm2.getDrawableConstantFlags = function(model) {
          return _em.ccall("csmGetDrawableConstantFlags", "number", ["number"], [model]);
        };
        _csm2.getDrawableDynamicFlags = function(model) {
          return _em.ccall("csmGetDrawableDynamicFlags", "number", ["number"], [model]);
        };
        _csm2.getDrawableTextureIndices = function(model) {
          return _em.ccall("csmGetDrawableTextureIndices", "number", ["number"], [model]);
        };
        _csm2.getDrawableDrawOrders = function(model) {
          return _em.ccall("csmGetDrawableDrawOrders", "number", ["number"], [model]);
        };
        _csm2.getDrawableRenderOrders = function(model) {
          return _em.ccall("csmGetDrawableRenderOrders", "number", ["number"], [model]);
        };
        _csm2.getDrawableOpacities = function(model) {
          return _em.ccall("csmGetDrawableOpacities", "number", ["number"], [model]);
        };
        _csm2.getDrawableMaskCounts = function(model) {
          return _em.ccall("csmGetDrawableMaskCounts", "number", ["number"], [model]);
        };
        _csm2.getDrawableMasks = function(model) {
          return _em.ccall("csmGetDrawableMasks", "number", ["number"], [model]);
        };
        _csm2.getDrawableVertexCounts = function(model) {
          return _em.ccall("csmGetDrawableVertexCounts", "number", ["number"], [model]);
        };
        _csm2.getDrawableVertexPositions = function(model) {
          return _em.ccall("csmGetDrawableVertexPositions", "number", ["number"], [model]);
        };
        _csm2.getDrawableVertexUvs = function(model) {
          return _em.ccall("csmGetDrawableVertexUvs", "number", ["number"], [model]);
        };
        _csm2.getDrawableIndexCounts = function(model) {
          return _em.ccall("csmGetDrawableIndexCounts", "number", ["number"], [model]);
        };
        _csm2.getDrawableIndices = function(model) {
          return _em.ccall("csmGetDrawableIndices", "number", ["number"], [model]);
        };
        _csm2.getDrawableMultiplyColors = function(model) {
          return _em.ccall("csmGetDrawableMultiplyColors", "number", ["number"], [model]);
        };
        _csm2.getDrawableScreenColors = function(model) {
          return _em.ccall("csmGetDrawableScreenColors", "number", ["number"], [model]);
        };
        _csm2.getDrawableParentPartIndices = function(model) {
          return _em.ccall("csmGetDrawableParentPartIndices", "number", ["number"], [model]);
        };
        _csm2.mallocMoc = function(mocSize) {
          return _em.ccall("csmMallocMoc", "number", ["number"], [mocSize]);
        };
        _csm2.mallocModelAndInitialize = function(moc) {
          return _em.ccall("csmMallocModelAndInitialize", "number", ["number"], [moc]);
        };
        _csm2.malloc = function(size) {
          return _em.ccall("csmMalloc", "number", ["number"], [size]);
        };
        _csm2.setLogFunction = function(handler) {
          _em.ccall("csmSetLogFunction", null, ["number"], [handler]);
        };
        _csm2.updateModel = function(model) {
          _em.ccall("csmUpdateModel", null, ["number"], [model]);
        };
        _csm2.readCanvasInfo = function(model, outSizeInPixels, outOriginInPixels, outPixelsPerUnit) {
          _em.ccall("csmReadCanvasInfo", null, ["number", "number", "number", "number"], [model, outSizeInPixels, outOriginInPixels, outPixelsPerUnit]);
        };
        _csm2.resetDrawableDynamicFlags = function(model) {
          _em.ccall("csmResetDrawableDynamicFlags", null, ["number"], [model]);
        };
        _csm2.free = function(memory) {
          _em.ccall("csmFree", null, ["number"], [memory]);
        };
        _csm2.initializeAmountOfMemory = function(size) {
          _em.ccall("csmInitializeAmountOfMemory", null, ["number"], [size]);
        };
        return _csm2;
      }()
    );
    Live2DCubismCore3.AlignofMoc = 64;
    Live2DCubismCore3.AlignofModel = 16;
    Live2DCubismCore3.MocVersion_Unknown = 0;
    Live2DCubismCore3.MocVersion_30 = 1;
    Live2DCubismCore3.MocVersion_33 = 2;
    Live2DCubismCore3.MocVersion_40 = 3;
    Live2DCubismCore3.MocVersion_42 = 4;
    Live2DCubismCore3.MocVersion_50 = 5;
    Live2DCubismCore3.ParameterType_Normal = 0;
    Live2DCubismCore3.ParameterType_BlendShape = 1;
    ;
    var Version = (
      /** @class */
      function() {
        function Version2() {
        }
        Version2.csmGetVersion = function() {
          return _csm.getVersion();
        };
        Version2.csmGetLatestMocVersion = function() {
          return _csm.getLatestMocVersion();
        };
        Version2.csmGetMocVersion = function(moc, mocBytes) {
          return _csm.getMocVersion(moc._ptr, mocBytes.byteLength);
        };
        return Version2;
      }()
    );
    Live2DCubismCore3.Version = Version;
    var Logging = (
      /** @class */
      function() {
        function Logging2() {
        }
        Logging2.csmSetLogFunction = function(handler) {
          Logging2.logFunction = handler;
          var pointer = _em.addFunction(Logging2.wrapLogFunction, "vi");
          _csm.setLogFunction(pointer);
        };
        Logging2.csmGetLogFunction = function() {
          return Logging2.logFunction;
        };
        Logging2.wrapLogFunction = function(messagePtr) {
          var messageStr = _em.UTF8ToString(messagePtr);
          Logging2.logFunction(messageStr);
        };
        return Logging2;
      }()
    );
    Live2DCubismCore3.Logging = Logging;
    var Moc2 = (
      /** @class */
      function() {
        function Moc3(mocBytes) {
          var memory = _csm.mallocMoc(mocBytes.byteLength);
          if (!memory) {
            return;
          }
          var destination = new Uint8Array(_em.HEAPU8.buffer, memory, mocBytes.byteLength);
          destination.set(new Uint8Array(mocBytes));
          this._ptr = _csm.reviveMocInPlace(memory, mocBytes.byteLength);
          if (!this._ptr) {
            _csm.free(memory);
          }
        }
        Moc3.prototype.hasMocConsistency = function(mocBytes) {
          var memory = _csm.mallocMoc(mocBytes.byteLength);
          if (!memory) {
            return;
          }
          var destination = new Uint8Array(_em.HEAPU8.buffer, memory, mocBytes.byteLength);
          destination.set(new Uint8Array(mocBytes));
          var hasConsistency = _csm.hasMocConsistency(memory, mocBytes.byteLength);
          _csm.free(memory);
          return hasConsistency;
        };
        Moc3.fromArrayBuffer = function(buffer) {
          if (!buffer) {
            return null;
          }
          var moc = new Moc3(buffer);
          return moc._ptr ? moc : null;
        };
        Moc3.prototype._release = function() {
          _csm.free(this._ptr);
          this._ptr = 0;
        };
        return Moc3;
      }()
    );
    Live2DCubismCore3.Moc = Moc2;
    var Model = (
      /** @class */
      function() {
        function Model2(moc) {
          this._ptr = _csm.mallocModelAndInitialize(moc._ptr);
          if (!this._ptr) {
            return;
          }
          this.parameters = new Parameters(this._ptr);
          this.parts = new Parts(this._ptr);
          this.drawables = new Drawables(this._ptr);
          this.canvasinfo = new CanvasInfo(this._ptr);
        }
        Model2.fromMoc = function(moc) {
          var model = new Model2(moc);
          return model._ptr ? model : null;
        };
        Model2.prototype.update = function() {
          _csm.updateModel(this._ptr);
        };
        Model2.prototype.release = function() {
          _csm.free(this._ptr);
          this._ptr = 0;
        };
        return Model2;
      }()
    );
    Live2DCubismCore3.Model = Model;
    var CanvasInfo = (
      /** @class */
      /* @__PURE__ */ function() {
        function CanvasInfo2(modelPtr) {
          if (!modelPtr) {
            return;
          }
          var _canvasSize_data = new Float32Array(2);
          var _canvasSize_nDataBytes = _canvasSize_data.length * _canvasSize_data.BYTES_PER_ELEMENT;
          var _canvasSize_dataPtr = _csm.malloc(_canvasSize_nDataBytes);
          var _canvasSize_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasSize_dataPtr, _canvasSize_nDataBytes);
          _canvasSize_dataHeap.set(new Uint8Array(_canvasSize_data.buffer));
          var _canvasOrigin_data = new Float32Array(2);
          var _canvasOrigin_nDataBytes = _canvasOrigin_data.length * _canvasOrigin_data.BYTES_PER_ELEMENT;
          var _canvasOrigin_dataPtr = _csm.malloc(_canvasOrigin_nDataBytes);
          var _canvasOrigin_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasOrigin_dataPtr, _canvasOrigin_nDataBytes);
          _canvasOrigin_dataHeap.set(new Uint8Array(_canvasOrigin_data.buffer));
          var _canvasPPU_data = new Float32Array(1);
          var _canvasPPU_nDataBytes = _canvasPPU_data.length * _canvasPPU_data.BYTES_PER_ELEMENT;
          var _canvasPPU_dataPtr = _csm.malloc(_canvasPPU_nDataBytes);
          var _canvasPPU_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasPPU_dataPtr, _canvasPPU_nDataBytes);
          _canvasPPU_dataHeap.set(new Uint8Array(_canvasPPU_data.buffer));
          _csm.readCanvasInfo(modelPtr, _canvasSize_dataHeap.byteOffset, _canvasOrigin_dataHeap.byteOffset, _canvasPPU_dataHeap.byteOffset);
          _canvasSize_data = new Float32Array(_canvasSize_dataHeap.buffer, _canvasSize_dataHeap.byteOffset, _canvasSize_dataHeap.length);
          _canvasOrigin_data = new Float32Array(_canvasOrigin_dataHeap.buffer, _canvasOrigin_dataHeap.byteOffset, _canvasOrigin_dataHeap.length);
          _canvasPPU_data = new Float32Array(_canvasPPU_dataHeap.buffer, _canvasPPU_dataHeap.byteOffset, _canvasPPU_dataHeap.length);
          this.CanvasWidth = _canvasSize_data[0];
          this.CanvasHeight = _canvasSize_data[1];
          this.CanvasOriginX = _canvasOrigin_data[0];
          this.CanvasOriginY = _canvasOrigin_data[1];
          this.PixelsPerUnit = _canvasPPU_data[0];
          _csm.free(_canvasSize_dataHeap.byteOffset);
          _csm.free(_canvasOrigin_dataHeap.byteOffset);
          _csm.free(_canvasPPU_dataHeap.byteOffset);
        }
        return CanvasInfo2;
      }()
    );
    Live2DCubismCore3.CanvasInfo = CanvasInfo;
    var Parameters = (
      /** @class */
      /* @__PURE__ */ function() {
        function Parameters2(modelPtr) {
          var length = 0;
          var length2 = null;
          this.count = _csm.getParameterCount(modelPtr);
          length = _csm.getParameterCount(modelPtr);
          this.ids = new Array(length);
          var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getParameterIds(modelPtr), length);
          for (var i = 0; i < _ids.length; i++) {
            this.ids[i] = _em.UTF8ToString(_ids[i]);
          }
          length = _csm.getParameterCount(modelPtr);
          this.minimumValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterMinimumValues(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.types = new Int32Array(_em.HEAP32.buffer, _csm.getParameterTypes(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.maximumValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterMaximumValues(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.defaultValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterDefaultValues(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.values = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterValues(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.keyCounts = new Int32Array(_em.HEAP32.buffer, _csm.getParameterKeyCounts(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getParameterKeyCounts(modelPtr), length);
          this.keyValues = new Array(length);
          var _keyValues = new Uint32Array(_em.HEAPU32.buffer, _csm.getParameterKeyValues(modelPtr), length);
          for (var i = 0; i < _keyValues.length; i++) {
            this.keyValues[i] = new Float32Array(_em.HEAPF32.buffer, _keyValues[i], length2[i]);
          }
        }
        return Parameters2;
      }()
    );
    Live2DCubismCore3.Parameters = Parameters;
    var Parts = (
      /** @class */
      /* @__PURE__ */ function() {
        function Parts2(modelPtr) {
          var length = 0;
          this.count = _csm.getPartCount(modelPtr);
          length = _csm.getPartCount(modelPtr);
          this.ids = new Array(length);
          var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getPartIds(modelPtr), length);
          for (var i = 0; i < _ids.length; i++) {
            this.ids[i] = _em.UTF8ToString(_ids[i]);
          }
          length = _csm.getPartCount(modelPtr);
          this.opacities = new Float32Array(_em.HEAPF32.buffer, _csm.getPartOpacities(modelPtr), length);
          length = _csm.getPartCount(modelPtr);
          this.parentIndices = new Int32Array(_em.HEAP32.buffer, _csm.getPartParentPartIndices(modelPtr), length);
        }
        return Parts2;
      }()
    );
    Live2DCubismCore3.Parts = Parts;
    var Drawables = (
      /** @class */
      function() {
        function Drawables2(modelPtr) {
          this._modelPtr = modelPtr;
          var length = 0;
          var length2 = null;
          this.count = _csm.getDrawableCount(modelPtr);
          length = _csm.getDrawableCount(modelPtr);
          this.ids = new Array(length);
          var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableIds(modelPtr), length);
          for (var i = 0; i < _ids.length; i++) {
            this.ids[i] = _em.UTF8ToString(_ids[i]);
          }
          length = _csm.getDrawableCount(modelPtr);
          this.constantFlags = new Uint8Array(_em.HEAPU8.buffer, _csm.getDrawableConstantFlags(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.dynamicFlags = new Uint8Array(_em.HEAPU8.buffer, _csm.getDrawableDynamicFlags(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.textureIndices = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableTextureIndices(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.drawOrders = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableDrawOrders(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.renderOrders = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableRenderOrders(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.opacities = new Float32Array(_em.HEAPF32.buffer, _csm.getDrawableOpacities(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.maskCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableMaskCounts(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.vertexCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.indexCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableIndexCounts(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.multiplyColors = new Float32Array(_em.HEAPF32.buffer, _csm.getDrawableMultiplyColors(modelPtr), length * 4);
          length = _csm.getDrawableCount(modelPtr);
          this.screenColors = new Float32Array(_em.HEAPF32.buffer, _csm.getDrawableScreenColors(modelPtr), length * 4);
          length = _csm.getDrawableCount(modelPtr);
          this.parentPartIndices = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableParentPartIndices(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableMaskCounts(modelPtr), length);
          this.masks = new Array(length);
          var _masks = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableMasks(modelPtr), length);
          for (var i = 0; i < _masks.length; i++) {
            this.masks[i] = new Int32Array(_em.HEAP32.buffer, _masks[i], length2[i]);
          }
          length = _csm.getDrawableCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
          this.vertexPositions = new Array(length);
          var _vertexPositions = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableVertexPositions(modelPtr), length);
          for (var i = 0; i < _vertexPositions.length; i++) {
            this.vertexPositions[i] = new Float32Array(_em.HEAPF32.buffer, _vertexPositions[i], length2[i] * 2);
          }
          length = _csm.getDrawableCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
          this.vertexUvs = new Array(length);
          var _vertexUvs = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableVertexUvs(modelPtr), length);
          for (var i = 0; i < _vertexUvs.length; i++) {
            this.vertexUvs[i] = new Float32Array(_em.HEAPF32.buffer, _vertexUvs[i], length2[i] * 2);
          }
          length = _csm.getDrawableCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableIndexCounts(modelPtr), length);
          this.indices = new Array(length);
          var _indices = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableIndices(modelPtr), length);
          for (var i = 0; i < _indices.length; i++) {
            this.indices[i] = new Uint16Array(_em.HEAPU16.buffer, _indices[i], length2[i]);
          }
        }
        Drawables2.prototype.resetDynamicFlags = function() {
          _csm.resetDrawableDynamicFlags(this._modelPtr);
        };
        return Drawables2;
      }()
    );
    Live2DCubismCore3.Drawables = Drawables;
    var Utils = (
      /** @class */
      function() {
        function Utils2() {
        }
        Utils2.hasBlendAdditiveBit = function(bitfield) {
          return (bitfield & 1 << 0) == 1 << 0;
        };
        Utils2.hasBlendMultiplicativeBit = function(bitfield) {
          return (bitfield & 1 << 1) == 1 << 1;
        };
        Utils2.hasIsDoubleSidedBit = function(bitfield) {
          return (bitfield & 1 << 2) == 1 << 2;
        };
        Utils2.hasIsInvertedMaskBit = function(bitfield) {
          return (bitfield & 1 << 3) == 1 << 3;
        };
        Utils2.hasIsVisibleBit = function(bitfield) {
          return (bitfield & 1 << 0) == 1 << 0;
        };
        Utils2.hasVisibilityDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 1) == 1 << 1;
        };
        Utils2.hasOpacityDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 2) == 1 << 2;
        };
        Utils2.hasDrawOrderDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 3) == 1 << 3;
        };
        Utils2.hasRenderOrderDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 4) == 1 << 4;
        };
        Utils2.hasVertexPositionsDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 5) == 1 << 5;
        };
        Utils2.hasBlendColorDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 6) == 1 << 6;
        };
        return Utils2;
      }()
    );
    Live2DCubismCore3.Utils = Utils;
    var Memory = (
      /** @class */
      function() {
        function Memory2() {
        }
        Memory2.initializeAmountOfMemory = function(size) {
          if (size > 16777216) {
            _csm.initializeAmountOfMemory(size);
          }
        };
        return Memory2;
      }()
    );
    Live2DCubismCore3.Memory = Memory;
    var _em_module = function() {
      var _scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0;
      return function(_em_module2) {
        _em_module2 = _em_module2 || {};
        var b, n, l2 = {};
        for (n in b = b || (void 0 !== _em_module2 ? _em_module2 : {})) b.hasOwnProperty(n) && (l2[n] = b[n]);
        var x, y, v, w, p = false, q = false, r = false, p = "object" == typeof window, q = "function" == typeof importScripts, r = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node && !p && !q, t2 = !p && !r && !q, u = "", D = (r ? (u = __dirname + "/", v = function(a, c) {
          var d = z(a);
          return d || (x = x || __require("fs"), a = (y = y || __require("path")).normalize(a), d = x.readFileSync(a)), c ? d : d.toString();
        }, w = function(a) {
          return assert((a = (a = v(a, true)).buffer ? a : new Uint8Array(a)).buffer), a;
        }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(a) {
          throw a;
        }), process.on("unhandledRejection", B), b.inspect = function() {
          return "[Emscripten Module object]";
        }) : t2 ? ("undefined" != typeof read && (v = function(a) {
          var c = z(a);
          return c ? C(c) : read(a);
        }), w = function(a) {
          var c;
          if (!(c = z(a))) {
            if ("function" == typeof readbuffer) return new Uint8Array(readbuffer(a));
            assert("object" == typeof (c = read(a, "binary")));
          }
          return c;
        }, "undefined" != typeof print && ((console = "undefined" == typeof console ? {} : console).log = print, console.warn = console.error = "undefined" != typeof printErr ? printErr : print)) : (p || q) && (q ? u = self.location.href : document.currentScript && (u = document.currentScript.src), u = 0 !== (u = _scriptDir ? _scriptDir : u).indexOf("blob:") ? u.substr(0, u.lastIndexOf("/") + 1) : "", v = function(a) {
          try {
            var c = new XMLHttpRequest();
            return c.open("GET", a, false), c.send(null), c.responseText;
          } catch (d) {
            if (a = z(a)) return C(a);
            throw d;
          }
        }, q) && (w = function(a) {
          try {
            var c = new XMLHttpRequest();
            return c.open("GET", a, false), c.responseType = "arraybuffer", c.send(null), new Uint8Array(c.response);
          } catch (d) {
            if (a = z(a)) return a;
            throw d;
          }
        }), b.print || console.log.bind(console)), E = b.printErr || console.warn.bind(console);
        for (n in l2) l2.hasOwnProperty(n) && (b[n] = l2[n]);
        function da() {
          return { exports: function(asmLibraryArg, wasmMemory, wasmTable) {
            var scratchBuffer = new ArrayBuffer(8), b2 = new Int32Array(scratchBuffer), c = new Float32Array(scratchBuffer), d = new Float64Array(scratchBuffer);
            function f(index, value) {
              b2[index] = value;
            }
            function g() {
              return d[0];
            }
            function h(value) {
              d[0] = value;
            }
            function j(value) {
              c[0] = value;
            }
            function k() {
              return c[0];
            }
            scratchBuffer = wasmMemory.buffer, U2 = new Uint8Array(scratchBuffer);
            var U2, global, buffer2, m, n2, o, p2, q2, r2, s, t3, u2, v2, w2, x2, y2, z2, A, C2, H2, I2, J2, K2, L2, M2, scratchBuffer = function(offset, s2) {
              var V2, W2;
              if ("undefined" == typeof Buffer) for (V2 = atob(s2), W2 = 0; W2 < V2.length; W2++) U2[offset + W2] = V2.charCodeAt(W2);
              else for (V2 = Buffer.from(s2, "base64"), W2 = 0; W2 < V2.length; W2++) U2[offset + W2] = V2[W2];
            };
            return scratchBuffer(1024, "QW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIGludGVycG9sYXRpb24gZm9yIGJsZW5kIHNoYXBlcy4gQ29tYmluYXRpb25Db3VudCBpcyAlZC4ACgBbQ1NNXSBbRV1XYXJwRGVmb3JtZXI6OlRyYW5zZm9ybVRhcmdldCgpIGVycm9yLiBbJWRdIHAwMT0oJS40ZiAsICUuNGYpCgBbQ1NNXSBbRV1Jbml0aWFsaXplRGVmb3JtZXJzKCk6IFVua25vd24gRGVmb3JtZXIgVHlwZS4KAFtDU01dIFtFXWNzbUhhc01vY0NvbnNpc3RlbmN5OiBUaGlzIG1vYzMgc2l6ZSBpcyBpbnZhbGlkLgoAW0NTTV0gW0VdJXM6ICVzCgBbQ1NNXSBbV11Sb3RhdGlvbkRlZm9ybWVyOiBOb3QgZm91bmQgdHJhbnNmb3JtZWQgRGlyZWN0aW9uLgoAW0NTTV0gW0VdVXBkYXRlRGVmb3JtZXJIaWVyYXJjaHkoKTogVW5rbm93biBEZWZvcm1lciBUeXBlLgoAJXMKACAgAE1PQzMAImFkZHJlc3MiIGlzIG51bGwuACUwMlggAFtDU01dIFtFXWNzbUhhc01vY0NvbnNpc3RlbmN5OiBGaWxlVHlwZSBpcyBpbnZhbGlkLgoAImFkZHJlc3MiIGFsaWdubWVudCBpcyBpbnZhbGlkLgBbQ1NNXSBbRV1jc21IYXNNb2NDb25zaXN0ZW5jeTogVGhpcyBtb2MzIHZlciBpcyBpbnZhbGlkIFt2ZXI6JWRdLgoAInNpemUiIGlzIGludmFsaWQuAFtDU01dIFtFXWNzbUhhc01vY0NvbnNpc3RlbmN5OiBUaGUgQ29yZSB1bnN1cHBvcnQgbGF0ZXIgdGhhbiBtb2MzIHZlcjpbJWRdLiBUaGlzIG1vYzMgdmVyIGlzIFslZF0uCgAibW9kZWwiIGlzIGludmFsaWQuAFtDU01dIFtFXWNzbUhhc01vY0NvbnNpc3RlbmN5OiBIZWFkZXIgc2VjdGlvbiBpcyBpbnZhbGlkLgoAIm91dFNpemVJblBpeGVscyIgaXMgbnVsbC4AW0NTTV0gW0VdY3NtSGFzTW9jQ29uc2lzdGVuY3k6IERhdGEgc2VjdGlvbiBpcyBpbnZhbGlkLgoAIm91dE9yaWdpbkluUGl4ZWxzIiBpcyBudWxsLgBbQ1NNXSBbRV1jc21SZXZpdmVNb2NJblBsYWNlIGlzIGZhaWxlZC4gQ29ycnVwdGVkICBtb2MzIGZpbGUuCgAib3V0UGl4ZWxzUGVyVW5pdCIgaXMgbnVsbC4AW0NTTV0gW0VdY3NtUmV2aXZlTW9jSW5QbGFjZSBpcyBmYWlsZWQuIFRoZSBDb3JlIHVuc3VwcG9ydCBsYXRlciB0aGFuIG1vYzMgdmVyOlslZF0uIFRoaXMgbW9jMyB2ZXIgaXMgWyVkXS4KACJtb2MiIGlzIGludmFsaWQuAFtDU01dIFtFXWNzbUdldE1vY1ZlcnNpb24gaXMgZmFpbGVkLiBDb3JydXB0ZWQgbW9jMyBmaWxlLgoAInNpemUiIGlzIGludmFsaWQATGl2ZTJEIEN1YmlzbSBTREsgQ29yZSBWZXJzaW9uICVkLiVkLiVkAGNzbUdldE1vY1ZlcnNpb24AY3NtSGFzTW9jQ29uc2lzdGVuY3kAY3NtUmV2aXZlTW9jSW5QbGFjZQBjc21SZWFkQ2FudmFzSW5mbwBjc21HZXRTaXplb2ZNb2RlbABjc21Jbml0aWFsaXplTW9kZWxJblBsYWNlAGNzbVVwZGF0ZU1vZGVsAGNzbUdldFBhcmFtZXRlckNvdW50AGNzbUdldFBhcmFtZXRlcklkcwBjc21HZXRQYXJhbWV0ZXJUeXBlcwBjc21HZXRQYXJhbWV0ZXJNaW5pbXVtVmFsdWVzAGNzbUdldFBhcmFtZXRlck1heGltdW1WYWx1ZXMAY3NtR2V0UGFyYW1ldGVyRGVmYXVsdFZhbHVlcwBjc21HZXRQYXJhbWV0ZXJWYWx1ZXMAY3NtR2V0UGFydENvdW50AGNzbUdldFBhcnRJZHMAY3NtR2V0UGFydE9wYWNpdGllcwBjc21HZXRQYXJ0UGFyZW50UGFydEluZGljZXMAY3NtR2V0RHJhd2FibGVDb3VudABjc21HZXREcmF3YWJsZUlkcwBjc21HZXREcmF3YWJsZUNvbnN0YW50RmxhZ3MAY3NtR2V0RHJhd2FibGVEeW5hbWljRmxhZ3MAY3NtR2V0RHJhd2FibGVUZXh0dXJlSW5kaWNlcwBjc21HZXREcmF3YWJsZURyYXdPcmRlcnMAY3NtR2V0RHJhd2FibGVSZW5kZXJPcmRlcnMAY3NtR2V0RHJhd2FibGVPcGFjaXRpZXMAY3NtR2V0RHJhd2FibGVNYXNrQ291bnRzAGNzbUdldERyYXdhYmxlTWFza3MAY3NtR2V0RHJhd2FibGVWZXJ0ZXhDb3VudHMAY3NtR2V0RHJhd2FibGVWZXJ0ZXhQb3NpdGlvbnMAY3NtR2V0RHJhd2FibGVWZXJ0ZXhVdnMAY3NtR2V0RHJhd2FibGVJbmRleENvdW50cwBjc21HZXREcmF3YWJsZUluZGljZXMAY3NtR2V0RHJhd2FibGVNdWx0aXBseUNvbG9ycwBjc21HZXREcmF3YWJsZVNjcmVlbkNvbG9ycwBjc21HZXREcmF3YWJsZVBhcmVudFBhcnRJbmRpY2VzAGNzbVJlc2V0RHJhd2FibGVEeW5hbWljRmxhZ3MAY3NtR2V0UGFyYW1ldGVyS2V5Q291bnRzAGNzbUdldFBhcmFtZXRlcktleVZhbHVlcw=="), scratchBuffer(3228, "Cg=="), scratchBuffer(3267, "//////8="), scratchBuffer(3336, "LSsgICAwWDB4AChudWxsKQ=="), scratchBuffer(3360, "EQAKABEREQAAAAAFAAAAAAAACQAAAAAL"), scratchBuffer(3392, "EQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERER"), scratchBuffer(3441, "Cw=="), scratchBuffer(3450, "EQAKChEREQAKAAACAAkLAAAACQALAAAL"), scratchBuffer(3499, "DA=="), scratchBuffer(3511, "DAAAAAAMAAAAAAkMAAAAAAAMAAAM"), scratchBuffer(3557, "Dg=="), scratchBuffer(3569, "DQAAAAQNAAAAAAkOAAAAAAAOAAAO"), scratchBuffer(3615, "EA=="), scratchBuffer(3627, "DwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhIS"), scratchBuffer(3682, "EgAAABISEgAAAAAAAAk="), scratchBuffer(3731, "Cw=="), scratchBuffer(3743, "CgAAAAAKAAAAAAkLAAAAAAALAAAL"), scratchBuffer(3789, "DA=="), scratchBuffer(3801, "DAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGLTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgAuAAAAAKgaAAAAAAAAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGA"), scratchBuffer(6675, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNThj7T7aD0k/Xph7P9oPyT9pN6wxaCEiM7QPFDNoIaIz2w9JP9sPSb/kyxZA5MsWwAAAAAAAAACA2w9JQNsPScAAAIA/AADAPwAAAADcz9E1AAAAAADAFT8="), scratchBuffer(6824, "BQ=="), scratchBuffer(6836, "DQ=="), scratchBuffer(6860, "DgAAAA8AAABYHAAAAAQ="), scratchBuffer(6884, "AQ=="), scratchBuffer(6899, "Cv////8="), scratchBuffer(7156, "gCA="), global = { Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array, NaN: NaN, Infinity: 1 / 0, Math }, scratchBuffer = asmLibraryArg, buffer2 = wasmMemory.buffer, m = scratchBuffer.memory, n2 = wasmTable, o = new global.Int8Array(buffer2), p2 = new global.Int16Array(buffer2), q2 = new global.Int32Array(buffer2), r2 = new global.Uint8Array(buffer2), s = new global.Uint16Array(buffer2), t3 = new global.Uint32Array(buffer2), u2 = new global.Float32Array(buffer2), v2 = new global.Float64Array(buffer2), w2 = global.Math.imul, x2 = global.Math.fround, y2 = global.Math.abs, z2 = global.Math.clz32, A = global.Math.min, global.Math.max, C2 = global.Math.floor, global.Math.ceil, global.Math.sqrt, scratchBuffer.abort, global.NaN, H2 = global.Infinity, I2 = scratchBuffer.a, J2 = scratchBuffer.b, K2 = scratchBuffer.c, L2 = 5251744, M2 = 0, n2[1] = function(a, Ln, Mn, Nn, On) {
              a |= 0, Ln |= 0, Mn |= 0, Nn |= 0, On |= 0;
              var Wn, ko, lo, oo, qo, ro, so, to, uo, vo, wo, xo, yo, zo, Ao, Bo, Co, Do, Eo, Fo, Go, Ho, Io, po, Pn = 0, Qn = x2(0), Rn = x2(0), Sn = 0, Tn = x2(0), Un = x2(0), Vn = x2(0), Xn = x2(0), Yn = x2(0), Zn = x2(0), _n = x2(0), $n = x2(0), ao = x2(0), bo = x2(0), co = x2(0), eo = x2(0), fo = x2(0), go = x2(0), ho = x2(0), io = x2(0), jo = x2(0), mo = x2(0), no = x2(0), Jo = (x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), 0);
              if (L2 = po = L2 - 32 | 0, 1 <= (0 | On)) {
                for (Wn = q2[16 + (q2[a + 308 >> 2] + (Ln << 5) | 0) >> 2], Pn = q2[a + 60 >> 2] + w2(Wn, 24) | 0, Ln = (ko = q2[Pn + 8 >> 2]) + -1 | 0, xo = (qo = q2[Pn + 4 >> 2]) + -1 | 0, yo = uo = (Wn = q2[q2[a + 152 >> 2] + (Wn << 2) >> 2]) + (ko << 3) | 0, zo = vo = Wn + ((to = w2(qo, lo = ko + 1 | 0)) << 3) | 0, Ao = wo = Wn + (ko + to << 3) | 0, Io = q2[Pn + 12 >> 2], ro = x2(0 | qo), so = x2(0 | ko), a = 0; ; ) if (Vn = u2[(Pn = (oo = a << 3) + Mn | 0) + 4 >> 2], Rn = x2(Vn * ro), Xn = u2[Pn >> 2], Qn = x2(Xn * so), Pn = Vn >= x2(1), Rn = !(Vn < x2(0) ^ 1) || Pn | Xn >= x2(1) | Xn < x2(0) ? (Jo || (ao = u2[4 + Ao >> 2], Bo = u2[Wn + 4 >> 2], Yn = x2(ao - Bo), Co = u2[4 + yo >> 2], Do = u2[4 + zo >> 2], Zn = x2(Co - Do), bo = x2(x2(Yn - Zn) * x2(0.5)), Eo = u2[wo >> 2], Fo = u2[Wn >> 2], _n = x2(Eo - Fo), Go = u2[uo >> 2], Ho = u2[vo >> 2], $n = x2(Go - Ho), co = x2(x2(_n - $n) * x2(0.5)), Zn = x2(x2(Zn + Yn) * x2(0.5)), $n = x2(x2($n + _n) * x2(0.5)), Jo = 1, Yn = x2(x2(x2(x2(x2(Bo + Co) + Do) + ao) * x2(0.25)) - x2(Yn * x2(0.5))), _n = x2(x2(x2(x2(x2(Fo + Go) + Ho) + Eo) * x2(0.25)) - x2(_n * x2(0.5)))), Vn < x2(3) ^ 1 | Xn > x2(-2) ^ 1 | (Xn < x2(3) ^ 1 | Vn > x2(-2) ^ 1) ? (u2[Nn + oo >> 2] = x2(Vn * co) + x2(x2(Xn * $n) + _n), Qn = x2(Vn * bo), x2(x2(Xn * Zn) + Yn)) : (Xn <= x2(0) ? Vn <= x2(0) ? (Un = x2(x2(Vn + x2(2)) * x2(0.5)), Tn = x2(x2(Xn + x2(2)) * x2(0.5)), Qn = x2(bo + bo), mo = x2(Yn - Qn), Rn = x2(co + co), no = x2(_n - Rn), io = x2(Yn - x2(Zn + Zn)), eo = x2(io - Qn), jo = x2(_n - x2($n + $n)), fo = x2(jo - Rn), go = u2[Wn + 4 >> 2], ho = u2[Wn >> 2]) : Pn ? (Qn = x2(bo * x2(3)), Rn = x2(Yn - x2(Zn + Zn)), io = x2(Qn + Rn), eo = x2(co * x2(3)), fo = x2(_n - x2($n + $n)), jo = x2(eo + fo), Un = x2(x2(Vn + x2(-1)) * x2(0.5)), Tn = x2(x2(Xn + x2(2)) * x2(0.5)), go = x2(Qn + Yn), ho = x2(eo + _n), eo = x2(bo + Rn), fo = x2(co + fo), mo = u2[4 + zo >> 2], no = u2[vo >> 2]) : (Qn = x2(Yn - x2(Zn + Zn)), Pn = xo, Sn = x2(y2(Rn)) < x2(2147483648) ? ~~Rn : -2147483648, Un = x2(0 | (Pn = (0 | Sn) == (0 | qo) ? Pn : Sn)), Tn = x2(Un / ro), eo = x2(x2(Tn * bo) + Qn), ao = x2(Tn * co), Tn = x2(_n - x2($n + $n)), fo = x2(ao + Tn), Vn = x2(x2(0 | (Sn = Pn + 1 | 0)) / ro), io = x2(x2(Vn * bo) + Qn), jo = x2(x2(Vn * co) + Tn), Tn = x2(x2(Xn + x2(2)) * x2(0.5)), Un = x2(Rn - Un), Pn = Wn + (w2(Pn, lo) << 3) | 0, mo = u2[Pn + 4 >> 2], no = u2[Pn >> 2], Pn = Wn + (w2(Sn, lo) << 3) | 0, go = u2[Pn + 4 >> 2], ho = u2[Pn >> 2]) : Xn >= x2(1) ? Vn <= x2(0) ? (Un = x2(x2(Vn + x2(2)) * x2(0.5)), Tn = x2(x2(Xn + x2(-1)) * x2(0.5)), Qn = x2(bo + bo), eo = x2(x2(Zn + Yn) - Qn), Rn = x2(co + co), fo = x2(x2($n + _n) - Rn), go = x2(x2(Zn * x2(3)) + Yn), mo = x2(go - Qn), ho = x2(x2($n * x2(3)) + _n), no = x2(ho - Rn), io = u2[4 + yo >> 2], jo = u2[uo >> 2]) : Pn ? (Qn = x2(bo * x2(3)), io = x2(Qn + x2(Zn + Yn)), Rn = x2(co * x2(3)), jo = x2(Rn + x2($n + _n)), ao = Qn, Qn = x2(x2(Zn * x2(3)) + Yn), go = x2(ao + Qn), ao = Rn, Rn = x2(x2($n * x2(3)) + _n), ho = x2(ao + Rn), Un = x2(x2(Vn + x2(-1)) * x2(0.5)), Tn = x2(x2(Xn + x2(-1)) * x2(0.5)), mo = x2(bo + Qn), no = x2(co + Rn), eo = u2[4 + Ao >> 2], fo = u2[wo >> 2]) : (Qn = x2(x2(Zn * x2(3)) + Yn), Pn = xo, Sn = x2(y2(Rn)) < x2(2147483648) ? ~~Rn : -2147483648, Un = x2(0 | (Pn = (0 | Sn) == (0 | qo) ? Pn : Sn)), Tn = x2(Un / ro), mo = x2(x2(Tn * bo) + Qn), ao = x2(Tn * co), Tn = x2(x2($n * x2(3)) + _n), no = x2(ao + Tn), Vn = x2(x2(0 | (Sn = Pn + 1 | 0)) / ro), go = x2(x2(Vn * bo) + Qn), ho = x2(x2(Vn * co) + Tn), Tn = x2(x2(Xn + x2(-1)) * x2(0.5)), Un = x2(Rn - Un), Pn = Wn + (w2(Pn, lo) + ko << 3) | 0, eo = u2[Pn + 4 >> 2], fo = u2[Pn >> 2], Pn = Wn + (w2(Sn, lo) + ko << 3) | 0, io = u2[Pn + 4 >> 2], jo = u2[Pn >> 2]) : Vn <= x2(0) ? (Un = x2(x2(Vn + x2(2)) * x2(0.5)), Pn = Ln, Sn = x2(y2(Rn = Qn)) < x2(2147483648) ? ~~Qn : -2147483648, Qn = x2(0 | (Pn = (0 | Sn) == (0 | ko) ? Pn : Sn)), Tn = x2(Rn - Qn), Qn = x2(Qn / so), Rn = x2(bo + bo), eo = x2(x2(x2(Qn * Zn) + Yn) - Rn), ao = x2(x2(Qn * $n) + _n), Qn = x2(co + co), fo = x2(ao - Qn), Vn = x2(x2(0 | (Sn = Pn + 1 | 0)) / so), mo = x2(x2(x2(Vn * Zn) + Yn) - Rn), no = x2(x2(x2(Vn * $n) + _n) - Qn), io = u2[(Pn = Wn + (Pn << 3) | 0) + 4 >> 2], jo = u2[Pn >> 2], go = u2[(Pn = Wn + (Sn << 3) | 0) + 4 >> 2], ho = u2[Pn >> 2]) : Pn ? (ao = Rn = x2(bo * x2(3)), Pn = Ln, Sn = x2(y2(Qn)) < x2(2147483648) ? ~~Qn : -2147483648, Tn = x2(0 | (Pn = (0 | Sn) == (0 | ko) ? Pn : Sn)), Un = x2(Tn / so), io = x2(ao + x2(x2(Un * Zn) + Yn)), Xn = x2(co * x2(3)), jo = x2(Xn + x2(x2(Un * $n) + _n)), ao = Rn, Rn = x2(x2(0 | (Sn = Pn + 1 | 0)) / so), go = x2(ao + x2(x2(Rn * Zn) + Yn)), ho = x2(Xn + x2(x2(Rn * $n) + _n)), Un = x2(x2(Vn + x2(-1)) * x2(0.5)), Tn = x2(Qn - Tn), eo = u2[(Pn = Wn + (Pn + to << 3) | 0) + 4 >> 2], fo = u2[Pn >> 2], mo = u2[(Pn = Wn + (Sn + to << 3) | 0) + 4 >> 2], no = u2[Pn >> 2]) : (v2[16 + po >> 3] = Vn, q2[po >> 2] = a, v2[8 + po >> 3] = Xn, Y3(4, 1107, po)), x2(Tn + Un) <= x2(1) ? (u2[Nn + oo >> 2] = x2(fo + x2(x2(no - fo) * Tn)) + x2(x2(jo - fo) * Un), Qn = x2(eo + x2(x2(mo - eo) * Tn)), x2(x2(io - eo) * Un)) : (Qn = x2(x2(1) - Tn), Rn = x2(x2(1) - Un), u2[Nn + oo >> 2] = x2(ho + x2(x2(jo - ho) * Qn)) + x2(x2(no - ho) * Rn), Qn = x2(go + x2(x2(io - go) * Qn)), x2(x2(mo - go) * Rn)))) : (Pn = x2(y2(ao = Rn)) < x2(2147483648) ? ~~Rn : -2147483648, Un = x2(ao - x2(0 | Pn)), Sn = x2(y2(Rn = Qn)) < x2(2147483648) ? ~~Qn : -2147483648, Tn = x2(Rn - x2(0 | Sn)), Pn = Sn + w2(Pn, lo) | 0, Io ? (Qn = x2(x2(1) - Un), Rn = x2(x2(1) - Tn), Sn = Wn + (Pn << 3) | 0, Pn = Wn + (Pn + lo << 3) | 0, u2[Nn + oo >> 2] = x2(x2(x2(Qn * x2(Rn * u2[Sn >> 2])) + x2(Qn * x2(Tn * u2[Sn + 8 >> 2]))) + x2(Un * x2(Rn * u2[Pn >> 2]))) + x2(Un * x2(Tn * u2[Pn + 8 >> 2])), Qn = x2(x2(x2(Qn * x2(Rn * u2[Sn + 4 >> 2])) + x2(Qn * x2(Tn * u2[Sn + 12 >> 2]))) + x2(Un * x2(Rn * u2[Pn + 4 >> 2]))), x2(Un * x2(Tn * u2[Pn + 12 >> 2]))) : x2(Tn + Un) <= x2(1) ? (Qn = x2(x2(x2(1) - Tn) - Un), Sn = Wn + (Pn << 3) | 0, Pn = Wn + (Pn + lo << 3) | 0, u2[Nn + oo >> 2] = x2(x2(Qn * u2[Sn >> 2]) + x2(Tn * u2[Sn + 8 >> 2])) + x2(Un * u2[Pn >> 2]), Qn = x2(x2(Qn * u2[Sn + 4 >> 2]) + x2(Tn * u2[Sn + 12 >> 2])), x2(Un * u2[Pn + 4 >> 2])) : (Qn = x2(x2(Tn + x2(-1)) + Un), Sn = Wn + (Pn + lo << 3) | 0, Rn = x2(x2(1) - Tn), Vn = x2(x2(1) - Un), Pn = Wn + (Pn << 3) | 0, u2[Nn + oo >> 2] = x2(x2(Qn * u2[Sn + 8 >> 2]) + x2(Rn * u2[Sn >> 2])) + x2(Vn * u2[Pn + 8 >> 2]), Qn = x2(x2(Qn * u2[Sn + 12 >> 2]) + x2(Rn * u2[Sn + 4 >> 2])), x2(Vn * u2[Pn + 12 >> 2]))), u2[4 + (Nn + oo | 0) >> 2] = Qn + Rn, (0 | On) == (0 | (a = a + 1 | 0))) break;
              }
              L2 = 32 + po | 0;
            }, n2[2] = function(a, mh) {
              a |= 0, mh |= 0;
              var Dh = 0, Eh = 0, Fh = 0, Gh = 0, Hh = 0, Ih = x2(0), Jh = 0, Kh = 0, Mh = (x2(0), 0), Nh = 0, Gh = q2[a + 320 >> 2], Dh = q2[a + 316 >> 2], Hh = q2[a + 308 >> 2];
              -1 == (0 | (Eh = q2[(Fh = Hh + (mh << 5) | 0) + 8 >> 2])) ? (q2[(Nh = Dh) + (Dh = mh << 2) >> 2] = q2[q2[a + 148 >> 2] + (q2[Fh + 16 >> 2] << 2) >> 2], q2[Dh + Gh >> 2] = 1065353216) : (Jh = q2[Fh + 16 >> 2], Kh = q2[q2[a + 152 >> 2] + (Jh << 2) >> 2], n2[q2[24 + (Hh + (Eh << 5) | 0) >> 2]](a, Eh, Kh, Kh, q2[16 + (q2[a + 60 >> 2] + w2(Jh, 24) | 0) >> 2]), Ih = u2[q2[a + 148 >> 2] + (q2[Fh + 16 >> 2] << 2) >> 2], Fh = q2[Fh + 8 >> 2] << 2, u2[(Eh = mh << 2) + Dh >> 2] = Ih * u2[Fh + Dh >> 2], q2[Eh + Gh >> 2] = q2[Fh + Gh >> 2]), 4 <= r2[q2[a >> 2] + 4 | 0] && (Gh = mh << 2, Dh = q2[a + 308 >> 2] + (mh << 5) | 0, Eh = q2[Dh + 16 >> 2] << 2, Fh = q2[a + 328 >> 2], mh = q2[a + 324 >> 2], -1 == (0 | (Hh = q2[Dh + 8 >> 2])) ? (Hh = q2[a + 156 >> 2], q2[(Dh = Gh << 2) + mh >> 2] = q2[Hh + (Eh <<= 2) >> 2], q2[(Jh = 4 | Dh) + mh >> 2] = q2[(Kh = 4 | Eh) + Hh >> 2], q2[(Mh = 8 | Dh) + mh >> 2] = q2[Hh + (Nh = 8 | Eh) >> 2], q2[mh + ((Gh |= 3) << 2) >> 2] = 1065353216, a = q2[a + 160 >> 2], q2[Dh + Fh >> 2] = q2[a + Eh >> 2], q2[Fh + Jh >> 2] = q2[a + Kh >> 2], q2[Fh + Mh >> 2] = q2[a + Nh >> 2]) : (Eh = (Kh = Eh << 2) + q2[a + 156 >> 2] | 0, u2[(Dh = (Jh = Gh << 2) + mh | 0) >> 2] = u2[Eh >> 2] * u2[(Hh = (Mh = Hh << 4) + mh | 0) >> 2], u2[Dh + 4 >> 2] = u2[Eh + 4 >> 2] * u2[Hh + 4 >> 2], u2[Dh + 8 >> 2] = u2[Eh + 8 >> 2] * u2[Hh + 8 >> 2], q2[mh + ((Gh |= 3) << 2) >> 2] = 1065353216, a = Kh + q2[a + 160 >> 2] | 0, Nh = u2[a >> 2], Ih = u2[(Dh = Fh + Mh | 0) >> 2], u2[(mh = Fh + Jh | 0) >> 2] = x2(Nh + Ih) - x2(Nh * Ih), Nh = u2[a + 4 >> 2], Ih = u2[Dh + 4 >> 2], u2[mh + 4 >> 2] = x2(Nh + Ih) - x2(Nh * Ih), Nh = u2[a + 8 >> 2], Ih = u2[Dh + 8 >> 2], u2[mh + 8 >> 2] = x2(Nh + Ih) - x2(Nh * Ih)), q2[Fh + (Gh << 2) >> 2] = 1065353216);
            }, n2[3] = function(a, Sm, un, xn, yn) {
              a |= 0, Sm |= 0, un |= 0, xn |= 0, yn |= 0;
              var Dn, En, Fn, Hn, In, zn = 0, zn = (x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), (Sm = q2[16 + (q2[a + 308 >> 2] + (Sm << 5) | 0) >> 2]) << 2), Bn = function(a2) {
                var El, Hl, Fl, Dl = x2(0), Gl = 0;
                L2 = Fl = L2 - 16 | 0, j(a2);
                a: if ((El = 2147483647 & (Gl = b2[0])) >>> 0 <= 1061752794) Dl = x2(1), El >>> 0 < 964689920 || (Dl = ba(+a2));
                else if (El >>> 0 <= 1081824209) Hl = +a2, Dl = 1075235812 <= El >>> 0 ? x2(-ba(((0 | Gl) < 0 ? 3.141592653589793 : -3.141592653589793) + Hl)) : aa((0 | Gl) <= -1 ? 1.5707963267948966 + Hl : 1.5707963267948966 - Hl);
                else if (El >>> 0 <= 1088565717) Dl = 1085271520 <= El >>> 0 ? ba(+a2 + ((0 | Gl) < 0 ? 6.283185307179586 : -6.283185307179586)) : aa((0 | Gl) <= -1 ? -4.71238898038469 - +a2 : +a2 - 4.71238898038469);
                else if (Dl = x2(a2 - a2), !(2139095040 <= El >>> 0)) if ((El = 3 & Da(a2, 8 + Fl | 0)) >>> 0 <= 2) {
                  b: switch (El - 1 | 0) {
                    default:
                      Dl = ba(v2[8 + Fl >> 3]);
                      break a;
                    case 0:
                      Dl = aa(-v2[8 + Fl >> 3]);
                      break a;
                    case 1:
                      break b;
                  }
                  Dl = x2(-ba(v2[8 + Fl >> 3]));
                } else Dl = aa(v2[8 + Fl >> 3]);
                return L2 = 16 + Fl | 0, a2 = Dl;
              }(An = x2(x2(x2(u2[4 + (q2[a + 168 >> 2] + w2(Sm, 12) | 0) >> 2] + u2[zn + q2[a + 284 >> 2] >> 2]) * x2(3.1415927410125732)) / x2(180))), Cn = u2[zn + q2[a + 272 >> 2] >> 2], Gn = q2[zn + q2[a + 292 >> 2] >> 2], An = function(a2) {
                var Vk, Al, Bl = 0, Cl = 0;
                L2 = Al = L2 - 16 | 0, j(a2);
                a: if ((Vk = 2147483647 & (Cl = b2[0])) >>> 0 <= 1061752794) Vk >>> 0 < 964689920 || (a2 = aa(+a2));
                else if (Vk >>> 0 <= 1081824209) Bl = +a2, a2 = Vk >>> 0 <= 1075235811 ? (0 | Cl) <= -1 ? x2(-ba(Bl + 1.5707963267948966)) : ba(Bl + -1.5707963267948966) : aa(-(((0 | Cl) < 0 ? 3.141592653589793 : -3.141592653589793) + Bl));
                else if (Vk >>> 0 <= 1088565717) Bl = +a2, a2 = Vk >>> 0 <= 1085271519 ? (0 | Cl) <= -1 ? ba(Bl + 4.71238898038469) : x2(-ba(Bl + -4.71238898038469)) : aa(((0 | Cl) < 0 ? 6.283185307179586 : -6.283185307179586) + Bl);
                else if (2139095040 <= Vk >>> 0) a2 = x2(a2 - a2);
                else if ((Vk = 3 & Da(a2, 8 + Al | 0)) >>> 0 <= 2) {
                  b: switch (Vk - 1 | 0) {
                    default:
                      a2 = aa(v2[8 + Al >> 3]);
                      break a;
                    case 0:
                      a2 = ba(v2[8 + Al >> 3]);
                      break a;
                    case 1:
                      break b;
                  }
                  a2 = aa(-v2[8 + Al >> 3]);
                } else a2 = x2(-ba(v2[8 + Al >> 3]));
                return L2 = 16 + Al | 0, a2;
              }(An);
              if ((Sm = 0) < (0 | yn)) {
                for (Bn = x2(Cn * Bn), En = x2(Gn ? -1 : 1), Hn = x2(Bn * En), Dn = q2[zn + q2[a + 288 >> 2] >> 2] ? x2(-1) : x2(1), In = x2(x2(Cn * An) * Dn), Bn = x2(Bn * Dn), Cn = x2(x2(Cn * x2(-An)) * En), An = u2[zn + q2[a + 280 >> 2] >> 2], En = u2[zn + q2[a + 276 >> 2] >> 2]; ; ) if (zn = (a = Sm << 3) + xn | 0, Dn = u2[(a = a + un | 0) >> 2], Fn = u2[a + 4 >> 2], u2[zn + 4 >> 2] = An + x2(x2(In * Dn) + x2(Hn * Fn)), u2[zn >> 2] = En + x2(x2(Bn * Dn) + x2(Cn * Fn)), (0 | yn) == (0 | (Sm = Sm + 1 | 0))) break;
              }
            }, n2[4] = function(a, mh) {
              a |= 0, mh |= 0;
              var yh, zh, Ah, Bh, Ch, nh, oh = 0, ph = 0, qh = 0, rh = x2(0), sh = 0, th = 0, uh = x2(0), vh = 0, wh = 0, xh = 0;
              if (x2(0), x2(0), x2(0), x2(0), L2 = nh = L2 + -64 | 0, vh = q2[a + 320 >> 2], wh = q2[a + 316 >> 2], ph = q2[a + 308 >> 2], -1 == (0 | (sh = q2[(qh = ph + (mh << 5) | 0) + 8 >> 2]))) oh = q2[qh + 16 >> 2] << 2, q2[(ph = mh << 2) + wh >> 2] = q2[oh + q2[a + 268 >> 2] >> 2], q2[ph + vh >> 2] = q2[oh + q2[a + 272 >> 2] >> 2];
              else {
                oh = q2[qh + 16 >> 2] << 2, xh = q2[oh + q2[a + 276 >> 2] >> 2], q2[24 + nh >> 2] = xh, oh = q2[oh + q2[a + 280 >> 2] >> 2], q2[28 + nh >> 2] = oh, q2[16 + nh >> 2] = 0, zh = 1 == q2[(th = ph + (sh << 5) | 0) + 12 >> 2] ? x2(-10) : x2(-0.10000000149011612), u2[20 + nh >> 2] = zh, q2[60 + nh >> 2] = oh, q2[56 + nh >> 2] = xh, n2[q2[th + 24 >> 2]](a, sh, 56 + nh | 0, 48 + nh | 0, 1), rh = x2(1), ph = 9;
                b: {
                  for (; ; ) {
                    if (oh = ph, uh = x2(rh * x2(0)), u2[32 + nh >> 2] = uh + u2[56 + nh >> 2], yh = x2(zh * rh), u2[36 + nh >> 2] = yh + u2[60 + nh >> 2], n2[q2[th + 24 >> 2]](a, sh, 32 + nh | 0, 40 + nh | 0, 1), Ah = x2(u2[44 + nh >> 2] - u2[52 + nh >> 2]), u2[44 + nh >> 2] = Ah, Bh = x2(u2[40 + nh >> 2] - u2[48 + nh >> 2]), u2[40 + nh >> 2] = Bh, Ah != x2(0) || Bh != x2(0)) {
                      ph = q2[44 + nh >> 2], q2[8 + nh >> 2] = q2[40 + nh >> 2], q2[12 + nh >> 2] = ph;
                      break b;
                    }
                    if (u2[32 + nh >> 2] = u2[56 + nh >> 2] - uh, u2[36 + nh >> 2] = u2[60 + nh >> 2] - yh, n2[q2[th + 24 >> 2]](a, sh, 32 + nh | 0, 40 + nh | 0, 1), uh = x2(u2[40 + nh >> 2] - u2[48 + nh >> 2]), u2[40 + nh >> 2] = uh, yh = x2(u2[44 + nh >> 2] - u2[52 + nh >> 2]), (u2[44 + nh >> 2] = yh) != x2(0) || uh != x2(0)) {
                      u2[12 + nh >> 2] = -yh, u2[8 + nh >> 2] = -uh;
                      break b;
                    }
                    if (ph = oh + -1 | 0, rh = x2(rh * x2(0.10000000149011612)), !oh) break;
                  }
                  Y3(3, 1311, 0);
                }
                rh = function(a2, ji) {
                  var ki = x2(0);
                  if ((ki = x2(Ba2(u2[a2 + 4 >> 2], u2[a2 >> 2]) - Ba2(u2[ji + 4 >> 2], u2[ji >> 2]))) < x2(-3.1415927410125732)) {
                    for (; ; ) if (!((ki = x2(ki + x2(6.2831854820251465))) < x2(-3.1415927410125732))) break;
                  }
                  if (ki > x2(3.1415927410125732)) {
                    for (; ; ) if (!((ki = x2(ki + x2(-6.2831854820251465))) > x2(3.1415927410125732))) break;
                  }
                  return ki;
                }(16 + nh | 0, 8 + nh | 0), n2[q2[th + 24 >> 2]](a, q2[qh + 8 >> 2], 24 + nh | 0, 24 + nh | 0, 1), ph = q2[qh + 16 >> 2] << 2, q2[ph + q2[a + 276 >> 2] >> 2] = q2[24 + nh >> 2], q2[ph + q2[a + 280 >> 2] >> 2] = q2[28 + nh >> 2], oh = ph + q2[a + 284 >> 2] | 0, u2[oh >> 2] = u2[oh >> 2] + x2(x2(rh * x2(-180)) / x2(3.1415927410125732)), qh = q2[qh + 8 >> 2] << 2, u2[(oh = mh << 2) + wh >> 2] = u2[ph + q2[a + 268 >> 2] >> 2] * u2[qh + wh >> 2], ph = ph + q2[a + 272 >> 2] | 0, rh = x2(u2[ph >> 2] * u2[qh + vh >> 2]), u2[oh + vh >> 2] = rh, u2[ph >> 2] = rh;
              }
              4 <= r2[q2[a >> 2] + 4 | 0] && (oh = mh << 2, qh = q2[a + 308 >> 2] + (mh << 5) | 0, sh = q2[qh + 16 >> 2] << 2, ph = q2[a + 328 >> 2], mh = q2[a + 324 >> 2], -1 == (0 | (th = q2[qh + 8 >> 2])) ? (th = q2[a + 296 >> 2], q2[(qh = oh << 2) + mh >> 2] = q2[th + (sh <<= 2) >> 2], q2[(vh = 4 | qh) + mh >> 2] = q2[(wh = 4 | sh) + th >> 2], q2[(xh = 8 | qh) + mh >> 2] = q2[th + (Ch = 8 | sh) >> 2], q2[mh + ((oh |= 3) << 2) >> 2] = 1065353216, a = q2[a + 300 >> 2], q2[ph + qh >> 2] = q2[a + sh >> 2], q2[ph + vh >> 2] = q2[a + wh >> 2], q2[ph + xh >> 2] = q2[a + Ch >> 2]) : (sh = (wh = sh << 2) + q2[a + 296 >> 2] | 0, u2[(qh = (vh = oh << 2) + mh | 0) >> 2] = u2[sh >> 2] * u2[(th = (xh = th << 4) + mh | 0) >> 2], u2[qh + 4 >> 2] = u2[sh + 4 >> 2] * u2[th + 4 >> 2], u2[qh + 8 >> 2] = u2[sh + 8 >> 2] * u2[th + 8 >> 2], q2[mh + ((oh |= 3) << 2) >> 2] = 1065353216, a = wh + q2[a + 300 >> 2] | 0, rh = u2[a >> 2], uh = u2[(qh = ph + xh | 0) >> 2], u2[(mh = ph + vh | 0) >> 2] = x2(rh + uh) - x2(rh * uh), rh = u2[a + 4 >> 2], uh = u2[qh + 4 >> 2], u2[mh + 4 >> 2] = x2(rh + uh) - x2(rh * uh), rh = u2[a + 8 >> 2], uh = u2[qh + 8 >> 2], u2[mh + 8 >> 2] = x2(rh + uh) - x2(rh * uh)), q2[ph + (oh << 2) >> 2] = 1065353216), L2 = nh + 64 | 0;
            }, n2[5] = function(a, Vk) {
              return a |= 0, Vk |= 0, x2(0), x2(0), 0 | ((a = u2[a >> 2]) < (Vk = u2[Vk >> 2]) ? -1 : Vk < a);
            }, n2[6] = function(a, vj, xj, yj) {
              a |= 0, vj |= 0, xj |= 0, yj |= 0;
              var Vj = 0, Wj = 0, Xj = x2(0), Yj = 0, Zj = 0, _j = 0, $j = 0, ak = 0;
              if (1 <= (0 | (Yj = q2[a + 8 >> 2]))) {
                for (_j = q2[a + 12 >> 2], Zj = q2[a + 20 >> 2]; ; ) if (u2[(Wj = Vj << 2) + _j >> 2] = u2[vj + Wj >> 2] * u2[Wj + Zj >> 2], !((0 | (Vj = Vj + 1 | 0)) < (0 | Yj))) break;
              }
              if (!((0 | (Yj = q2[a >> 2])) < 1)) if (_j = q2[a + 4 >> 2], yj) for (Wj = vj = 0; ; ) {
                if (q2[yj >> 2]) {
                  if ((0 | (Vj = q2[(Zj = vj << 2) + q2[a + 16 >> 2] >> 2])) < 1) Xj = x2(0);
                  else for ($j = Vj + Wj | 0, ak = q2[a + 12 >> 2], Xj = x2(0), Vj = Wj; ; ) if (Xj = x2(Xj + u2[ak + (Vj << 2) >> 2]), !((0 | (Vj = Vj + 1 | 0)) < (0 | $j))) break;
                  u2[xj + Zj >> 2] = Xj;
                }
                if (yj = yj + 4 | 0, Wj = q2[_j + (vj << 2) >> 2] + Wj | 0, !((0 | (vj = vj + 1 | 0)) < (0 | Yj))) break;
              }
              else for (Zj = q2[a + 16 >> 2], vj = yj = 0; ; ) {
                if ((0 | (Vj = q2[(Wj = yj << 2) + Zj >> 2])) <= 0) Xj = x2(0);
                else for ($j = vj + Vj | 0, ak = q2[a + 12 >> 2], Xj = x2(0), Vj = vj; ; ) if (Xj = x2(Xj + u2[ak + (Vj << 2) >> 2]), !((0 | (Vj = Vj + 1 | 0)) < (0 | $j))) break;
                if (u2[xj + Wj >> 2] = Xj, vj = q2[Wj + _j >> 2] + vj | 0, !((0 | (yj = yj + 1 | 0)) < (0 | Yj))) break;
              }
            }, n2[7] = function(a, vj, xj, yj) {
              a |= 0, vj |= 0, xj |= 0, yj |= 0;
              var zj = 0, Aj = x2(0), Qj = 0, Rj = 0, Sj = 0, Tj = 0, Uj = 0;
              if (1 <= (0 | (Tj = q2[a + 8 >> 2]))) {
                for (Rj = q2[a + 12 >> 2], Sj = q2[a + 20 >> 2]; ; ) if (u2[(Qj = zj << 2) + Rj >> 2] = u2[vj + Qj >> 2] * u2[Qj + Sj >> 2], !((0 | (zj = zj + 1 | 0)) < (0 | Tj))) break;
              }
              if (!((0 | (zj = q2[a >> 2])) < 1)) if (Tj = q2[a + 4 >> 2], yj) for (Qj = vj = 0; ; ) {
                if (q2[yj >> 2]) {
                  if ((0 | (zj = q2[(Rj = vj << 2) + q2[a + 16 >> 2] >> 2])) < 1) Aj = x2(0);
                  else for (Sj = zj + Qj | 0, Uj = q2[a + 12 >> 2], Aj = x2(0), zj = Qj; ; ) if (Aj = x2(Aj + u2[Uj + (zj << 2) >> 2]), !((0 | (zj = zj + 1 | 0)) < (0 | Sj))) break;
                  zj = xj + Rj | 0, Aj = x2(Aj + x2(0.0010000000474974513)), Rj = x2(y2(Aj)) < x2(2147483648) ? ~~Aj : -2147483648, q2[zj >> 2] = Rj, zj = q2[a >> 2];
                }
                if (yj = yj + 4 | 0, Qj = q2[Tj + (vj << 2) >> 2] + Qj | 0, !((0 | (vj = vj + 1 | 0)) < (0 | zj))) break;
              }
              else for (Rj = q2[a + 16 >> 2], vj = yj = 0; ; ) {
                if ((0 | (zj = q2[(Qj = yj << 2) + Rj >> 2])) <= 0) Aj = x2(0);
                else for (Sj = vj + zj | 0, Uj = q2[a + 12 >> 2], Aj = x2(0), zj = vj; ; ) if (Aj = x2(Aj + u2[Uj + (zj << 2) >> 2]), !((0 | (zj = zj + 1 | 0)) < (0 | Sj))) break;
                if (zj = xj + Qj | 0, Aj = x2(Aj + x2(0.0010000000474974513)), Sj = x2(y2(Aj)) < x2(2147483648) ? ~~Aj : -2147483648, q2[zj >> 2] = Sj, vj = q2[Qj + Tj >> 2] + vj | 0, !((0 | (yj = yj + 1 | 0)) < q2[a >> 2])) break;
              }
            }, n2[8] = function(a, vj, xj, yj, zj, Aj) {
              a |= 0, vj |= 0, xj |= 0, yj |= 0, zj |= 0, Aj |= 0;
              var Oj, Pj, Bj = 0, Cj = 0, Dj = 0, Ej = 0, Fj = 0, Gj = 0, Hj = 0, Ij = 0, Kj = 0, Lj = 0, Mj = x2(0), Nj = 0, Jj = q2[a >> 2];
              if (!((0 | Jj) < 1)) if (Oj = zj << 2, Pj = q2[a + 4 >> 2], Aj) for (; ; ) {
                if (q2[Aj >> 2] && (Dj = q2[(Bj = Ej << 2) + q2[a + 16 >> 2] >> 2], Hj = q2[xj + Bj >> 2], Cj = q2[yj + Bj >> 2], (Bj = (0 | (Ij = w2(Cj, zj))) < 1) || ca2(Hj, 0, w2(Cj, Oj)), !(Bj | (0 | Dj) < 1))) for (Kj = Dj + Gj | 0, Lj = q2[a + 20 >> 2], Bj = Gj; ; ) {
                  for (Mj = u2[(Cj = Bj << 2) + Lj >> 2], Nj = q2[vj + Cj >> 2], Fj = 0; ; ) if (u2[(Cj = (Dj = Fj << 2) + Hj | 0) >> 2] = u2[Cj >> 2] + x2(Mj * u2[Dj + Nj >> 2]), (0 | Ij) == (0 | (Fj = Fj + 1 | 0))) break;
                  if (!((0 | (Bj = Bj + 1 | 0)) < (0 | Kj))) break;
                }
                if (Aj = Aj + 4 | 0, Gj = q2[(Ej << 2) + Pj >> 2] + Gj | 0, !((0 | (Ej = Ej + 1 | 0)) < (0 | Jj))) break;
              }
              else for (Aj = 0; ; ) {
                if (Dj = q2[(Ej = Aj << 2) + q2[a + 16 >> 2] >> 2], Hj = q2[xj + Ej >> 2], Cj = q2[yj + Ej >> 2], (Bj = (0 | (Ij = w2(Cj, zj))) < 1) || ca2(Hj, 0, w2(Cj, Oj)), !(Bj | (0 | Dj) <= 0)) for (Kj = Dj + Gj | 0, Lj = q2[a + 20 >> 2], Bj = Gj; ; ) {
                  for (Mj = u2[(Cj = Bj << 2) + Lj >> 2], Nj = q2[vj + Cj >> 2], Fj = 0; ; ) if (u2[(Cj = (Dj = Fj << 2) + Hj | 0) >> 2] = u2[Cj >> 2] + x2(Mj * u2[Dj + Nj >> 2]), (0 | Ij) == (0 | (Fj = Fj + 1 | 0))) break;
                  if (!((0 | (Bj = Bj + 1 | 0)) < (0 | Kj))) break;
                }
                if (Gj = q2[Ej + Pj >> 2] + Gj | 0, !((0 | (Aj = Aj + 1 | 0)) < (0 | Jj))) break;
              }
            }, n2[9] = function(a) {
              a |= 0;
              var Me, Ne, Oe, Ie = 0, Je = 0, Ke = 0, Le = 0;
              if (!(q2[a + 648 >> 2] || (0 | (Ie = q2[a + 332 >> 2])) < 1)) for (Ne = (Je = q2[a + 336 >> 2]) + w2(Ie, 20) | 0, Ie = q2[a + 424 >> 2], Le = q2[a + 444 >> 2]; ; ) {
                if (q2[Ie >> 2] && !((0 | (Ke = q2[Je + 16 >> 2])) < (a = 1))) {
                  for (Ke <<= 1, Oe = q2[Le >> 2]; ; ) if (u2[(Me = (a << 2) + Oe | 0) >> 2] = -u2[Me >> 2], !((0 | (a = a + 2 | 0)) < (0 | Ke))) break;
                }
                if (Le = Le + 4 | 0, Ie = Ie + 4 | 0, !((Je = Je + 20 | 0) >>> 0 < Ne >>> 0)) break;
              }
            }, n2[10] = function(a, Sm, un) {
              var wn;
              return $(wn = q2[(a |= 0) + 20 >> 2], Sm |= 0, Sm = (un |= 0) >>> 0 < (Sm = q2[a + 16 >> 2] - wn | 0) >>> 0 ? un : Sm), q2[a + 20 >> 2] = Sm + q2[a + 20 >> 2], 0 | un;
            }, n2[11] = function(a, Il, Rm, Sm, Tm, Um) {
              a |= 0, Il = +Il, Rm |= 0, Sm |= 0, Tm |= 0, Um |= 0;
              var fn, qn, Zm, Vm = 0, Wm = 0, Xm = 0, Ym = 0, _m = 0, $m = 0, an = 0, bn = 0, cn = 0, dn = 0, en = 0, gn = 0, hn = 0, jn = 0, kn = 0, mn = 0;
              if (q2[44 + (L2 = Zm = L2 - 560 | 0) >> 2] = 0, h(+Il), Vm = 0 | b2[1], qn = 4294967295 < b2[0] >>> 0 ? 0 : 1, kn = (0 | Vm) < -1 || ((0 | Vm) <= -1 ? qn : 0) ? (h(+(Il = -Il)), Vm = 0 | b2[1], b2[0], jn = 1, 3840) : 2048 & Tm ? (jn = 1, 3843) : (jn = 1 & Tm) ? 3846 : 3841, 2146435072 == (2146435072 & Vm)) _(a, 32, Rm, $m = jn + 3 | 0, -65537 & Tm), Z2(a, kn, jn), Sm = Um >>> 5 & 1, Z2(a, Il != Il ? Sm ? 3867 : 3871 : Sm ? 3859 : 3863, 3);
              else if (Il = function Ja(a2, ic) {
                var kc, lc, jc = 0;
                if (h(+a2), jc = 0 | b2[1], kc = 0 | b2[0], 2047 != (0 | (jc = (lc = jc) >>> 20 & 2047))) {
                  if (!jc) return jc = ic, ic = 0 == a2 ? 0 : (a2 = Ja(18446744073709552e3 * a2, ic), q2[ic >> 2] + -64 | 0), q2[jc >> 2] = ic, a2;
                  q2[ic >> 2] = jc + -1022, f(0, 0 | kc), f(1, -2146435073 & lc | 1071644672), a2 = +g();
                }
                return a2;
              }(Il, 44 + Zm | 0), 0 != (Il += Il) && (q2[44 + Zm >> 2] = q2[44 + Zm >> 2] + -1), fn = 16 + Zm | 0, 97 == (0 | (qn = 32 | Um))) {
                if (en = (dn = 32 & Um) ? kn + 9 | 0 : kn, !(11 < Sm >>> 0) && (Vm = 12 - Sm | 0)) {
                  for (gn = 8; ; ) if (gn *= 16, !(Vm = Vm + -1 | 0)) break;
                  Il = 45 == r2[0 | en] ? -(gn + (-Il - gn)) : Il + gn - gn;
                }
                for ((0 | fn) == (0 | (Vm = ga((Xm = (Vm = q2[44 + Zm >> 2]) >> 31) ^ Vm + Xm, 0, fn))) && (o[15 + Zm | 0] = 48, Vm = 15 + Zm | 0), _m = 2 | jn, Xm = q2[44 + Zm >> 2], o[0 | (cn = Vm + -2 | 0)] = Um + 15, o[Vm + -1 | 0] = (0 | Xm) < 0 ? 45 : 43, Vm = 8 & Tm, Wm = 16 + Zm | 0; ; ) if (Um = Wm, bn = dn, Xm = y2(Il) < 2147483648 ? ~~Il : -2147483648, o[0 | Wm] = bn | r2[Xm + 3824 | 0], 1 != ((Wm = Um + 1 | 0) - (16 + Zm | 0) | 0) | (0 == (Il = 16 * (Il - (0 | Xm))) ? !(Vm | 0 < (0 | Sm)) : 0) || (o[Um + 1 | 0] = 46, Wm = Um + 2 | 0), 0 == Il) break;
                _(a, 32, Rm, $m = (Um = !Sm | (0 | Sm) <= ((Wm - Zm | 0) - 18 | 0) ? ((fn - (16 + Zm | 0) | 0) - cn | 0) + Wm | 0 : 2 + ((Sm + fn | 0) - cn | 0) | 0) + _m | 0, Tm), Z2(a, en, _m), _(a, 48, Rm, $m, 65536 ^ Tm), Z2(a, 16 + Zm | 0, Sm = Wm - (16 + Zm | 0) | 0), _(a, 48, Um - ((Vm = Sm) + (Sm = fn - cn | 0) | 0) | 0, 0, 0), Z2(a, cn, Sm);
              } else {
                for (Vm = (0 | Sm) < 0, 0 == Il ? Ym = q2[44 + Zm >> 2] : (Ym = q2[44 + Zm >> 2] + -28 | 0, q2[44 + Zm >> 2] = Ym, Il *= 268435456), an = Vm ? 6 : Sm, Xm = dn = (0 | Ym) < 0 ? 48 + Zm | 0 : 336 + Zm | 0; ; ) if (Xm = (Sm = Xm) + 4 | 0, 0 == (Il = 1e9 * (Il - ((q2[Sm >> 2] = Vm = Il < 4294967296 & 0 <= Il ? ~~Il >>> 0 : 0) >>> 0)))) break;
                if ((0 | Ym) < 1) Vm = Xm, Wm = dn;
                else for (Wm = dn; ; ) {
                  if (cn = (0 | Ym) < 29 ? Ym : 29, !((Vm = Xm + -4 | 0) >>> 0 < Wm >>> 0)) {
                    for (Sm = cn, bn = 0; ; ) if (mn = bn, bn = q2[(en = Vm) >> 2], _m = 31 & Sm, _m = 32 <= (63 & Sm) >>> ($m = 0) ? (Ym = bn << _m, 0) : (Ym = (1 << _m) - 1 & bn >>> 32 - _m, bn << _m), $m = Ym + $m | 0, $m = (bn = mn + _m | 0) >>> 0 < _m >>> 0 ? $m + 1 | 0 : $m, mn = en, en = ad(bn = bd(_m = bn, $m, 1e9), M2, 1e9), q2[mn >> 2] = _m - en, !(Wm >>> 0 <= (Vm = Vm + -4 | 0) >>> 0)) break;
                    (Sm = bn) && (q2[(Wm = Wm + -4 | 0) >> 2] = Sm);
                  }
                  for (; ; ) if (!(Wm >>> 0 < (Vm = Xm) >>> 0) || q2[(Xm = Vm + -4 | 0) >> 2]) break;
                  if (Ym = q2[44 + Zm >> 2] - cn | 0, Xm = Vm, !(0 < (0 | (q2[44 + Zm >> 2] = Ym)))) break;
                }
                if ((0 | Ym) <= -1) for (hn = 1 + ((an + 25 | 0) / 9 | 0) | 0, cn = 102 == (0 | qn); ; ) {
                  if (bn = (0 | Ym) < -9 ? 9 : 0 - Ym | 0, Vm >>> 0 <= Wm >>> 0) Wm = q2[Wm >> 2] ? Wm : Wm + 4 | 0;
                  else {
                    for (en = 1e9 >>> bn, _m = -1 << bn ^ -1, Ym = 0, Xm = Wm; ; ) if (Sm = q2[Xm >> 2], q2[Xm >> 2] = (Sm >>> bn) + Ym, Ym = w2(en, Sm & _m), !((Xm = Xm + 4 | 0) >>> 0 < Vm >>> 0)) break;
                    Wm = q2[Wm >> 2] ? Wm : Wm + 4 | 0, Ym && (q2[Vm >> 2] = Ym, Vm = Vm + 4 | 0);
                  }
                  if (Ym = bn + q2[44 + Zm >> 2] | 0, Vm = (0 | hn) < Vm - (Sm = cn ? dn : Wm) >> 2 ? Sm + (hn << 2) | 0 : Vm, !((0 | (q2[44 + Zm >> 2] = Ym)) < 0)) break;
                }
                if (!(Vm >>> (Xm = 0) <= Wm >>> 0 || (Xm = w2(dn - Wm >> 2, 9), (Sm = q2[Wm >> 2]) >>> 0 < (Ym = 10)))) {
                  for (; ; ) if (Xm = Xm + 1 | 0, !((Ym = w2(Ym, 10)) >>> 0 <= Sm >>> 0)) break;
                }
                if ((0 | (Sm = (an - (102 == (0 | qn) ? 0 : Xm) | 0) - (103 == (0 | qn) & 0 != (0 | an)) | 0)) < (w2(Vm - dn >> 2, 9) + -9 | 0)) {
                  if ($m = (dn + ((Sm = (0 | (_m = Sm + 9216 | 0)) / 9 | 0) << 2) | 0) - 4092 | 0, Ym = 10, (0 | (Sm = 1 + (_m - w2(Sm, 9) | 0) | 0)) <= 8) {
                    for (; ; ) if (Ym = w2(Ym, 10), 9 == (0 | (Sm = Sm + 1 | 0))) break;
                  }
                  if (hn = $m + 4 | 0, ((cn = (en = q2[$m >> 2]) - w2(Ym, _m = (en >>> 0) / (Ym >>> 0) | 0) | 0) || (0 | hn) != (0 | Vm)) && (gn = cn >>> 0 < (Sm = Ym >>> 1) >>> 0 ? 0.5 : (0 | Vm) == (0 | hn) && (0 | Sm) == (0 | cn) ? 1 : 1.5, Il = 1 & _m ? 9007199254740994 : 9007199254740992, !jn | 45 != r2[0 | kn] || (gn = -gn, Il = -Il), q2[$m >> 2] = Sm = en - cn | 0, Il + gn != Il)) {
                    if (1e9 <= (q2[$m >> 2] = Sm = Sm + Ym | 0) >>> 0) {
                      for (; ; ) if (($m = $m + -4 | (q2[$m >> 2] = 0)) >>> 0 < Wm >>> 0 && (q2[(Wm = Wm + -4 | 0) >> 2] = 0), Sm = q2[$m >> 2] + 1 | 0, !(999999999 < (q2[$m >> 2] = Sm) >>> 0)) break;
                    }
                    if (Xm = w2(dn - Wm >> 2, 9), !((Sm = q2[Wm >> 2]) >>> 0 < (Ym = 10))) {
                      for (; ; ) if (Xm = Xm + 1 | 0, !((Ym = w2(Ym, 10)) >>> 0 <= Sm >>> 0)) break;
                    }
                  }
                  Vm = (Sm = $m + 4 | 0) >>> 0 < Vm >>> 0 ? Sm : Vm;
                }
                j: {
                  for (; ; ) {
                    if ((cn = Vm) >>> (en = 0) <= Wm >>> 0) break j;
                    if (q2[(Vm = cn + -4 | 0) >> 2]) break;
                  }
                  en = 1;
                }
                if (103 != (0 | qn)) _m = 8 & Tm;
                else if (an = ((Sm = (0 | Xm) < (0 | (Vm = an || 1)) & -5 < (0 | Xm)) ? -1 ^ Xm : -1) + Vm | 0, Um = (Sm ? -1 : -2) + Um | 0, !(_m = 8 & Tm)) {
                  if (Vm = 9, en && (_m = q2[cn + -4 >> 2]) && !((_m >>> (Vm = 0)) % (Sm = 10))) {
                    for (; ; ) if (Vm = Vm + 1 | 0, (_m >>> 0) % ((Sm = w2(Sm, 10)) >>> 0)) break;
                  }
                  Sm = w2(cn - dn >> 2, 9) + -9 | 0, an = 102 == (32 | Um) ? ((_m = 0) | an) < (0 | (Sm = 0 < (0 | (Sm = Sm - Vm | 0)) ? Sm : 0)) ? an : Sm : ((_m = 0) | an) < (0 | (Sm = 0 < (0 | (Sm = (Sm + Xm | 0) - Vm | 0)) ? Sm : 0)) ? an : Sm;
                }
                if ($m = 0 != (0 | (Ym = an | _m)), Sm = a, mn = Rm, Vm = 0 < (0 | Xm) ? Xm : 0, 102 != (0 | (bn = 32 | Um))) {
                  if ((fn - (Vm = ga((Vm = Xm >> 31) + Xm ^ Vm, 0, fn)) | 0) <= 1) {
                    for (; ; ) if (o[0 | (Vm = Vm + -1 | 0)] = 48, !((fn - Vm | 0) < 2)) break;
                  }
                  o[0 | (hn = Vm + -2 | 0)] = Um, o[Vm + -1 | 0] = (0 | Xm) < 0 ? 45 : 43, Vm = fn - hn | 0;
                }
                if (_(Sm, 32, mn, $m = 1 + (Vm + ($m + (an + jn | 0) | 0) | 0) | 0, Tm), Z2(a, kn, jn), _(a, 48, Rm, $m, 65536 ^ Tm), 102 == (0 | bn)) {
                  for (Sm = 16 + Zm | 8, Xm = 16 + Zm | 9, Wm = Um = dn >>> 0 < Wm >>> 0 ? dn : Wm; ; ) {
                    if (Vm = ga(q2[Wm >> 2], 0, Xm), (0 | Um) != (0 | Wm)) {
                      if (!(Vm >>> 0 <= 16 + Zm >>> 0)) {
                        for (; ; ) if (o[0 | (Vm = Vm + -1 | 0)] = 48, !(16 + Zm >>> 0 < Vm >>> 0)) break;
                      }
                    } else (0 | Vm) == (0 | Xm) && (o[24 + Zm | 0] = 48, Vm = Sm);
                    if (Z2(a, Vm, Xm - Vm | 0), !((Wm = Wm + 4 | 0) >>> 0 <= dn >>> 0)) break;
                  }
                  Ym && Z2(a, 3875, 1);
                  p: if (!((0 | an) < 1 | cn >>> 0 <= Wm >>> 0)) for (; ; ) {
                    if (16 + Zm >>> 0 < (Vm = ga(q2[Wm >> 2], 0, Xm)) >>> 0) {
                      for (; ; ) if (o[0 | (Vm = Vm + -1 | 0)] = 48, !(16 + Zm >>> 0 < Vm >>> 0)) break;
                    }
                    if (Z2(a, Vm, (0 | an) < 9 ? an : 9), an = an + -9 | 0, cn >>> 0 <= (Wm = Wm + 4 | 0) >>> 0) break p;
                    if (!(0 < (0 | an))) break;
                  }
                  _(a, 48, an + 9 | 0, 9, 0);
                } else {
                  q: if (!((0 | an) < 0)) for (Um = en ? cn : Wm + 4 | 0, Sm = 16 + Zm | 8, dn = 16 + Zm | 9, Xm = Wm; ; ) {
                    if ((0 | dn) == (0 | (Vm = ga(q2[Xm >> 2], 0, dn))) && (o[24 + Zm | 0] = 48, Vm = Sm), (0 | Wm) != (0 | Xm)) {
                      if (!(Vm >>> 0 <= 16 + Zm >>> 0)) {
                        for (; ; ) if (o[0 | (Vm = Vm + -1 | 0)] = 48, !(16 + Zm >>> 0 < Vm >>> 0)) break;
                      }
                    } else Z2(a, Vm, 1), Vm = Vm + 1 | 0, (0 | an) < 1 && !_m || Z2(a, 3875, 1);
                    if (Z2(a, bn = Vm, (0 | (Vm = dn - Vm | 0)) < (0 | an) ? Vm : an), an = an - Vm | 0, Um >>> 0 <= (Xm = Xm + 4 | 0) >>> 0) break q;
                    if (!(-1 < (0 | an))) break;
                  }
                  _(a, 48, an + 18 | 0, 18, 0), Z2(a, hn, fn - hn | 0);
                }
              }
              return _(a, 32, Rm, $m, 8192 ^ Tm), L2 = 560 + Zm | 0, 0 | ((0 | $m) < (0 | Rm) ? Rm : $m);
            }, n2[12] = function(a, Il) {
              a |= 0;
              var tm = 0, tm = Il |= 0;
              Il = q2[Il >> 2] + 15 & -16, q2[tm >> 2] = Il + 16, tm = a, a = Cc(q2[Il >> 2], q2[Il + 4 >> 2], q2[Il + 8 >> 2], q2[Il + 12 >> 2]), v2[tm >> 3] = a;
            }, n2[13] = function(a) {
              return 0;
            }, n2[14] = function(a, Il, tm) {
              Il |= 0, tm |= 0;
              var Om, Cm, Bm = 0, Lm = 0, Mm = 0, Nm = 0;
              for (L2 = Cm = L2 - 32 | 0, Bm = q2[(a |= 0) + 28 >> 2], q2[16 + Cm >> 2] = Bm, Mm = q2[a + 20 >> 2], q2[28 + Cm >> 2] = tm, q2[24 + Cm >> 2] = Il, Mm = (q2[20 + Cm >> 2] = Il = Mm - Bm | 0) + tm | 0, Nm = 2, Il = 16 + Cm | 0; ; ) {
                a: {
                  if ((Lm = (Bm = 0) | K2(q2[a + 60 >> 2], 0 | Il, 0 | Nm, 12 + Cm | 0)) && (q2[2086] = Lm, Bm = -1), (0 | (Bm = Bm ? q2[12 + Cm >> 2] = -1 : q2[12 + Cm >> 2])) == (0 | Mm)) Il = q2[a + 44 >> 2], q2[a + 28 >> 2] = Il, q2[a + 20 >> 2] = Il, q2[a + 16 >> 2] = Il + q2[a + 48 >> 2], a = tm;
                  else {
                    if (-1 < (0 | Bm)) break a;
                    q2[a + 28 >> 2] = 0, q2[a + 16 >> 2] = 0, q2[a + 20 >> 2] = 0, q2[a >> 2] = 32 | q2[a >> 2], 2 != ((a = 0) | Nm) && (a = tm - q2[Il + 4 >> 2] | 0);
                  }
                  return L2 = 32 + Cm | 0, 0 | a;
                }
                Lm = q2[Il + 4 >> 2], q2[(Il = (Om = Lm >>> 0 < Bm >>> 0) ? Il + 8 | 0 : Il) >> 2] = (Lm = Bm - (Om ? Lm : 0) | 0) + q2[Il >> 2], q2[Il + 4 >> 2] = q2[Il + 4 >> 2] - Lm, Mm = Mm - Bm | 0, Nm = Nm - Om | 0;
              }
            }, n2[15] = function(a, Il, tm, Bm) {
              return M2 = 0;
            }, { d: function() {
            }, e: function() {
              return 83886080;
            }, f: function() {
              return 5;
            }, g: function(a, vj) {
              return vj |= 0, L2 = vj = L2 - 16 | 0, a = (a |= 0) ? sa(a) ? (Y3(4, 2150, 0), 0) : r2[a + 4 | 0] : (q2[vj + 4 >> 2] = 1444, q2[vj >> 2] = 2267, Y3(4, 1294, vj), 0), L2 = vj + 16 | 0, 0 | a;
            }, h: function(a, vj) {
              var wj;
              return vj |= 0, L2 = wj = L2 - 48 | 0, a = (a |= 0) ? (a + 63 & -64) != (0 | a) ? (q2[36 + wj >> 2] = 1522, q2[32 + wj >> 2] = 2284, Y3(4, 1294, 32 + wj | 0), 0) : (vj + 63 & -64) == (0 | vj) && vj ? function(a2, Vk) {
                var Wk = 0, Xk = 0, Yk = 0, Zk = 0, _k = 0, $k = 0, al = 0, bl = 0, cl = 0, dl = 0, el = 0, fl = 0, gl = 0, hl = 0, il = 0, jl = 0, kl = 0, ll = 0, ml = 0, nl = 0, ol = 0, pl = 0;
                L2 = _k = (pl = Xk = L2) - 704 & -64;
                a: if (Vk >>> 0 <= 1343) Y3(4, 1235, 0);
                else if (sa(a2)) Y3(4, 1469, 0);
                else if (Xk = r2[0 | (nl = a2 + 4 | 0)]) {
                  if (!(6 <= Xk >>> 0)) {
                    (jl = 1 == (0 | !r2[a2 + 5 | 0])) || (da2(nl, 1), X3(a2 - -64 | 0, 4, 160)), ca2(_k - -64 | 0, 0, 640), na2(a2, _k - -64 | 0), Xk = a2 + Vk | 0, Vk = q2[_k + 64 >> 2];
                    b: {
                      c: {
                        d: {
                          if (5 <= (il = r2[a2 + 4 | 0]) >>> 0) {
                            if (Vk >>> 0 < a2 >>> 0 | Xk >>> 0 < Vk >>> 0) break c;
                            if ((Zk = Vk + 256 | 0) >>> 0 < a2 >>> 0) break c;
                            if (Zk >>> 0 <= Xk >>> 0) break d;
                            break c;
                          }
                          if (Vk >>> 0 < a2 >>> 0 | Xk >>> 0 < Vk >>> 0) break c;
                          if ((Zk = Vk + 128 | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0) break c;
                        }
                        if (!((Yk = q2[_k + 68 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Zk >>> 0) && !((Yk = Yk - -64 | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (dl = q2[Vk >> 2])) < 0 || (Zk = q2[_k + 72 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = (Wk = Zk) + (Zk = dl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (al = q2[_k + 76 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < al >>> 0 | al >>> 0 < Yk >>> 0 || (Wk = (dl << 6) + al | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 80 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 84 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 88 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 92 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 96 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 100 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 4 >> 2])) < 0 || (Zk = q2[_k + 104 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || ($k = (Yk = Zk) + (Zk = Wk << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Yk = q2[_k + 108 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < $k >>> 0 || (Wk = Yk + (Wk << 6) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 112 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 116 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 120 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 124 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 128 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 132 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 136 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 8 >> 2])) < 0 || (Zk = q2[_k + 140 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = (el = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 144 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 148 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 156 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 160 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 164 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 12 >> 2])) < 0 || (Zk = q2[_k + 172 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = (fl = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 176 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + fl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 180 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + fl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 188 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Wk = Zk + fl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (0 | (Yk = q2[Vk + 16 >> 2])) < 0 || (Zk = q2[_k + 192 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || ($k = (Wk = Zk) + (Zk = Yk << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 196 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 200 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 204 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 208 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + (Yk << 6) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 212 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 216 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 220 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 228 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 232 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 236 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 240 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 244 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 248 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || (Wk = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 252 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 256 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 260 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 264 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 268 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 272 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (0 | ($k = q2[Vk + 20 >> 2])) < 0 || (Yk = q2[_k + 276 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (gl = (Wk = Yk) + (Yk = $k << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 280 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || ($k = Wk + ($k << 6) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 284 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 288 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 292 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 296 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 300 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 308 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 312 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (0 | (gl = q2[Vk + 24 >> 2])) < 0 || (Wk = q2[_k + 336 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + (gl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (0 | (gl = q2[Vk + 28 >> 2])) < 0 || (Wk = q2[_k + 340 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = (ll = gl << 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 344 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + ll | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (0 | (gl = q2[Vk + 32 >> 2])) < 0 || (Wk = q2[_k + 356 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || (gl = ($k = gl << 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 360 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 364 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 368 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 372 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 376 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 380 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (0 | (bl = q2[Vk + 36 >> 2])) < 0 || (Wk = q2[_k + 392 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (bl = (gl = bl << 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 396 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + gl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 400 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + gl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 40 >> 2])) < 0 || (Wk = q2[_k + 412 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 44 >> 2])) < 0 || (Wk = q2[_k + 424 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 48 >> 2])) < 0 || (Wk = q2[_k + 428 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = (cl <<= 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 432 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + cl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 52 >> 2])) < 0 || (Wk = q2[_k + 416 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = (cl <<= 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 420 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + cl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 56 >> 2])) < 0 || (Wk = q2[_k + 552 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 60 >> 2])) < 0 || (Wk = q2[_k + 556 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 64 >> 2])) < 0 || (Wk = q2[_k + 560 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 1) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 68 >> 2])) < 0 || (Wk = q2[_k + 564 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 72 >> 2])) < 0 || (Wk = q2[_k + 568 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (cl = (bl = Wk) + (Wk = cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 572 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 576 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 580 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 584 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (bl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 76 >> 2])) < 0 || (Wk = q2[_k + 588 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (cl = (bl = cl << 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (Wk = q2[_k + 592 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (Wk = q2[_k + 596 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < cl >>> 0 || (bl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 80 >> 2])) < 0 || (Wk = q2[_k + 600 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (hl = (bl = Wk) + (Wk = cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < hl >>> 0 || (bl = q2[_k + 604 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < hl >>> 0 || (cl = bl + (cl << 6) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 608 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 612 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 616 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 620 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 624 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 628 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 632 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (bl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 84 >> 2])) < 0 || (Wk = q2[_k + 636 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 640 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 1) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 88 >> 2])) < 0 || (Wk = q2[_k + 644 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (Wk = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0)) {
                          if (!(il >>> 0 < 2)) {
                            if ((bl = q2[_k + 168 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < Wk >>> 0) break c;
                            if ((Wk = bl + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                            if (!(il >>> 0 < 4)) {
                              if ((bl = q2[_k + 324 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < Wk >>> 0) break c;
                              if ((bl = Yk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0) break c;
                              if ((Wk = q2[_k + 328 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0) break c;
                              if ((bl = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0) break c;
                              if ((Wk = q2[_k + 332 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0) break c;
                              if ((bl = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0) break c;
                              if ((Wk = q2[_k + 152 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0) break c;
                              if ((el = Wk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Wk = q2[_k + 184 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < el >>> 0) break c;
                              if ((el = Wk + fl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Wk = q2[_k + 224 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < el >>> 0) break c;
                              if ((Wk = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((0 | (el = q2[Vk + 92 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 648 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((el = (Wk = el << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Zk = q2[_k + 652 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < el >>> 0) break c;
                              if ((el = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Zk = q2[_k + 656 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < el >>> 0) break c;
                              if ((Wk = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((0 | (el = q2[Vk + 96 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 660 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((el = (Wk = el << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Zk = q2[_k + 664 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < el >>> 0) break c;
                              if ((el = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Zk = q2[_k + 668 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < el >>> 0) break c;
                              if ((Wk = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 304 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 316 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 320 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 100 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 436 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 440 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 444 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 104 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 448 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Zk) + (Zk = Wk << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = q2[_k + 452 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = q2[_k + 456 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = q2[_k + 460 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = q2[_k + 464 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 108 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 480 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 484 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 488 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 112 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 504 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 508 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 512 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 116 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 528 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Yk = Zk + (Wk << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 120 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 532 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 536 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 540 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 124 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 544 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Yk = (Wk <<= 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((Zk = q2[_k + 548 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                            }
                          }
                          if (il >>> 0 < 5) break b;
                          if (!((Zk = q2[_k + 348 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Yk = Zk + ll | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 352 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + ll | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 384 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 388 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 404 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + gl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 408 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + gl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 128 >> 2])) < 0 || (Zk = q2[_k + 468 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 472 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 476 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 132 >> 2])) < 0 || (Zk = q2[_k + 492 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 496 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 500 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 136 >> 2])) < 0 || (Zk = q2[_k + 516 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 520 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 524 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Zk = Yk + Zk | 0) >>> 0 < a2 >>> 0 || !(Zk >>> 0 <= Xk >>> 0))) break b;
                        }
                      }
                      Y3(4, 1760, 0), da2(nl, 1), X3(a2 - -64 | 0, 4, 160);
                      break a;
                    }
                    jl || (ya2(a2), o[a2 + 5 | 0] = 0, Vk = q2[_k + 64 >> 2], dl = q2[Vk >> 2], al = q2[_k + 76 >> 2], il = r2[a2 + 4 | 0]);
                    f: {
                      if ((a2 = 0) < (0 | dl)) {
                        for (; ; ) {
                          if (63 < ia2((a2 << 6) + al | 0) >>> 0) break f;
                          if ((0 | dl) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        if (Wk = Vk + 48 | 0, (Xk = 0) < (0 | (a2 = q2[Vk >> 2]))) {
                          for (Zk = q2[Vk + 48 >> 2], Yk = q2[_k + 80 >> 2]; ; ) {
                            if ((0 | (al = q2[Yk + (Xk << 2) >> 2])) < 0 | (0 | Zk) <= (0 | al)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (gl = Vk + 24 | 0, Zk = q2[Vk + 24 >> 2], $k = q2[_k + 88 >> 2], dl = q2[_k + 84 >> 2], Xk = 0; ; ) {
                            if (Yk = q2[(al = Xk << 2) + $k >> 2]) {
                              if ((0 | Yk) < 0 | (0 | Zk) < (0 | Yk)) break f;
                              if ((0 | (al = q2[al + dl >> 2])) < 0 | (0 | Zk) <= (0 | al)) break f;
                              if ((Yk = Yk + al | 0) >>> 31 | (0 | Zk) < (0 | Yk)) break f;
                            }
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 92 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 96 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 100 >> 2]; ; ) {
                            if ((0 | (Yk = q2[Zk + (Xk << 2) >> 2])) < -1 | (0 | a2) <= (0 | Yk)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                        } else gl = Vk + 24 | 0;
                      } else gl = Vk + 24 | 0, Wk = Vk + 48 | 0;
                      if ((a2 = 0) < (0 | (Xk = q2[Vk + 4 >> 2]))) {
                        for (Zk = q2[_k + 108 >> 2]; ; ) {
                          if (63 < ia2(Zk + (a2 << 6) | 0) >>> 0) break f;
                          if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        if (Zk = q2[Vk + 48 >> 2], $k = Zk + -1 | 0, !(((Xk = 0) | (a2 = q2[Vk + 4 >> 2])) <= 0)) {
                          for (Yk = q2[_k + 112 >> 2]; ; ) {
                            if ((0 | (al = q2[Yk + (Xk << 2) >> 2])) < 0 | (0 | Zk) <= (0 | al)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 116 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 120 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Zk = q2[Vk >> 2], Xk = 0, Yk = q2[_k + 124 >> 2]; ; ) {
                            if ((0 | (al = q2[Yk + (Xk << 2) >> 2])) < -1 | (0 | Zk) <= (0 | al)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 128 >> 2]; ; ) {
                            if ((0 | (Yk = q2[Zk + (Xk << 2) >> 2])) < -1 | (0 | a2) <= (0 | Yk)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 132 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Yk = Vk + 8 | 0, al = Vk + 12 | 0, dl = q2[_k + 136 >> 2], Xk = 0; ; ) {
                            if (1 < (fl = q2[(el = Xk << 2) + Zk >> 2]) >>> 0) break f;
                            if ((0 | (el = q2[dl + el >> 2])) < 0 | (0 | el) >= q2[(fl - 1 | 0 ? Yk : al) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                        }
                      } else $k = q2[Wk >> 2] + -1 | 0;
                      if ((a2 = 0) < (0 | (Xk = q2[Vk + 8 >> 2]))) {
                        for (Zk = q2[_k + 140 >> 2]; ; ) {
                          if ((0 | (Yk = q2[Zk + (a2 << 2) >> 2])) < 0 | (0 | $k) < (0 | Yk)) break f;
                          if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        for (ll = Vk + 28 | 0, Zk = q2[Vk + 28 >> 2], dl = q2[_k + 148 >> 2], el = q2[_k + 144 >> 2], a2 = 0; ; ) {
                          if (Yk = q2[(al = a2 << 2) + dl >> 2]) {
                            if ((0 | Yk) < 0 | (0 | Zk) < (0 | Yk)) break f;
                            if ((0 | (al = q2[al + el >> 2])) < 0 | (0 | Zk) <= (0 | al)) break f;
                            if ((Yk = Yk + al | 0) >>> 31 | (0 | Zk) < (0 | Yk)) break f;
                          }
                          if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        for (a2 = 0, Yk = q2[_k + 156 >> 2], al = q2[_k + 164 >> 2], dl = q2[_k + 160 >> 2]; ; ) {
                          if ((0 | (el = q2[(Zk = a2 << 2) + dl >> 2])) < 1) break f;
                          if ((0 | (fl = q2[Zk + al >> 2])) < 1) break f;
                          if ((0 | (Zk = q2[Yk + Zk >> 2])) < 1 | (0 | Zk) != (0 | w2(fl + 1 | 0, el + 1 | 0))) break f;
                          if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                      } else ll = Vk + 28 | 0;
                      if ((a2 = 0) < (0 | (Yk = q2[Vk + 12 >> 2]))) {
                        for (Xk = q2[_k + 172 >> 2]; ; ) {
                          if ((0 | (Zk = q2[Xk + (a2 << 2) >> 2])) < 0 | (0 | $k) < (0 | Zk)) break f;
                          if ((0 | Yk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        for (bl = Vk + 32 | 0, Xk = q2[Vk + 32 >> 2], $k = q2[_k + 180 >> 2], dl = q2[_k + 176 >> 2], a2 = 0; ; ) {
                          if (Zk = q2[(al = a2 << 2) + $k >> 2]) {
                            if ((0 | Zk) < 0 | (0 | Xk) < (0 | Zk)) break f;
                            if ((0 | (al = q2[al + dl >> 2])) < 0 | (0 | Xk) <= (0 | al)) break f;
                            if ((Zk = Zk + al | 0) >>> 31 | (0 | Xk) < (0 | Zk)) break f;
                          }
                          if ((0 | Yk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                      } else bl = Vk + 32 | 0;
                      Zk = Vk + 16 | 0, a2 = 0;
                      m: {
                        n: {
                          if (!((0 | (Xk = q2[Vk + 16 >> 2])) <= 0)) {
                            for (Yk = q2[_k + 208 >> 2]; ; ) {
                              if (63 < ia2(Yk + (a2 << 6) | 0) >>> 0) break f;
                              if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            if (!(((Xk = 0) | (a2 = q2[Zk >> 2])) <= 0)) {
                              for (Yk = q2[Wk >> 2], al = q2[_k + 212 >> 2]; ; ) {
                                if ((0 | ($k = q2[al + (Xk << 2) >> 2])) < 0 | (0 | Yk) <= (0 | $k)) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (nl = Vk + 36 | 0, Yk = q2[Vk + 36 >> 2], dl = q2[_k + 220 >> 2], el = q2[_k + 216 >> 2], Xk = 0; ; ) {
                                if (al = q2[($k = Xk << 2) + dl >> 2]) {
                                  if ((0 | al) < 0 | (0 | Yk) < (0 | al)) break f;
                                  if ((0 | ($k = q2[$k + el >> 2])) < 0 | (0 | Yk) <= (0 | $k)) break f;
                                  if ((al = al + $k | 0) >>> 31 | (0 | Yk) < (0 | al)) break f;
                                }
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Xk = 0, Yk = q2[_k + 228 >> 2]; ; ) {
                                if (1 < t3[Yk + (Xk << 2) >> 2]) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Xk = 0, Yk = q2[_k + 232 >> 2]; ; ) {
                                if (1 < t3[Yk + (Xk << 2) >> 2]) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Yk = q2[Vk >> 2], Xk = 0, al = q2[_k + 236 >> 2]; ; ) {
                                if ((0 | ($k = q2[al + (Xk << 2) >> 2])) < -1 | (0 | Yk) <= (0 | $k)) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Yk = q2[Vk + 4 >> 2], Xk = 0, al = q2[_k + 240 >> 2]; ; ) {
                                if ((0 | ($k = q2[al + (Xk << 2) >> 2])) < -1 | (0 | Yk) <= (0 | $k)) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Yk = q2[_k + 244 >> 2], Xk = 0; ; ) {
                                if (q2[Yk + (Xk << 2) >> 2] < 0) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              break n;
                            }
                          }
                          al = Vk + 68 | 0, nl = Vk + 36 | 0;
                          break m;
                        }
                        for (Yk = q2[_k + 252 >> 2], Xk = 0; ; ) {
                          if (q2[Yk + (Xk << 2) >> 2] < 0) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (al = q2[Vk + 60 >> 2], Xk = 0, $k = q2[_k + 256 >> 2]; ; ) {
                          if ((dl = q2[(dl = Xk << 2) + $k >> 2] + (q2[Yk + dl >> 2] << 1) | 0) >>> 31 | (0 | al) < (0 | dl)) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (Yk = q2[Vk + 64 >> 2], dl = q2[_k + 264 >> 2], el = q2[_k + 260 >> 2], Xk = 0; ; ) {
                          if (al = q2[($k = Xk << 2) + dl >> 2]) {
                            if ((0 | al) < 0 | (0 | Yk) < (0 | al)) break f;
                            if ((0 | ($k = q2[$k + el >> 2])) < 0 | (0 | Yk) <= (0 | $k)) break f;
                            if ((al = al + $k | 0) >>> 31 | (0 | Yk) < (0 | al)) break f;
                          }
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (al = Vk + 68 | 0, Yk = q2[Vk + 68 >> 2], el = q2[_k + 272 >> 2], fl = q2[_k + 268 >> 2], Xk = 0; ; ) {
                          if ($k = q2[(dl = Xk << 2) + el >> 2]) {
                            if ((0 | $k) < 0 | (0 | Yk) < (0 | $k)) break f;
                            if ((0 | (dl = q2[dl + fl >> 2])) < 0 | (0 | Yk) <= (0 | dl)) break f;
                            if (($k = $k + dl | 0) >>> 31 | (0 | Yk) < (0 | $k)) break f;
                          }
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                      }
                      a2 = 0;
                      p: {
                        q: {
                          if (!((0 | (Xk = q2[Vk + 20 >> 2])) <= 0)) {
                            for (Yk = q2[_k + 280 >> 2]; ; ) {
                              if (63 < ia2(Yk + (a2 << 6) | 0) >>> 0) break f;
                              if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            if (!(((a2 = 0) | (Xk = q2[Vk + 20 >> 2])) <= 0)) {
                              for (Yk = q2[_k + 296 >> 2]; ; ) {
                                if (1 < t3[Yk + (a2 << 2) >> 2]) break f;
                                if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (Yk = q2[_k + 300 >> 2], a2 = 0; ; ) {
                                if (q2[Yk + (a2 << 2) >> 2] < 0) break f;
                                if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              break q;
                            }
                          }
                          a2 = q2[Vk + 52 >> 2];
                          break p;
                        }
                        for (a2 = q2[Vk + 52 >> 2], el = q2[_k + 312 >> 2], fl = q2[_k + 308 >> 2], $k = 0; ; ) {
                          if (Yk = q2[(dl = $k << 2) + el >> 2]) {
                            if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                            if ((0 | (dl = q2[dl + fl >> 2])) < 0 | (0 | a2) <= (0 | dl)) break f;
                            if ((Yk = Yk + dl | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                          }
                          if ((0 | Xk) == (0 | ($k = $k + 1 | 0))) break;
                        }
                      }
                      if (Xk = 0, Yk = q2[Vk + 40 >> 2], 0 < (0 | ($k = q2[Vk + 8 >> 2]))) for (dl = q2[_k + 344 >> 2], el = q2[_k + 156 >> 2]; ; ) {
                        if ((fl = q2[(fl = Xk << 2) + dl >> 2] + (q2[el + fl >> 2] << 1) | 0) >>> 31 | (0 | Yk) < (0 | fl)) break f;
                        if ((0 | $k) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if ((Xk = 0) < (0 | ($k = q2[bl >> 2]))) {
                        for (dl = q2[_k + 376 >> 2]; ; ) {
                          if (1 < t3[dl + (Xk << 2) >> 2]) break f;
                          if ((0 | $k) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (Xk = 0, dl = q2[_k + 380 >> 2]; ; ) {
                          if (1 < t3[dl + (Xk << 2) >> 2]) break f;
                          if ((0 | $k) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                      }
                      if ((Xk = 0) < (0 | ($k = q2[Zk >> 2]))) for (dl = q2[_k + 400 >> 2], el = q2[_k + 252 >> 2]; ; ) {
                        if ((fl = q2[(fl = Xk << 2) + dl >> 2] + (q2[el + fl >> 2] << 1) | 0) >>> 31 | (0 | Yk) < (0 | fl)) break f;
                        if ((0 | $k) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if ((Xk = 0) < (0 | (Yk = q2[Vk + 44 >> 2]))) for (dl = q2[_k + 424 >> 2]; ; ) {
                        if ((0 | (el = q2[dl + (Xk << 2) >> 2])) < 0 | (0 | a2) <= (0 | el)) break f;
                        if ((0 | Yk) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if (1 <= (0 | (el = q2[Wk >> 2]))) for (Xk = 0, fl = q2[_k + 432 >> 2], cl = q2[_k + 428 >> 2]; ; ) {
                        if (Wk = q2[(dl = Xk << 2) + fl >> 2]) {
                          if ((0 | Wk) < 0 | (0 | Yk) < (0 | Wk)) break f;
                          if ((0 | (dl = q2[cl + dl >> 2])) < 0 | (0 | Yk) <= (0 | dl)) break f;
                          if ((Wk = Wk + dl | 0) >>> 31 | (0 | Yk) < (0 | Wk)) break f;
                        }
                        if ((0 | el) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if (1 <= (0 | a2)) for (Yk = q2[Vk + 56 >> 2], Xk = 0, el = q2[_k + 420 >> 2], fl = q2[_k + 416 >> 2]; ; ) {
                        if (Wk = q2[(dl = Xk << 2) + el >> 2]) {
                          if ((0 | Wk) < 0 | (0 | Yk) < (0 | Wk)) break f;
                          if ((0 | (dl = q2[dl + fl >> 2])) < 0 | (0 | Yk) <= (0 | dl)) break f;
                          if ((Wk = Wk + dl | 0) >>> 31 | (0 | Yk) < (0 | Wk)) break f;
                        }
                        if ((0 | (Xk = Xk + 1 | 0)) == (0 | a2)) break;
                      }
                      if ((a2 = 0) < (0 | (Xk = q2[al >> 2]))) for (Yk = q2[_k + 564 >> 2]; ; ) {
                        if ((0 | (al = q2[Yk + (a2 << 2) >> 2])) < -1 | (0 | $k) <= (0 | al)) break f;
                        if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                      }
                      if (a2 = q2[Vk + 76 >> 2], 1 <= (0 | (al = q2[Vk + 72 >> 2]))) for (Xk = 0, $k = q2[_k + 572 >> 2], dl = q2[_k + 568 >> 2]; ; ) {
                        if (Yk = q2[(Wk = Xk << 2) + $k >> 2]) {
                          if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                          if ((0 | (Wk = q2[Wk + dl >> 2])) < 0 | (0 | a2) <= (0 | Wk)) break f;
                          if ((Yk = Wk + Yk | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                        }
                        if ((0 | al) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if ((Xk = 0) < (0 | a2)) {
                        for (Yk = q2[_k + 588 >> 2]; ; ) {
                          if (1 < t3[Yk + (Xk << 2) >> 2]) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (Wk = q2[_k + 592 >> 2], Xk = 0; ; ) {
                          if (1 < (dl = q2[($k = Xk << 2) + Yk >> 2]) >>> 0) break f;
                          if ((0 | ($k = q2[Wk + $k >> 2])) < 0 | (0 | $k) >= q2[(dl - 1 | 0 ? Zk : Vk) >> 2]) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (Xk = 0, Yk = q2[_k + 596 >> 2]; ; ) {
                          if ((0 | (Wk = q2[Yk + (Xk << 2) >> 2])) < -1 | (0 | al) <= (0 | Wk)) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                      }
                      a2 = 0;
                      s: {
                        if (!((0 | ($k = q2[Vk + 80 >> 2])) <= 0)) {
                          for (Xk = q2[_k + 604 >> 2]; ; ) {
                            if (63 < ia2(Xk + (a2 << 6) | 0) >>> 0) break f;
                            if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                          }
                          if (!(((a2 = 0) | ($k = q2[Vk + 80 >> 2])) <= 0)) {
                            for (Xk = q2[Vk + 48 >> 2], Yk = q2[_k + 608 >> 2]; ; ) {
                              if ((0 | (al = q2[Yk + (a2 << 2) >> 2])) < 0 | (0 | Xk) <= (0 | al)) break f;
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (el = q2[Vk + 88 >> 2], al = q2[_k + 616 >> 2], Wk = q2[_k + 612 >> 2], a2 = 0; ; ) {
                              if (Xk = q2[(Yk = a2 << 2) + al >> 2]) {
                                if ((0 | Xk) < 0 | (0 | el) < (0 | Xk)) break f;
                                if ((0 | (Yk = q2[Wk + Yk >> 2])) < 0 | (0 | el) <= (0 | Yk)) break f;
                                if ((Xk = Xk + Yk | 0) >>> 31 | (0 | el) < (0 | Xk)) break f;
                              }
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (Zk = q2[Zk >> 2], al = q2[_k + 620 >> 2], a2 = 0; ; ) {
                              if ((0 | (Xk = q2[al + (a2 << 2) >> 2])) < 0 | (0 | Zk) <= (0 | Xk)) break f;
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (Wk = q2[_k + 624 >> 2], a2 = 0; ; ) {
                              if ((0 | (Xk = q2[Wk + (a2 << 2) >> 2])) < 0 | (0 | Zk) <= (0 | Xk)) break f;
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (Xk = q2[Vk + 84 >> 2], dl = q2[_k + 632 >> 2], fl = q2[_k + 628 >> 2], a2 = 0; ; ) {
                              if (Yk = q2[(cl = a2 << 2) + dl >> 2]) {
                                if ((0 | Yk) < 0 | (0 | Xk) < (0 | Yk)) break f;
                                if ((0 | (cl = q2[cl + fl >> 2])) < 0 | (0 | Xk) <= (0 | cl)) break f;
                                if ((Yk = Yk + cl | 0) >>> 31 | (0 | Xk) < (0 | Yk)) break f;
                              }
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (hl = q2[_k + 640 >> 2], Xk = q2[_k + 252 >> 2], Yk = 0; ; ) {
                              if (0 < (0 | (jl = q2[(a2 = Yk << 2) + dl >> 2]))) for (cl = hl + (q2[a2 + fl >> 2] << 1) | 0, ol = q2[Xk + (q2[a2 + Wk >> 2] << 2) >> 2], kl = q2[Xk + (q2[a2 + al >> 2] << 2) >> 2], a2 = 0; ; ) {
                                if ((0 | ol) <= s[cl + (2 | (ml = a2 << 1)) >> 1] | (0 | kl) <= s[cl + ml >> 1]) break f;
                                if (!((0 | (a2 = a2 + 2 | 0)) < (0 | jl))) break;
                              }
                              if ((0 | $k) == (0 | (Yk = Yk + 1 | 0))) break;
                            }
                            break s;
                          }
                        }
                        Zk = q2[Vk + 16 >> 2], el = q2[Vk + 88 >> 2];
                      }
                      if (!((255 & il) >>> 0 < 2)) {
                        if ((a2 = 0) < (0 | (dl = q2[Vk + 8 >> 2]))) for (Xk = q2[_k + 168 >> 2]; ; ) {
                          if (1 < t3[Xk + (a2 << 2) >> 2]) break f;
                          if ((0 | dl) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        if (!((255 & il) >>> 0 < 4)) {
                          if (al = q2[Vk + 56 >> 2], 1 <= (0 | (fl = q2[Vk + 20 >> 2]))) for (Wk = q2[_k + 332 >> 2], cl = q2[_k + 328 >> 2], a2 = 0; ; ) {
                            if (Xk = q2[(Yk = a2 << 2) + Wk >> 2]) {
                              if ((0 | Xk) < 0 | (0 | al) < (0 | Xk)) break f;
                              if ((0 | (Yk = q2[Yk + cl >> 2])) < 0 | (0 | al) <= (0 | Yk)) break f;
                              if ((Xk = Xk + Yk | 0) >>> 31 | (0 | al) < (0 | Xk)) break f;
                            }
                            if ((0 | fl) == (0 | (a2 = a2 + 1 | 0))) break;
                          }
                          if ((0 | (a2 = q2[Vk + 92 >> 2])) != q2[Vk + 96 >> 2]) break f;
                          if (1 <= (0 | dl)) for (cl = q2[_k + 152 >> 2], Xk = 0, hl = q2[_k + 148 >> 2]; ; ) {
                            if (Yk = q2[(Wk = Xk << 2) + hl >> 2]) {
                              if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                              if ((0 | (Wk = q2[Wk + cl >> 2])) < 0 | (0 | a2) <= (0 | Wk)) break f;
                              if ((Yk = Wk + Yk | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                            }
                            if ((0 | dl) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          if (1 <= (0 | (ol = q2[Vk + 12 >> 2]))) for (cl = q2[_k + 184 >> 2], Xk = 0, hl = q2[_k + 180 >> 2]; ; ) {
                            if (Yk = q2[(Wk = Xk << 2) + hl >> 2]) {
                              if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                              if ((0 | (Wk = q2[Wk + cl >> 2])) < 0 | (0 | a2) <= (0 | Wk)) break f;
                              if ((Yk = Wk + Yk | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                            }
                            if ((0 | ol) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          if (1 <= (0 | Zk)) for (cl = q2[_k + 224 >> 2], Xk = 0, hl = q2[_k + 220 >> 2]; ; ) {
                            if (Yk = q2[(Wk = Xk << 2) + hl >> 2]) {
                              if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                              if ((0 | (Wk = q2[Wk + cl >> 2])) < 0 | (0 | a2) <= (0 | Wk)) break f;
                              if ((Yk = Wk + Yk | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                            }
                            if ((0 | Zk) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          if ((Xk = 0) < (0 | fl)) {
                            for (Yk = q2[_k + 304 >> 2]; ; ) {
                              if (1 < t3[Yk + (Xk << 2) >> 2]) break f;
                              if ((0 | fl) == (0 | (Xk = Xk + 1 | 0))) break;
                            }
                            for (Yk = q2[Vk + 100 >> 2], hl = q2[_k + 320 >> 2], jl = q2[_k + 316 >> 2], Xk = 0; ; ) {
                              if (Wk = q2[(cl = Xk << 2) + hl >> 2]) {
                                if ((0 | Wk) < 0 | (0 | Yk) < (0 | Wk)) break f;
                                if ((0 | (cl = q2[cl + jl >> 2])) < 0 | (0 | Yk) <= (0 | cl)) break f;
                                if ((Wk = Wk + cl | 0) >>> 31 | (0 | Yk) < (0 | Wk)) break f;
                              }
                              if ((0 | fl) == (0 | (Xk = Xk + 1 | 0))) break;
                            }
                          } else Yk = q2[Vk + 100 >> 2];
                          if (1 <= (0 | Yk)) {
                            for (cl = q2[_k + 440 >> 2], Xk = 0, jl = q2[_k + 436 >> 2]; ; ) {
                              if (Wk = q2[(hl = Xk << 2) + cl >> 2]) {
                                if ((0 | Wk) < 0 | (0 | al) < (0 | Wk)) break f;
                                if ((0 | (hl = q2[hl + jl >> 2])) < 0 | (0 | al) <= (0 | hl)) break f;
                                if ((Wk = Wk + hl | 0) >>> 31 | (0 | al) < (0 | Wk)) break f;
                              }
                              if ((0 | Yk) == (0 | (Xk = Xk + 1 | 0))) break;
                            }
                            for (al = q2[_k + 444 >> 2], Xk = 0; ; ) {
                              if ((0 | (hl = q2[(Wk = Xk << 2) + al >> 2])) < 0 | (0 | hl) >= q2[Wk + cl >> 2]) break f;
                              if ((0 | Yk) == (0 | (Xk = Xk + 1 | 0))) break;
                            }
                          }
                          if ((al = 0) < (0 | (Xk = q2[Vk + 104 >> 2]))) {
                            for (Wk = q2[_k + 448 >> 2]; ; ) {
                              if ((0 | (cl = q2[Wk + (al << 2) >> 2])) < 0 | (0 | Yk) <= (0 | cl)) break f;
                              if ((0 | Xk) == (0 | (al = al + 1 | 0))) break;
                            }
                            for (Wk = q2[Vk + 116 >> 2], hl = q2[_k + 464 >> 2], jl = q2[_k + 460 >> 2], Yk = 0; ; ) {
                              if (al = q2[(cl = Yk << 2) + hl >> 2]) {
                                if ((0 | al) < 0 | (0 | Wk) < (0 | al)) break f;
                                if ((0 | (cl = q2[cl + jl >> 2])) < 0 | (0 | Wk) <= (0 | cl)) break f;
                                if ((al = al + cl | 0) >>> 31 | (0 | Wk) < (0 | al)) break f;
                              }
                              if ((0 | Xk) == (0 | (Yk = Yk + 1 | 0))) break;
                            }
                          } else Wk = q2[Vk + 116 >> 2];
                          if ((Yk = 0) < (0 | (cl = q2[Vk + 108 >> 2]))) {
                            for (al = q2[_k + 480 >> 2]; ; ) {
                              if ((0 | (hl = q2[al + (Yk << 2) >> 2])) < 0 | (0 | dl) <= (0 | hl)) break f;
                              if ((0 | cl) == (0 | (Yk = Yk + 1 | 0))) break;
                            }
                            for (hl = q2[_k + 488 >> 2], kl = q2[_k + 484 >> 2], Yk = 0; ; ) {
                              if (al = q2[(dl = Yk << 2) + hl >> 2]) {
                                if ((0 | al) < 0 | (0 | Xk) < (0 | al)) break f;
                                if ((0 | (dl = q2[dl + kl >> 2])) < 0 | (0 | Xk) <= (0 | dl)) break f;
                                if ((al = al + dl | 0) >>> 31 | (0 | Xk) < (0 | al)) break f;
                              }
                              if ((0 | cl) == (0 | (Yk = Yk + 1 | 0))) break;
                            }
                            for (hl = q2[ll >> 2], Yk = q2[_k + 456 >> 2], dl = q2[_k + 452 >> 2], al = 0; ; ) {
                              if (ml = q2[kl + (al << 2) >> 2] << 2, jl = q2[ml + Yk >> 2]) {
                                if ((0 | jl) < 0 | (0 | hl) < (0 | jl)) break f;
                                if ((0 | (ml = q2[dl + ml >> 2])) < 0 | (0 | hl) <= (0 | ml)) break f;
                                if ((0 | (jl = jl + ml | 0)) < 0 | (0 | hl) < (0 | jl)) break f;
                              }
                              if ((0 | cl) == (0 | (al = al + 1 | 0))) break;
                            }
                          } else Yk = q2[_k + 456 >> 2], dl = q2[_k + 452 >> 2];
                          if ((al = 0) < (0 | (cl = q2[Vk + 112 >> 2]))) {
                            for (hl = q2[_k + 504 >> 2]; ; ) {
                              if ((0 | (jl = q2[hl + (al << 2) >> 2])) < 0 | (0 | Zk) <= (0 | jl)) break f;
                              if ((0 | cl) == (0 | (al = al + 1 | 0))) break;
                            }
                            for (kl = q2[_k + 512 >> 2], jl = q2[_k + 508 >> 2], Zk = 0; ; ) {
                              if (al = q2[(hl = Zk << 2) + kl >> 2]) {
                                if ((0 | al) < 0 | (0 | Xk) < (0 | al)) break f;
                                if ((0 | (hl = q2[hl + jl >> 2])) < 0 | (0 | Xk) <= (0 | hl)) break f;
                                if ((al = al + hl | 0) >>> 31 | (0 | Xk) < (0 | al)) break f;
                              }
                              if ((0 | cl) == (0 | (Zk = Zk + 1 | 0))) break;
                            }
                            for (al = q2[nl >> 2], Zk = 0; ; ) {
                              if (kl = q2[jl + (Zk << 2) >> 2] << 2, hl = q2[kl + Yk >> 2]) {
                                if ((0 | hl) < 0 | (0 | al) < (0 | hl)) break f;
                                if ((0 | (kl = q2[dl + kl >> 2])) < 0 | (0 | al) <= (0 | kl)) break f;
                                if ((0 | (hl = hl + kl | 0)) < 0 | (0 | al) < (0 | hl)) break f;
                              }
                              if ((0 | cl) == (0 | (Zk = Zk + 1 | 0))) break;
                            }
                          }
                          if (Zk = 0, al = q2[Vk + 120 >> 2], 0 < (0 | Wk)) for (cl = q2[_k + 528 >> 2]; ; ) {
                            if ((0 | (hl = q2[cl + (Zk << 2) >> 2])) < 0 | (0 | al) <= (0 | hl)) break f;
                            if ((0 | (Zk = Zk + 1 | 0)) == (0 | Wk)) break;
                          }
                          if ((Zk = 0) < (0 | al)) {
                            for (Wk = q2[_k + 532 >> 2]; ; ) {
                              if ((0 | (cl = q2[Wk + (Zk << 2) >> 2])) < -1 | (0 | fl) <= (0 | cl)) break f;
                              if ((0 | al) == (0 | (Zk = Zk + 1 | 0))) break;
                            }
                            for (Wk = q2[Vk + 124 >> 2], hl = q2[_k + 540 >> 2], jl = q2[_k + 536 >> 2], Zk = 0; ; ) {
                              if (fl = q2[(cl = Zk << 2) + hl >> 2]) {
                                if ((0 | fl) < 0 | (0 | Wk) < (0 | fl)) break f;
                                if ((0 | (cl = q2[cl + jl >> 2])) < 0 | (0 | Wk) <= (0 | cl)) break f;
                                if ((fl = cl + fl | 0) >>> 31 | (0 | Wk) < (0 | fl)) break f;
                              }
                              if ((0 | al) == (0 | (Zk = Zk + 1 | 0))) break;
                            }
                          }
                          if (!((255 & il) >>> 0 < 5)) {
                            if ((Zk = 0) < (0 | (il = q2[ll >> 2]))) {
                              for (al = q2[_k + 348 >> 2]; ; ) {
                                if ((0 | (Wk = q2[al + (Zk << 2) >> 2])) < 0 | (0 | a2) < (0 | Wk)) break f;
                                if ((0 | il) == (0 | (Zk = Zk + 1 | 0))) break;
                              }
                              for (al = q2[_k + 352 >> 2], Zk = 0; ; ) {
                                if ((0 | (Wk = q2[al + (Zk << 2) >> 2])) < 0 | (0 | a2) < (0 | Wk)) break f;
                                if ((0 | il) == (0 | (Zk = Zk + 1 | 0))) break;
                              }
                            }
                            if ((il = 0) < (0 | (Zk = q2[bl >> 2]))) {
                              for (al = q2[_k + 384 >> 2]; ; ) {
                                if ((0 | (Wk = q2[al + (il << 2) >> 2])) < 0 | (0 | a2) < (0 | Wk)) break f;
                                if ((0 | Zk) == (0 | (il = il + 1 | 0))) break;
                              }
                              for (al = q2[_k + 388 >> 2], il = 0; ; ) {
                                if ((0 | (Wk = q2[al + (il << 2) >> 2])) < 0 | (0 | a2) < (0 | Wk)) break f;
                                if ((0 | Zk) == (0 | (il = il + 1 | 0))) break;
                              }
                            }
                            if ((il = 0) < (0 | (al = q2[nl >> 2]))) {
                              for (Wk = q2[_k + 404 >> 2]; ; ) {
                                if ((0 | (fl = q2[Wk + (il << 2) >> 2])) < 0 | (0 | a2) < (0 | fl)) break f;
                                if ((0 | al) == (0 | (il = il + 1 | 0))) break;
                              }
                              for (Wk = q2[_k + 408 >> 2], il = 0; ; ) {
                                if ((0 | (fl = q2[Wk + (il << 2) >> 2])) < 0 | (0 | a2) < (0 | fl)) break f;
                                if ((0 | al) == (0 | (il = il + 1 | 0))) break;
                              }
                            }
                            if ((a2 = 0) < (0 | (il = q2[Vk + 128 >> 2]))) {
                              for (al = q2[Vk >> 2], Wk = q2[_k + 468 >> 2]; ; ) {
                                if ((0 | (fl = q2[Wk + (a2 << 2) >> 2])) < 0 | (0 | al) <= (0 | fl)) break f;
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (ll = q2[_k + 476 >> 2], fl = q2[_k + 472 >> 2], a2 = 0; ; ) {
                                if (al = q2[(Wk = a2 << 2) + ll >> 2]) {
                                  if ((0 | al) < 0 | (0 | Xk) < (0 | al)) break f;
                                  if ((0 | (Wk = q2[Wk + fl >> 2])) < 0 | (0 | Xk) <= (0 | Wk)) break f;
                                  if ((al = Wk + al | 0) >>> 31 | (0 | Xk) < (0 | al)) break f;
                                }
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (al = q2[gl >> 2], a2 = 0; ; ) {
                                if (gl = q2[fl + (a2 << 2) >> 2] << 2, Wk = q2[gl + Yk >> 2]) {
                                  if ((0 | Wk) < 0 | (0 | al) < (0 | Wk)) break f;
                                  if ((0 | (gl = q2[dl + gl >> 2])) < 0 | (0 | al) <= (0 | gl)) break f;
                                  if ((0 | (Wk = Wk + gl | 0)) < 0 | (0 | al) < (0 | Wk)) break f;
                                }
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                            }
                            if ((a2 = 0) < (0 | (il = q2[Vk + 132 >> 2]))) {
                              for (al = q2[_k + 492 >> 2]; ; ) {
                                if ((0 | (Wk = q2[al + (a2 << 2) >> 2])) < 0 | (0 | ol) <= (0 | Wk)) break f;
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (gl = q2[_k + 500 >> 2], Wk = q2[_k + 496 >> 2], a2 = 0; ; ) {
                                if (al = q2[(fl = a2 << 2) + gl >> 2]) {
                                  if ((0 | al) < 0 | (0 | Xk) < (0 | al)) break f;
                                  if ((0 | (fl = q2[Wk + fl >> 2])) < 0 | (0 | Xk) <= (0 | fl)) break f;
                                  if ((al = al + fl | 0) >>> 31 | (0 | Xk) < (0 | al)) break f;
                                }
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (a2 = 0; ; ) {
                                if (fl = q2[Wk + (a2 << 2) >> 2] << 2, al = q2[fl + Yk >> 2]) {
                                  if ((0 | al) < 0 | (0 | Zk) < (0 | al)) break f;
                                  if ((0 | (fl = q2[dl + fl >> 2])) < 0 | (0 | Zk) <= (0 | fl)) break f;
                                  if ((0 | (al = al + fl | 0)) < 0 | (0 | Zk) < (0 | al)) break f;
                                }
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                            }
                            if (!(((a2 = 0) | (Vk = q2[Vk + 136 >> 2])) <= 0)) {
                              for (Zk = q2[_k + 516 >> 2]; ; ) {
                                if ((0 | (il = q2[Zk + (a2 << 2) >> 2])) < 0 | (0 | $k) <= (0 | il)) break f;
                                if ((0 | Vk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (al = q2[_k + 524 >> 2], Zk = q2[_k + 520 >> 2], a2 = 0; ; ) {
                                if (_k = q2[(il = a2 << 2) + al >> 2]) {
                                  if ((0 | _k) < 0 | (0 | Xk) < (0 | _k)) break f;
                                  if ((0 | (il = q2[Zk + il >> 2])) < 0 | (0 | Xk) <= (0 | il)) break f;
                                  if ((_k = _k + il | 0) >>> 31 | (0 | Xk) < (0 | _k)) break f;
                                }
                                if ((0 | Vk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (a2 = 0; ; ) {
                                if (_k = q2[Zk + (a2 << 2) >> 2] << 2, Xk = q2[_k + Yk >> 2]) {
                                  if ((0 | Xk) < 0 | (0 | el) < (0 | Xk)) break f;
                                  if ((0 | (_k = q2[_k + dl >> 2])) < 0 | (0 | el) <= (0 | _k)) break f;
                                  if ((0 | (Xk = Xk + _k | 0)) < 0 | (0 | el) < (0 | Xk)) break f;
                                }
                                if ((0 | Vk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                            }
                          }
                        }
                      }
                      return L2 = pl, 1;
                    }
                    return Y3(4, 1846, 0), L2 = pl, 0;
                  }
                  q2[_k + 52 >> 2] = Xk, q2[_k + 48 >> 2] = 5, Y3(4, 1640, _k + 48 | 0);
                } else q2[_k + 32 >> 2] = Xk, Y3(4, 1554, _k + 32 | 0);
                return L2 = pl, 0;
              }(a, vj) : (q2[20 + wj >> 2] = 1621, q2[16 + wj >> 2] = 2284, Y3(4, 1294, 16 + wj | 0), 0) : (q2[4 + wj >> 2] = 1444, q2[wj >> 2] = 2284, Y3(4, 1294, wj), 0), L2 = 48 + wj | 0, 0 | a;
            }, i: function(a) {
              q2[1805] = a |= 0;
            }, j: function(a, ej) {
              var fj;
              return ej |= 0, L2 = fj = L2 - 48 | 0, a = (a |= 0) ? (a + 63 & -64) != (0 | a) ? (q2[36 + fj >> 2] = 1522, q2[32 + fj >> 2] = 2305, Y3(4, 1294, 32 + fj | 0), 0) : (ej + 63 & -64) == (0 | ej) && ej ? function(a2) {
                var Kk = 0, Lk = 0, Mk = 0, Nk = 0, Ok = 0, Pk = 0, Qk = 0, Rk = 0, Sk = 0, Tk = 0, Uk = 0;
                q2[24 + (L2 = Qk = L2 - 32 | 0) >> 2] = 0, q2[16 + Qk >> 2] = 5, q2[20 + Qk >> 2] = 0, function(a3) {
                  var Uh;
                  Ka(16 + (L2 = Uh = L2 - 272 | 0) | 0, 2227, q2[12 + Uh >> 2] = a3), Sa(16 + Uh | 0), L2 = 272 + Uh | 0;
                }(16 + Qk | 0);
                a: {
                  if (sa(a2)) Y3(4, 1932, 0);
                  else {
                    if (!(6 <= (Mk = r2[a2 + 4 | 0]) >>> 0)) {
                      if (1 != (0 | !r2[a2 + 5 | 0]) ? (da2(a2 + 4 | 0, 1), X3(a2 - -64 | 0, 4, 160), o[a2 + 5 | 0] = 0, na2(a2, a2 + 704 | 0), ya2(a2)) : na2(a2, a2 + 704 | 0), r2[7224] || (q2[1807] = 6, o[7224] = 1, q2[1808] = 7, q2[1809] = 8, q2[1810] = 9), Lk = q2[a2 + 704 >> 2], 1 <= (0 | (Mk = q2[Lk + 16 >> 2]))) {
                        for (Nk = q2[a2 + 912 >> 2], Sk = Nk + (Mk << 2) | 0, Ok = q2[a2 + 908 >> 2]; ; ) {
                          Rk = q2[a2 + 1204 >> 2] + (q2[Ok >> 2] << 2) | 0, Lk = 0, Mk = q2[Nk >> 2], Kk = Mk + -1 | 0;
                          d: if (!((0 | Kk) < 1)) e: for (; ; ) {
                            for (; ; ) {
                              if (q2[(Pk = Rk + (Lk << 2) | 0) >> 2] <= -1) {
                                if (!function(a3, Vk, ql) {
                                  var rl = 0, sl = 0;
                                  a: if ((0 | a3) != (0 | Vk)) {
                                    if (!(a3 >>> 0 < Vk + ql >>> 0 && Vk >>> 0 < (sl = a3 + ql | 0) >>> 0)) return $(a3, Vk, ql);
                                    if (rl = 3 & (a3 ^ Vk), a3 >>> 0 < Vk >>> 0) {
                                      if (!rl) {
                                        if (3 & a3) for (; ; ) {
                                          if (!ql) break a;
                                          if (o[0 | a3] = r2[0 | Vk], Vk = Vk + 1 | 0, ql = ql + -1 | 0, !(3 & (a3 = a3 + 1 | 0))) break;
                                        }
                                        if (!(ql >>> 0 <= 3)) {
                                          for (rl = ql; ; ) if (q2[a3 >> 2] = q2[Vk >> 2], Vk = Vk + 4 | 0, a3 = a3 + 4 | 0, !(3 < (rl = rl + -4 | 0) >>> 0)) break;
                                          ql &= 3;
                                        }
                                      }
                                      if (ql) {
                                        for (; ; ) if (o[0 | a3] = r2[0 | Vk], a3 = a3 + 1 | 0, Vk = Vk + 1 | 0, !(ql = ql + -1 | 0)) break;
                                      }
                                    } else {
                                      if (!rl) {
                                        if (3 & sl) for (; ; ) {
                                          if (!ql) break a;
                                          if (o[0 | (rl = (ql = ql + -1 | 0) + a3 | 0)] = r2[Vk + ql | 0], !(3 & rl)) break;
                                        }
                                        if (!(ql >>> 0 <= 3)) {
                                          for (; ; ) if (q2[(ql = ql + -4 | 0) + a3 >> 2] = q2[Vk + ql >> 2], !(3 < ql >>> 0)) break;
                                        }
                                      }
                                      if (ql) {
                                        for (; ; ) if (o[(ql = ql + -1 | 0) + a3 | 0] = r2[Vk + ql | 0], !ql) break;
                                      }
                                    }
                                  }
                                }(Pk, Pk + 4 | 0, (-1 ^ Lk) + Mk << 2), (0 | Lk) < (0 | (Kk = (Mk = Kk) + -1 | 0))) continue e;
                                break d;
                              }
                              if (!((0 | (Lk = Lk + 1 | 0)) < (0 | Kk))) break;
                            }
                            break;
                          }
                          if (Lk = Nk, 0 < (0 | Mk) && (Mk = q2[Rk + (Kk << 2) >> 2] < 0 ? Kk : Mk), q2[Lk >> 2] = Mk, Ok = Ok + 4 | 0, !((Nk = Nk + 4 | 0) >>> 0 < Sk >>> 0)) break;
                        }
                        Lk = q2[a2 + 704 >> 2];
                      }
                      if (1 <= q2[Lk >> 2]) {
                        for (Kk = 0; ; ) if (q2[q2[a2 + 712 >> 2] + (Kk << 2) >> 2] = q2[a2 + 716 >> 2] + (Kk << 6), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk >> 2])) break;
                      }
                      if (1 <= q2[Lk + 4 >> 2]) {
                        for (Kk = 0; ; ) if (q2[q2[a2 + 744 >> 2] + (Kk << 2) >> 2] = q2[a2 + 748 >> 2] + (Kk << 6), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk + 4 >> 2])) break;
                      }
                      if (1 <= q2[Lk + 16 >> 2]) {
                        for (Kk = 0; ; ) if (q2[(Mk = Kk << 2) + q2[a2 + 832 >> 2] >> 2] = q2[a2 + 848 >> 2] + (Kk << 6), q2[Mk + q2[a2 + 836 >> 2] >> 2] = q2[a2 + 1196 >> 2] + (q2[Mk + q2[a2 + 896 >> 2] >> 2] << 2), q2[Mk + q2[a2 + 840 >> 2] >> 2] = q2[a2 + 1200 >> 2] + (q2[Mk + q2[a2 + 900 >> 2] >> 2] << 1), q2[Mk + q2[a2 + 844 >> 2] >> 2] = q2[a2 + 1204 >> 2] + (q2[Mk + q2[a2 + 908 >> 2] >> 2] << 2), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk + 16 >> 2])) break;
                      }
                      if (1 <= q2[Lk + 20 >> 2]) {
                        for (Kk = 0; ; ) if (q2[q2[a2 + 916 >> 2] + (Kk << 2) >> 2] = q2[a2 + 920 >> 2] + (Kk << 6), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk + 20 >> 2])) break;
                      }
                      if (1 <= q2[Lk + 80 >> 2]) {
                        for (Kk = 0; ; ) if (q2[q2[a2 + 1240 >> 2] + (Kk << 2) >> 2] = q2[a2 + 1244 >> 2] + (Kk << 6), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk + 80 >> 2])) break;
                      }
                      if (1 & o[q2[a2 + 708 >> 2] + 20 | 0]) break a;
                      if ((0 | (Nk = q2[Lk + 16 >> 2])) < 1) break a;
                      for (Kk = q2[a2 + 904 >> 2], Rk = q2[a2 + 900 >> 2], Pk = q2[a2 + 1200 >> 2], Ok = 0; ; ) {
                        if (0 < (0 | (Sk = q2[(Mk = Ok << 2) + Kk >> 2] + -1 | 0))) {
                          for (Tk = Pk + (q2[Mk + Rk >> 2] << 1) | 0, Lk = 0; ; ) if (Uk = s[(Mk = Tk + (Lk << 1) | 0) >> 1], p2[Mk >> 1] = s[Mk + 4 >> 1], p2[Mk + 4 >> 1] = Uk, !((0 | (Lk = Lk + 3 | 0)) < (0 | Sk))) break;
                        }
                        if ((0 | Nk) == (0 | (Ok = Ok + 1 | 0))) break;
                      }
                      for (Mk = q2[a2 + 892 >> 2], Ok = q2[a2 + 896 >> 2], Rk = q2[a2 + 1196 >> 2], Kk = 0; ; ) {
                        if (1 <= (0 | (Pk = q2[(Lk = Kk << 2) + Mk >> 2]))) {
                          for (Lk = Rk + (q2[Lk + Ok >> 2] << 2) | 0, Pk = Lk + (Pk << 3) | 0, Lk = Lk + 4 | 0; ; ) if (u2[Lk >> 2] = x2(1) - u2[Lk >> 2], !((Lk = Lk + 8 | 0) >>> 0 < Pk >>> 0)) break;
                        }
                        if ((0 | Nk) == (0 | (Kk = Kk + 1 | 0))) break;
                      }
                      break a;
                    }
                    q2[4 + Qk >> 2] = Mk, q2[Qk >> 2] = 5, Y3(4, 2023, Qk);
                  }
                  a2 = 0;
                }
                return L2 = 32 + Qk | 0, a2;
              }(a) : (q2[20 + fj >> 2] = 1621, q2[16 + fj >> 2] = 2305, Y3(4, 1294, 16 + fj | 0), 0) : (q2[4 + fj >> 2] = 1444, q2[fj >> 2] = 2305, Y3(4, 1294, fj), 0), L2 = 48 + fj | 0, 0 | a;
            }, k: function(a, ej, fj, gj) {
              var hj;
              ej |= 0, fj |= 0, gj |= 0, L2 = hj = L2 + -64 | 0, (a |= 0) ? ej ? fj ? gj ? (a = q2[q2[a >> 2] + 708 >> 2], q2[ej >> 2] = q2[a + 12 >> 2], q2[ej + 4 >> 2] = q2[a + 16 >> 2], q2[fj >> 2] = q2[a + 4 >> 2], q2[fj + 4 >> 2] = q2[a + 8 >> 2], q2[gj >> 2] = q2[a >> 2]) : (q2[52 + hj >> 2] = 1995, q2[48 + hj >> 2] = 2325, Y3(4, 1294, 48 + hj | 0)) : (q2[36 + hj >> 2] = 1903, q2[32 + hj >> 2] = 2325, Y3(4, 1294, 32 + hj | 0)) : (q2[20 + hj >> 2] = 1819, q2[16 + hj >> 2] = 2325, Y3(4, 1294, 16 + hj | 0)) : (q2[4 + hj >> 2] = 1740, q2[hj >> 2] = 2325, Y3(4, 1294, hj)), L2 = hj + 64 | 0;
            }, l: xa2, m: wa2, n: function(a) {
              var dj;
              L2 = dj = L2 - 16 | 0, (a |= 0) ? ua(a) : (q2[4 + dj >> 2] = 1740, q2[dj >> 2] = 2387, Y3(4, 1294, dj)), L2 = 16 + dj | 0;
            }, o: function(a) {
              var cj;
              return L2 = cj = L2 - 16 | 0, a = (a |= 0) ? q2[a + 540 >> 2] : (q2[4 + cj >> 2] = 1740, q2[cj >> 2] = 2402, Y3(4, 1294, cj), -1), L2 = 16 + cj | 0, 0 | a;
            }, p: function(a) {
              var bj;
              return L2 = bj = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 916 >> 2] : (q2[4 + bj >> 2] = 1740, q2[bj >> 2] = 2423, Y3(4, 1294, bj), 0), L2 = 16 + bj | 0, 0 | a;
            }, q: function(a) {
              var aj;
              return L2 = aj = L2 - 16 | 0, a = (a |= 0) ? q2[a + 548 >> 2] : (q2[4 + aj >> 2] = 1740, q2[aj >> 2] = 2442, Y3(4, 1294, aj), 0), L2 = 16 + aj | 0, 0 | a;
            }, r: function(a) {
              var $i;
              return L2 = $i = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 928 >> 2] : (q2[4 + $i >> 2] = 1740, q2[$i >> 2] = 2463, Y3(4, 1294, $i), 0), L2 = 16 + $i | 0, 0 | a;
            }, s: function(a) {
              var _i;
              return L2 = _i = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 924 >> 2] : (q2[4 + _i >> 2] = 1740, q2[_i >> 2] = 2492, Y3(4, 1294, _i), 0), L2 = 16 + _i | 0, 0 | a;
            }, t: function(a) {
              var Zi;
              return L2 = Zi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 932 >> 2] : (q2[4 + Zi >> 2] = 1740, q2[Zi >> 2] = 2521, Y3(4, 1294, Zi), 0), L2 = 16 + Zi | 0, 0 | a;
            }, u: function(a) {
              var Yi;
              return L2 = Yi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 552 >> 2] : (q2[4 + Yi >> 2] = 1740, q2[Yi >> 2] = 2550, Y3(4, 1294, Yi), 0), L2 = 16 + Yi | 0, 0 | a;
            }, v: function(a) {
              var Xi;
              return L2 = Xi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 4 >> 2] : (q2[4 + Xi >> 2] = 1740, q2[Xi >> 2] = 2572, Y3(4, 1294, Xi), -1), L2 = 16 + Xi | 0, 0 | a;
            }, w: function(a) {
              var Wi;
              return L2 = Wi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 712 >> 2] : (q2[4 + Wi >> 2] = 1740, q2[Wi >> 2] = 2588, Y3(4, 1294, Wi), 0), L2 = 16 + Wi | 0, 0 | a;
            }, x: function(a) {
              var Vi;
              return L2 = Vi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 52 >> 2] : (q2[4 + Vi >> 2] = 1740, q2[Vi >> 2] = 2602, Y3(4, 1294, Vi), 0), L2 = 16 + Vi | 0, 0 | a;
            }, y: function(a) {
              var Ui;
              return L2 = Ui = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 740 >> 2] : (q2[4 + Ui >> 2] = 1740, q2[Ui >> 2] = 2622, Y3(4, 1294, Ui), 0), L2 = 16 + Ui | 0, 0 | a;
            }, z: function(a) {
              var Ti;
              return L2 = Ti = L2 - 16 | 0, a = (a |= 0) ? q2[a + 332 >> 2] : (q2[4 + Ti >> 2] = 1740, q2[Ti >> 2] = 2650, Y3(4, 1294, Ti), -1), L2 = 16 + Ti | 0, 0 | a;
            }, A: function(a) {
              var Si;
              return L2 = Si = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 832 >> 2] : (q2[4 + Si >> 2] = 1740, q2[Si >> 2] = 2670, Y3(4, 1294, Si), 0), L2 = 16 + Si | 0, 0 | a;
            }, B: function(a) {
              var Ri;
              return L2 = Ri = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 888 >> 2] : (q2[4 + Ri >> 2] = 1740, q2[Ri >> 2] = 2688, Y3(4, 1294, Ri), 0), L2 = 16 + Ri | 0, 0 | a;
            }, C: function(a) {
              var Qi;
              return L2 = Qi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 432 >> 2] : (q2[4 + Qi >> 2] = 1740, q2[Qi >> 2] = 2716, Y3(4, 1294, Qi), 0), L2 = 16 + Qi | 0, 0 | a;
            }, D: function(a) {
              var Pi;
              return L2 = Pi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 884 >> 2] : (q2[4 + Pi >> 2] = 1740, q2[Pi >> 2] = 2743, Y3(4, 1294, Pi), 0), L2 = 16 + Pi | 0, 0 | a;
            }, E: function(a) {
              var Oi;
              return L2 = Oi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 440 >> 2] : (q2[4 + Oi >> 2] = 1740, q2[Oi >> 2] = 2772, Y3(4, 1294, Oi), 0), L2 = 16 + Oi | 0, 0 | a;
            }, F: function(a) {
              var Ni;
              return L2 = Ni = L2 - 16 | 0, a = (a |= 0) ? q2[a + 436 >> 2] : (q2[4 + Ni >> 2] = 1740, q2[Ni >> 2] = 2797, Y3(4, 1294, Ni), 0), L2 = 16 + Ni | 0, 0 | a;
            }, G: function(a) {
              var Mi;
              return L2 = Mi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 448 >> 2] : (q2[4 + Mi >> 2] = 1740, q2[Mi >> 2] = 2824, Y3(4, 1294, Mi), 0), L2 = 16 + Mi | 0, 0 | a;
            }, H: function(a) {
              var Li;
              return L2 = Li = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 912 >> 2] : (q2[4 + Li >> 2] = 1740, q2[Li >> 2] = 2848, Y3(4, 1294, Li), 0), L2 = 16 + Li | 0, 0 | a;
            }, I: function(a) {
              var Ki;
              return L2 = Ki = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 844 >> 2] : (q2[4 + Ki >> 2] = 1740, q2[Ki >> 2] = 2873, Y3(4, 1294, Ki), 0), L2 = 16 + Ki | 0, 0 | a;
            }, J: function(a) {
              var Ji;
              return L2 = Ji = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 892 >> 2] : (q2[4 + Ji >> 2] = 1740, q2[Ji >> 2] = 2893, Y3(4, 1294, Ji), 0), L2 = 16 + Ji | 0, 0 | a;
            }, K: function(a) {
              var Ii;
              return L2 = Ii = L2 - 16 | 0, a = (a |= 0) ? q2[a + 444 >> 2] : (q2[4 + Ii >> 2] = 1740, q2[Ii >> 2] = 2920, Y3(4, 1294, Ii), 0), L2 = 16 + Ii | 0, 0 | a;
            }, L: function(a) {
              var Hi;
              return L2 = Hi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 836 >> 2] : (q2[4 + Hi >> 2] = 1740, q2[Hi >> 2] = 2950, Y3(4, 1294, Hi), 0), L2 = 16 + Hi | 0, 0 | a;
            }, M: function(a) {
              var ri;
              return L2 = ri = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 904 >> 2] : (q2[4 + ri >> 2] = 1740, q2[ri >> 2] = 2974, Y3(4, 1294, ri), 0), L2 = 16 + ri | 0, 0 | a;
            }, N: function(a) {
              var qi;
              return L2 = qi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 840 >> 2] : (q2[4 + qi >> 2] = 1740, q2[qi >> 2] = 3e3, Y3(4, 1294, qi), 0), L2 = 16 + qi | 0, 0 | a;
            }, O: function(a) {
              var pi;
              return L2 = pi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 452 >> 2] : (q2[4 + pi >> 2] = 1740, q2[pi >> 2] = 3022, Y3(4, 1294, pi), 0), L2 = 16 + pi | 0, 0 | a;
            }, P: function(a) {
              var oi;
              return L2 = oi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 456 >> 2] : (q2[4 + oi >> 2] = 1740, q2[oi >> 2] = 3051, Y3(4, 1294, oi), 0), L2 = 16 + oi | 0, 0 | a;
            }, Q: function(a) {
              var ni;
              return L2 = ni = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 876 >> 2] : (q2[4 + ni >> 2] = 1740, q2[ni >> 2] = 3078, Y3(4, 1294, ni), 0), L2 = 16 + ni | 0, 0 | a;
            }, R: function(a) {
              var mi;
              L2 = mi = L2 - 16 | 0, (a |= 0) ? q2[a + 428 >> 2] = 1 : (q2[4 + mi >> 2] = 1740, q2[mi >> 2] = 3110, Y3(4, 1294, mi)), L2 = 16 + mi | 0;
            }, S: function(a) {
              var li;
              return L2 = li = L2 - 16 | 0, a = (a |= 0) ? q2[a + 640 >> 2] : (q2[4 + li >> 2] = 1740, q2[li >> 2] = 3139, Y3(4, 1294, li), 0), L2 = 16 + li | 0, 0 | a;
            }, T: function(a) {
              var ji;
              return L2 = ji = L2 - 16 | 0, a = (a |= 0) ? q2[a + 636 >> 2] : (q2[4 + ji >> 2] = 1740, q2[ji >> 2] = 3164, Y3(4, 1294, ji), 0), L2 = 16 + ji | 0, 0 | a;
            }, U: function(a) {
              var Fc;
              return oa2(12 + (L2 = Fc = L2 - 16 | 0) | 0, 64, a |= 0), L2 = 16 + Fc | 0, q2[12 + Fc >> 2];
            }, V: function(a) {
              var Ec, Cc2, Dc = 0;
              return L2 = Cc2 = L2 - 16 | 0, !(a |= 0) || oa2(12 + Cc2 | 0, 16, Ec = xa2(a)) || (Dc = wa2(a, q2[12 + Cc2 >> 2], Ec)) || (pa2(q2[12 + Cc2 >> 2]), Dc = 0), L2 = 16 + Cc2 | 0, 0 | Dc;
            }, W: function(a) {
              return 0 | qa(a |= 0);
            }, X: function(a) {
              pa2(a |= 0);
            }, Y: function(a) {
              var Sm;
              oa2(12 + (L2 = Sm = L2 - 16 | 0) | 0, 64, a |= 0), pa2(q2[12 + Sm >> 2]), L2 = 16 + Sm | 0;
            }, Z: function() {
              return 0 | L2;
            }, _: function(a) {
              return 0 | (L2 = a = L2 - (a |= 0) & -16);
            }, $: function(a) {
              L2 = a |= 0;
            }, aa: function(a) {
              return 0 | function(pagesToAdd) {
                pagesToAdd |= 0;
                var P2 = 0 | N2(), pagesToAdd = P2 + pagesToAdd | 0;
                {
                  var S;
                  P2 < pagesToAdd && pagesToAdd < 65536 && (pagesToAdd = new ArrayBuffer(w2(pagesToAdd, 65536)), (S = new global.Int8Array(pagesToAdd)).set(o), o = S, o = new global.Int8Array(pagesToAdd), p2 = new global.Int16Array(pagesToAdd), q2 = new global.Int32Array(pagesToAdd), r2 = new global.Uint8Array(pagesToAdd), s = new global.Uint16Array(pagesToAdd), t3 = new global.Uint32Array(pagesToAdd), u2 = new global.Float32Array(pagesToAdd), v2 = new global.Float64Array(pagesToAdd), buffer2 = pagesToAdd, m.buffer = pagesToAdd);
                }
                return P2;
              }(0 | (a |= 0));
            }, ba: function(a, Vk) {
              n2[a |= 0](Vk |= 0);
            } };
            function X3(a, b3, c2) {
              var e, f2, d2 = 0;
              if (c2) for (; ; ) {
                if (c2 = c2 + -1 | 0, a >>> 0 < (d2 = (e = a + b3 | 0) - 1 | 0) >>> 0) {
                  for (; ; ) if (f2 = r2[0 | a], o[0 | a] = r2[0 | d2], o[0 | d2] = f2, !((a = a + 1 | 0) >>> 0 < (d2 = d2 + -1 | 0) >>> 0)) break;
                }
                if (a = e, !c2) break;
              }
            }
            function Y3(a, b3, c2) {
              var g2;
              L2 = g2 = L2 - 272 | 0, t3[1804] > a >>> 0 || (a = q2[1805]) && (Ka(16 + g2 | 0, b3, q2[12 + g2 >> 2] = c2), n2[a](16 + g2 | 0)), L2 = 272 + g2 | 0;
            }
            function Z2(a, b3, c2) {
              32 & r2[0 | a] || !function(a2, Rm, Sm) {
                var Tm = 0, Um = 0, tn = 0;
                a: {
                  if (!(Tm = q2[Sm + 16 >> 2])) {
                    if (function(a3) {
                      var Rm2 = 0;
                      if (Rm2 = r2[a3 + 74 | 0], o[a3 + 74 | 0] = Rm2 + -1 | Rm2, 8 & (Rm2 = q2[a3 >> 2])) return q2[a3 >> 2] = 32 | Rm2, 1;
                      return q2[a3 + 4 >> 2] = 0, q2[a3 + 8 >> 2] = 0, Rm2 = q2[a3 + 44 >> 2], q2[a3 + 28 >> 2] = Rm2, q2[a3 + 20 >> 2] = Rm2, q2[a3 + 16 >> 2] = Rm2 + q2[a3 + 48 >> 2], 0;
                    }(Sm)) break a;
                    Tm = q2[Sm + 16 >> 2];
                  }
                  if (tn = q2[Sm + 20 >> 2], Tm - tn >>> 0 < Rm >>> 0) return n2[q2[Sm + 36 >> 2]](Sm, a2, Rm);
                  b: if (!(o[Sm + 75 | 0] < 0)) {
                    for (Tm = Rm; ; ) {
                      if (!(Um = Tm)) break b;
                      if (10 == r2[(Tm = Um + -1 | 0) + a2 | 0]) break;
                    }
                    if (n2[q2[Sm + 36 >> 2]](Sm, a2, Um) >>> 0 < Um >>> 0) break a;
                    Rm = Rm - Um | 0, a2 = a2 + Um | 0, tn = q2[Sm + 20 >> 2];
                  }
                  $(tn, a2, Rm), q2[Sm + 20 >> 2] = q2[Sm + 20 >> 2] + Rm;
                }
              }(b3, c2, a);
            }
            function _(a, b3, c2, h2, i) {
              var k2, l3, j2;
              if (L2 = j2 = L2 - 256 | 0, !(73728 & i | (0 | c2) <= (0 | h2))) {
                if (ca2(j2, b3, (k2 = (i = c2 - h2 | 0) >>> 0 < 256) ? i : 256), b3 = a, l3 = j2, !k2) {
                  for (c2 = c2 - h2 | 0; ; ) if (Z2(a, j2, 256), !(255 < (i = i + -256 | 0) >>> 0)) break;
                  i = 255 & c2;
                }
                Z2(b3, l3, i);
              }
              L2 = 256 + j2 | 0;
            }
            function $(a, b3, c2) {
              var h2, i = 0;
              if (8192 <= c2 >>> 0) I2(0 | a, 0 | b3, 0 | c2);
              else {
                if (h2 = a + c2 | 0, 3 & (a ^ b3)) {
                  if (h2 >>> 0 < 4) c2 = a;
                  else if ((i = h2 - 4 | 0) >>> 0 < a >>> 0) c2 = a;
                  else for (c2 = a; ; ) if (o[0 | c2] = r2[0 | b3], o[c2 + 1 | 0] = r2[b3 + 1 | 0], o[c2 + 2 | 0] = r2[b3 + 2 | 0], o[c2 + 3 | 0] = r2[b3 + 3 | 0], b3 = b3 + 4 | 0, !((c2 = c2 + 4 | 0) >>> 0 <= i >>> 0)) break;
                } else {
                  b: if ((0 | c2) < 1) c2 = a;
                  else if (3 & a) for (c2 = a; ; ) {
                    if (o[0 | c2] = r2[0 | b3], b3 = b3 + 1 | 0, h2 >>> 0 <= (c2 = c2 + 1 | 0) >>> 0) break b;
                    if (!(3 & c2)) break;
                  }
                  else c2 = a;
                  if (!((a = -4 & h2) >>> 0 < 64 || (i = a + -64 | 0) >>> 0 < c2 >>> 0)) {
                    for (; ; ) if (q2[c2 >> 2] = q2[b3 >> 2], q2[c2 + 4 >> 2] = q2[b3 + 4 >> 2], q2[c2 + 8 >> 2] = q2[b3 + 8 >> 2], q2[c2 + 12 >> 2] = q2[b3 + 12 >> 2], q2[c2 + 16 >> 2] = q2[b3 + 16 >> 2], q2[c2 + 20 >> 2] = q2[b3 + 20 >> 2], q2[c2 + 24 >> 2] = q2[b3 + 24 >> 2], q2[c2 + 28 >> 2] = q2[b3 + 28 >> 2], q2[c2 + 32 >> 2] = q2[b3 + 32 >> 2], q2[c2 + 36 >> 2] = q2[b3 + 36 >> 2], q2[c2 + 40 >> 2] = q2[b3 + 40 >> 2], q2[c2 + 44 >> 2] = q2[b3 + 44 >> 2], q2[c2 + 48 >> 2] = q2[b3 + 48 >> 2], q2[c2 + 52 >> 2] = q2[b3 + 52 >> 2], q2[c2 + 56 >> 2] = q2[b3 + 56 >> 2], q2[c2 + 60 >> 2] = q2[b3 + 60 >> 2], b3 = b3 - -64 | 0, !((c2 = c2 - -64 | 0) >>> 0 <= i >>> 0)) break;
                  }
                  if (!(a >>> 0 <= c2 >>> 0)) {
                    for (; ; ) if (q2[c2 >> 2] = q2[b3 >> 2], b3 = b3 + 4 | 0, !((c2 = c2 + 4 | 0) >>> 0 < a >>> 0)) break;
                  }
                }
                if (c2 >>> 0 < h2 >>> 0) {
                  for (; ; ) if (o[0 | c2] = r2[0 | b3], b3 = b3 + 1 | 0, (0 | h2) == (0 | (c2 = c2 + 1 | 0))) break;
                }
              }
            }
            function aa(a) {
              var b3, c2;
              return x2((b3 = a * a) * b3 * (c2 = b3 * a) * (2718311493989822e-21 * b3 - 19839334836096632e-20) + (c2 * (0.008333329385889463 * b3 - 0.16666666641626524) + a));
            }
            function ba(a) {
              var m2;
              return x2(-0.499999997251031 * (a *= a) + 1 + 0.04166662332373906 * (m2 = a * a) + a * m2 * (2439044879627741e-20 * a - 0.001388676377460993));
            }
            function ca2(a, n3, p3) {
              var r3, s2, t4, u3;
              if (p3 && (o[(r3 = a + p3 | 0) - 1 | 0] = n3, o[0 | a] = n3, !(p3 >>> 0 < 3 || (o[r3 - 2 | 0] = n3, o[a + 1 | 0] = n3, o[r3 - 3 | 0] = n3, o[a + 2 | 0] = n3, p3 >>> 0 < 7) || (o[r3 - 4 | 0] = n3, o[a + 3 | 0] = n3, p3 >>> 0 < 9) || (s2 = (r3 = 0 - a & 3) + a | 0, n3 = w2(255 & n3, 16843009), q2[s2 >> 2] = n3, q2[(r3 = (p3 = p3 - r3 & -4) + s2 | 0) - 4 >> 2] = n3, p3 >>> 0 < 9) || (q2[8 + s2 >> 2] = n3, q2[4 + s2 >> 2] = n3, q2[r3 - 8 >> 2] = n3, q2[r3 - 12 >> 2] = n3, p3 >>> 0 < 25) || (q2[24 + s2 >> 2] = n3, q2[20 + s2 >> 2] = n3, q2[16 + s2 >> 2] = n3, q2[12 + s2 >> 2] = n3, q2[r3 - 16 >> 2] = n3, q2[r3 - 20 >> 2] = n3, q2[r3 - 24 >> 2] = n3, q2[r3 - 28 >> 2] = n3, (p3 = p3 - (u3 = 4 & s2 | 24) | 0) >>> 0 < 32)))) {
                for (t4 = r3 = n3, n3 = s2 + u3 | 0; ; ) if (q2[n3 + 24 >> 2] = t4, q2[n3 + 28 >> 2] = r3, q2[n3 + 16 >> 2] = t4, q2[n3 + 20 >> 2] = r3, q2[n3 + 8 >> 2] = t4, q2[n3 + 12 >> 2] = r3, q2[n3 >> 2] = t4, q2[n3 + 4 >> 2] = r3, n3 = n3 + 32 | 0, !(31 < (p3 = p3 + -32 | 0) >>> 0)) break;
              }
              return a;
            }
            function da2(a, n3) {
              var p3;
              if (a >>> 0 < (n3 = (a + n3 | 0) - 1 | 0) >>> 0) {
                for (; ; ) if (p3 = r2[0 | a], o[0 | a] = r2[0 | n3], o[0 | n3] = p3, !((a = a + 1 | 0) >>> 0 < (n3 = n3 + -1 | 0) >>> 0)) break;
              }
            }
            function ea(a) {
              var n3 = 0, o2 = N2();
              return (a = (n3 = q2[2216]) + a | 0) >>> 0 <= o2 << 16 >>> 0 || J2(0 | a) ? (q2[2216] = a, n3) : (q2[2086] = 48, -1);
            }
            function fa(a, v3, y3, z3, B2, C3, D2) {
              var H3, I3, K3, N3, Q2, R, S, O2, P2, J3, E2 = 0, F2 = x2(0), G2 = x2(0), M3 = x2(0);
              x2(0), x2(0), x2(0), x2(0);
              if (L2 = J3 = L2 - 16 | 0, 1 <= (0 | a)) for (R = w2(a, 12) + v3 | 0; ; ) {
                if (1 <= (0 | (I3 = q2[v3 + 4 >> 2]))) {
                  for (S = (a = q2[v3 + 8 >> 2]) + w2(I3, 48) | 0, I3 = (H3 = q2[v3 >> 2] << 4) + D2 | 0, K3 = (8 | H3) + D2 | 0, H3 = (4 | H3) + D2 | 0; ; ) if ((E2 = q2[a + 8 >> 2]) && ((O2 = E2 + -1 | 0) >>> 0 <= 1 ? (P2 = (q2[a + 4 >> 2] << 2) + y3 | 0, E2 = q2[P2 + (q2[a + 12 >> 2] << 2) >> 2] << 2, F2 = u2[E2 + C3 >> 2], Q2 = u2[B2 + E2 >> 2], G2 = u2[z3 + E2 >> 2], O2 - 1 ? (M3 = G2, G2 = u2[a + 20 >> 2], u2[I3 >> 2] = u2[I3 >> 2] + x2(u2[a + 44 >> 2] * x2(M3 * G2)), u2[H3 >> 2] = u2[H3 >> 2] + x2(x2(Q2 * G2) * u2[a + 44 >> 2]), u2[K3 >> 2] = u2[K3 >> 2] + x2(x2(F2 * G2) * u2[a + 44 >> 2])) : (E2 = q2[(q2[a + 16 >> 2] << 2) + P2 >> 2] << 2, O2 = u2[E2 + C3 >> 2], P2 = u2[B2 + E2 >> 2], M3 = G2, G2 = u2[a + 20 >> 2], N3 = u2[a + 24 >> 2], u2[I3 >> 2] = u2[I3 >> 2] + x2(u2[a + 44 >> 2] * x2(x2(M3 * G2) + x2(u2[z3 + E2 >> 2] * N3))), u2[H3 >> 2] = u2[H3 >> 2] + x2(x2(x2(Q2 * G2) + x2(P2 * N3)) * u2[a + 44 >> 2]), u2[K3 >> 2] = u2[K3 >> 2] + x2(x2(x2(F2 * G2) + x2(O2 * N3)) * u2[a + 44 >> 2]))) : (q2[J3 >> 2] = E2, Y3(4, 1024, J3))), !((a = a + 48 | 0) >>> 0 < S >>> 0)) break;
                }
                if (a = (q2[v3 >> 2] << 4) + D2 | 0, F2 = u2[a >> 2], u2[a >> 2] = F2 < x2(0) ? x2(0) : x2(A(F2, x2(1))), F2 = u2[a + 4 >> 2], u2[a + 4 >> 2] = F2 < x2(0) ? x2(0) : x2(A(F2, x2(1))), F2 = u2[a + 8 >> 2], u2[a + 8 >> 2] = F2 < x2(0) ? x2(0) : x2(A(F2, x2(1))), !((v3 = v3 + 12 | 0) >>> 0 < R >>> 0)) break;
              }
              L2 = 16 + J3 | 0;
            }
            function ga(a, q3, v3) {
              var y3, x3 = 0, z3 = 0;
              if (1 == (0 | q3) & a >>> 0 < 0 | q3 >>> 0 < 1) x3 = a;
              else for (; ; ) if (y3 = ad(x3 = bd(a, q3, 10), z3 = M2, 10), o[0 | (v3 = v3 + -1 | 0)] = a - y3 | 48, y3 = 9 == (0 | q3) & 4294967295 < a >>> 0 | 9 < q3 >>> 0, a = x3, q3 = z3, !y3) break;
              if (x3) {
                for (; ; ) if (o[0 | (v3 = v3 + -1 | 0)] = x3 - w2(a = (x3 >>> 0) / 10 | 0, 10) | 48, q3 = 9 < x3 >>> 0, x3 = a, !q3) break;
              }
              return v3;
            }
            function ha2(a) {
              return a + -48 >>> 0 < 10;
            }
            function ia2(a) {
              var q3;
              return (q3 = La(a, 64)) ? q3 - a | 0 : 64;
            }
            function ja2(a, v3) {
              var w3 = 0;
              return 1024 <= (0 | v3) ? (a *= 898846567431158e293, v3 = (0 | (w3 = v3 + -1023 | 0)) < 1024 ? w3 : (a *= 898846567431158e293, ((0 | v3) < 3069 ? v3 : 3069) + -2046 | 0)) : -1023 < (0 | v3) || (a *= 22250738585072014e-324, v3 = -1023 < (0 | (w3 = v3 + 1022 | 0)) ? w3 : (a *= 22250738585072014e-324, (-3066 < (0 | v3) ? v3 : -3066) + 2044 | 0)), f(0, 0), f(1, v3 + 1023 << 20), a * +g();
            }
            function ka2(a, v3) {
              var A2 = 0, B2 = 0, C3 = a, B2 = v3 >>> 0 <= 31 ? (A2 = q2[a + 4 >> 2], q2[a >> 2]) : (A2 = q2[a >> 2], q2[a + 4 >> 2] = A2, v3 = v3 + -32 | (q2[a >> 2] = 0), 0);
              q2[C3 >> 2] = B2 << v3, q2[a + 4 >> 2] = A2 << v3 | B2 >>> 32 - v3;
            }
            function la2(a, v3, D2, V2, W2) {
              var X4, Y4 = 0, Z3 = 0, _2 = 0;
              L2 = X4 = L2 - 240 | 0, Y4 = q2[v3 >> 2], q2[232 + X4 >> 2] = Y4, v3 = q2[v3 + 4 >> 2], q2[X4 >> 2] = a, q2[236 + X4 >> 2] = v3, Z3 = 1;
              a: {
                b: {
                  c: {
                    if ((v3 || 1 != (0 | Y4)) && (Y4 = a - q2[(D2 << 2) + W2 >> 2] | 0, !((0 | n2[5](Y4, a)) < 1))) {
                      for (_2 = !V2; ; ) {
                        e: {
                          if (v3 = Y4, !(!_2 | (0 | D2) < 2)) {
                            if (V2 = q2[((D2 << 2) + W2 | 0) - 8 >> 2], -1 < (0 | n2[5](Y4 = a + -4 | 0, v3))) break e;
                            if (-1 < (0 | n2[5](Y4 - V2 | 0, v3))) break e;
                          }
                          if (q2[(Z3 << 2) + X4 >> 2] = v3, Z3 = Z3 + 1 | 0, ma2(232 + X4 | 0, a = Oa(232 + X4 | 0)), D2 = a + D2 | 0, !q2[236 + X4 >> 2] && 1 == q2[232 + X4 >> 2]) break b;
                          if (_2 = 1, Y4 = (a = v3) - q2[(D2 << 2) + W2 >> 2] | (V2 = 0), 0 < (0 | n2[5](Y4, q2[X4 >> 2]))) continue;
                          break c;
                        }
                        break;
                      }
                      v3 = a;
                      break b;
                    }
                    v3 = a;
                  }
                  if (V2) break a;
                }
                Na(X4, Z3), ta2(v3, D2, W2);
              }
              L2 = 240 + X4 | 0;
            }
            function ma2(a, v3) {
              var D2 = 0, L3 = 0, V2 = a, L3 = v3 >>> 0 <= 31 ? (D2 = q2[a >> 2], q2[a + 4 >> 2]) : (D2 = q2[a + 4 >> 2], q2[a + 4 >> 2] = 0, q2[a >> 2] = D2, v3 = v3 + -32 | 0, 0);
              q2[V2 + 4 >> 2] = L3 >>> v3, q2[a >> 2] = L3 << 32 - v3 | D2 >>> v3;
            }
            function na2(a, v3) {
              var W2 = r2[a + 4 | 0];
              q2[v3 >> 2] = q2[a + 64 >> 2] + a, q2[v3 + 4 >> 2] = q2[a + 68 >> 2] + a, q2[v3 + 8 >> 2] = q2[a + 72 >> 2] + a, q2[v3 + 12 >> 2] = q2[a + 76 >> 2] + a, q2[v3 + 16 >> 2] = q2[a + 80 >> 2] + a, q2[v3 + 20 >> 2] = q2[a + 84 >> 2] + a, q2[v3 + 24 >> 2] = q2[a + 88 >> 2] + a, q2[v3 + 28 >> 2] = q2[a + 92 >> 2] + a, q2[v3 + 32 >> 2] = q2[a + 96 >> 2] + a, q2[v3 + 36 >> 2] = q2[a + 100 >> 2] + a, q2[v3 + 40 >> 2] = q2[a + 104 >> 2] + a, q2[v3 + 44 >> 2] = q2[a + 108 >> 2] + a, q2[v3 + 48 >> 2] = q2[a + 112 >> 2] + a, q2[v3 + 52 >> 2] = q2[a + 116 >> 2] + a, q2[v3 + 56 >> 2] = q2[a + 120 >> 2] + a, q2[v3 + 60 >> 2] = q2[a + 124 >> 2] + a, q2[v3 - -64 >> 2] = q2[a + 128 >> 2] + a, q2[v3 + 68 >> 2] = q2[a + 132 >> 2] + a, q2[v3 + 72 >> 2] = q2[a + 136 >> 2] + a, q2[v3 + 76 >> 2] = q2[a + 140 >> 2] + a, q2[v3 + 80 >> 2] = q2[a + 144 >> 2] + a, q2[v3 + 84 >> 2] = q2[a + 148 >> 2] + a, q2[v3 + 92 >> 2] = q2[a + 152 >> 2] + a, q2[v3 + 96 >> 2] = q2[a + 156 >> 2] + a, q2[v3 + 100 >> 2] = q2[a + 160 >> 2] + a, q2[v3 + 108 >> 2] = q2[a + 164 >> 2] + a, q2[v3 + 112 >> 2] = q2[a + 168 >> 2] + a, q2[v3 + 116 >> 2] = q2[a + 172 >> 2] + a, q2[v3 + 124 >> 2] = q2[a + 176 >> 2] + a, q2[v3 + 128 >> 2] = q2[a + 180 >> 2] + a, q2[v3 + 132 >> 2] = q2[a + 184 >> 2] + a, q2[v3 + 136 >> 2] = q2[a + 188 >> 2] + a, q2[v3 + 140 >> 2] = q2[a + 192 >> 2] + a, q2[v3 + 144 >> 2] = q2[a + 196 >> 2] + a, q2[v3 + 148 >> 2] = q2[a + 200 >> 2] + a, q2[v3 + 152 >> 2] = q2[a + 204 >> 2] + a, q2[v3 + 156 >> 2] = q2[a + 208 >> 2] + a, q2[v3 + 164 >> 2] = q2[a + 212 >> 2] + a, q2[v3 + 168 >> 2] = q2[a + 216 >> 2] + a, q2[v3 + 172 >> 2] = q2[a + 220 >> 2] + a, q2[v3 + 176 >> 2] = q2[a + 224 >> 2] + a, q2[v3 + 180 >> 2] = q2[a + 228 >> 2] + a, q2[v3 + 184 >> 2] = q2[a + 232 >> 2] + a, q2[v3 + 188 >> 2] = q2[a + 236 >> 2] + a, q2[v3 + 192 >> 2] = q2[a + 240 >> 2] + a, q2[v3 + 196 >> 2] = q2[a + 244 >> 2] + a, q2[v3 + 200 >> 2] = q2[a + 248 >> 2] + a, q2[v3 + 204 >> 2] = q2[a + 252 >> 2] + a, q2[v3 + 208 >> 2] = q2[a + 256 >> 2] + a, q2[v3 + 212 >> 2] = q2[a + 260 >> 2] + a, q2[v3 + 216 >> 2] = q2[a + 264 >> 2] + a, q2[v3 + 220 >> 2] = q2[a + 268 >> 2] + a, q2[v3 + 224 >> 2] = q2[a + 272 >> 2] + a, q2[v3 + 228 >> 2] = q2[a + 276 >> 2] + a, q2[v3 + 232 >> 2] = q2[a + 280 >> 2] + a, q2[v3 + 236 >> 2] = q2[a + 284 >> 2] + a, q2[v3 + 244 >> 2] = q2[a + 288 >> 2] + a, q2[v3 + 248 >> 2] = q2[a + 292 >> 2] + a, q2[v3 + 272 >> 2] = q2[a + 296 >> 2] + a, q2[v3 + 276 >> 2] = q2[a + 300 >> 2] + a, q2[v3 + 280 >> 2] = q2[a + 304 >> 2] + a, q2[v3 + 292 >> 2] = q2[a + 308 >> 2] + a, q2[v3 + 296 >> 2] = q2[a + 312 >> 2] + a, q2[v3 + 300 >> 2] = q2[a + 316 >> 2] + a, q2[v3 + 304 >> 2] = q2[a + 320 >> 2] + a, q2[v3 + 308 >> 2] = q2[a + 324 >> 2] + a, q2[v3 + 312 >> 2] = q2[a + 328 >> 2] + a, q2[v3 + 316 >> 2] = q2[a + 332 >> 2] + a, q2[v3 + 328 >> 2] = q2[a + 336 >> 2] + a, q2[v3 + 332 >> 2] = q2[a + 340 >> 2] + a, q2[v3 + 336 >> 2] = q2[a + 344 >> 2] + a, q2[v3 + 348 >> 2] = q2[a + 348 >> 2] + a, q2[v3 + 360 >> 2] = q2[a + 352 >> 2] + a, q2[v3 + 364 >> 2] = q2[a + 356 >> 2] + a, q2[v3 + 368 >> 2] = q2[a + 360 >> 2] + a, q2[v3 + 352 >> 2] = q2[a + 364 >> 2] + a, q2[v3 + 356 >> 2] = q2[a + 368 >> 2] + a, q2[v3 + 488 >> 2] = q2[a + 372 >> 2] + a, q2[v3 + 492 >> 2] = q2[a + 376 >> 2] + a, q2[v3 + 496 >> 2] = q2[a + 380 >> 2] + a, q2[v3 + 500 >> 2] = q2[a + 384 >> 2] + a, q2[v3 + 504 >> 2] = q2[a + 388 >> 2] + a, q2[v3 + 508 >> 2] = q2[a + 392 >> 2] + a, q2[v3 + 512 >> 2] = q2[a + 396 >> 2] + a, q2[v3 + 516 >> 2] = q2[a + 400 >> 2] + a, q2[v3 + 520 >> 2] = q2[a + 404 >> 2] + a, q2[v3 + 524 >> 2] = q2[a + 408 >> 2] + a, q2[v3 + 528 >> 2] = q2[a + 412 >> 2] + a, q2[v3 + 532 >> 2] = q2[a + 416 >> 2] + a, q2[v3 + 536 >> 2] = q2[a + 420 >> 2] + a, q2[v3 + 540 >> 2] = q2[a + 424 >> 2] + a, q2[v3 + 544 >> 2] = q2[a + 428 >> 2] + a, q2[v3 + 548 >> 2] = q2[a + 432 >> 2] + a, q2[v3 + 552 >> 2] = q2[a + 436 >> 2] + a, q2[v3 + 556 >> 2] = q2[a + 440 >> 2] + a, q2[v3 + 560 >> 2] = q2[a + 444 >> 2] + a, q2[v3 + 564 >> 2] = q2[a + 448 >> 2] + a, q2[v3 + 568 >> 2] = q2[a + 452 >> 2] + a, q2[v3 + 572 >> 2] = q2[a + 456 >> 2] + a, q2[v3 + 576 >> 2] = q2[a + 460 >> 2] + a, q2[v3 + 580 >> 2] = q2[a + 464 >> 2] + a, W2 >>> 0 < 2 || (q2[v3 + 104 >> 2] = q2[a + 468 >> 2] + a, W2 >>> 0 < 4) || (q2[v3 + 260 >> 2] = q2[a + 472 >> 2] + a, q2[v3 + 264 >> 2] = q2[a + 476 >> 2] + a, q2[v3 + 268 >> 2] = q2[a + 480 >> 2] + a, q2[v3 + 88 >> 2] = q2[a + 484 >> 2] + a, q2[v3 + 120 >> 2] = q2[a + 488 >> 2] + a, q2[v3 + 160 >> 2] = q2[a + 492 >> 2] + a, q2[v3 + 584 >> 2] = q2[a + 496 >> 2] + a, q2[v3 + 588 >> 2] = q2[a + 500 >> 2] + a, q2[v3 + 592 >> 2] = q2[a + 504 >> 2] + a, q2[v3 + 596 >> 2] = q2[a + 508 >> 2] + a, q2[v3 + 600 >> 2] = q2[a + 512 >> 2] + a, q2[v3 + 604 >> 2] = q2[a + 516 >> 2] + a, q2[v3 + 240 >> 2] = q2[a + 520 >> 2] + a, q2[v3 + 252 >> 2] = q2[a + 524 >> 2] + a, q2[v3 + 256 >> 2] = q2[a + 528 >> 2] + a, q2[v3 + 372 >> 2] = q2[a + 532 >> 2] + a, q2[v3 + 376 >> 2] = q2[a + 536 >> 2] + a, q2[v3 + 380 >> 2] = q2[a + 540 >> 2] + a, q2[v3 + 384 >> 2] = q2[a + 544 >> 2] + a, q2[v3 + 388 >> 2] = q2[a + 548 >> 2] + a, q2[v3 + 392 >> 2] = q2[a + 552 >> 2] + a, q2[v3 + 396 >> 2] = q2[a + 556 >> 2] + a, q2[v3 + 400 >> 2] = q2[a + 560 >> 2] + a, q2[v3 + 416 >> 2] = q2[a + 564 >> 2] + a, q2[v3 + 420 >> 2] = q2[a + 568 >> 2] + a, q2[v3 + 424 >> 2] = q2[a + 572 >> 2] + a, q2[v3 + 440 >> 2] = q2[a + 576 >> 2] + a, q2[v3 + 444 >> 2] = q2[a + 580 >> 2] + a, q2[v3 + 448 >> 2] = q2[a + 584 >> 2] + a, q2[v3 + 464 >> 2] = q2[a + 588 >> 2] + a, q2[v3 + 468 >> 2] = q2[a + 592 >> 2] + a, q2[v3 + 472 >> 2] = q2[a + 596 >> 2] + a, q2[v3 + 476 >> 2] = q2[a + 600 >> 2] + a, q2[v3 + 480 >> 2] = q2[a + 604 >> 2] + a, q2[v3 + 484 >> 2] = q2[a + 608 >> 2] + a, 4 != (0 | W2) && (q2[v3 + 284 >> 2] = q2[a + 612 >> 2] + a, q2[v3 + 288 >> 2] = q2[a + 616 >> 2] + a, q2[v3 + 320 >> 2] = q2[a + 620 >> 2] + a, q2[v3 + 324 >> 2] = q2[a + 624 >> 2] + a, q2[v3 + 340 >> 2] = q2[a + 628 >> 2] + a, q2[v3 + 344 >> 2] = q2[a + 632 >> 2] + a, q2[v3 + 404 >> 2] = q2[a + 636 >> 2] + a, q2[v3 + 408 >> 2] = q2[a + 640 >> 2] + a, q2[v3 + 412 >> 2] = q2[a + 644 >> 2] + a, q2[v3 + 428 >> 2] = q2[a + 648 >> 2] + a, q2[v3 + 432 >> 2] = q2[a + 652 >> 2] + a, q2[v3 + 436 >> 2] = q2[a + 656 >> 2] + a, q2[v3 + 452 >> 2] = q2[a + 660 >> 2] + a, q2[v3 + 456 >> 2] = q2[a + 664 >> 2] + a, q2[v3 + 460 >> 2] = q2[a + 668 >> 2] + a));
            }
            function oa2(a, v3, $2) {
              var aa2 = 0;
              a: {
                if (8 == (0 | v3)) v3 = qa($2);
                else {
                  if (aa2 = 28, 3 & v3 | 1 != (0 | function(a2) {
                    var $o = 0, ap = 0;
                    for (; ; ) {
                      if (ap = $o, !a2) break;
                      a2 &= a2 - 1, $o = $o + 1 | 0;
                    }
                    return ap;
                  }(v3 >>> 2))) break a;
                  if (aa2 = 48, -64 - v3 >>> 0 < $2 >>> 0) break a;
                  v3 = function(a2, Vk) {
                    var ql = 0, tl = 0, ul = 0, vl = 0, wl = 0;
                    if ((tl = a2 >>> 0 > (ql = 16) ? a2 : 16) + -1 & tl) {
                      for (; ; ) if (ql = (a2 = ql) << 1, !(a2 >>> 0 < tl >>> 0)) break;
                    } else a2 = tl;
                    if (-64 - a2 >>> 0 <= Vk >>> 0) return q2[2086] = 48, 0;
                    if (!(ql = qa(12 + ((tl = Vk >>> 0 < 11 ? 16 : Vk + 11 & -8) + a2 | 0) | 0))) return 0;
                    Vk = ql + -8 | 0;
                    ql & a2 + -1 ? (wl = q2[(vl = ql + -4 | 0) >> 2], ul = (-8 & wl) - (ql = (a2 = 15 < (ql = ((a2 + ql | 0) - 1 & 0 - a2) - 8 | 0) - Vk >>> 0 ? ql : a2 + ql | 0) - Vk | 0) | 0, 3 & wl ? (q2[a2 + 4 >> 2] = ul | 1 & q2[a2 + 4 >> 2] | 2, q2[4 + (ul = a2 + ul | 0) >> 2] = 1 | q2[4 + ul >> 2], q2[vl >> 2] = ql | 1 & q2[vl >> 2] | 2, q2[a2 + 4 >> 2] = 1 | q2[a2 + 4 >> 2], za(Vk, ql)) : (Vk = q2[Vk >> 2], q2[a2 + 4 >> 2] = ul, q2[a2 >> 2] = Vk + ql)) : a2 = Vk;
                    3 & (Vk = q2[a2 + 4 >> 2]) && ((ql = -8 & Vk) >>> 0 <= tl + 16 >>> 0 || (q2[a2 + 4 >> 2] = tl | 1 & Vk | 2, Vk = a2 + tl | 0, tl = ql - tl | 0, q2[Vk + 4 >> 2] = 3 | tl, q2[(ql = a2 + ql | 0) + 4 >> 2] = 1 | q2[ql + 4 >> 2], za(Vk, tl)));
                    return a2 + 8 | 0;
                  }(16 < v3 >>> 0 ? v3 : 16, $2);
                }
                if (!v3) return 1;
                q2[a >> 2] = v3, aa2 = 0;
              }
              return aa2;
            }
            function pa2(a) {
              var da3, v3 = 0, $2 = 0, ba2 = 0, ca3 = 0, ea2 = 0, fa2 = 0, ha3 = 0;
              a: if (a) {
                da3 = (ba2 = a + -8 | 0) + (a = -8 & ($2 = q2[a + -4 >> 2])) | 0;
                b: if (!(1 & $2)) {
                  if (!(3 & $2)) break a;
                  if ((ba2 = ba2 - ($2 = q2[ba2 >> 2]) | 0) >>> 0 < t3[2091]) break a;
                  if (a = a + $2 | 0, q2[2092] != (0 | ba2)) if ($2 >>> 0 <= 255) ca3 = q2[ba2 + 8 >> 2], $2 >>>= 3, (0 | (v3 = q2[ba2 + 12 >> 2])) == (0 | ca3) ? (ha3 = q2[2087] & dd($2), q2[8348 >> 2] = ha3) : (q2[ca3 + 12 >> 2] = v3, q2[v3 + 8 >> 2] = ca3);
                  else {
                    if (fa2 = q2[ba2 + 24 >> 2], (0 | ba2) != (0 | ($2 = q2[ba2 + 12 >> 2]))) v3 = q2[ba2 + 8 >> 2], q2[v3 + 12 >> 2] = $2, q2[$2 + 8 >> 2] = v3;
                    else if ((v3 = q2[(ca3 = ba2 + 20 | 0) >> 2]) || (v3 = q2[(ca3 = ba2 + 16 | 0) >> 2])) {
                      for (; ; ) if (ea2 = ca3, !((v3 = q2[(ca3 = ($2 = v3) + 20 | 0) >> 2]) || (ca3 = $2 + 16 | 0, v3 = q2[$2 + 16 >> 2]))) break;
                      q2[ea2 >> 2] = 0;
                    } else $2 = 0;
                    if (fa2) {
                      ca3 = q2[ba2 + 28 >> 2];
                      e: {
                        if (q2[(v3 = 8652 + (ca3 << 2) | 0) >> 2] == (0 | ba2)) {
                          if (q2[v3 >> 2] = $2) break e;
                          ha3 = q2[2088] & dd(ca3), q2[8352 >> 2] = ha3;
                          break b;
                        }
                        if (!(q2[fa2 + (q2[fa2 + 16 >> 2] == (0 | ba2) ? 16 : 20) >> 2] = $2)) break b;
                      }
                      q2[$2 + 24 >> 2] = fa2, (v3 = q2[ba2 + 16 >> 2]) && (q2[$2 + 16 >> 2] = v3, q2[v3 + 24 >> 2] = $2), (v3 = q2[ba2 + 20 >> 2]) && (q2[$2 + 20 >> 2] = v3, q2[v3 + 24 >> 2] = $2);
                    }
                  }
                  else if (3 == (3 & ($2 = q2[4 + da3 >> 2]))) return q2[2089] = a, q2[4 + da3 >> 2] = -2 & $2, q2[ba2 + 4 >> 2] = 1 | a, void (q2[a + ba2 >> 2] = a);
                }
                if (!(da3 >>> 0 <= ba2 >>> 0) && 1 & ($2 = q2[4 + da3 >> 2])) {
                  f: {
                    if (!(2 & $2)) {
                      if (q2[2093] == (0 | da3)) {
                        if (q2[2093] = ba2, a = q2[2090] + a | 0, q2[2090] = a, q2[ba2 + 4 >> 2] = 1 | a, q2[2092] != (0 | ba2)) break a;
                        return q2[2089] = 0, void (q2[2092] = 0);
                      }
                      if (q2[2092] == (0 | da3)) return q2[2092] = ba2, a = q2[2089] + a | 0, q2[2089] = a, q2[ba2 + 4 >> 2] = 1 | a, void (q2[a + ba2 >> 2] = a);
                      a = (-8 & $2) + a | 0;
                      g: if ($2 >>> 0 <= 255) $2 >>>= 3, (0 | (v3 = q2[8 + da3 >> 2])) == (0 | (ca3 = q2[12 + da3 >> 2])) ? (ha3 = q2[2087] & dd($2), q2[8348 >> 2] = ha3) : (q2[v3 + 12 >> 2] = ca3, q2[ca3 + 8 >> 2] = v3);
                      else {
                        if (fa2 = q2[24 + da3 >> 2], (0 | da3) != (0 | ($2 = q2[12 + da3 >> 2]))) v3 = q2[8 + da3 >> 2], q2[v3 + 12 >> 2] = $2, q2[$2 + 8 >> 2] = v3;
                        else if ((v3 = q2[(ca3 = 20 + da3 | 0) >> 2]) || (v3 = q2[(ca3 = 16 + da3 | 0) >> 2])) {
                          for (; ; ) if (ea2 = ca3, !((v3 = q2[(ca3 = ($2 = v3) + 20 | 0) >> 2]) || (ca3 = $2 + 16 | 0, v3 = q2[$2 + 16 >> 2]))) break;
                          q2[ea2 >> 2] = 0;
                        } else $2 = 0;
                        if (fa2) {
                          ca3 = q2[28 + da3 >> 2];
                          j: {
                            if (q2[(v3 = 8652 + (ca3 << 2) | 0) >> 2] == (0 | da3)) {
                              if (q2[v3 >> 2] = $2) break j;
                              ha3 = q2[2088] & dd(ca3), q2[8352 >> 2] = ha3;
                              break g;
                            }
                            if (!(q2[fa2 + (q2[fa2 + 16 >> 2] == (0 | da3) ? 16 : 20) >> 2] = $2)) break g;
                          }
                          q2[$2 + 24 >> 2] = fa2, (v3 = q2[16 + da3 >> 2]) && (q2[$2 + 16 >> 2] = v3, q2[v3 + 24 >> 2] = $2), (v3 = q2[20 + da3 >> 2]) && (q2[$2 + 20 >> 2] = v3, q2[v3 + 24 >> 2] = $2);
                        }
                      }
                      if (q2[ba2 + 4 >> 2] = 1 | a, q2[a + ba2 >> 2] = a, q2[2092] != (0 | ba2)) break f;
                      return void (q2[2089] = a);
                    }
                    q2[4 + da3 >> 2] = -2 & $2, q2[ba2 + 4 >> 2] = 1 | a, q2[a + ba2 >> 2] = a;
                  }
                  if (a >>> 0 <= 255) return $2 = 8388 + ((a >>>= 3) << 3) | 0, a = (v3 = q2[2087]) & (a = 1 << a) ? q2[$2 + 8 >> 2] : (q2[2087] = a | v3, $2), q2[$2 + 8 >> 2] = ba2, q2[a + 12 >> 2] = ba2, q2[ba2 + 12 >> 2] = $2, void (q2[ba2 + 8 >> 2] = a);
                  q2[ba2 + 16 >> 2] = 0, v3 = q2[ba2 + 20 >> 2] = 0, (ca3 = a >>> 8) && (v3 = 31, 16777215 < a >>> 0 || (v3 = ca3, v3 = 28 + ((v3 = ((v3 = (v3 <<= ca3 = ca3 + 1048320 >>> 16 & 8) << (fa2 = v3 + 520192 >>> 16 & 4)) << (ea2 = v3 + 245760 >>> 16 & 2) >>> 15) - (ea2 | ca3 | fa2) | 0) << 1 | a >>> v3 + 21 & 1) | 0)), ea2 = 8652 + ((q2[($2 = ba2) + 28 >> 2] = v3) << 2) | 0;
                  m: if ((ca3 = q2[2088]) & ($2 = 1 << v3)) {
                    ca3 = a << (31 == (0 | v3) ? 0 : 25 - (v3 >>> 1) | 0), $2 = q2[ea2 >> 2];
                    n: {
                      for (; ; ) {
                        if ((-8 & q2[(v3 = $2) + 4 >> 2]) == (0 | a)) break n;
                        if ($2 = ca3 >>> 29, ca3 <<= 1, !($2 = q2[(ea2 = v3 + (4 & $2) | 0) + 16 >> 2])) break;
                      }
                      q2[ea2 + 16 >> 2] = ba2, q2[ba2 + 12 >> 2] = ba2, q2[ba2 + 24 >> 2] = v3, q2[ba2 + 8 >> 2] = ba2;
                      break m;
                    }
                    a = q2[v3 + 8 >> 2], q2[a + 12 >> 2] = ba2, q2[v3 + 8 >> 2] = ba2, q2[ba2 + 24 >> 2] = 0, q2[ba2 + 12 >> 2] = v3, q2[ba2 + 8 >> 2] = a;
                  } else q2[2088] = $2 | ca3, q2[ea2 >> 2] = ba2, q2[ba2 + 12 >> 2] = ba2, q2[ba2 + 24 >> 2] = ea2, q2[ba2 + 8 >> 2] = ba2;
                  if (a = q2[2095] + -1 | 0, !(q2[2095] = a)) {
                    for (ba2 = 8804; ; ) if (ba2 = (a = q2[ba2 >> 2]) + 8 | 0, !a) break;
                    q2[2095] = -1;
                  }
                }
              }
            }
            function qa(a) {
              var sa2, ia3 = 0, ja3 = 0, ka3 = 0, la3 = 0, ma3 = 0, na3 = 0, oa3 = 0, pa3 = 0, qa2 = 0, ra3 = 0, ua2 = 0;
              L2 = sa2 = L2 - 16 | 0;
              a: {
                b: {
                  c: {
                    d: {
                      e: {
                        f: {
                          g: {
                            h: {
                              i: {
                                j: {
                                  k: {
                                    if (a >>> 0 <= 244) {
                                      if (3 & (ia3 = (ma3 = q2[2087]) >>> (a = (na3 = a >>> 0 < 11 ? 16 : a + 11 & -8) >>> 3))) {
                                        a = (ia3 = q2[(la3 = (ja3 = a + (1 & (-1 ^ ia3)) | 0) << 3) + 8396 >> 2]) + 8 | 0, (0 | (ka3 = q2[ia3 + 8 >> 2])) == (0 | (la3 = la3 + 8388 | 0)) ? (ua2 = dd(ja3) & ma3, q2[8348 >> 2] = ua2) : (q2[ka3 + 12 >> 2] = la3, q2[la3 + 8 >> 2] = ka3), q2[ia3 + 4 >> 2] = 3 | (ja3 <<= 3), q2[(ia3 = ia3 + ja3 | 0) + 4 >> 2] = 1 | q2[ia3 + 4 >> 2];
                                        break a;
                                      }
                                      if (na3 >>> 0 <= (pa3 = q2[2089]) >>> 0) break k;
                                      if (ia3) {
                                        ja3 = ia3 = (a = (0 - (a = (0 - (ja3 = 2 << a) | ja3) & ia3 << a) & a) - 1 | 0) >>> 12 & 16, ia3 = q2[(ka3 = (ja3 = ((ja3 = (ja3 |= ia3 = (a >>>= ia3) >>> 5 & 8) | (ia3 = (a >>>= ia3) >>> 2 & 4) | (ia3 = (a >>>= ia3) >>> 1 & 2)) | (ia3 = (a >>>= ia3) >>> 1 & 1)) + (a >>> ia3) | 0) << 3) + 8396 >> 2], (0 | (a = q2[ia3 + 8 >> 2])) == (0 | (ka3 = ka3 + 8388 | 0)) ? (ma3 = dd(ja3) & ma3, q2[2087] = ma3) : (q2[a + 12 >> 2] = ka3, q2[ka3 + 8 >> 2] = a), a = ia3 + 8 | 0, q2[ia3 + 4 >> 2] = 3 | na3, q2[(oa3 = ia3 + na3 | 0) + 4 >> 2] = 1 | (la3 = (ja3 <<= 3) - na3 | 0), q2[ia3 + ja3 >> 2] = la3, pa3 && (ia3 = 8388 + ((ja3 = pa3 >>> 3) << 3) | 0, ka3 = q2[2092], ja3 = (ja3 = 1 << ja3) & ma3 ? q2[ia3 + 8 >> 2] : (q2[2087] = ja3 | ma3, ia3), q2[ia3 + 8 >> 2] = ka3, q2[ja3 + 12 >> 2] = ka3, q2[ka3 + 12 >> 2] = ia3, q2[ka3 + 8 >> 2] = ja3), q2[2092] = oa3, q2[2089] = la3;
                                        break a;
                                      }
                                      if (!(ra3 = q2[2088])) break k;
                                      for (ja3 = ia3 = (a = (ra3 & 0 - ra3) - 1 | 0) >>> 12 & 16, ia3 = q2[8652 + (((ja3 = (ja3 |= ia3 = (a >>>= ia3) >>> 5 & 8) | (ia3 = (a >>>= ia3) >>> 2 & 4) | (ia3 = (a >>>= ia3) >>> 1 & 2)) | (ia3 = (a >>>= ia3) >>> 1 & 1)) + (a >>> ia3) << 2) >> 2], ka3 = (-8 & q2[ia3 + 4 >> 2]) - na3 | 0, ja3 = ia3; ; ) {
                                        if (!(a = (a = q2[ja3 + 16 >> 2]) || q2[ja3 + 20 >> 2])) break;
                                        ka3 = (ja3 = (la3 = (-8 & q2[a + 4 >> 2]) - na3 | 0) >>> 0 < ka3 >>> 0) ? la3 : ka3, ia3 = ja3 ? a : ia3, ja3 = a;
                                      }
                                      if (qa2 = q2[ia3 + 24 >> 2], (0 | (la3 = q2[ia3 + 12 >> 2])) != (0 | ia3)) {
                                        a = q2[ia3 + 8 >> 2], q2[a + 12 >> 2] = la3, q2[la3 + 8 >> 2] = a;
                                        break b;
                                      }
                                      if (!(a = q2[(ja3 = ia3 + 20 | 0) >> 2])) {
                                        if (!(a = q2[ia3 + 16 >> 2])) break j;
                                        ja3 = ia3 + 16 | 0;
                                      }
                                      for (; ; ) if (oa3 = ja3, !((a = q2[(ja3 = (la3 = a) + 20 | 0) >> 2]) || (ja3 = la3 + 16 | 0, a = q2[la3 + 16 >> 2]))) break;
                                      q2[oa3 >> 2] = 0;
                                      break b;
                                    }
                                    if (na3 = -1, !(4294967231 < a >>> 0) && (na3 = -8 & (ia3 = a + 11 | 0), pa3 = q2[2088])) {
                                      ja3 = 0 - na3 | 0, ma3 = 0, (ia3 >>>= 8) && (ma3 = 31, 16777215 < na3 >>> 0 || (ma3 = 28 + ((a = ((ma3 = (ia3 <<= ka3 = ia3 + 1048320 >>> 16 & 8) << (a = ia3 + 520192 >>> 16 & 4)) << (ia3 = ma3 + 245760 >>> 16 & 2) >>> 15) - (ia3 | a | ka3) | 0) << 1 | na3 >>> a + 21 & 1) | 0));
                                      q: {
                                        r: {
                                          if (ka3 = q2[8652 + (ma3 << 2) >> 2]) for (ia3 = na3 << (31 == (0 | ma3) ? 0 : 25 - (ma3 >>> 1) | 0), a = 0; ; ) {
                                            if (!(ja3 >>> 0 <= (oa3 = (-8 & q2[ka3 + 4 >> 2]) - na3 | 0) >>> 0 || (la3 = ka3, ja3 = oa3))) {
                                              ja3 = 0, a = ka3;
                                              break r;
                                            }
                                            if (oa3 = q2[ka3 + 20 >> 2], ka3 = q2[16 + ((ia3 >>> 29 & 4) + ka3 | 0) >> 2], a = !oa3 || (0 | oa3) == (0 | ka3) ? a : oa3, ia3 <<= 0 != (0 | ka3), !ka3) break;
                                          }
                                          else a = 0;
                                          if (!(a | la3)) {
                                            if (!(a = (0 - (a = 2 << ma3) | a) & pa3)) break k;
                                            ka3 = ia3 = (a = (a & 0 - a) - 1 | 0) >>> 12 & 16, a = q2[8652 + (((ka3 = (ka3 |= ia3 = (a >>>= ia3) >>> 5 & 8) | (ia3 = (a >>>= ia3) >>> 2 & 4) | (ia3 = (a >>>= ia3) >>> 1 & 2)) | (ia3 = (a >>>= ia3) >>> 1 & 1)) + (a >>> ia3) << 2) >> 2];
                                          }
                                          if (!a) break q;
                                        }
                                        for (; ; ) if (ja3 = (ia3 = (ka3 = (-8 & q2[a + 4 >> 2]) - na3 | 0) >>> 0 < ja3 >>> 0) ? ka3 : ja3, la3 = ia3 ? a : la3, !(a = (ia3 = q2[a + 16 >> 2]) || q2[a + 20 >> 2])) break;
                                      }
                                      if (!(!la3 | ja3 >>> 0 >= q2[2089] - na3 >>> 0)) {
                                        if (oa3 = q2[la3 + 24 >> 2], (0 | la3) != (0 | (ia3 = q2[la3 + 12 >> 2]))) {
                                          a = q2[la3 + 8 >> 2], q2[a + 12 >> 2] = ia3, q2[ia3 + 8 >> 2] = a;
                                          break c;
                                        }
                                        if (!(a = q2[(ka3 = la3 + 20 | 0) >> 2])) {
                                          if (!(a = q2[la3 + 16 >> 2])) break i;
                                          ka3 = la3 + 16 | 0;
                                        }
                                        for (; ; ) if (ma3 = ka3, !((a = q2[(ka3 = (ia3 = a) + 20 | 0) >> 2]) || (ka3 = ia3 + 16 | 0, a = q2[ia3 + 16 >> 2]))) break;
                                        q2[ma3 >> 2] = 0;
                                        break c;
                                      }
                                    }
                                  }
                                  if (na3 >>> 0 <= (ia3 = q2[2089]) >>> 0) {
                                    a = q2[2092], 16 <= (ja3 = ia3 - na3 | 0) >>> 0 ? (q2[2089] = ja3, q2[2092] = ka3 = a + na3 | 0, q2[ka3 + 4 >> 2] = 1 | ja3, q2[a + ia3 >> 2] = ja3, q2[a + 4 >> 2] = 3 | na3) : (q2[2092] = 0, q2[2089] = 0, q2[a + 4 >> 2] = 3 | ia3, q2[(ia3 = a + ia3 | 0) + 4 >> 2] = 1 | q2[ia3 + 4 >> 2]), a = a + 8 | 0;
                                    break a;
                                  }
                                  if (na3 >>> 0 < (ka3 = q2[2090]) >>> 0) {
                                    q2[2090] = ia3 = ka3 - na3 | 0, a = q2[2093], q2[2093] = ja3 = a + na3 | 0, q2[ja3 + 4 >> 2] = 1 | ia3, q2[a + 4 >> 2] = 3 | na3, a = a + 8 | 0;
                                    break a;
                                  }
                                  if ((ja3 = (ma3 = (ja3 = la3 = na3 + 47 | (a = 0)) + (ia3 = q2[2205] ? q2[2207] : (q2[2208] = -1, q2[2209] = -1, q2[2206] = 4096, q2[2207] = 4096, q2[2205] = 12 + sa2 & -16 ^ 1431655768, q2[2210] = 0, q2[2198] = 0, 4096)) | 0) & (oa3 = 0 - ia3 | 0)) >>> 0 <= na3 >>> 0) break a;
                                  if ((ia3 = q2[2197]) && (qa2 = (pa3 = q2[2195]) + ja3 | 0) >>> 0 <= pa3 >>> 0 | ia3 >>> 0 < qa2 >>> 0) break a;
                                  if (4 & r2[8792]) break f;
                                  v: {
                                    w: {
                                      if (ia3 = q2[2093]) for (a = 8796; ; ) {
                                        if ((pa3 = q2[a >> 2]) + q2[a + 4 >> 2] >>> 0 > ia3 >>> 0 && pa3 >>> 0 <= ia3 >>> 0) break w;
                                        if (!(a = q2[a + 8 >> 2])) break;
                                      }
                                      if (-1 == (0 | (ia3 = ea(0)))) break g;
                                      if (ma3 = ja3, (ma3 = (ka3 = (a = q2[2206]) + -1 | 0) & ia3 ? (ja3 - ia3 | 0) + (ia3 + ka3 & 0 - a) | 0 : ma3) >>> 0 <= na3 >>> 0 | 2147483646 < ma3 >>> 0) break g;
                                      if ((a = q2[2197]) && (oa3 = (ka3 = q2[2195]) + ma3 | 0) >>> 0 <= ka3 >>> 0 | a >>> 0 < oa3 >>> 0) break g;
                                      if ((0 | ia3) != (0 | (a = ea(ma3)))) break v;
                                      break e;
                                    }
                                    if (2147483646 < (ma3 = oa3 & ma3 - ka3) >>> 0) break g;
                                    if ((0 | (ia3 = ea(ma3))) == (q2[a >> 2] + q2[a + 4 >> 2] | 0)) break h;
                                    a = ia3;
                                  }
                                  if (!(na3 + 48 >>> 0 <= ma3 >>> 0 | 2147483646 < ma3 >>> 0 | -1 == (0 | (ia3 = a)))) {
                                    if (2147483646 < (a = (a = q2[2207]) + (la3 - ma3 | 0) & 0 - a) >>> 0) break e;
                                    if (-1 != (0 | ea(a))) {
                                      ma3 = a + ma3 | 0;
                                      break e;
                                    }
                                    ea(0 - ma3 | 0);
                                    break g;
                                  }
                                  if (-1 != (0 | ia3)) break e;
                                  break g;
                                }
                                la3 = 0;
                                break b;
                              }
                              ia3 = 0;
                              break c;
                            }
                            if (-1 != (0 | ia3)) break e;
                          }
                          q2[2198] = 4 | q2[2198];
                        }
                        if (2147483646 < ja3 >>> 0) break d;
                        if (ia3 = ea(ja3), (a = ea(0)) >>> 0 <= ia3 >>> 0 | -1 == (0 | ia3) | -1 == (0 | a)) break d;
                        if ((ma3 = a - ia3 | 0) >>> 0 <= na3 + 40 >>> 0) break d;
                      }
                      a = q2[2195] + ma3 | 0, (q2[2195] = a) >>> 0 > t3[2196] && (q2[2196] = a);
                      x: {
                        y: {
                          z: {
                            if (ja3 = q2[2093]) {
                              for (a = 8796; ; ) {
                                if (((ka3 = q2[a >> 2]) + (la3 = q2[a + 4 >> 2]) | 0) == (0 | ia3)) break z;
                                if (!(a = q2[a + 8 >> 2])) break;
                              }
                              break y;
                            }
                            for ((a = q2[2091]) >>> 0 <= ia3 >>> 0 && a || (q2[2091] = ia3), a = 0, q2[2200] = ma3, q2[2199] = ia3, q2[2095] = -1, q2[2096] = q2[2205], q2[2202] = 0; ; ) if (q2[(ja3 = a << 3) + 8396 >> 2] = ka3 = ja3 + 8388 | 0, q2[ja3 + 8400 >> 2] = ka3, 32 == (0 | (a = a + 1 | 0))) break;
                            q2[2090] = ka3 = (a = ma3 + -40 | 0) - (ja3 = ia3 + 8 & 7 ? -8 - ia3 & 7 : 0) | 0, q2[2093] = ja3 = ia3 + ja3 | 0, q2[ja3 + 4 >> 2] = 1 | ka3, q2[4 + (a + ia3 | 0) >> 2] = 40, q2[2094] = q2[2209];
                            break x;
                          }
                          if (!(8 & r2[a + 12 | 0] | ia3 >>> 0 <= ja3 >>> 0 | ja3 >>> 0 < ka3 >>> 0)) {
                            q2[a + 4 >> 2] = la3 + ma3, q2[2093] = ia3 = (a = ja3 + 8 & 7 ? -8 - ja3 & 7 : 0) + ja3 | 0, ka3 = q2[2090] + ma3 | 0, q2[2090] = a = ka3 - a | 0, q2[ia3 + 4 >> 2] = 1 | a, q2[4 + (ja3 + ka3 | 0) >> 2] = 40, q2[2094] = q2[2209];
                            break x;
                          }
                        }
                        ia3 >>> 0 < (la3 = q2[2091]) >>> 0 && (q2[2091] = ia3, la3 = 0), ka3 = ia3 + ma3 | 0, a = 8796;
                        A: {
                          B: {
                            C: {
                              D: {
                                E: {
                                  F: {
                                    for (; ; ) {
                                      if ((0 | ka3) == q2[a >> 2]) break;
                                      if (!(a = q2[a + 8 >> 2])) break F;
                                    }
                                    if (!(8 & r2[a + 12 | 0])) break E;
                                  }
                                  for (a = 8796; ; ) {
                                    if ((ka3 = q2[a >> 2]) >>> 0 <= ja3 >>> 0 && ja3 >>> 0 < (la3 = ka3 + q2[a + 4 >> 2] | 0) >>> 0) break D;
                                    a = q2[a + 8 >> 2];
                                  }
                                }
                                if (q2[a >> 2] = ia3, q2[a + 4 >> 2] = q2[a + 4 >> 2] + ma3, q2[(qa2 = (ia3 + 8 & 7 ? -8 - ia3 & 7 : 0) + ia3 | 0) + 4 >> 2] = 3 | na3, a = ((ia3 = ka3 + (ka3 + 8 & 7 ? -8 - ka3 & 7 : 0) | 0) - qa2 | 0) - na3 | 0, oa3 = na3 + qa2 | 0, (0 | ia3) == (0 | ja3)) {
                                  q2[2093] = oa3, a = q2[2090] + a | 0, q2[2090] = a, q2[oa3 + 4 >> 2] = 1 | a;
                                  break B;
                                }
                                if (q2[2092] == (0 | ia3)) {
                                  q2[2092] = oa3, a = q2[2089] + a | 0, q2[2089] = a, q2[oa3 + 4 >> 2] = 1 | a, q2[a + oa3 >> 2] = a;
                                  break B;
                                }
                                if (1 == (3 & (ja3 = q2[ia3 + 4 >> 2]))) {
                                  ra3 = -8 & ja3;
                                  G: if (ja3 >>> 0 <= 255) la3 = ja3 >>> 3, ja3 = q2[ia3 + 8 >> 2], (0 | (ka3 = q2[ia3 + 12 >> 2])) == (0 | ja3) ? (ua2 = q2[2087] & dd(la3), q2[8348 >> 2] = ua2) : (q2[ja3 + 12 >> 2] = ka3, q2[ka3 + 8 >> 2] = ja3);
                                  else {
                                    if (pa3 = q2[ia3 + 24 >> 2], (0 | (ma3 = q2[ia3 + 12 >> 2])) != (0 | ia3)) ja3 = q2[ia3 + 8 >> 2], q2[ja3 + 12 >> 2] = ma3, q2[ma3 + 8 >> 2] = ja3;
                                    else if ((na3 = q2[(ka3 = ia3 + 20 | 0) >> 2]) || (na3 = q2[(ka3 = ia3 + 16 | 0) >> 2])) {
                                      for (; ; ) if (ja3 = ka3, !((na3 = q2[(ka3 = (ma3 = na3) + 20 | 0) >> 2]) || (ka3 = ma3 + 16 | 0, na3 = q2[ma3 + 16 >> 2]))) break;
                                      q2[ja3 >> 2] = 0;
                                    } else ma3 = 0;
                                    if (pa3) {
                                      ja3 = q2[ia3 + 28 >> 2];
                                      J: {
                                        if (q2[(ka3 = 8652 + (ja3 << 2) | 0) >> 2] == (0 | ia3)) {
                                          if (q2[ka3 >> 2] = ma3) break J;
                                          ua2 = q2[2088] & dd(ja3), q2[8352 >> 2] = ua2;
                                          break G;
                                        }
                                        if (!(q2[pa3 + (q2[pa3 + 16 >> 2] == (0 | ia3) ? 16 : 20) >> 2] = ma3)) break G;
                                      }
                                      q2[ma3 + 24 >> 2] = pa3, (ja3 = q2[ia3 + 16 >> 2]) && (q2[ma3 + 16 >> 2] = ja3, q2[ja3 + 24 >> 2] = ma3), (ja3 = q2[ia3 + 20 >> 2]) && (q2[ma3 + 20 >> 2] = ja3, q2[ja3 + 24 >> 2] = ma3);
                                    }
                                  }
                                  ia3 = ia3 + ra3 | 0, a = a + ra3 | 0;
                                }
                                if (q2[ia3 + 4 >> 2] = -2 & q2[ia3 + 4 >> 2], q2[oa3 + 4 >> 2] = 1 | a, (q2[a + oa3 >> 2] = a) >>> 0 <= 255) {
                                  a = 8388 + ((ia3 = a >>> 3) << 3) | 0, ia3 = (ja3 = q2[2087]) & (ia3 = 1 << ia3) ? q2[a + 8 >> 2] : (q2[2087] = ia3 | ja3, a), q2[a + 8 >> 2] = oa3, q2[ia3 + 12 >> 2] = oa3, q2[oa3 + 12 >> 2] = a, q2[oa3 + 8 >> 2] = ia3;
                                  break B;
                                }
                                if (ia3 = 0, (ka3 = a >>> 8) && (ia3 = 31, 16777215 < a >>> 0 || (ia3 = 28 + ((ia3 = ((na3 = (ka3 <<= la3 = ka3 + 1048320 >>> 16 & 8) << (ia3 = ka3 + 520192 >>> 16 & 4)) << (ka3 = na3 + 245760 >>> 16 & 2) >>> 15) - (ka3 | ia3 | la3) | 0) << 1 | a >>> ia3 + 21 & 1) | 0)), q2[(ja3 = oa3) + 28 >> 2] = ia3, q2[oa3 + 16 >> 2] = 0, ja3 = 8652 + (ia3 << 2) | (q2[oa3 + 20 >> 2] = 0), (ka3 = q2[2088]) & (la3 = 1 << ia3)) {
                                  for (ka3 = a << (31 == (0 | ia3) ? 0 : 25 - (ia3 >>> 1) | 0), ia3 = q2[ja3 >> 2]; ; ) {
                                    if ((-8 & q2[(ja3 = ia3) + 4 >> 2]) == (0 | a)) break C;
                                    if (ia3 = ka3 >>> 29, ka3 <<= 1, !(ia3 = q2[(la3 = (4 & ia3) + ja3 | 0) + 16 >> 2])) break;
                                  }
                                  q2[la3 + 16 >> 2] = oa3;
                                } else q2[2088] = ka3 | la3, q2[ja3 >> 2] = oa3;
                                q2[oa3 + 24 >> 2] = ja3, q2[oa3 + 12 >> 2] = oa3, q2[oa3 + 8 >> 2] = oa3;
                                break B;
                              }
                              for (q2[2090] = oa3 = (a = ma3 + -40 | 0) - (ka3 = ia3 + 8 & 7 ? -8 - ia3 & 7 : 0) | 0, q2[2093] = ka3 = ia3 + ka3 | 0, q2[ka3 + 4 >> 2] = 1 | oa3, q2[4 + (a + ia3 | 0) >> 2] = 40, q2[2094] = q2[2209], q2[(ka3 = (a = (la3 + (la3 + -39 & 7 ? 39 - la3 & 7 : 0) | 0) - 47 | 0) >>> 0 < ja3 + 16 >>> 0 ? ja3 : a) + 4 >> 2] = 27, a = q2[2202], q2[ka3 + 16 >> 2] = q2[2201], q2[ka3 + 20 >> 2] = a, a = q2[2200], q2[ka3 + 8 >> 2] = q2[2199], q2[ka3 + 12 >> 2] = a, q2[2201] = ka3 + 8, q2[2200] = ma3, q2[2199] = ia3, a = ka3 + 24 | (q2[2202] = 0); ; ) if (q2[a + 4 >> 2] = 7, ia3 = a + 8 | 0, a = a + 4 | 0, !(ia3 >>> 0 < la3 >>> 0)) break;
                              if ((0 | ja3) == (0 | ka3)) break x;
                              if (q2[ka3 + 4 >> 2] = -2 & q2[ka3 + 4 >> 2], q2[ja3 + 4 >> 2] = 1 | (la3 = ka3 - ja3 | 0), (q2[ka3 >> 2] = la3) >>> 0 <= 255) {
                                a = 8388 + ((ia3 = la3 >>> 3) << 3) | 0, ia3 = (ka3 = q2[2087]) & (ia3 = 1 << ia3) ? q2[a + 8 >> 2] : (q2[2087] = ia3 | ka3, a), q2[a + 8 >> 2] = ja3, q2[ia3 + 12 >> 2] = ja3, q2[ja3 + 12 >> 2] = a, q2[ja3 + 8 >> 2] = ia3;
                                break x;
                              }
                              if (q2[ja3 + 16 >> 2] = 0, a = q2[ja3 + 20 >> 2] = 0, (ka3 = la3 >>> 8) && (a = 31, 16777215 < la3 >>> 0 || (a = 28 + ((a = ((oa3 = (ka3 <<= ma3 = ka3 + 1048320 >>> 16 & 8) << (a = ka3 + 520192 >>> 16 & 4)) << (ka3 = oa3 + 245760 >>> 16 & 2) >>> 15) - (ka3 | a | ma3) | 0) << 1 | la3 >>> a + 21 & 1) | 0)), ia3 = 8652 + ((q2[(ia3 = ja3) + 28 >> 2] = a) << 2) | 0, (ka3 = q2[2088]) & (ma3 = 1 << a)) {
                                for (a = la3 << (31 == (0 | a) ? 0 : 25 - (a >>> 1) | 0), ia3 = q2[ia3 >> 2]; ; ) {
                                  if ((0 | la3) == (-8 & q2[(ka3 = ia3) + 4 >> 2])) break A;
                                  if (ia3 = a >>> 29, a <<= 1, !(ia3 = q2[(ma3 = ka3 + (4 & ia3) | 0) + 16 >> 2])) break;
                                }
                                q2[ma3 + 16 >> 2] = ja3, q2[ja3 + 24 >> 2] = ka3;
                              } else q2[2088] = ka3 | ma3, q2[ia3 >> 2] = ja3, q2[ja3 + 24 >> 2] = ia3;
                              q2[ja3 + 12 >> 2] = ja3, q2[ja3 + 8 >> 2] = ja3;
                              break x;
                            }
                            a = q2[ja3 + 8 >> 2], q2[a + 12 >> 2] = oa3, q2[ja3 + 8 >> 2] = oa3, q2[oa3 + 24 >> 2] = 0, q2[oa3 + 12 >> 2] = ja3, q2[oa3 + 8 >> 2] = a;
                          }
                          a = qa2 + 8 | 0;
                          break a;
                        }
                        a = q2[ka3 + 8 >> 2], q2[a + 12 >> 2] = ja3, q2[ka3 + 8 >> 2] = ja3, q2[ja3 + 24 >> 2] = 0, q2[ja3 + 12 >> 2] = ka3, q2[ja3 + 8 >> 2] = a;
                      }
                      if (!((a = q2[2090]) >>> 0 <= na3 >>> 0)) {
                        q2[2090] = ia3 = a - na3 | 0, a = q2[2093], q2[2093] = ja3 = a + na3 | 0, q2[ja3 + 4 >> 2] = 1 | ia3, q2[a + 4 >> 2] = 3 | na3, a = a + 8 | 0;
                        break a;
                      }
                    }
                    q2[2086] = 48, a = 0;
                    break a;
                  }
                  Q: if (oa3) {
                    a = q2[la3 + 28 >> 2];
                    R: {
                      if (q2[(ka3 = 8652 + (a << 2) | 0) >> 2] == (0 | la3)) {
                        if (q2[ka3 >> 2] = ia3) break R;
                        pa3 = dd(a) & pa3, q2[2088] = pa3;
                        break Q;
                      }
                      if (!(q2[oa3 + (q2[oa3 + 16 >> 2] == (0 | la3) ? 16 : 20) >> 2] = ia3)) break Q;
                    }
                    q2[ia3 + 24 >> 2] = oa3, (a = q2[la3 + 16 >> 2]) && (q2[ia3 + 16 >> 2] = a, q2[a + 24 >> 2] = ia3), (a = q2[la3 + 20 >> 2]) && (q2[ia3 + 20 >> 2] = a, q2[a + 24 >> 2] = ia3);
                  }
                  S: if (ja3 >>> 0 <= 15) q2[la3 + 4 >> 2] = 3 | (a = ja3 + na3 | 0), q2[(a = a + la3 | 0) + 4 >> 2] = 1 | q2[a + 4 >> 2];
                  else if (q2[la3 + 4 >> 2] = 3 | na3, q2[(ka3 = la3 + na3 | 0) + 4 >> 2] = 1 | ja3, (q2[ja3 + ka3 >> 2] = ja3) >>> 0 <= 255) a = 8388 + ((ia3 = ja3 >>> 3) << 3) | 0, ia3 = (ja3 = q2[2087]) & (ia3 = 1 << ia3) ? q2[a + 8 >> 2] : (q2[2087] = ia3 | ja3, a), q2[a + 8 >> 2] = ka3, q2[ia3 + 12 >> 2] = ka3, q2[ka3 + 12 >> 2] = a, q2[ka3 + 8 >> 2] = ia3;
                  else {
                    a = 0, (na3 = ja3 >>> 8) && (a = 31, 16777215 < ja3 >>> 0 || (a = 28 + ((a = ((oa3 = (na3 <<= ma3 = na3 + 1048320 >>> 16 & 8) << (a = na3 + 520192 >>> 16 & 4)) << (na3 = oa3 + 245760 >>> 16 & 2) >>> 15) - (na3 | a | ma3) | 0) << 1 | ja3 >>> a + 21 & 1) | 0)), q2[(ia3 = ka3) + 28 >> 2] = a, q2[ka3 + 16 >> 2] = 0, ia3 = 8652 + (a << 2) | (q2[ka3 + 20 >> 2] = 0);
                    V: {
                      if ((na3 = 1 << a) & pa3) {
                        for (a = ja3 << (31 == (0 | a) ? 0 : 25 - (a >>> 1) | 0), na3 = q2[ia3 >> 2]; ; ) {
                          if ((-8 & q2[(ia3 = na3) + 4 >> 2]) == (0 | ja3)) break V;
                          if (na3 = a >>> 29, a <<= 1, !(na3 = q2[(ma3 = (4 & na3) + ia3 | 0) + 16 >> 2])) break;
                        }
                        q2[ma3 + 16 >> 2] = ka3;
                      } else q2[2088] = na3 | pa3, q2[ia3 >> 2] = ka3;
                      q2[ka3 + 24 >> 2] = ia3, q2[ka3 + 12 >> 2] = ka3, q2[ka3 + 8 >> 2] = ka3;
                      break S;
                    }
                    a = q2[ia3 + 8 >> 2], q2[a + 12 >> 2] = ka3, q2[ia3 + 8 >> 2] = ka3, q2[ka3 + 24 >> 2] = 0, q2[ka3 + 12 >> 2] = ia3, q2[ka3 + 8 >> 2] = a;
                  }
                  a = la3 + 8 | 0;
                  break a;
                }
                X: if (qa2) {
                  a = q2[ia3 + 28 >> 2];
                  Y: {
                    if (q2[(ja3 = 8652 + (a << 2) | 0) >> 2] == (0 | ia3)) {
                      if (q2[ja3 >> 2] = la3) break Y;
                      ua2 = dd(a) & ra3, q2[8352 >> 2] = ua2;
                      break X;
                    }
                    if (!(q2[qa2 + (q2[qa2 + 16 >> 2] == (0 | ia3) ? 16 : 20) >> 2] = la3)) break X;
                  }
                  q2[la3 + 24 >> 2] = qa2, (a = q2[ia3 + 16 >> 2]) && (q2[la3 + 16 >> 2] = a, q2[a + 24 >> 2] = la3), (a = q2[ia3 + 20 >> 2]) && (q2[la3 + 20 >> 2] = a, q2[a + 24 >> 2] = la3);
                }
                ka3 >>> 0 <= 15 ? (q2[ia3 + 4 >> 2] = 3 | (a = ka3 + na3 | 0), q2[(a = a + ia3 | 0) + 4 >> 2] = 1 | q2[a + 4 >> 2]) : (q2[ia3 + 4 >> 2] = 3 | na3, q2[(na3 = ia3 + na3 | 0) + 4 >> 2] = 1 | ka3, q2[ka3 + na3 >> 2] = ka3, pa3 && (a = 8388 + ((ja3 = pa3 >>> 3) << 3) | 0, la3 = q2[2092], ja3 = (ja3 = 1 << ja3) & ma3 ? q2[a + 8 >> 2] : (q2[2087] = ja3 | ma3, a), q2[a + 8 >> 2] = la3, q2[ja3 + 12 >> 2] = la3, q2[la3 + 12 >> 2] = a, q2[la3 + 8 >> 2] = ja3), q2[2092] = na3, q2[2089] = ka3), a = ia3 + 8 | 0;
              }
              return L2 = 16 + sa2 | 0, a;
            }
            function ra2(a, va3, wa3, xa3, ya3, za2, Aa3) {
              var Qa, Ta, Ba3, Ca3 = 0, Da2 = 0, Fa2 = 0, Ia2 = 0, Ja = 0, Ka2 = 0, Ma2 = 0, Na2 = 0, Oa2 = 0, Pa = 0, Ra = 0, Sa2 = 0;
              q2[76 + (L2 = Ba3 = L2 - 80 | 0) >> 2] = va3, Ta = 55 + Ba3 | 0, Qa = 56 + Ba3 | 0, va3 = 0;
              a: {
                b: {
                  c: for (; ; ) {
                    (0 | Oa2) < 0 || (Oa2 = (2147483647 - Oa2 | 0) < (0 | va3) ? (q2[2086] = 61, -1) : va3 + Oa2 | 0);
                    e: {
                      f: {
                        g: {
                          h: {
                            i: {
                              j: {
                                k: {
                                  l: {
                                    m: {
                                      n: {
                                        o: {
                                          p: {
                                            q: {
                                              if (Ia2 = q2[76 + Ba3 >> 2], Fa2 = r2[0 | (va3 = Ia2)]) {
                                                for (; ; ) {
                                                  r: {
                                                    s: {
                                                      t: if (Ca3 = 255 & Fa2) {
                                                        if (37 != (0 | Ca3)) break s;
                                                        for (Fa2 = va3; ; ) {
                                                          if (37 != r2[va3 + 1 | 0]) break t;
                                                          if (q2[76 + Ba3 >> 2] = Ca3 = va3 + 2 | 0, Fa2 = Fa2 + 1 | 0, Da2 = r2[va3 + 2 | 0], va3 = Ca3, 37 != (0 | Da2)) break;
                                                        }
                                                      } else Fa2 = va3;
                                                      if (va3 = Fa2 - Ia2 | 0, a && Z2(a, Ia2, va3), va3) continue c;
                                                      Pa = -1, Ja = !ha2(o[q2[76 + (Ca3 = Ba3) >> 2] + (Fa2 = 1) | 0]), va3 = q2[76 + Ba3 >> 2], Ja | 36 != r2[va3 + 2 | 0] || (Pa = o[va3 + 1 | 0] + -48 | 0, Ra = 1, Fa2 = 3), q2[Ca3 + 76 >> 2] = va3 = Fa2 + va3 | 0;
                                                      u: if (31 < (Da2 = (Ma2 = o[(Fa2 = 0) | va3]) + -32 | 0) >>> 0) Ca3 = va3;
                                                      else if (Ca3 = va3, 75913 & (Da2 = 1 << Da2)) for (; ; ) {
                                                        if (q2[76 + Ba3 >> 2] = Ca3 = va3 + 1 | 0, Fa2 |= Da2, 31 < (Da2 = (Ma2 = o[va3 + 1 | 0]) + -32 | 0) >>> 0) break u;
                                                        if (va3 = Ca3, !(75913 & (Da2 = 1 << Da2))) break;
                                                      }
                                                      if (42 == (0 | Ma2)) {
                                                        if (Ja = Ba3, ha2(o[Ca3 + 1 | 0]) && (va3 = q2[76 + Ba3 >> 2], 36 == r2[va3 + 2 | 0])) q2[((o[va3 + 1 | 0] << 2) + ya3 | 0) - 192 >> 2] = 10, Na2 = q2[((o[va3 + 1 | 0] << 3) + xa3 | 0) - 384 >> 2], Ra = 1, va3 = va3 + 3 | 0;
                                                        else {
                                                          if (Ra) break b;
                                                          Na2 = Ra = 0, a && (va3 = q2[wa3 >> 2], q2[wa3 >> 2] = va3 + 4, Na2 = q2[va3 >> 2]), va3 = q2[76 + Ba3 >> 2] + 1 | 0;
                                                        }
                                                        q2[Ja + 76 >> 2] = va3, -1 < (0 | Na2) || (Na2 = 0 - Na2 | 0, Fa2 |= 8192);
                                                      } else {
                                                        if ((0 | (Na2 = Ha(76 + Ba3 | 0))) < 0) break b;
                                                        va3 = q2[76 + Ba3 >> 2];
                                                      }
                                                      if (Da2 = -1, 46 == r2[0 | va3]) if (42 == r2[va3 + 1 | 0]) if (ha2(o[va3 + 2 | 0]) && (va3 = q2[76 + Ba3 >> 2], 36 == r2[va3 + 3 | 0])) q2[((o[va3 + 2 | 0] << 2) + ya3 | 0) - 192 >> 2] = 10, Da2 = q2[((o[va3 + 2 | 0] << 3) + xa3 | 0) - 384 >> 2], q2[76 + Ba3 >> 2] = va3 = va3 + 4 | 0;
                                                      else {
                                                        if (Ra) break b;
                                                        Da2 = a ? (va3 = q2[wa3 >> 2], q2[wa3 >> 2] = va3 + 4, q2[va3 >> 2]) : 0, va3 = q2[76 + Ba3 >> 2] + 2 | 0, q2[76 + Ba3 >> 2] = va3;
                                                      }
                                                      else q2[76 + Ba3 >> 2] = va3 + 1, Da2 = Ha(76 + Ba3 | 0), va3 = q2[76 + Ba3 >> 2];
                                                      for (Ca3 = 0; ; ) {
                                                        if (Sa2 = Ca3, Ka2 = -1, 57 < o[0 | va3] + -65 >>> 0) break a;
                                                        if (q2[76 + Ba3 >> 2] = Ma2 = va3 + 1 | 0, Ca3 = o[0 | va3], va3 = Ma2, !((Ca3 = r2[3295 + (Ca3 + w2(Sa2, 58) | 0) | 0]) + -1 >>> 0 < 8)) break;
                                                      }
                                                      if (!Ca3) break a;
                                                      A: {
                                                        B: {
                                                          C: {
                                                            if (19 == (0 | Ca3)) {
                                                              if ((0 | Pa) <= -1) break C;
                                                              break a;
                                                            }
                                                            if ((0 | Pa) < 0) break B;
                                                            q2[(Pa << 2) + ya3 >> 2] = Ca3, Ca3 = q2[(va3 = (Pa << 3) + xa3 | 0) + 4 >> 2], q2[64 + Ba3 >> 2] = q2[va3 >> 2], q2[68 + Ba3 >> 2] = Ca3;
                                                          }
                                                          if (va3 = 0, a) break A;
                                                          continue c;
                                                        }
                                                        if (!a) break e;
                                                        Ga(Ba3 + 64 | 0, Ca3, wa3, Aa3), Ma2 = q2[76 + Ba3 >> 2];
                                                      }
                                                      if (Ja = -65537 & Fa2, Fa2 = 8192 & Fa2 ? Ja : Fa2, Pa = 3336, Ca3 = Qa, va3 = o[Ma2 + -1 | (Ka2 = 0)], (Ma2 = (va3 = Sa2 && 3 == (15 & va3) ? -33 & va3 : va3) + -88 | 0) >>> 0 <= 32) break r;
                                                      D: {
                                                        E: {
                                                          F: {
                                                            G: {
                                                              if (6 < (Ja = va3 + -65 | 0) >>> 0) {
                                                                if (83 != (0 | va3)) break f;
                                                                if (!Da2) break G;
                                                                Ca3 = q2[64 + Ba3 >> 2];
                                                                break E;
                                                              }
                                                              switch (Ja - 1 | 0) {
                                                                case 1:
                                                                  break F;
                                                                case 0:
                                                                case 2:
                                                                  break f;
                                                                default:
                                                                  break q;
                                                              }
                                                            }
                                                            _(a, 32, Na2, va3 = 0, Fa2);
                                                            break D;
                                                          }
                                                          q2[12 + Ba3 >> 2] = 0, q2[8 + Ba3 >> 2] = q2[64 + Ba3 >> 2], q2[64 + Ba3 >> 2] = 8 + Ba3, Da2 = -1, Ca3 = 8 + Ba3 | 0;
                                                        }
                                                        va3 = 0;
                                                        H: {
                                                          for (; ; ) {
                                                            if (!(Ia2 = q2[Ca3 >> 2])) break H;
                                                            if ((Ja = (0 | (Ia2 = Ea(4 + Ba3 | 0, Ia2))) < 0) | Da2 - va3 >>> 0 < Ia2 >>> 0) break;
                                                            if (Ca3 = Ca3 + 4 | 0, !((va3 = va3 + Ia2 | 0) >>> 0 < Da2 >>> 0)) break H;
                                                          }
                                                          if (Ka2 = -1, Ja) break a;
                                                        }
                                                        if (_(a, 32, Na2, va3, Fa2), va3) for (Da2 = 0, Ca3 = q2[64 + Ba3 >> 2]; ; ) {
                                                          if (!(Ia2 = q2[Ca3 >> 2])) break D;
                                                          if ((0 | va3) < (0 | (Da2 = (Ia2 = Ea(4 + Ba3 | 0, Ia2)) + Da2 | 0))) break D;
                                                          if (Z2(a, 4 + Ba3 | 0, Ia2), Ca3 = Ca3 + 4 | 0, !(Da2 >>> 0 < va3 >>> 0)) break;
                                                        }
                                                        else va3 = 0;
                                                      }
                                                      _(a, 32, Na2, va3, 8192 ^ Fa2), va3 = (0 | va3) < (0 | Na2) ? Na2 : va3;
                                                      continue c;
                                                    }
                                                    q2[76 + Ba3 >> 2] = Ca3 = va3 + 1 | 0, Fa2 = r2[va3 + 1 | 0], va3 = Ca3;
                                                    continue;
                                                  }
                                                  break;
                                                }
                                                switch (Ma2 - 1 | 0) {
                                                  case 28:
                                                    break i;
                                                  case 21:
                                                    break j;
                                                  case 23:
                                                    break l;
                                                  case 22:
                                                    break m;
                                                  case 11:
                                                  case 16:
                                                    break n;
                                                  case 10:
                                                    break o;
                                                  case 26:
                                                    break p;
                                                  case 8:
                                                  case 12:
                                                  case 13:
                                                  case 14:
                                                    break q;
                                                  case 0:
                                                  case 1:
                                                  case 2:
                                                  case 3:
                                                  case 4:
                                                  case 5:
                                                  case 6:
                                                  case 7:
                                                  case 9:
                                                  case 15:
                                                  case 17:
                                                  case 18:
                                                  case 19:
                                                  case 20:
                                                  case 24:
                                                  case 25:
                                                  case 27:
                                                  case 29:
                                                  case 30:
                                                    break f;
                                                  default:
                                                    break k;
                                                }
                                              }
                                              if (Ka2 = Oa2, a) break a;
                                              if (!Ra) break e;
                                              for (va3 = 1; ; ) {
                                                if (a = q2[(va3 << 2) + ya3 >> 2]) {
                                                  if (Ga((va3 << 3) + xa3 | 0, a, wa3, Aa3), 10 != (0 | (va3 = va3 + (Ka2 = 1) | 0))) continue;
                                                  break a;
                                                }
                                                break;
                                              }
                                              if (Ka2 = 1, 9 < va3 >>> 0) break a;
                                              if (Ka2 = -1, q2[(va3 << 2) + ya3 >> 2]) break a;
                                              for (; ; ) if (q2[((va3 = va3 + 1 | 0) << 2) + ya3 >> 2] || 10 == (0 | va3)) break;
                                              Ka2 = va3 >>> 0 < 10 ? -1 : 1;
                                              break a;
                                            }
                                            va3 = 0 | n2[za2](a, v2[64 + Ba3 >> 3], Na2, Da2, Fa2, va3);
                                            continue;
                                          }
                                          Ca3 = (va3 = La(Ia2 = (va3 = q2[64 + Ba3 >> 2]) || 3346, Da2)) || Da2 + Ia2 | 0, Fa2 = Ja, Da2 = va3 ? va3 - Ia2 | 0 : Da2;
                                          break f;
                                        }
                                        o[55 + Ba3 | 0] = q2[64 + Ba3 >> 2], Da2 = 1, Ia2 = Ta, Fa2 = Ja;
                                        break f;
                                      }
                                      if (va3 = Ja = q2[68 + Ba3 >> 2], Ia2 = q2[64 + Ba3 >> 2], (0 | va3) < -1 || (0 | va3) <= -1 && !(4294967295 < Ia2 >>> 0)) {
                                        va3 = 0 - (va3 + (0 < Ia2 >>> 0) | 0) | 0, q2[64 + Ba3 >> 2] = Ia2 = 0 - Ia2 | 0, q2[68 + Ba3 >> 2] = va3, Ka2 = 1, Pa = 3336;
                                        break h;
                                      }
                                      if (2048 & Fa2) {
                                        Ka2 = 1, Pa = 3337;
                                        break h;
                                      }
                                      Pa = (Ka2 = 1 & Fa2) ? 3338 : 3336;
                                      break h;
                                    }
                                    if (Ia2 = function(a2, Il, Rm) {
                                      if (a2 | Il) {
                                        for (; ; ) if (o[0 | (Rm = Rm + -1 | 0)] = 7 & a2 | 48, !((a2 = (7 & Il) << 29 | a2 >>> 3) | (Il >>>= 3))) break;
                                      }
                                      return Rm;
                                    }(q2[64 + Ba3 >> 2], q2[68 + Ba3 >> 2], Qa), !(8 & Fa2)) break g;
                                    Da2 = (0 | (va3 = Qa - Ia2 | 0)) < (0 | Da2) ? Da2 : va3 + 1 | 0;
                                    break g;
                                  }
                                  Da2 = 8 < Da2 >>> 0 ? Da2 : 8, Fa2 |= 8, va3 = 120;
                                }
                                if (Ia2 = function(a2, Il, Rm, Sm) {
                                  if (a2 | Il) {
                                    for (; ; ) if (o[0 | (Rm = Rm + -1 | 0)] = r2[3824 + (15 & a2) | 0] | Sm, !((a2 = (15 & Il) << 28 | a2 >>> 4) | (Il >>>= 4))) break;
                                  }
                                  return Rm;
                                }(q2[64 + Ba3 >> 2], q2[68 + Ba3 >> 2], Qa, 32 & va3), !(8 & Fa2) | !(q2[64 + Ba3 >> 2] | q2[68 + Ba3 >> 2])) break g;
                                Pa = 3336 + (va3 >>> 4) | 0, Ka2 = 2;
                                break g;
                              }
                              if (7 < (Ca3 = 255 & Sa2) >>> (va3 = 0)) continue;
                              I: switch (Ca3 - 1 | 0) {
                                default:
                                case 0:
                                  q2[q2[64 + Ba3 >> 2] >> 2] = Oa2;
                                  continue;
                                case 1:
                                  Ca3 = q2[64 + Ba3 >> 2], q2[Ca3 >> 2] = Oa2, q2[Ca3 + 4 >> 2] = Oa2 >> 31;
                                  continue;
                                case 2:
                                  p2[q2[64 + Ba3 >> 2] >> 1] = Oa2;
                                  continue;
                                case 3:
                                  o[q2[64 + Ba3 >> 2]] = Oa2;
                                  continue;
                                case 5:
                                  q2[q2[64 + Ba3 >> 2] >> 2] = Oa2;
                                  continue;
                                case 4:
                                  continue;
                                case 6:
                                  break I;
                              }
                              Ca3 = q2[64 + Ba3 >> 2], q2[Ca3 >> 2] = Oa2, q2[Ca3 + 4 >> 2] = Oa2 >> 31;
                              continue;
                            }
                            Ia2 = q2[64 + Ba3 >> 2], va3 = q2[68 + Ba3 >> 2], Pa = 3336;
                          }
                          Ia2 = ga(Ia2, va3, Qa);
                        }
                        Fa2 = -1 < (0 | Da2) ? -65537 & Fa2 : Fa2, Da2 = !!((Ja = va3 = q2[68 + Ba3 >> 2]) | (Ma2 = q2[64 + Ba3 >> 2])) | Da2 ? (0 | (va3 = !(Ja | Ma2) + (Qa - Ia2 | 0) | 0)) < (0 | Da2) ? Da2 : va3 : (Ia2 = Qa, 0);
                      }
                      _(a, 32, va3 = (0 | Na2) < (0 | (Ca3 = (Da2 = (0 | Da2) < (0 | (Ja = Ca3 - Ia2 | 0)) ? Ja : Da2) + Ka2 | 0)) ? Ca3 : Na2, Ca3, Fa2), Z2(a, Pa, Ka2), _(a, 48, va3, Ca3, 65536 ^ Fa2), _(a, 48, Da2, Ja, 0), Z2(a, Ia2, Ja), _(a, 32, va3, Ca3, 8192 ^ Fa2);
                      continue;
                    }
                    break;
                  }
                  Ka2 = 0;
                  break a;
                }
                Ka2 = -1;
              }
              return L2 = 80 + Ba3 | 0, Ka2;
            }
            function sa(a) {
              var ya3, va3 = 0, wa3 = 0, xa3 = 0, za2 = 0, xa3 = 4, wa3 = 1439;
              a: if (va3 = r2[0 | a]) {
                for (; ; ) {
                  if ((0 | (ya3 = r2[0 | wa3])) != (0 | va3) || !(xa3 = xa3 + -1 | 0) | !ya3) break;
                  if (wa3 = wa3 + 1 | 0, va3 = r2[a + 1 | 0], a = a + 1 | 0, !va3) break a;
                }
                za2 = va3;
              }
              return (255 & za2) - r2[0 | wa3] | 0;
            }
            function ta2(a, Aa3, Ea2) {
              var La2, Ga2, Ha2 = 0, Ua = 0, Va = 0;
              q2[(L2 = Ga2 = L2 - 240 | 0) >> 2] = a, Ua = 1;
              a: if (!((0 | Aa3) < 2)) for (Ha2 = a; ; ) {
                if (Ha2 = (La2 = Ha2 + -4 | 0) - q2[((Va = Aa3 + -2 | 0) << 2) + Ea2 >> 2] | 0, 0 <= (0 | n2[5](a, Ha2)) && -1 < (0 | n2[5](a, La2))) break a;
                if (a = (Ua << 2) + Ga2 | 0, 0 <= (0 | n2[5](Ha2, La2)) ? (q2[a >> 2] = Ha2, Va = Aa3 + -1 | 0) : Ha2 = q2[a >> 2] = La2, Ua = Ua + 1 | 0, (0 | Va) < 2) break a;
                a = q2[Ga2 >> 2], Aa3 = Va;
              }
              Na(Ga2, Ua), L2 = 240 + Ga2 | 0;
            }
            function ua(a) {
              var Ea2, ab, Aa3 = 0;
              x2(0);
              if (!function(a2) {
                var Vg = 0, Wg = 0;
                q2[a2 + 428 >> 2] && (Wg = q2[a2 + 332 >> 2], Vg = Wg << 2, $(q2[a2 + 460 >> 2], q2[a2 + 436 >> 2], Vg), $(q2[a2 + 464 >> 2], q2[a2 + 440 >> 2], Vg), $(q2[a2 + 468 >> 2], q2[a2 + 448 >> 2], Vg), r2[q2[a2 >> 2] + 4 | 0] < 4 || (Vg = Wg << 4, $(q2[a2 + 472 >> 2], q2[a2 + 452 >> 2], Vg), $(q2[a2 + 476 >> 2], q2[a2 + 456 >> 2], Vg)));
              }(a), !function(a2) {
                var fe = 0, ge = x2(0), he = x2(0), ie = 0, je = x2(0), ke = 0, le = x2(0), me = 0, ne = x2(0);
                if (1 <= (0 | (ie = q2[a2 >> 2]))) {
                  for (fe = q2[a2 + 4 >> 2], me = fe + w2(ie, 52) | 0, a2 = q2[a2 + 12 >> 2]; ; ) if (ge = u2[a2 >> 2], ne = u2[fe + 44 >> 2], ke = q2[fe + 16 >> 2], ge = ke ? (he = ge, ge = u2[fe + 4 >> 2], je = u2[fe + 12 >> 2], he = x2(x2(he - ge) / je), le = x2(C2(he)), ie = x2(y2(le)) < x2(2147483648) ? ~~le : -2147483648, x2(ge + x2(je * x2(he - x2(0 | ie))))) : (je = u2[fe + 4 >> 2], he = u2[fe + 8 >> 2], ge < je ? je : he < ge ? he : ge), ne != ge ? (u2[fe + 44 >> 2] = ge, q2[fe + 48 >> 2] = 1) : q2[fe + 48 >> 2] = 0, ke || (u2[a2 >> 2] = ge), a2 = a2 + 4 | 0, !((fe = fe + 52 | 0) >>> 0 < me >>> 0)) break;
                }
              }(a + 540 | 0), !function(a2) {
                var Rd = 0, Sd = 0, Td = x2(0), Ud = 0, Vd = x2(0), Wd = x2(0), Xd = x2(0), Yd = 0, Zd = x2(0), _d = 0, $d = 0, ae = 0, be = 0, ce = x2(0), de = 0, ee = 0;
                if (1 <= (0 | (Ud = q2[a2 + 540 >> 2]))) for (Yd = q2[a2 + 544 >> 2], de = Yd + w2(Ud, 52) | 0, ee = q2[a2 + 644 >> 2]; ; ) {
                  a: if (!(q2[Yd >> 2] || (0 | (Ud = q2[Yd + 32 >> 2])) < 1)) if (a2 = q2[Yd + 28 >> 2], ae = a2 + w2(Ud, 28) | 0, ce = u2[Yd + 24 >> 2], Xd = u2[Yd + 20 >> 2], Wd = u2[Yd + 44 >> 2], ee) for (; ; ) {
                    Zd = x2($d = 0);
                    h: {
                      i: {
                        j: {
                          if ((0 | (Sd = q2[a2 >> 2])) < 1) Rd = Ud = 0;
                          else if (_d = q2[a2 + 4 >> 2], Vd = u2[_d >> 2], Td = x2(Vd - Xd), 1 == (0 | Sd)) Ud = Wd < x2(Xd + Vd) ^ 1 | Td < Wd ^ 1, Rd = 0;
                          else {
                            if (Wd < Td) {
                              Ud = 1, Rd = 0;
                              break i;
                            }
                            if (Ud = 0, Wd < x2(Xd + Vd)) Rd = 0;
                            else {
                              if (Rd = 1, Td = u2[_d + 4 >> 2], !(Wd < x2(Xd + Td))) for (; ; ) {
                                if ((0 | Sd) == (0 | (Rd = Rd + 1 | 0))) break j;
                                if (Vd = Td, Td = u2[_d + (Rd << 2) >> 2], Wd < x2(Xd + Td)) break;
                              }
                              x2(Td - Xd) < Wd || (Rd = Rd + -1 | 0, (Td = x2(Td - Vd)) < ce) || (Zd = x2(x2(Wd - Vd) / Td));
                            }
                          }
                          if (Ud) break i;
                          if (_d = Sd = 1, q2[a2 + 16 >> 2]) break h;
                          break i;
                        }
                        Rd = Sd + -1 | 0, Ud = 1;
                      }
                      Vd = u2[a2 + 12 >> 2], _d = (Sd = Vd != Zd) & (Zd == x2(0) | Vd == x2(0)) | q2[a2 + 8 >> 2] != (0 | Rd), $d = Ud;
                    }
                    if (q2[a2 + 20 >> 2] = _d, q2[a2 + 24 >> 2] = Sd, u2[a2 + 12 >> 2] = Zd, q2[a2 + 16 >> 2] = $d, q2[a2 + 8 >> 2] = Rd, !((a2 = a2 + 28 | 0) >>> 0 < ae >>> 0)) break;
                  }
                  else {
                    if (!q2[Yd + 48 >> 2]) {
                      for (; ; ) if (q2[a2 + 20 >> 2] = 0, q2[a2 + 24 >> 2] = 0, !((a2 = a2 + 28 | 0) >>> 0 < ae >>> 0)) break a;
                    }
                    for (; ; ) {
                      Zd = x2($d = 0), Rd = q2[(_d = a2) >> 2], Sd = 0;
                      b: {
                        c: {
                          d: {
                            e: if (!((0 | Rd) < 1)) {
                              if (Ud = q2[a2 + 4 >> 2], Vd = u2[Ud >> 2], Td = x2(Vd - Xd), 1 != (0 | Rd)) {
                                if (!(Wd < Td)) {
                                  if (Sd = 0, Wd < x2(Xd + Vd)) break e;
                                  Sd = 1;
                                  f: if (Td = u2[Ud + 4 >> 2], !(Wd < x2(Xd + Td))) {
                                    for (Rd = Rd + -1 | 0; ; ) {
                                      if (Vd = Td, (0 | Rd) == (0 | Sd)) break;
                                      if (Td = u2[Ud + ((Sd = Sd + 1 | 0) << 2) >> 2], Wd < x2(Xd + Td)) break f;
                                    }
                                    Ud = 1;
                                    break c;
                                  }
                                  if (Ud = 0, x2(Td - Xd) < Wd) {
                                    Rd = Sd;
                                    break d;
                                  }
                                  if (Rd = Sd + -1 | 0, (Td = x2(Td - Vd)) < ce) break d;
                                  Zd = x2(x2(Wd - Vd) / Td);
                                  break d;
                                }
                                Ud = 1, Rd = 0;
                                break c;
                              }
                              Sd = Wd < x2(Xd + Vd) ^ 1 | Td < Wd ^ 1;
                            }
                            Ud = Sd, Rd = 0;
                          }
                          if (!Ud && (be = Sd = 1, q2[a2 + 16 >> 2])) break b;
                        }
                        $d = Ud, Vd = u2[a2 + 12 >> 2], be = (Sd = Vd != Zd) & (Zd == x2(0) | Vd == x2(0)) | q2[a2 + 8 >> 2] != (0 | Rd);
                      }
                      if (q2[_d + 20 >> 2] = be, q2[a2 + 24 >> 2] = Sd, u2[a2 + 12 >> 2] = Zd, q2[a2 + 16 >> 2] = $d, q2[a2 + 8 >> 2] = Rd, !((a2 = a2 + 28 | 0) >>> 0 < ae >>> 0)) break;
                    }
                  }
                  if (!((Yd = Yd + 52 | 0) >>> 0 < de >>> 0)) break;
                }
              }(a), !function(a2) {
                var kd = 0, ld = x2(0), md = 0, nd = 0, od = x2(0), pd = 0, qd = x2(0), rd = x2(0), sd = 0, td = 0, ud = 0, vd = 0;
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (0 | (kd = q2[a2 + 540 >> 2])) < 1)) for (pd = q2[a2 + 544 >> 2], ud = pd + w2(kd, 52) | 0, vd = q2[a2 + 644 >> 2]; ; ) {
                  b: if (1 == q2[pd >> 2] && !((0 | (kd = q2[pd + 40 >> 2])) < 1)) if (a2 = q2[pd + 36 >> 2], sd = a2 + w2(kd, 28) | 0, rd = u2[pd + 44 >> 2], vd) for (; ; ) {
                    qd = x2(kd = 0), nd = q2[a2 >> 2];
                    d: if (!((0 | nd) < 2 || (md = q2[a2 + 4 >> 2], ld = u2[md >> 2], rd <= ld))) {
                      kd = 1;
                      e: if (od = u2[md + 4 >> 2], !(rd < od)) {
                        for (; ; ) {
                          if (ld = od, (0 | nd) == (0 | (kd = kd + 1 | 0))) break;
                          if (od = u2[md + (kd << 2) >> 2], rd < od) break e;
                        }
                        kd = nd + -1 | 0;
                        break d;
                      }
                      qd = x2(x2(rd - ld) / x2(od - ld)), kd = kd + -1 | 0;
                    }
                    if (ld = u2[a2 + 16 >> 2], u2[a2 + 16 >> 2] = qd, nd = q2[a2 + 12 >> 2], q2[a2 + 12 >> 2] = kd, md = ld != qd, q2[a2 + 24 >> 2] = md, q2[a2 + 20 >> 2] = md & (qd == x2(0) | ld == x2(0)) | (0 | kd) != (0 | nd), !((a2 = a2 + 28 | 0) >>> 0 < sd >>> 0)) break;
                  }
                  else {
                    if (!q2[pd + 48 >> 2]) {
                      for (; ; ) if (q2[a2 + 20 >> 2] = 0, q2[a2 + 24 >> 2] = 0, !((a2 = a2 + 28 | 0) >>> 0 < sd >>> 0)) break b;
                    }
                    for (; ; ) {
                      qd = x2(nd = 0), td = q2[a2 >> 2];
                      c: if (!((0 | td) < 2 || (md = q2[a2 + 4 >> 2], ld = u2[md >> 2], rd <= ld))) {
                        if (kd = 1, od = u2[md + 4 >> 2], !(rd < od)) for (nd = td + -1 | 0; ; ) {
                          if (ld = od, (0 | kd) == (0 | nd)) break c;
                          if (od = u2[md + ((kd = kd + 1 | 0) << 2) >> 2], rd < od) break;
                        }
                        qd = x2(x2(rd - ld) / x2(od - ld)), nd = kd + -1 | 0;
                      }
                      if (ld = u2[a2 + 16 >> 2], u2[a2 + 16 >> 2] = qd, kd = q2[a2 + 12 >> 2], q2[a2 + 12 >> 2] = nd, md = ld != qd, q2[a2 + 24 >> 2] = md, q2[a2 + 20 >> 2] = md & (qd == x2(0) | ld == x2(0)) | (0 | kd) != (0 | nd), !((a2 = a2 + 28 | 0) >>> 0 < sd >>> 0)) break;
                    }
                  }
                  if (!((pd = pd + 52 | 0) >>> 0 < ud >>> 0)) break;
                }
              }(a), !function(a2) {
                var wd = 0, xd = 0, yd = 0, zd = 0, Ad = 0, Bd = 0, Cd = 0, Dd = x2(0), Ed = 0, Fd = 0, Gd = 0, Hd = 0, Id6 = 0, Jd = 0, Kd = 0, Ld = 0, Md = 0, Nd = 0, Od = 0, Pd = 0, Qd = 0;
                if (1 <= (0 | (xd = q2[a2 + 564 >> 2]))) for (Ad = q2[a2 + 568 >> 2], Pd = Ad + w2(xd, 36) | 0, Nd = q2[a2 + 644 >> 2]; ; ) {
                  yd = zd = xd = 0, Jd = q2[Ad + 4 >> 2];
                  a: {
                    if (!(Bd = (0 | Jd) < 1)) for (Ed = q2[Ad >> 2], a2 = Kd = 0; ; ) {
                      if (wd = q2[Ed + (a2 << 2) >> 2], q2[wd + 16 >> 2]) {
                        wd = 1, Ld = 0;
                        break a;
                      }
                      if (yd = yd || q2[wd + 24 >> 2], xd = xd || q2[wd + 20 >> 2], zd = (u2[wd + 12 >> 2] != x2(0)) + zd | 0, (0 | Jd) == (0 | (a2 = a2 + 1 | 0))) break;
                    }
                    if (wd = 0, (Kd = Nd ? 1 : yd) | (Ld = Nd ? 1 : xd) && (Ed = 1 << zd, q2[Ad + 12 >> 2] = Ed, 31 != (0 | zd))) {
                      for (xd = q2[Ad + 20 >> 2], Od = q2[Ad >> 2], a2 = q2[Ad + 16 >> 2], yd = a2 + (Cd = Ed << 2) | 0, yd = ca2(Fd = a2, 0, 4 + ((Md = -1 ^ a2) + ((a2 = a2 + 4 | 0) >>> 0 < yd >>> 0 ? yd : a2) | 0) & -4), Cd = xd + Cd | 0, a2 = xd; ; ) if (q2[a2 >> 2] = 1065353216, !((a2 = a2 + 4 | 0) >>> 0 < Cd >>> 0)) break;
                      if (!Bd) {
                        if (Bd = 0, Cd = wd = 1, zd) for (; ; ) {
                          if (zd = q2[(Bd << 2) + Od >> 2], Gd = q2[zd + 8 >> 2], Hd = w2(Gd, wd), a2 = 0, (Dd = u2[zd + 12 >> 2]) != x2(0)) {
                            for (q2[yd >> 2] = Hd + q2[yd >> 2], u2[xd >> 2] = x2(x2(1) - Dd) * u2[xd >> 2], Gd = w2(Gd + (a2 = 1) | 0, wd); ; ) if (Dd = u2[zd + 12 >> 2], Qd = q2[(Md = Fd = (Id6 = a2 << 2) + yd | 0) >> 2], Fd = a2 & Cd, q2[Md >> 2] = Qd + (Fd ? Gd : Hd), u2[(Id6 = xd + Id6 | 0) >> 2] = (Fd ? Dd : x2(x2(1) - Dd)) * u2[Id6 >> 2], (0 | Ed) == (0 | (a2 = a2 + 1 | 0))) break;
                            Cd <<= 1;
                          } else for (; ; ) if (q2[(Gd = yd + (a2 << 2) | 0) >> 2] = Hd + q2[Gd >> 2], (0 | Ed) == (0 | (a2 = a2 + 1 | 0))) break;
                          if (wd = w2(q2[zd >> 2], wd), (0 | Jd) == (0 | (Bd = Bd + 1 | 0))) break;
                        }
                        else for (; ; ) {
                          if (zd = q2[(Bd << 2) + Od >> 2], Cd = w2(q2[zd + 8 >> 2], wd), a2 = 0, (Dd = u2[zd + 12 >> 2]) != x2(0)) q2[yd >> 2] = Cd + q2[yd >> 2], u2[xd >> 2] = x2(x2(1) - Dd) * u2[xd >> 2];
                          else for (; ; ) if (q2[(Hd = yd + (a2 << 2) | 0) >> 2] = Cd + q2[Hd >> 2], (0 | Ed) == (0 | (a2 = a2 + 1 | 0))) break;
                          if (wd = w2(q2[zd >> 2], wd), (0 | Jd) == (0 | (Bd = Bd + 1 | 0))) break;
                        }
                        wd = 0;
                      }
                    }
                  }
                  if (q2[Ad + 32 >> 2] = wd, q2[Ad + 24 >> 2] = Ld, q2[Ad + 28 >> 2] = Kd, !((Ad = Ad + 36 | 0) >>> 0 < Pd >>> 0)) break;
                }
              }(a), !function(a2) {
                var Wc = x2(0), Xc = 0, Yc = 0, Zc2 = 0, _c = 0, $c = 0, ad2 = x2(0), bd2 = x2(0), cd = x2(0), dd2 = 0, ed = 0, fd = 0, gd = 0, hd = 0, id = 0, jd = 0;
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (0 | (Xc = q2[a2 + 588 >> 2])) < 1)) for (Zc2 = q2[a2 + 592 >> 2], jd = Zc2 + w2(Xc, 48) | 0, gd = q2[a2 + 644 >> 2]; ; ) {
                  if (a2 = q2[Zc2 >> 2], ed = gd ? 1 : q2[a2 + 20 >> 2], fd = gd ? 1 : q2[a2 + 24 >> 2], ed | fd) {
                    c: {
                      d: {
                        $c = Zc2, _c = q2[a2 + 8 >> 2], Xc = q2[a2 + 12 >> 2], Wc = u2[a2 + 16 >> 2], a2 = (0 | _c) != (0 | Xc);
                        e: {
                          if (Wc != x2(0)) {
                            if (a2 = Xc + 1 | 0, (0 | Xc) == (0 | _c)) {
                              ed = 1, q2[Zc2 + 8 >> 2] = 1, Wc = x2(x2(1) - Wc), fd = 1;
                              break e;
                            }
                            a2 = (0 | a2) == (0 | _c) ? 1 : 2;
                          }
                          if (q2[$c + 8 >> 2] = a2, !fd) break d;
                          a2 = Xc;
                        }
                        u2[Zc2 + 24 >> 2] = Wc, u2[Zc2 + 20 >> 2] = x2(1) - Wc;
                        break c;
                      }
                      fd = 0, a2 = Xc;
                    }
                    ed ? (q2[Zc2 + 12 >> 2] = a2, q2[Zc2 + 16 >> 2] = a2 + 1) : ed = 0;
                  } else ed = fd = 0;
                  g: if ((0 | (hd = q2[Zc2 + 36 >> 2])) < 1) cd = x2(1);
                  else {
                    if (id = q2[Zc2 + 40 >> 2], a2 = 0, cd = x2(1), !gd) for (; ; ) {
                      h: {
                        i: {
                          if (Xc = q2[(a2 << 2) + id >> 2], Yc = q2[Xc >> 2]) {
                            if (!q2[Yc + 48 >> 2]) {
                              Wc = u2[Xc + 16 >> 2];
                              break h;
                            }
                            if ((0 | (_c = q2[Xc + 12 >> 2])) < 1) {
                              Wc = x2(1), u2[Xc + 16 >> 2] = 1;
                              break h;
                            }
                            if (dd2 = q2[Xc + 8 >> 2], 1 != (0 | _c) && (ad2 = u2[Yc + 44 >> 2], $c = q2[Xc + 4 >> 2], bd2 = u2[$c >> 2], !(ad2 <= bd2))) break i;
                            Wc = u2[dd2 >> 2], u2[Xc + 16 >> 2] = Wc;
                            break h;
                          }
                          q2[Xc + 16 >> 2] = 1065353216, Wc = x2(1);
                          break h;
                        }
                        Yc = 1;
                        j: if (Wc = u2[$c + 4 >> 2], !(ad2 < Wc)) {
                          for (; ; ) {
                            if (bd2 = Wc, (0 | _c) == (0 | (Yc = Yc + 1 | 0))) break;
                            if (Wc = u2[$c + (Yc << 2) >> 2], ad2 < Wc) break j;
                          }
                          Wc = u2[(dd2 + (_c << 2) | 0) - 4 >> 2], u2[Xc + 16 >> 2] = Wc;
                          break h;
                        }
                        $c = Xc, Wc = x2(x2(ad2 - bd2) / x2(Wc - bd2)), Wc = x2(x2(Wc * u2[(Xc = dd2 + (Yc << 2) | 0) >> 2]) + x2(u2[Xc + -4 >> 2] * x2(x2(1) - Wc))), u2[$c + 16 >> 2] = Wc;
                      }
                      if (cd = cd < Wc ? cd : Wc, (0 | hd) == (0 | (a2 = a2 + 1 | 0))) break g;
                    }
                    for (; ; ) {
                      Xc = q2[(a2 << 2) + id >> 2], Yc = q2[Xc >> 2], Wc = x2(1);
                      l: if (Yc && (dd2 = q2[Xc + 12 >> 2], Wc = x2(1), !((0 | dd2) < 1)) && (_c = q2[Xc + 8 >> 2], Wc = u2[_c >> 2], 1 != (0 | dd2))) {
                        m: {
                          if (ad2 = u2[Yc + 44 >> 2], $c = q2[Xc + 4 >> 2], bd2 = u2[$c >> 2], ad2 <= bd2) {
                            Wc = u2[_c >> 2];
                            break l;
                          }
                          if (Yc = 1, Wc = u2[$c + 4 >> 2], !(ad2 < Wc)) {
                            for (; ; ) {
                              if (bd2 = Wc, (0 | dd2) == (0 | (Yc = Yc + 1 | 0))) break;
                              if (Wc = u2[$c + (Yc << 2) >> 2], ad2 < Wc) break m;
                            }
                            Wc = u2[(_c + (dd2 << 2) | 0) - 4 >> 2];
                            break l;
                          }
                        }
                        Wc = x2(x2(ad2 - bd2) / x2(Wc - bd2)), Wc = x2(x2(Wc * u2[(Yc = _c + (Yc << 2) | 0) >> 2]) + x2(u2[Yc + -4 >> 2] * x2(x2(1) - Wc)));
                      }
                      if (u2[Xc + 16 >> 2] = Wc, cd = cd < Wc ? cd : Wc, (0 | hd) == (0 | (a2 = a2 + 1 | 0))) break;
                    }
                  }
                  if (q2[Zc2 + 32 >> 2] = fd, q2[Zc2 + 28 >> 2] = ed, u2[Zc2 + 44 >> 2] = cd, !((Zc2 = Zc2 + 48 | 0) >>> 0 < jd >>> 0)) break;
                }
              }(a), 1 <= (0 | (Ea2 = q2[a + 4 >> 2]))) {
                for (Ea2 = (Aa3 = q2[a + 52 >> 2]) + (Ea2 << 2) | 0; ; ) if (ab = u2[Aa3 >> 2], u2[Aa3 >> 2] = ab < x2(0) ? x2(0) : x2(A(ab, x2(1))), !((Aa3 = Aa3 + 4 | 0) >>> 0 < Ea2 >>> 0)) break;
              }
              !function(a2) {
                var De = 0, Ee = 0, Fe = 0, Ge = 0, He = 0;
                if (1 <= (0 | (Ee = q2[a2 + 4 >> 2]))) {
                  for (De = q2[a2 + 8 >> 2], He = De + w2(Ee, 12) | 0, Fe = q2[a2 + 40 >> 2], a2 = Fe; ; ) if (Ee = 0, q2[De + 8 >> 2] && (Ge = q2[De + 4 >> 2], !q2[(Ge << 2) + Fe >> 2] && -1 != (0 | Ge) || (Ee = !q2[q2[De >> 2] + 32 >> 2])), q2[a2 >> 2] = Ee, a2 = a2 + 4 | 0, !((De = De + 12 | 0) >>> 0 < He >>> 0)) break;
                }
              }(a), function(a2) {
                var pg = 0, qg = 0, rg = 0, sg = 0, tg = 0, ug = 0, vg = 0, wg = 0, xg = 0, yg = 0, zg = 0, Ag = 0;
                if (1 <= (0 | (vg = q2[a2 + 4 >> 2]))) for (xg = q2[a2 + 8 >> 2], wg = q2[a2 >> 2], yg = q2[wg + 724 >> 2]; ; ) {
                  if (rg = q2[w2(tg, 12) + xg >> 2], (q2[rg + 28 >> 2] || q2[rg + 24 >> 2]) && (q2[(pg = tg << 2) + q2[a2 + 28 >> 2] >> 2] = q2[rg + 12 >> 2], q2[rg + 24 >> 2]) && !((0 | (sg = q2[rg + 12 >> 2])) < 1)) {
                    for (qg = q2[rg + 16 >> 2], sg = qg + (sg << 2) | 0, zg = q2[pg + yg >> 2], pg = q2[a2 + 36 >> 2] + (ug << 2) | 0, Ag = q2[wg + 976 >> 2]; ; ) if (q2[pg >> 2] = q2[(q2[qg >> 2] + zg << 2) + Ag >> 2], pg = pg + 4 | 0, !((qg = qg + 4 | 0) >>> 0 < sg >>> 0)) break;
                  }
                  if (q2[rg + 28 >> 2] && !((0 | (pg = q2[rg + 12 >> 2])) < 1)) {
                    for (qg = q2[rg + 20 >> 2], sg = qg + (pg << 2) | 0, pg = q2[a2 + 32 >> 2] + (ug << 2) | 0; ; ) if (q2[pg >> 2] = q2[qg >> 2], pg = pg + 4 | 0, !((qg = qg + 4 | 0) >>> 0 < sg >>> 0)) break;
                  }
                  if (ug = q2[rg + 8 >> 2] + ug | 0, (0 | vg) == (0 | (tg = tg + 1 | 0))) break;
                }
              }(a), n2[q2[1808]](a + 12 | 0, q2[a + 36 >> 2], q2[a + 44 >> 2], q2[a + 40 >> 2]), function(a2) {
                var ue = 0, ve = 0, we = 0, xe = 0, ye = 0, ze = 0, Ae = 0, Be = 0, Ce = 0;
                if (1 <= (0 | (we = q2[a2 + 304 >> 2]))) {
                  for (ue = q2[a2 + 308 >> 2], ze = ue + (we << 5) | 0, Ae = q2[a2 + 264 >> 2], Be = q2[a2 + 144 >> 2], Ce = q2[a2 + 40 >> 2], ye = q2[a2 + 312 >> 2], we = ye; ; ) if (xe = we, ve = 0, a2 = ve = !q2[ue + 28 >> 2] || -1 != (0 | (a2 = q2[ue + 4 >> 2])) && (ve = 0, !q2[(a2 << 2) + Ce >> 2]) || -1 != (0 | (a2 = q2[ue + 8 >> 2])) && (ve = 0, !q2[(a2 << 2) + ye >> 2]) ? ve : !q2[q2[ue >> 2] + 32 >> 2], q2[xe >> 2] = a2, (xe = q2[ue + 12 >> 2]) >>> 0 <= 1 ? xe - 1 ? q2[(q2[ue + 16 >> 2] << 2) + Be >> 2] = a2 : q2[(q2[ue + 16 >> 2] << 2) + Ae >> 2] = a2 : Y3(4, 1372, 0), we = we + 4 | 0, !((ue = ue + 32 | 0) >>> 0 < ze >>> 0)) break;
                }
              }(a), function(a2) {
                var Uf = 0, Vf = 0, Wf = 0, Xf = 0, Yf = 0, Zf = 0, _f = 0, $f = 0, ag = 0, bg = 0, cg = 0, dg = 0, eg = 0, fg = 0, gg = 0, hg = 0, ig = 0, jg = 0, kg = 0, lg = 0, mg = 0, ng = 0, og = 0;
                if (Yf = q2[a2 >> 2], 1 <= (0 | ($f = q2[a2 + 56 >> 2]))) {
                  for (ag = q2[a2 + 60 >> 2], bg = q2[Yf + 1052 >> 2], cg = q2[Yf + 784 >> 2]; ; ) {
                    if (Uf = q2[ag + w2(Zf, 24) >> 2], (q2[Uf + 28 >> 2] || q2[Uf + 24 >> 2]) && (q2[(Vf = Zf << 2) + q2[a2 + 80 >> 2] >> 2] = q2[Uf + 12 >> 2], q2[Uf + 24 >> 2]) && !((0 | (Xf = q2[Uf + 12 >> 2])) < 1)) {
                      for (Wf = q2[Uf + 16 >> 2], dg = Wf + (Xf << 2) | 0, eg = q2[Vf + cg >> 2], Vf = (Xf = _f << 2) + q2[a2 + 92 >> 2] | 0, Xf = Xf + q2[a2 + 88 >> 2] | 0; ; ) if (fg = eg + q2[Wf >> 2] << 2, q2[Vf >> 2] = bg + (q2[fg + q2[Yf + 984 >> 2] >> 2] << 2), q2[Xf >> 2] = q2[fg + q2[Yf + 980 >> 2] >> 2], Xf = Xf + 4 | 0, Vf = Vf + 4 | 0, !((Wf = Wf + 4 | 0) >>> 0 < dg >>> 0)) break;
                    }
                    if (q2[Uf + 28 >> 2] && !((0 | (Vf = q2[Uf + 12 >> 2])) < 1)) {
                      for (Wf = q2[Uf + 20 >> 2], Xf = Wf + (Vf << 2) | 0, Vf = q2[a2 + 84 >> 2] + (_f << 2) | 0; ; ) if (q2[Vf >> 2] = q2[Wf >> 2], Vf = Vf + 4 | 0, !((Wf = Wf + 4 | 0) >>> 0 < Xf >>> 0)) break;
                    }
                    if (_f = q2[Uf + 8 >> 2] + _f | 0, (0 | $f) == (0 | (Zf = Zf + 1 | 0))) break;
                  }
                  Yf = q2[a2 >> 2];
                }
                if (!(r2[Yf + 4 | 0] < 4 || (0 | (eg = q2[a2 + 56 >> 2])) < 1)) for (fg = q2[Yf + 792 >> 2], gg = q2[a2 + 60 >> 2], Wf = _f = 0; ; ) {
                  if (Zf = q2[w2(Wf, 24) + gg >> 2], q2[Zf + 24 >> 2] && !((0 | (Uf = q2[Zf + 12 >> 2])) < 1)) {
                    for (Vf = q2[Zf + 16 >> 2], hg = Vf + (Uf << 2) | 0, ig = q2[fg + (Wf << 2) >> 2], Xf = (Uf = _f << 2) + q2[a2 + 96 >> 2] | 0, $f = Uf + q2[a2 + 100 >> 2] | 0, ag = Uf + q2[a2 + 104 >> 2] | 0, bg = Uf + q2[a2 + 108 >> 2] | 0, cg = Uf + q2[a2 + 112 >> 2] | 0, dg = Uf + q2[a2 + 116 >> 2] | 0, jg = q2[Yf + 1308 >> 2], kg = q2[Yf + 1304 >> 2], lg = q2[Yf + 1300 >> 2], mg = q2[Yf + 1296 >> 2], ng = q2[Yf + 1292 >> 2], og = q2[Yf + 1288 >> 2]; ; ) if (Uf = q2[Vf >> 2] + ig << 2, q2[Xf >> 2] = q2[Uf + og >> 2], q2[$f >> 2] = q2[Uf + ng >> 2], q2[ag >> 2] = q2[Uf + mg >> 2], q2[bg >> 2] = q2[Uf + lg >> 2], q2[cg >> 2] = q2[Uf + kg >> 2], q2[dg >> 2] = q2[Uf + jg >> 2], dg = dg + 4 | 0, cg = cg + 4 | 0, bg = bg + 4 | 0, ag = ag + 4 | 0, $f = $f + 4 | 0, Xf = Xf + 4 | 0, !((Vf = Vf + 4 | 0) >>> 0 < hg >>> 0)) break;
                  }
                  if (_f = q2[Zf + 8 >> 2] + _f | 0, (0 | eg) == (0 | (Wf = Wf + 1 | 0))) break;
                }
              }(a), function(a2) {
                var xf = 0, yf = 0, zf = 0, Af = 0, Bf = 0, Cf = 0, Df = 0, Ef = 0, Ff = 0, Gf = 0, Hf = 0, If = 0, Jf = 0, Kf = 0, Lf = 0, Mf = 0, Nf = 0, Of = 0, Pf = 0, Qf = 0, Rf = 0, Sf = 0, Tf = 0;
                if (Tf = q2[a2 + 168 >> 2], zf = q2[a2 >> 2], 1 <= (0 | (Kf = q2[a2 + 164 >> 2]))) for (Mf = q2[zf + 816 >> 2]; ; ) {
                  if (Af = q2[w2(Ef, 12) + Tf >> 2], (q2[Af + 28 >> 2] || q2[Af + 24 >> 2]) && (q2[(Ff = Ef << 2) + q2[a2 + 188 >> 2] >> 2] = q2[Af + 12 >> 2], q2[Af + 24 >> 2])) {
                    if (yf = q2[Af + 16 >> 2], Lf = q2[Ff + Mf >> 2], 1 <= (0 | (xf = q2[Af + 12 >> 2]))) {
                      for (Nf = yf + (xf << 2) | 0, Bf = (xf = Df << 2) + q2[a2 + 200 >> 2] | 0, Gf = xf + q2[a2 + 204 >> 2] | 0, Hf = xf + q2[a2 + 208 >> 2] | 0, If = xf + q2[a2 + 212 >> 2] | 0, Jf = xf + q2[a2 + 196 >> 2] | 0, Of = q2[zf + 996 >> 2], Pf = q2[zf + 1012 >> 2], Qf = q2[zf + 1008 >> 2], Rf = q2[zf + 1004 >> 2], Sf = q2[zf + 1e3 >> 2], xf = yf; ; ) if (Cf = Lf + q2[xf >> 2] << 2, q2[Bf >> 2] = q2[Cf + Sf >> 2], q2[Gf >> 2] = q2[Cf + Rf >> 2], q2[Hf >> 2] = q2[Cf + Qf >> 2], q2[If >> 2] = q2[Cf + Pf >> 2], q2[Jf >> 2] = q2[Cf + Of >> 2], Jf = Jf + 4 | 0, If = If + 4 | 0, Hf = Hf + 4 | 0, Gf = Gf + 4 | 0, Bf = Bf + 4 | 0, !((xf = xf + 4 | 0) >>> 0 < Nf >>> 0)) break;
                    }
                    xf = Lf + q2[yf >> 2] << 2, q2[Ff + q2[a2 + 288 >> 2] >> 2] = q2[xf + q2[zf + 1016 >> 2] >> 2], q2[Ff + q2[a2 + 292 >> 2] >> 2] = q2[xf + q2[zf + 1020 >> 2] >> 2];
                  }
                  if (q2[Af + 28 >> 2] && !((0 | (yf = q2[Af + 12 >> 2])) < 1)) {
                    for (xf = q2[Af + 20 >> 2], yf = xf + (yf << 2) | 0, Bf = q2[a2 + 192 >> 2] + (Df << 2) | 0; ; ) if (q2[Bf >> 2] = q2[xf >> 2], Bf = Bf + 4 | 0, !((xf = xf + 4 | 0) >>> 0 < yf >>> 0)) break;
                  }
                  if (Df = q2[Af + 8 >> 2] + Df | 0, (0 | Kf) == (0 | (Ef = Ef + 1 | 0))) break;
                }
                if (!(r2[zf + 4 | 0] < 4 || (0 | (Ff = q2[a2 + 164 >> 2])) < 1)) for (Lf = q2[zf + 824 >> 2], Df = Af = 0; ; ) {
                  if (Cf = q2[w2(Df, 12) + Tf >> 2], q2[Cf + 24 >> 2] && !((0 | (xf = q2[Cf + 12 >> 2])) < 1)) {
                    for (Bf = q2[Cf + 16 >> 2], Kf = Bf + (xf << 2) | 0, Mf = q2[Lf + (Df << 2) >> 2], Gf = (yf = Af << 2) + q2[a2 + 216 >> 2] | 0, Hf = yf + q2[a2 + 220 >> 2] | 0, If = yf + q2[a2 + 224 >> 2] | 0, Jf = yf + q2[a2 + 228 >> 2] | 0, xf = yf + q2[a2 + 232 >> 2] | 0, Ef = yf + q2[a2 + 236 >> 2] | 0, Nf = q2[zf + 1308 >> 2], Of = q2[zf + 1304 >> 2], Pf = q2[zf + 1300 >> 2], Qf = q2[zf + 1296 >> 2], Rf = q2[zf + 1292 >> 2], Sf = q2[zf + 1288 >> 2]; ; ) if (yf = Mf + q2[Bf >> 2] << 2, q2[Gf >> 2] = q2[yf + Sf >> 2], q2[Hf >> 2] = q2[yf + Rf >> 2], q2[If >> 2] = q2[yf + Qf >> 2], q2[Jf >> 2] = q2[yf + Pf >> 2], q2[xf >> 2] = q2[yf + Of >> 2], q2[Ef >> 2] = q2[yf + Nf >> 2], Ef = Ef + 4 | 0, xf = xf + 4 | 0, Jf = Jf + 4 | 0, If = If + 4 | 0, Hf = Hf + 4 | 0, Gf = Gf + 4 | 0, !((Bf = Bf + 4 | 0) >>> 0 < Kf >>> 0)) break;
                  }
                  if (Af = q2[Cf + 8 >> 2] + Af | 0, (0 | Ff) == (0 | (Df = Df + 1 | 0))) break;
                }
              }(a), function(a2) {
                var qk = 0, rk = 0, sk = 0, tk = 0, uk = 0, vk = 0, wk = 0, xk = 0, yk = 0;
                qk = a2 - -64 | 0, n2[q2[1807]](qk, q2[a2 + 88 >> 2], q2[a2 + 148 >> 2], q2[a2 + 144 >> 2]), n2[q2[1809]](qk, q2[a2 + 92 >> 2], q2[a2 + 152 >> 2], q2[q2[a2 >> 2] + 796 >> 2], 2, q2[a2 + 144 >> 2]);
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (n2[q2[1807]](qk, q2[a2 + 96 >> 2], q2[a2 + 120 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 100 >> 2], q2[a2 + 124 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 104 >> 2], q2[a2 + 128 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 108 >> 2], q2[a2 + 132 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 112 >> 2], q2[a2 + 136 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 116 >> 2], q2[a2 + 140 >> 2], q2[a2 + 144 >> 2]), (0 | (vk = q2[a2 + 56 >> 2])) < 1))) {
                  for (wk = q2[a2 + 128 >> 2], xk = q2[a2 + 124 >> 2], yk = q2[a2 + 120 >> 2], rk = q2[a2 + 156 >> 2], qk = 0; ; ) if (uk = qk << 2, q2[(sk = tk << 2) + rk >> 2] = q2[uk + yk >> 2], q2[rk + (4 | sk) >> 2] = q2[uk + xk >> 2], q2[rk + (8 | sk) >> 2] = q2[uk + wk >> 2], tk = tk + 4 | 0, (0 | vk) == (0 | (qk = qk + 1 | 0))) break;
                  for (rk = q2[a2 + 160 >> 2], uk = q2[a2 + 140 >> 2], wk = q2[a2 + 136 >> 2], xk = q2[a2 + 132 >> 2], qk = a2 = 0; ; ) if (sk = qk << 2, q2[(tk = a2 << 2) + rk >> 2] = q2[sk + xk >> 2], q2[rk + (4 | tk) >> 2] = q2[sk + wk >> 2], q2[rk + (8 | tk) >> 2] = q2[sk + uk >> 2], a2 = a2 + 4 | 0, (0 | vk) == (0 | (qk = qk + 1 | 0))) break;
                }
              }(a), function(a2) {
                var hk = 0, ik = 0, jk = 0, kk = 0, lk = 0, mk = 0, nk = 0, ok = 0, pk = 0;
                hk = a2 + 172 | 0, n2[q2[1807]](hk, q2[a2 + 196 >> 2], q2[a2 + 268 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 200 >> 2], q2[a2 + 284 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 204 >> 2], q2[a2 + 276 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 208 >> 2], q2[a2 + 280 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 212 >> 2], q2[a2 + 272 >> 2], q2[a2 + 264 >> 2]);
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (n2[q2[1807]](hk, q2[a2 + 216 >> 2], q2[a2 + 240 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 220 >> 2], q2[a2 + 244 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 224 >> 2], q2[a2 + 248 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 228 >> 2], q2[a2 + 252 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 232 >> 2], q2[a2 + 256 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 236 >> 2], q2[a2 + 260 >> 2], q2[a2 + 264 >> 2]), (0 | (mk = q2[a2 + 164 >> 2])) < 1))) {
                  for (nk = q2[a2 + 248 >> 2], ok = q2[a2 + 244 >> 2], pk = q2[a2 + 240 >> 2], ik = q2[a2 + 296 >> 2], hk = 0; ; ) if (lk = hk << 2, q2[(jk = kk << 2) + ik >> 2] = q2[lk + pk >> 2], q2[ik + (4 | jk) >> 2] = q2[lk + ok >> 2], q2[ik + (8 | jk) >> 2] = q2[lk + nk >> 2], kk = kk + 4 | 0, (0 | mk) == (0 | (hk = hk + 1 | 0))) break;
                  for (ik = q2[a2 + 300 >> 2], lk = q2[a2 + 260 >> 2], nk = q2[a2 + 256 >> 2], ok = q2[a2 + 252 >> 2], hk = a2 = 0; ; ) if (jk = hk << 2, q2[(kk = a2 << 2) + ik >> 2] = q2[jk + ok >> 2], q2[ik + (4 | kk) >> 2] = q2[jk + nk >> 2], q2[ik + (8 | kk) >> 2] = q2[jk + lk >> 2], a2 = a2 + 4 | 0, (0 | mk) == (0 | (hk = hk + 1 | 0))) break;
                }
              }(a), function(a2) {
                var oe = 0, pe = 0, qe = 0, re = 0, se = 0, te = 0;
                if (1 <= (0 | (pe = q2[a2 + 332 >> 2]))) {
                  for (oe = q2[a2 + 336 >> 2], re = oe + w2(pe, 20) | 0, se = q2[a2 + 312 >> 2], te = q2[a2 + 40 >> 2], a2 = q2[a2 + 424 >> 2]; ; ) if (pe = 0, q2[oe + 12 >> 2] && (qe = q2[oe + 4 >> 2], q2[(qe << 2) + te >> 2] || -1 == (0 | qe)) && (qe = q2[oe + 8 >> 2], q2[(qe << 2) + se >> 2] || -1 == (0 | qe)) && (pe = !q2[q2[oe >> 2] + 32 >> 2]), q2[a2 >> 2] = pe, a2 = a2 + 4 | 0, !((oe = oe + 20 | 0) >>> 0 < re >>> 0)) break;
                }
              }(a), function(a2) {
                var $e = 0, af = 0, bf = 0, cf = 0, df = 0, ef = 0, ff = 0, gf = 0, hf = 0, jf = 0, kf = 0, lf = 0, mf = 0, nf = 0, of = 0, pf = 0, qf = 0, rf = 0, sf = 0, tf = 0, uf = 0, vf = 0, wf = 0;
                if (cf = q2[a2 >> 2], 1 <= (0 | (jf = q2[a2 + 332 >> 2]))) {
                  for (kf = q2[a2 + 336 >> 2], lf = q2[cf + 1052 >> 2], mf = q2[cf + 856 >> 2]; ; ) {
                    if ($e = q2[kf + w2(ff, 20) >> 2], (q2[$e + 28 >> 2] || q2[$e + 24 >> 2]) && (q2[(af = ff << 2) + q2[a2 + 356 >> 2] >> 2] = q2[$e + 12 >> 2], q2[$e + 24 >> 2]) && !((0 | (df = q2[$e + 12 >> 2])) < 1)) {
                      for (bf = q2[$e + 16 >> 2], nf = bf + (df << 2) | 0, of = q2[af + mf >> 2], af = (ef = gf << 2) + q2[a2 + 372 >> 2] | 0, df = ef + q2[a2 + 364 >> 2] | 0, ef = ef + q2[a2 + 368 >> 2] | 0; ; ) if (hf = of + q2[bf >> 2] << 2, q2[af >> 2] = lf + (q2[hf + q2[cf + 1040 >> 2] >> 2] << 2), q2[df >> 2] = q2[hf + q2[cf + 1032 >> 2] >> 2], q2[ef >> 2] = q2[hf + q2[cf + 1036 >> 2] >> 2], ef = ef + 4 | 0, df = df + 4 | 0, af = af + 4 | 0, !((bf = bf + 4 | 0) >>> 0 < nf >>> 0)) break;
                    }
                    if (q2[$e + 28 >> 2] && !((0 | (af = q2[$e + 12 >> 2])) < 1)) {
                      for (bf = q2[$e + 20 >> 2], df = bf + (af << 2) | 0, af = q2[a2 + 360 >> 2] + (gf << 2) | 0; ; ) if (q2[af >> 2] = q2[bf >> 2], af = af + 4 | 0, !((bf = bf + 4 | 0) >>> 0 < df >>> 0)) break;
                    }
                    if (gf = q2[$e + 8 >> 2] + gf | 0, (0 | jf) == (0 | (ff = ff + 1 | 0))) break;
                  }
                  cf = q2[a2 >> 2];
                }
                if (!(r2[cf + 4 | 0] < 4 || (0 | (mf = q2[a2 + 332 >> 2])) < 1)) for (nf = q2[cf + 864 >> 2], of = q2[a2 + 336 >> 2], bf = gf = 0; ; ) {
                  if (ff = q2[of + w2(bf, 20) >> 2], q2[ff + 24 >> 2] && !((0 | ($e = q2[ff + 12 >> 2])) < 1)) {
                    for (af = q2[ff + 16 >> 2], pf = af + ($e << 2) | 0, qf = q2[nf + (bf << 2) >> 2], df = ($e = gf << 2) + q2[a2 + 376 >> 2] | 0, ef = $e + q2[a2 + 380 >> 2] | 0, hf = $e + q2[a2 + 384 >> 2] | 0, jf = $e + q2[a2 + 388 >> 2] | 0, kf = $e + q2[a2 + 392 >> 2] | 0, lf = $e + q2[a2 + 396 >> 2] | 0, rf = q2[cf + 1308 >> 2], sf = q2[cf + 1304 >> 2], tf = q2[cf + 1300 >> 2], uf = q2[cf + 1296 >> 2], vf = q2[cf + 1292 >> 2], wf = q2[cf + 1288 >> 2]; ; ) if ($e = q2[af >> 2] + qf << 2, q2[df >> 2] = q2[$e + wf >> 2], q2[ef >> 2] = q2[$e + vf >> 2], q2[hf >> 2] = q2[$e + uf >> 2], q2[jf >> 2] = q2[$e + tf >> 2], q2[kf >> 2] = q2[$e + sf >> 2], q2[lf >> 2] = q2[$e + rf >> 2], lf = lf + 4 | 0, kf = kf + 4 | 0, jf = jf + 4 | 0, hf = hf + 4 | 0, ef = ef + 4 | 0, df = df + 4 | 0, !((af = af + 4 | 0) >>> 0 < pf >>> 0)) break;
                  }
                  if (gf = q2[ff + 8 >> 2] + gf | 0, (0 | mf) == (0 | (bf = bf + 1 | 0))) break;
                }
              }(a), function(a2) {
                var vj = 0, xj = 0, yj = 0, bk = 0, ck = 0, dk = 0, ek = 0, fk = 0, gk = 0;
                vj = a2 + 340 | 0, n2[q2[1807]](vj, q2[a2 + 364 >> 2], q2[a2 + 448 >> 2], q2[a2 + 424 >> 2]), n2[q2[1808]](vj, q2[a2 + 368 >> 2], q2[a2 + 440 >> 2], q2[a2 + 424 >> 2]), n2[q2[1809]](vj, q2[a2 + 372 >> 2], q2[a2 + 444 >> 2], q2[q2[a2 >> 2] + 892 >> 2], 2, q2[a2 + 424 >> 2]);
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (n2[q2[1807]](vj, q2[a2 + 376 >> 2], q2[a2 + 400 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 380 >> 2], q2[a2 + 404 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 384 >> 2], q2[a2 + 408 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 388 >> 2], q2[a2 + 412 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 392 >> 2], q2[a2 + 416 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 396 >> 2], q2[a2 + 420 >> 2], q2[a2 + 424 >> 2]), (0 | (dk = q2[a2 + 332 >> 2])) < 1))) {
                  for (ek = q2[a2 + 408 >> 2], fk = q2[a2 + 404 >> 2], gk = q2[a2 + 400 >> 2], xj = q2[a2 + 452 >> 2], vj = 0; ; ) if (ck = vj << 2, q2[(yj = bk << 2) + xj >> 2] = q2[ck + gk >> 2], q2[xj + (4 | yj) >> 2] = q2[ck + fk >> 2], q2[xj + (8 | yj) >> 2] = q2[ck + ek >> 2], bk = bk + 4 | 0, (0 | dk) == (0 | (vj = vj + 1 | 0))) break;
                  for (xj = q2[a2 + 456 >> 2], ck = q2[a2 + 420 >> 2], ek = q2[a2 + 416 >> 2], fk = q2[a2 + 412 >> 2], vj = a2 = 0; ; ) if (yj = vj << 2, q2[(bk = a2 << 2) + xj >> 2] = q2[yj + fk >> 2], q2[xj + (4 | bk) >> 2] = q2[yj + ek >> 2], q2[xj + (8 | bk) >> 2] = q2[yj + ck >> 2], a2 = a2 + 4 | 0, (0 | dk) == (0 | (vj = vj + 1 | 0))) break;
                }
              }(a), function(a2) {
                var Pe = 0, Qe = 0, Re = 0, Se = 0, Te = 0, Ue = 0, Ve = 0, We = 0, Xe = 0, Ye = 0, Ze = 0, _e = 0;
                if (1 <= (0 | (Ve = q2[a2 + 500 >> 2]))) for (Xe = q2[a2 + 504 >> 2], We = q2[a2 >> 2], Ye = q2[We + 1252 >> 2]; ; ) {
                  if (Re = q2[w2(Te, 24) + Xe >> 2], (q2[Re + 28 >> 2] || q2[Re + 24 >> 2]) && (q2[(Pe = Te << 2) + q2[a2 + 524 >> 2] >> 2] = q2[Re + 12 >> 2], q2[Re + 24 >> 2]) && !((0 | (Se = q2[Re + 12 >> 2])) < 1)) {
                    for (Qe = q2[Re + 16 >> 2], Se = Qe + (Se << 2) | 0, Ze = q2[Pe + Ye >> 2], Pe = q2[a2 + 532 >> 2] + (Ue << 2) | 0, _e = q2[We + 1284 >> 2]; ; ) if (q2[Pe >> 2] = q2[(q2[Qe >> 2] + Ze << 2) + _e >> 2], Pe = Pe + 4 | 0, !((Qe = Qe + 4 | 0) >>> 0 < Se >>> 0)) break;
                  }
                  if (q2[Re + 28 >> 2] && !((0 | (Pe = q2[Re + 12 >> 2])) < 1)) {
                    for (Qe = q2[Re + 20 >> 2], Se = Qe + (Pe << 2) | 0, Pe = q2[a2 + 528 >> 2] + (Ue << 2) | 0; ; ) if (q2[Pe >> 2] = q2[Qe >> 2], Pe = Pe + 4 | 0, !((Qe = Qe + 4 | 0) >>> 0 < Se >>> 0)) break;
                  }
                  if (Ue = q2[Re + 8 >> 2] + Ue | 0, (0 | Ve) == (0 | (Te = Te + 1 | 0))) break;
                }
              }(a), n2[q2[1807]](a + 508 | 0, q2[a + 532 >> 2], q2[a + 536 >> 2], 0), function(a2) {
                var zk = x2(0), Ak = 0, Bk = 0, Ck = 0, Dk = 0, Ek = 0, Fk = 0, Gk = x2(0), Hk = 0, Ik = 0, Jk = 0;
                L2 = Ek = L2 - 16 | 0, Ck = q2[a2 >> 2];
                if (!(r2[Ck + 4 | 0] < 5 || (0 | (Dk = q2[a2 + 596 >> 2])) < 1)) for (Bk = q2[a2 + 600 >> 2], Hk = Bk + w2(Dk, 12) | 0, Ik = q2[a2 + 44 >> 2], Dk = q2[Ck + 976 >> 2]; ; ) {
                  if (Ck = (q2[Bk >> 2] << 2) + Ik | 0, zk = x2(q2[Ck >> 2]), 1 <= (0 | (Ak = q2[Bk + 4 >> 2]))) {
                    for (a2 = q2[Bk + 8 >> 2], Jk = a2 + w2(Ak, 48) | 0; ; ) if ((Ak = q2[a2 + 8 >> 2]) && ((Fk = Ak + -1 | 0) >>> 0 <= 1 ? (Ak = q2[a2 + 4 >> 2], Gk = u2[Dk + (Ak + q2[a2 + 12 >> 2] << 2) >> 2], zk = x2(Fk - 1 ? zk + x2(u2[a2 + 44 >> 2] * x2(Gk * u2[a2 + 20 >> 2])) : zk + x2(u2[a2 + 44 >> 2] * x2(x2(Gk * u2[a2 + 20 >> 2]) + x2(u2[Dk + (Ak + q2[a2 + 16 >> 2] << 2) >> 2] * u2[a2 + 24 >> 2]))))) : (q2[Ek >> 2] = Ak, Y3(4, 1024, Ek))), !((a2 = a2 + 48 | 0) >>> 0 < Jk >>> 0)) break;
                  }
                  if (zk = (zk = x2(zk + x2(0.0010000000474974513))) < x2(0) ? x2(0) : x2(A(zk, x2(1e3))), a2 = x2(y2(zk)) < x2(2147483648) ? ~~zk : -2147483648, q2[Ck >> 2] = a2, !((Bk = Bk + 12 | 0) >>> 0 < Hk >>> 0)) break;
                }
                L2 = 16 + Ek | 0;
              }(a), function(a2) {
                var ej = 0, gj = 0, ij = 0, jj = 0, kj = 0, lj = x2(0), mj = 0, nj = 0, oj = 0, pj = 0, qj = 0, rj = 0, sj = 0, tj = 0, uj = 0;
                L2 = mj = L2 - 16 | 0, ej = q2[a2 >> 2];
                if (!(r2[ej + 4 | 0] < 4 || (va2(a2, q2[a2 + 604 >> 2], q2[a2 + 608 >> 2], q2[ej + 984 >> 2], q2[a2 + 152 >> 2], q2[ej + 796 >> 2]), gj = q2[a2 >> 2], r2[gj + 4 | 0] < 5))) {
                  if (ij = q2[a2 + 608 >> 2], qj = q2[gj + 992 >> 2], rj = q2[gj + 988 >> 2], 1 <= (0 | (ej = q2[a2 + 604 >> 2]))) {
                    for (sj = w2(ej, 12) + ij | 0, tj = q2[a2 + 148 >> 2], nj = q2[gj + 980 >> 2]; ; ) {
                      if (oj = (q2[ij >> 2] << 2) + tj | 0, kj = q2[oj >> 2], 1 <= (0 | (jj = q2[ij + 4 >> 2]))) {
                        for (ej = q2[ij + 8 >> 2], uj = ej + w2(jj, 48) | 0; ; ) if ((jj = q2[ej + 8 >> 2]) && ((pj = jj + -1 | 0) >>> 0 <= 1 ? (jj = q2[ej + 4 >> 2], lj = u2[(jj + q2[ej + 12 >> 2] << 2) + nj >> 2], kj = (j(x2(pj - 1 ? x2(u2[ej + 44 >> 2] * x2(lj * u2[ej + 20 >> 2])) + (f(0, kj), k()) : x2(u2[ej + 44 >> 2] * x2(x2(lj * u2[ej + 20 >> 2]) + x2(u2[(jj + q2[ej + 16 >> 2] << 2) + nj >> 2] * u2[ej + 24 >> 2]))) + (f(0, kj), k()))), b2[0])) : (q2[mj >> 2] = jj, Y3(4, 1024, mj))), !((ej = ej + 48 | 0) >>> 0 < uj >>> 0)) break;
                      }
                      if (f(0, kj), lj = k(), u2[oj >> 2] = lj < x2(0) ? x2(0) : x2(A(lj, x2(1))), !((ij = ij + 12 | 0) >>> 0 < sj >>> 0)) break;
                    }
                    ij = q2[a2 + 608 >> 2], ej = q2[a2 + 604 >> 2];
                  }
                  fa(ej, ij, rj, q2[gj + 1288 >> 2], q2[gj + 1292 >> 2], q2[gj + 1296 >> 2], q2[a2 + 156 >> 2]), fa(q2[a2 + 604 >> 2], q2[a2 + 608 >> 2], qj, q2[gj + 1300 >> 2], q2[gj + 1304 >> 2], q2[gj + 1308 >> 2], q2[a2 + 160 >> 2]);
                }
                L2 = 16 + mj | 0;
              }(a), function(a2) {
                var si = 0, ti = 0, ui = 0, vi = 0, wi = 0, xi = x2(0), yi = 0, zi = 0, Ai = 0, Bi = 0, Ci = 0, Di = 0, Ei = 0, Fi = 0, Gi = 0;
                L2 = zi = L2 - 80 | 0, wi = q2[a2 >> 2];
                if (!(r2[wi + 4 | 0] < 5)) {
                  if (Ei = q2[wi + 1028 >> 2], Fi = q2[wi + 1024 >> 2], ti = q2[a2 + 616 >> 2], si = q2[a2 + 612 >> 2], ui = ti, !((0 | si) < 1)) {
                    for (Ai = w2(si, 12) + ti | 0, Bi = q2[a2 + 276 >> 2], yi = q2[wi + 1004 >> 2]; ; ) {
                      if (Ci = Bi + (q2[ti >> 2] << 2) | 0, ui = q2[Ci >> 2], 1 <= (0 | (vi = q2[ti + 4 >> 2]))) {
                        for (si = q2[ti + 8 >> 2], Gi = si + w2(vi, 48) | 0; ; ) if ((vi = q2[si + 8 >> 2]) && ((Di = vi + -1 | 0) >>> 0 <= 1 ? (vi = q2[si + 4 >> 2], xi = u2[yi + (vi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Di - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[yi + (vi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[64 + zi >> 2] = vi, Y3(4, 1024, zi + 64 | 0))), !((si = si + 48 | 0) >>> 0 < Gi >>> 0)) break;
                      }
                      if (q2[Ci >> 2] = ui, !((ti = ti + 12 | 0) >>> 0 < Ai >>> 0)) break;
                    }
                    if (ti = q2[a2 + 616 >> 2], si = q2[a2 + 612 >> 2], ui = ti, !((0 | si) < 1)) {
                      for (Ai = w2(si, 12) + ti | 0, Bi = q2[a2 + 280 >> 2], yi = q2[q2[a2 >> 2] + 1008 >> 2]; ; ) {
                        if (Ci = Bi + (q2[ti >> 2] << 2) | 0, ui = q2[Ci >> 2], 1 <= (0 | (vi = q2[ti + 4 >> 2]))) {
                          for (si = q2[ti + 8 >> 2], Gi = si + w2(vi, 48) | 0; ; ) if ((vi = q2[si + 8 >> 2]) && ((Di = vi + -1 | 0) >>> 0 <= 1 ? (vi = q2[si + 4 >> 2], xi = u2[yi + (vi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Di - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[yi + (vi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[48 + zi >> 2] = vi, Y3(4, 1024, 48 + zi | 0))), !((si = si + 48 | 0) >>> 0 < Gi >>> 0)) break;
                        }
                        if (q2[Ci >> 2] = ui, !((ti = ti + 12 | 0) >>> 0 < Ai >>> 0)) break;
                      }
                      if (ti = q2[a2 + 616 >> 2], si = q2[a2 + 612 >> 2], ui = ti, !((0 | si) < 1)) {
                        for (Ai = w2(si, 12) + ti | 0, Bi = q2[a2 + 268 >> 2], yi = q2[q2[a2 >> 2] + 996 >> 2]; ; ) {
                          if (Ci = Bi + (q2[ti >> 2] << 2) | 0, ui = q2[Ci >> 2], 1 <= (0 | (vi = q2[ti + 4 >> 2]))) {
                            for (si = q2[ti + 8 >> 2], Gi = si + w2(vi, 48) | 0; ; ) if ((vi = q2[si + 8 >> 2]) && ((Di = vi + -1 | 0) >>> 0 <= 1 ? (vi = q2[si + 4 >> 2], xi = u2[yi + (vi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Di - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[yi + (vi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[32 + zi >> 2] = vi, Y3(4, 1024, 32 + zi | 0))), !((si = si + 48 | 0) >>> 0 < Gi >>> 0)) break;
                          }
                          if (f(0, ui), xi = k(), u2[Ci >> 2] = xi < x2(0) ? x2(0) : x2(A(xi, x2(1))), !((ti = ti + 12 | 0) >>> 0 < Ai >>> 0)) break;
                        }
                        si = q2[a2 + 612 >> 2], ui = q2[a2 + 616 >> 2];
                      }
                    }
                  }
                  if (fa(si, ui, Fi, q2[wi + 1288 >> 2], q2[wi + 1292 >> 2], q2[wi + 1296 >> 2], q2[a2 + 296 >> 2]), fa(q2[a2 + 612 >> 2], q2[a2 + 616 >> 2], Ei, q2[wi + 1300 >> 2], q2[wi + 1304 >> 2], q2[wi + 1308 >> 2], q2[a2 + 300 >> 2]), !((0 | (si = q2[a2 + 612 >> 2])) < 1)) {
                    for (ti = q2[a2 + 616 >> 2], vi = ti + w2(si, 12) | 0, Ei = q2[a2 + 284 >> 2], wi = q2[q2[a2 >> 2] + 1e3 >> 2]; ; ) {
                      if (Fi = Ei + (q2[ti >> 2] << 2) | 0, ui = q2[Fi >> 2], 1 <= (0 | (yi = q2[ti + 4 >> 2]))) {
                        for (si = q2[ti + 8 >> 2], Ai = si + w2(yi, 48) | 0; ; ) if ((yi = q2[si + 8 >> 2]) && ((Bi = yi + -1 | 0) >>> 0 <= 1 ? (yi = q2[si + 4 >> 2], xi = u2[wi + (yi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Bi - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[wi + (yi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[16 + zi >> 2] = yi, Y3(4, 1024, 16 + zi | 0))), !((si = si + 48 | 0) >>> 0 < Ai >>> 0)) break;
                      }
                      if (f(0, ui), xi = k(), u2[Fi >> 2] = xi < x2(-3600) ? x2(-3600) : x2(A(xi, x2(3600))), !((ti = ti + 12 | 0) >>> 0 < vi >>> 0)) break;
                    }
                    if (!((0 | (si = q2[a2 + 612 >> 2])) < 1)) for (ti = q2[a2 + 616 >> 2], yi = ti + w2(si, 12) | 0, vi = q2[a2 + 272 >> 2], a2 = q2[q2[a2 >> 2] + 1012 >> 2]; ; ) {
                      if (Ei = vi + (q2[ti >> 2] << 2) | 0, ui = q2[Ei >> 2], 1 <= (0 | (wi = q2[ti + 4 >> 2]))) {
                        for (si = q2[ti + 8 >> 2], Fi = si + w2(wi, 48) | 0; ; ) if ((wi = q2[si + 8 >> 2]) && ((Ai = wi + -1 | 0) >>> 0 <= 1 ? (wi = q2[si + 4 >> 2], xi = u2[a2 + (wi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Ai - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[a2 + (wi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[zi >> 2] = wi, Y3(4, 1024, zi))), !((si = si + 48 | 0) >>> 0 < Fi >>> 0)) break;
                      }
                      if (f(0, ui), xi = k(), u2[Ei >> 2] = xi < x2(9999999747378752e-20) ? x2(9999999747378752e-20) : x2(A(xi, x2(100))), !((ti = ti + 12 | 0) >>> 0 < yi >>> 0)) break;
                    }
                  }
                }
                L2 = 80 + zi | 0;
              }(a), function(a2) {
                var Vh = 0, Wh = 0, Xh = 0, Yh = 0, Zh = x2(0), _h = 0, $h = 0, ai = 0, bi = 0, ci = 0, di = 0, ei = 0, fi = x2(0), gi = 0, hi = 0, ii = 0;
                L2 = $h = L2 - 32 | 0, Xh = q2[a2 >> 2];
                if (!(r2[Xh + 4 | 0] < 4 || (va2(a2, q2[a2 + 620 >> 2], q2[a2 + 624 >> 2], q2[Xh + 1040 >> 2], q2[a2 + 444 >> 2], q2[Xh + 892 >> 2]), _h = q2[a2 >> 2], r2[_h + 4 | 0] < 5))) {
                  if (hi = q2[_h + 1048 >> 2], ii = q2[_h + 1044 >> 2], Yh = q2[a2 + 624 >> 2], Vh = q2[a2 + 620 >> 2], Xh = Yh, !((0 | Vh) < 1)) {
                    for (di = w2(Vh, 12) + Yh | 0, ei = q2[a2 + 440 >> 2], ai = q2[_h + 1036 >> 2]; ; ) {
                      if (Xh = ei + (q2[Yh >> 2] << 2) | 0, Zh = x2(q2[Xh >> 2]), 1 <= (0 | (Wh = q2[Yh + 4 >> 2]))) {
                        for (Vh = q2[Yh + 8 >> 2], bi = Vh + w2(Wh, 48) | 0; ; ) if ((Wh = q2[Vh + 8 >> 2]) && ((ci = Wh + -1 | 0) >>> 0 <= 1 ? (Wh = q2[Vh + 4 >> 2], fi = u2[ai + (Wh + q2[Vh + 12 >> 2] << 2) >> 2], Zh = x2(ci - 1 ? Zh + x2(u2[Vh + 44 >> 2] * x2(fi * u2[Vh + 20 >> 2])) : Zh + x2(u2[Vh + 44 >> 2] * x2(x2(fi * u2[Vh + 20 >> 2]) + x2(u2[ai + (Wh + q2[Vh + 16 >> 2] << 2) >> 2] * u2[Vh + 24 >> 2]))))) : (q2[16 + $h >> 2] = Wh, Y3(4, 1024, 16 + $h | 0))), !((Vh = Vh + 48 | 0) >>> 0 < bi >>> 0)) break;
                      }
                      if (Zh = (Zh = x2(Zh + x2(0.0010000000474974513))) < x2(0) ? x2(0) : x2(A(Zh, x2(1e3))), Vh = x2(y2(Zh)) < x2(2147483648) ? ~~Zh : -2147483648, q2[Xh >> 2] = Vh, !((Yh = Yh + 12 | 0) >>> 0 < di >>> 0)) break;
                    }
                    if (Yh = q2[a2 + 624 >> 2], Vh = q2[a2 + 620 >> 2], Xh = Yh, !((0 | Vh) < 1)) {
                      for (di = w2(Vh, 12) + Yh | 0, ei = q2[a2 + 448 >> 2], ai = q2[q2[a2 >> 2] + 1032 >> 2]; ; ) {
                        if (bi = ei + (q2[Yh >> 2] << 2) | 0, Xh = q2[bi >> 2], 1 <= (0 | (Wh = q2[Yh + 4 >> 2]))) {
                          for (Vh = q2[Yh + 8 >> 2], ci = Vh + w2(Wh, 48) | 0; ; ) if ((Wh = q2[Vh + 8 >> 2]) && ((gi = Wh + -1 | 0) >>> 0 <= 1 ? (Wh = q2[Vh + 4 >> 2], Zh = u2[ai + (Wh + q2[Vh + 12 >> 2] << 2) >> 2], Xh = (j(x2(gi - 1 ? x2(u2[Vh + 44 >> 2] * x2(Zh * u2[Vh + 20 >> 2])) + (f(0, Xh), k()) : x2(u2[Vh + 44 >> 2] * x2(x2(Zh * u2[Vh + 20 >> 2]) + x2(u2[ai + (Wh + q2[Vh + 16 >> 2] << 2) >> 2] * u2[Vh + 24 >> 2]))) + (f(0, Xh), k()))), b2[0])) : (q2[$h >> 2] = Wh, Y3(4, 1024, $h))), !((Vh = Vh + 48 | 0) >>> 0 < ci >>> 0)) break;
                        }
                        if (f(0, Xh), Zh = k(), u2[bi >> 2] = Zh < x2(0) ? x2(0) : x2(A(Zh, x2(1))), !((Yh = Yh + 12 | 0) >>> 0 < di >>> 0)) break;
                      }
                      Vh = q2[a2 + 620 >> 2], Xh = q2[a2 + 624 >> 2];
                    }
                  }
                  fa(Vh, Xh, ii, q2[_h + 1288 >> 2], q2[_h + 1292 >> 2], q2[_h + 1296 >> 2], q2[a2 + 452 >> 2]), fa(q2[a2 + 620 >> 2], q2[a2 + 624 >> 2], hi, q2[_h + 1300 >> 2], q2[_h + 1304 >> 2], q2[_h + 1308 >> 2], q2[a2 + 456 >> 2]);
                }
                L2 = 32 + $h | 0;
              }(a), function(a2) {
                var Bg = 0, Cg = 0, Dg = 0, Eg = 0, Fg = x2(0), Gg = 0, Hg = 0, Ig = 0, Jg = 0, Kg = 0, Lg = 0;
                L2 = Gg = L2 - 16 | 0, Cg = q2[a2 >> 2];
                if (!(r2[Cg + 4 | 0] < 5 || (0 | (Eg = q2[a2 + 628 >> 2])) < 1)) for (Dg = q2[a2 + 632 >> 2], Jg = Dg + w2(Eg, 12) | 0, Kg = q2[a2 + 536 >> 2], Eg = q2[Cg + 1284 >> 2]; ; ) {
                  if (Hg = (q2[Dg >> 2] << 2) + Kg | 0, Cg = q2[Hg >> 2], 1 <= (0 | (Bg = q2[Dg + 4 >> 2]))) {
                    for (a2 = q2[Dg + 8 >> 2], Lg = a2 + w2(Bg, 48) | 0; ; ) if ((Bg = q2[a2 + 8 >> 2]) && ((Ig = Bg + -1 | 0) >>> 0 <= 1 ? (Bg = q2[a2 + 4 >> 2], Fg = u2[Eg + (Bg + q2[a2 + 12 >> 2] << 2) >> 2], Cg = (j(x2(Ig - 1 ? x2(u2[a2 + 44 >> 2] * x2(Fg * u2[a2 + 20 >> 2])) + (f(0, Cg), k()) : x2(u2[a2 + 44 >> 2] * x2(x2(Fg * u2[a2 + 20 >> 2]) + x2(u2[Eg + (Bg + q2[a2 + 16 >> 2] << 2) >> 2] * u2[a2 + 24 >> 2]))) + (f(0, Cg), k()))), b2[0])) : (q2[Gg >> 2] = Bg, Y3(4, 1024, Gg))), !((a2 = a2 + 48 | 0) >>> 0 < Lg >>> 0)) break;
                  }
                  if (f(0, Cg), Fg = k(), u2[Hg >> 2] = Fg < x2(0) ? x2(0) : x2(A(Fg, x2(1))), !((Dg = Dg + 12 | 0) >>> 0 < Jg >>> 0)) break;
                }
                L2 = 16 + Gg | 0;
              }(a), function(a2) {
                var mh = 0, Oh = 0, Ph = 0, Qh = 0, Rh = x2(0), Sh = 0, Th = 0;
                if (1 <= (0 | (mh = q2[a2 + 4 >> 2]))) {
                  for (Oh = q2[a2 + 8 >> 2], Th = Oh + w2(mh, 12) | 0, mh = q2[a2 + 40 >> 2], Ph = q2[a2 + 52 >> 2], Qh = q2[a2 + 48 >> 2], a2 = Qh; ; ) if (q2[mh >> 2] && (Rh = u2[Ph >> 2], u2[a2 >> 2] = Rh, -1 != (0 | (Sh = q2[Oh + 4 >> 2]))) && (u2[a2 >> 2] = Rh * u2[(Sh << 2) + Qh >> 2]), a2 = a2 + 4 | 0, Ph = Ph + 4 | 0, mh = mh + 4 | 0, !((Oh = Oh + 12 | 0) >>> 0 < Th >>> 0)) break;
                }
              }(a), function(a2) {
                var ih = 0, jh = 0, kh = 0, lh = 0;
                if (1 <= (0 | (lh = q2[a2 + 304 >> 2]))) {
                  for (ih = q2[a2 + 308 >> 2], jh = q2[a2 + 312 >> 2]; ; ) if (q2[jh >> 2] && n2[q2[ih + 20 >> 2]](a2, kh), jh = jh + 4 | 0, ih = ih + 32 | 0, (0 | lh) == (0 | (kh = kh + 1 | 0))) break;
                }
              }(a), function(a2) {
                var Xg = 0, Yg = 0, Zg = x2(0), _g = x2(0), $g = 0, ah = 0, bh = 0, ch = x2(0), dh = 0, eh = 0, fh = 0, gh = 0, hh = 0;
                if (1 <= (0 | (Xg = q2[a2 + 332 >> 2]))) {
                  for (Yg = q2[a2 + 336 >> 2], eh = Yg + w2(Xg, 20) | 0, fh = q2[a2 + 308 >> 2], dh = q2[a2 + 316 >> 2], hh = q2[a2 + 48 >> 2], Xg = q2[a2 + 448 >> 2], $g = q2[a2 + 444 >> 2], bh = q2[a2 + 424 >> 2]; ; ) if (q2[bh >> 2] && (-1 != (0 | (ah = q2[Yg + 4 >> 2])) && (u2[Xg >> 2] = u2[(ah << 2) + hh >> 2] * u2[Xg >> 2]), -1 != (0 | (ah = q2[Yg + 8 >> 2]))) && (u2[Xg >> 2] = u2[dh + (ah << 2) >> 2] * u2[Xg >> 2], gh = q2[$g >> 2], n2[q2[24 + (fh + (ah << 5) | 0) >> 2]](a2, ah, gh, gh, q2[Yg + 16 >> 2])), $g = $g + 4 | 0, Xg = Xg + 4 | 0, bh = bh + 4 | 0, !((Yg = Yg + 20 | 0) >>> 0 < eh >>> 0)) break;
                }
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (0 | (Xg = q2[a2 + 332 >> 2])) < 1)) {
                  for ($g = q2[a2 + 336 >> 2], ah = $g + w2(Xg, 20) | 0, eh = q2[a2 + 328 >> 2], fh = q2[a2 + 324 >> 2], Yg = q2[a2 + 452 >> 2], Xg = q2[a2 + 456 >> 2], bh = q2[a2 + 424 >> 2]; ; ) if (q2[bh >> 2] && -1 != (0 | (a2 = q2[$g + 8 >> 2])) && (a2 = (dh = a2 << 4) + fh | 0, Zg = x2(u2[Yg >> 2] * u2[a2 >> 2]), u2[Yg >> 2] = Zg, _g = x2(u2[Yg + 4 >> 2] * u2[a2 + 4 >> 2]), u2[Yg + 4 >> 2] = _g, ch = u2[a2 + 8 >> 2], q2[Yg + 12 >> 2] = 1065353216, u2[Yg + 4 >> 2] = _g < x2(0) ? x2(0) : x2(A(_g, x2(1))), u2[Yg >> 2] = Zg < x2(0) ? x2(0) : x2(A(Zg, x2(1))), Zg = x2(ch * u2[Yg + 8 >> 2]), u2[Yg + 8 >> 2] = Zg < x2(0) ? x2(0) : x2(A(Zg, x2(1))), Zg = u2[Xg >> 2], _g = u2[(a2 = eh + dh | 0) >> 2], Zg = x2(x2(Zg + _g) - x2(Zg * _g)), u2[Xg >> 2] = Zg, _g = u2[Xg + 4 >> 2], ch = u2[a2 + 4 >> 2], _g = x2(x2(_g + ch) - x2(_g * ch)), u2[Xg + 4 >> 2] = _g, ch = u2[a2 + 8 >> 2], q2[Xg + 12 >> 2] = 1065353216, u2[Xg + 4 >> 2] = _g < x2(0) ? x2(0) : x2(A(_g, x2(1))), u2[Xg >> 2] = Zg < x2(0) ? x2(0) : x2(A(Zg, x2(1))), Zg = u2[Xg + 8 >> 2], Zg = x2(x2(ch + Zg) - x2(Zg * ch)), u2[Xg + 8 >> 2] = Zg < x2(0) ? x2(0) : x2(A(Zg, x2(1)))), Xg = Xg + 16 | 0, Yg = Yg + 16 | 0, bh = bh + 4 | 0, !(($g = $g + 20 | 0) >>> 0 < ah >>> 0)) break;
                }
              }(a), function(a2) {
                var Ln = 0, Mn = 0, Nn = 0, On = x2(0), Ko = x2(0), Lo = x2(0), Mo = x2(0), No = x2(0), Oo = 0, Po = 0, Qo = 0, Ro = 0, So = 0, To = 0, Uo = 0, Vo = x2(0), Wo = 0, Xo = 0, Yo = x2(0), Zo = 0, _o = 0;
                if (1 <= (0 | (Oo = q2[a2 + 500 >> 2]))) for (Zo = q2[a2 + 536 >> 2], Po = q2[a2 + 444 >> 2], _o = q2[a2 + 504 >> 2]; ; ) {
                  if (a2 = w2(Nn, 24) + _o | 0, 0 < (0 | (Qo = q2[a2 + 12 >> 2]))) {
                    for (On = u2[(Nn << 2) + Zo >> 2], Ro = q2[a2 + 20 >> 2], So = q2[a2 + 16 >> 2], To = q2[(q2[a2 + 4 >> 2] << 2) + Po >> 2], Uo = q2[(q2[a2 + 8 >> 2] << 2) + Po >> 2], a2 = 0; ; ) if (Vo = u2[((Ln = 1 | a2) << 2) + So >> 2], Mn = s[(a2 << 1) + Ro >> 1] << 3 & 262136, Ko = u2[(Wo = (4 | Mn) + To | 0) >> 2], Ln = s[(Ln << 1) + Ro >> 1] << 3 & 262136, Lo = u2[(Xo = (4 | Ln) + Uo | 0) >> 2], Mo = u2[(Mn = Mn + To | 0) >> 2], Yo = u2[(a2 << 2) + So >> 2], No = u2[(Ln = Ln + Uo | 0) >> 2], u2[Mn >> 2] = Mo + x2(On * x2(Yo * x2(No - Mo))), u2[Wo >> 2] = Ko + x2(On * x2(Yo * x2(Lo - Ko))), u2[Ln >> 2] = No + x2(On * x2(Vo * x2(Mo - No))), u2[Xo >> 2] = Lo + x2(On * x2(Vo * x2(Ko - Lo))), !((0 | (a2 = a2 + 2 | 0)) < (0 | Qo))) break;
                  }
                  if (!((0 | (Nn = Nn + 1 | 0)) < (0 | Oo))) break;
                }
              }(a), n2[q2[1810]](a), function(a2) {
                var Gc = 0, Ic = 0, Jc = 0, Kc = 0, Lc = 0, Mc = 0, Nc = 0, Oc = 0, Pc = 0, Qc = 0, Rc = 0, Sc = 0, Tc = 0, Uc = 0, Vc = 0;
                if (!((0 | (Rc = q2[a2 + 480 >> 2])) < 1)) {
                  for (Sc = q2[a2 + 484 >> 2], Kc = Sc + w2(Rc, 28) | 0, Nc = q2[a2 + 424 >> 2], Oc = q2[a2 + 40 >> 2], Lc = q2[a2 + 44 >> 2], Tc = q2[a2 + 440 >> 2], Gc = Sc; ; ) {
                    if (1 <= (0 | (Mc = q2[Gc + 4 >> 2]))) {
                      for (Qc = Gc + 20 | 0, Pc = q2[Gc + 12 >> 2], Ic = 0; ; ) if (Uc = q2[(Jc = Pc + (Ic << 4) | 0) + 4 >> 2] << 2, Jc = 1 == q2[(Vc = Jc) >> 2], q2[Vc + 12 >> 2] = q2[(q2[(Jc ? Oc : Nc) + Uc >> 2] ? (Jc ? Lc : Tc) + Uc | 0 : Qc) >> 2], !((0 | (Ic = Ic + 1 | 0)) < (0 | Mc))) break;
                    }
                    if (!((Gc = Gc + 28 | 0) >>> 0 < Kc >>> 0)) break;
                  }
                  if (!((0 | Rc) < 1)) for (Tc = q2[a2 + 436 >> 2], Oc = 0; ; ) {
                    if (Kc = w2(Oc, 28) + Sc | 0, !(q2[(Nc = Kc) + 24 >> 2] < 1)) {
                      for (Jc = q2[a2 + 488 >> 2], Ic = 0; ; ) if (q2[Jc + (Ic << 2) >> 2] = -1, Ic = Ic + 1 | 0, Gc = q2[Nc + 24 >> 2], !((0 | Ic) < (0 | Gc))) break;
                      if (!((0 | Gc) < 1)) {
                        for (Gc = q2[a2 + 496 >> 2], Ic = 0; ; ) if (q2[Gc + (Ic << 2) >> 2] = -1, !((0 | (Ic = Ic + 1 | 0)) < q2[Nc + 24 >> 2])) break;
                      }
                    }
                    if (!(q2[Kc + 4 >> 2] < 1)) {
                      for (Lc = q2[a2 + 492 >> 2], Ic = 0; ; ) if (q2[Lc + (Ic << 2) >> 2] = -1, Ic = Ic + 1 | 0, Gc = q2[Kc + 4 >> 2], !((0 | Ic) < (0 | Gc))) break;
                      if (!((0 | Gc) < 1)) {
                        for (Mc = q2[Kc + 12 >> 2], Qc = q2[a2 + 496 >> 2], Ic = 0; ; ) if (Pc = q2[12 + (Mc + (Ic << 4) | 0) >> 2] - q2[Kc + 20 >> 2] << 2, Gc = -1 == (0 | (Gc = q2[(Jc = Pc + Qc | 0) >> 2])) ? Pc + q2[a2 + 488 >> 2] | 0 : Lc + (Gc << 2) | 0, q2[Gc >> 2] = Ic, !((0 | (Ic = (q2[Jc >> 2] = Ic) + 1 | 0)) < q2[Kc + 4 >> 2])) break;
                      }
                    }
                    if (1 <= (0 | (Gc = q2[Nc + 24 >> 2]))) for (Lc = q2[Kc + 8 >> 2], Qc = q2[a2 + 488 >> 2], Mc = 0; ; ) {
                      if (-1 != (0 | (Ic = q2[Qc + (Mc << 2) >> 2]))) {
                        for (Pc = q2[a2 + 492 >> 2], Jc = q2[Kc + 12 >> 2]; ; ) if (Gc = 1 == q2[(Gc = Jc + (Ic << 4) | 0) >> 2] ? (Gc = w2(q2[Gc + 8 >> 2], 28) + Sc | 0, q2[Gc + 8 >> 2] = Lc, q2[Gc >> 2]) : (q2[Tc + (q2[Gc + 4 >> 2] << 2) >> 2] = Lc, 1), Lc = Gc + Lc | 0, Gc = q2[Pc + (Ic << 2) >> 2], !((0 | Ic) < (0 | Gc) && -1 != (0 | (Ic = Gc)))) break;
                        Gc = q2[Nc + 24 >> 2];
                      }
                      if (!((0 | (Mc = Mc + 1 | 0)) < (0 | Gc))) break;
                    }
                    if ((0 | Rc) == (0 | (Oc = Oc + 1 | 0))) break;
                  }
                }
              }(a), function(a2) {
                var Mg = 0, Ng = 0, Og = 0, Pg = 0, Qg = 0, Rg = 0, Sg = x2(0), Tg = 0, Ug = 0;
                Qg = q2[a2 + 332 >> 2];
                if (q2[a2 + 644 >> 2]) {
                  if (!(((q2[a2 + 428 >> 2] = 0) | Qg) < 1)) {
                    for (; ; ) if (Mg = 126, Tg = q2[a2 + 432 >> 2] + Og | 0, !q2[(Ng = Og << 2) + q2[a2 + 424 >> 2] >> 2] | u2[Ng + q2[a2 + 448 >> 2] >> 2] == x2(0) || (Mg = 127), o[0 | Tg] = Mg, (0 | Qg) == (0 | (Og = Og + 1 | 0))) break;
                  }
                } else if (q2[a2 + 428 >> 2]) {
                  if (Mg = r2[q2[a2 >> 2] + 4 | 0], !(((q2[a2 + 428 >> 2] = 0) | Qg) < 1)) {
                    if (4 <= Mg >>> 0) {
                      for (; ; ) if (Sg = u2[(Mg = Og << 2) + q2[a2 + 448 >> 2] >> 2], Pg = q2[Mg + q2[a2 + 424 >> 2] >> 2], Ng = Sg != x2(0) & 0 != (0 | Pg), Tg = q2[a2 + 432 >> 2] + Og | 0, Ng = (0 | Ng) == (1 & o[0 | Tg]) ? Ng : 2 | Ng, Ng = Sg != u2[Mg + q2[a2 + 468 >> 2] >> 2] ? 4 | Ng : Ng, Ng = q2[Mg + q2[a2 + 440 >> 2] >> 2] == q2[Mg + q2[a2 + 464 >> 2] >> 2] ? Ng : 8 | Ng, Mg = q2[Mg + q2[a2 + 436 >> 2] >> 2] == q2[Mg + q2[a2 + 460 >> 2] >> 2] ? Ng : 16 | Ng, Mg = Pg ? 32 | Mg : Mg, Pg = (Ng = Ug << 2) + q2[a2 + 452 >> 2] | 0, Rg = Ng + q2[a2 + 472 >> 2] | 0, (u2[Pg >> 2] != u2[Rg >> 2] | u2[Pg + 4 >> 2] != u2[Rg + 4 >> 2] | (u2[Pg + 8 >> 2] != u2[Rg + 8 >> 2] | u2[Pg + 12 >> 2] != u2[Rg + 12 >> 2]) || (Pg = Ng + q2[a2 + 456 >> 2] | 0, Ng = Ng + q2[a2 + 476 >> 2] | 0, u2[Pg >> 2] != u2[Ng >> 2] | u2[Pg + 4 >> 2] != u2[Ng + 4 >> 2] | u2[Pg + 8 >> 2] != u2[Ng + 8 >> 2]) || u2[Pg + 12 >> 2] != u2[Ng + 12 >> 2]) && (Mg |= 64), o[0 | Tg] = Mg, Ug = Ug + 4 | 0, (0 | Qg) == (0 | (Og = Og + 1 | 0))) break;
                    } else for (; ; ) if (Sg = u2[(Mg = Og << 2) + q2[a2 + 448 >> 2] >> 2], Pg = q2[Mg + q2[a2 + 424 >> 2] >> 2], Ng = Sg != x2(0) & 0 != (0 | Pg), Rg = q2[a2 + 432 >> 2] + Og | 0, Ng = (0 | Ng) == (1 & o[0 | Rg]) ? Ng : 2 | Ng, Ng = Sg != u2[Mg + q2[a2 + 468 >> 2] >> 2] ? 4 | Ng : Ng, Ng = q2[Mg + q2[a2 + 440 >> 2] >> 2] == q2[Mg + q2[a2 + 464 >> 2] >> 2] ? Ng : 8 | Ng, Mg = q2[Mg + q2[a2 + 436 >> 2] >> 2] == q2[Mg + q2[a2 + 460 >> 2] >> 2] ? Ng : 16 | Ng, o[0 | Rg] = Pg ? 32 | Mg : Mg, (0 | Qg) == (0 | (Og = Og + 1 | 0))) break;
                  }
                } else if (!((0 | Qg) < 1)) {
                  for (; ; ) if (!q2[(Mg = Og << 2) + q2[a2 + 424 >> 2] >> 2] | u2[Mg + q2[a2 + 448 >> 2] >> 2] == x2(0) ? (Mg = q2[a2 + 432 >> 2] + Og | 0, o[0 | Mg] = 254 & r2[0 | Mg]) : (Mg = q2[a2 + 432 >> 2] + Og | 0, o[0 | Mg] = 1 | r2[0 | Mg]), (0 | Qg) == (0 | (Og = Og + 1 | 0))) break;
                }
              }(a), q2[a + 644 >> 2] = 0;
            }
            function va2(a, Wa, Xa, Ya, Za, _a) {
              var fb, gb, hb, jb, kb, cb, $a = 0, bb = 0, db = 0, eb = 0, ib = 0;
              if (L2 = cb = L2 - 32 | 0, 1 <= (0 | Wa)) for (kb = w2(Wa, 12) + Xa | 0; ; ) {
                if (!((0 | ($a = q2[Xa + 4 >> 2])) < 1)) {
                  if (fb = (Wa = q2[Xa + 8 >> 2]) + w2($a, 48) | 0, $a = q2[Xa >> 2] << 2, 1 <= (0 | (db = q2[$a + _a >> 2]))) for (db <<= 1, gb = q2[q2[a >> 2] + 1052 >> 2], hb = q2[Za + $a >> 2]; ; ) {
                    b: if ($a = q2[Wa + 8 >> 2]) {
                      c: {
                        if ((bb = $a + -1 | 0) >>> 0 <= 1) {
                          if ($a = (q2[Wa + 4 >> 2] << 2) + Ya | 0, ib = (q2[$a + (q2[Wa + 12 >> 2] << 2) >> 2] << 2) + gb | 0, bb - 1) break c;
                          for (eb = (q2[$a + (q2[Wa + 16 >> 2] << 2) >> 2] << 2) + gb | 0, $a = 0; ; ) if (u2[(jb = (bb = $a << 2) + hb | 0) >> 2] = u2[jb >> 2] + x2(u2[Wa + 44 >> 2] * x2(x2(u2[bb + ib >> 2] * u2[Wa + 20 >> 2]) + x2(u2[bb + eb >> 2] * u2[Wa + 24 >> 2]))), (0 | db) == (0 | ($a = $a + 1 | 0))) break;
                          break b;
                        }
                        q2[cb >> 2] = $a, Y3(4, 1024, cb);
                        break b;
                      }
                      for ($a = 0; ; ) if (u2[(eb = (bb = $a << 2) + hb | 0) >> 2] = u2[eb >> 2] + x2(u2[Wa + 44 >> 2] * x2(u2[bb + ib >> 2] * u2[Wa + 20 >> 2])), (0 | db) == (0 | ($a = $a + 1 | 0))) break;
                    }
                    if (!((Wa = Wa + 48 | 0) >>> 0 < fb >>> 0)) break;
                  }
                  else for (; ; ) if (3 <= ($a = q2[Wa + 8 >> 2]) >>> 0 && (q2[16 + cb >> 2] = $a, Y3(4, 1024, 16 + cb | 0)), !((Wa = Wa + 48 | 0) >>> 0 < fb >>> 0)) break;
                }
                if (!((Xa = Xa + 12 | 0) >>> 0 < kb >>> 0)) break;
              }
              L2 = 32 + cb | 0;
            }
            function wa2(a, Wa, Xa) {
              Wa |= 0, Xa |= 0;
              var Ya;
              L2 = Ya = L2 + -64 | 0;
              a: {
                if (a |= 0) if (Wa) if ((Wa + 15 & -16) != (0 | Wa)) q2[52 + Ya >> 2] = 1522, q2[48 + Ya >> 2] = 2361, Y3(4, 1294, 48 + Ya | 0);
                else {
                  if (Wa = function(a2, Il, Jl) {
                    var $l = 0, am = 0, bm = 0, cm = 0, dm = 0, em = 0, fm = 0, gm = 0, hm = 0, im = 0, jm = 0, km = 0, lm = 0, mm = 0, nm = x2(0), om = 0, pm = 0, qm = 0, rm = 0, sm = 0;
                    if (ca2(16 + (L2 = cm = L2 - 576 | 0) | 0, 0, 560), Fa(a2, 16 + cm | 0, 12 + cm | 0), (dm = q2[12 + cm >> 2]) >>> 0 <= Jl >>> 0) {
                      if (am = ca2(Il, 0, dm), $l = am + q2[16 + cm >> 2] | 0, q2[$l + 8 >> 2] = am + q2[20 + cm >> 2], q2[$l + 40 >> 2] = am + q2[24 + cm >> 2], q2[$l + 44 >> 2] = am + q2[28 + cm >> 2], q2[$l + 48 >> 2] = am + q2[32 + cm >> 2], q2[$l + 52 >> 2] = am + q2[36 + cm >> 2], q2[$l + 16 >> 2] = am + q2[40 + cm >> 2], q2[$l + 24 >> 2] = am + q2[44 + cm >> 2], q2[$l + 28 >> 2] = am + q2[48 + cm >> 2], q2[$l + 32 >> 2] = am + q2[52 + cm >> 2], q2[$l + 36 >> 2] = am + q2[56 + cm >> 2], Il = q2[a2 + 704 >> 2], q2[$l + 308 >> 2] = am + q2[60 + cm >> 2], q2[$l + 312 >> 2] = am + q2[64 + cm >> 2], q2[$l + 316 >> 2] = am + q2[68 + cm >> 2], q2[$l + 320 >> 2] = am + q2[72 + cm >> 2], q2[$l + 324 >> 2] = am + q2[76 + cm >> 2], q2[$l + 328 >> 2] = am + q2[80 + cm >> 2], q2[$l + 60 >> 2] = am + q2[84 + cm >> 2], q2[$l + 144 >> 2] = am + q2[88 + cm >> 2], q2[$l + 148 >> 2] = am + q2[92 + cm >> 2], Jl = am + q2[96 + cm >> 2] | 0, q2[$l + 152 >> 2] = Jl, !((0 | (dm = q2[Il + 8 >> 2])) < 1) && (Il = am + q2[100 + cm >> 2] | 0, q2[Jl >> 2] = Il, 1 != (0 | dm))) {
                        for (Jl = 1; ; ) if (Il = (15 + (q2[q2[a2 + 796 >> 2] + (bm << 2) >> 2] << 3) & -16) + Il | 0, q2[q2[$l + 152 >> 2] + (Jl << 2) >> 2] = Il, (0 | dm) == (0 | (Jl = (bm = Jl) + 1 | 0))) break;
                      }
                      if (q2[$l + 156 >> 2] = am + q2[104 + cm >> 2], q2[$l + 160 >> 2] = am + q2[108 + cm >> 2], q2[$l + 68 >> 2] = am + q2[112 + cm >> 2], q2[$l + 76 >> 2] = am + q2[116 + cm >> 2], q2[$l + 80 >> 2] = am + q2[120 + cm >> 2], q2[$l + 84 >> 2] = am + q2[124 + cm >> 2], q2[$l + 88 >> 2] = am + q2[128 + cm >> 2], q2[$l + 92 >> 2] = am + q2[132 + cm >> 2], q2[$l + 96 >> 2] = am + q2[136 + cm >> 2], q2[$l + 100 >> 2] = am + q2[140 + cm >> 2], q2[$l + 104 >> 2] = am + q2[144 + cm >> 2], q2[$l + 108 >> 2] = am + q2[148 + cm >> 2], q2[$l + 112 >> 2] = am + q2[152 + cm >> 2], q2[$l + 116 >> 2] = am + q2[156 + cm >> 2], q2[$l + 120 >> 2] = am + q2[160 + cm >> 2], q2[$l + 124 >> 2] = am + q2[164 + cm >> 2], q2[$l + 128 >> 2] = am + q2[168 + cm >> 2], q2[$l + 132 >> 2] = am + q2[172 + cm >> 2], q2[$l + 136 >> 2] = am + q2[176 + cm >> 2], q2[$l + 140 >> 2] = am + q2[180 + cm >> 2], q2[$l + 168 >> 2] = am + q2[184 + cm >> 2], q2[$l + 264 >> 2] = am + q2[188 + cm >> 2], q2[$l + 268 >> 2] = am + q2[192 + cm >> 2], q2[$l + 272 >> 2] = am + q2[196 + cm >> 2], q2[$l + 276 >> 2] = am + q2[200 + cm >> 2], q2[$l + 280 >> 2] = am + q2[204 + cm >> 2], q2[$l + 284 >> 2] = am + q2[208 + cm >> 2], q2[$l + 288 >> 2] = am + q2[212 + cm >> 2], q2[$l + 292 >> 2] = am + q2[216 + cm >> 2], q2[$l + 296 >> 2] = am + q2[220 + cm >> 2], q2[$l + 300 >> 2] = am + q2[224 + cm >> 2], q2[$l + 176 >> 2] = am + q2[228 + cm >> 2], q2[$l + 184 >> 2] = am + q2[232 + cm >> 2], q2[$l + 188 >> 2] = am + q2[236 + cm >> 2], q2[$l + 192 >> 2] = am + q2[240 + cm >> 2], q2[$l + 196 >> 2] = am + q2[244 + cm >> 2], q2[$l + 200 >> 2] = am + q2[248 + cm >> 2], q2[$l + 204 >> 2] = am + q2[252 + cm >> 2], q2[$l + 208 >> 2] = am + q2[256 + cm >> 2], q2[$l + 212 >> 2] = am + q2[260 + cm >> 2], q2[$l + 216 >> 2] = am + q2[264 + cm >> 2], q2[$l + 220 >> 2] = am + q2[268 + cm >> 2], q2[$l + 224 >> 2] = am + q2[272 + cm >> 2], q2[$l + 228 >> 2] = am + q2[276 + cm >> 2], q2[$l + 232 >> 2] = am + q2[280 + cm >> 2], q2[$l + 236 >> 2] = am + q2[284 + cm >> 2], q2[$l + 240 >> 2] = am + q2[288 + cm >> 2], q2[$l + 244 >> 2] = am + q2[292 + cm >> 2], q2[$l + 248 >> 2] = am + q2[296 + cm >> 2], q2[$l + 252 >> 2] = am + q2[300 + cm >> 2], q2[$l + 256 >> 2] = am + q2[304 + cm >> 2], q2[$l + 260 >> 2] = am + q2[308 + cm >> 2], Il = q2[a2 + 704 >> 2], q2[$l + 336 >> 2] = am + q2[312 + cm >> 2], q2[$l + 424 >> 2] = am + q2[316 + cm >> 2], q2[$l + 432 >> 2] = am + q2[320 + cm >> 2], q2[$l + 436 >> 2] = am + q2[324 + cm >> 2], q2[$l + 440 >> 2] = am + q2[328 + cm >> 2], Jl = am + q2[332 + cm >> 2] | 0, q2[$l + 444 >> 2] = Jl, !((0 | (dm = q2[Il + 16 >> 2])) < 1) && (bm = am + q2[336 + cm >> 2] | 0, q2[Jl >> 2] = bm, (Jl = 1) != (0 | dm))) {
                        for (Il = 0; ; ) if (bm = (15 + (q2[q2[a2 + 892 >> 2] + (Il << 2) >> 2] << 3) & -16) + bm | 0, q2[q2[$l + 444 >> 2] + (Jl << 2) >> 2] = bm, (0 | dm) == (0 | (Jl = (Il = Jl) + 1 | 0))) break;
                      }
                      if (q2[$l + 448 >> 2] = am + q2[340 + cm >> 2], q2[$l + 452 >> 2] = am + q2[344 + cm >> 2], q2[$l + 456 >> 2] = am + q2[348 + cm >> 2], q2[$l + 460 >> 2] = am + q2[352 + cm >> 2], q2[$l + 464 >> 2] = am + q2[356 + cm >> 2], q2[$l + 468 >> 2] = am + q2[360 + cm >> 2], q2[$l + 472 >> 2] = am + q2[364 + cm >> 2], q2[$l + 476 >> 2] = am + q2[368 + cm >> 2], q2[$l + 344 >> 2] = am + q2[372 + cm >> 2], q2[$l + 352 >> 2] = am + q2[376 + cm >> 2], q2[$l + 356 >> 2] = am + q2[380 + cm >> 2], q2[$l + 360 >> 2] = am + q2[384 + cm >> 2], q2[$l + 364 >> 2] = am + q2[388 + cm >> 2], q2[$l + 368 >> 2] = am + q2[392 + cm >> 2], q2[$l + 372 >> 2] = am + q2[396 + cm >> 2], q2[$l + 376 >> 2] = am + q2[400 + cm >> 2], q2[$l + 380 >> 2] = am + q2[404 + cm >> 2], q2[$l + 384 >> 2] = am + q2[408 + cm >> 2], q2[$l + 388 >> 2] = am + q2[412 + cm >> 2], q2[$l + 392 >> 2] = am + q2[416 + cm >> 2], q2[$l + 396 >> 2] = am + q2[420 + cm >> 2], q2[$l + 400 >> 2] = am + q2[424 + cm >> 2], q2[$l + 404 >> 2] = am + q2[428 + cm >> 2], q2[$l + 408 >> 2] = am + q2[432 + cm >> 2], q2[$l + 412 >> 2] = am + q2[436 + cm >> 2], q2[$l + 416 >> 2] = am + q2[440 + cm >> 2], q2[$l + 420 >> 2] = am + q2[444 + cm >> 2], Il = q2[448 + cm >> 2], Jl = q2[452 + cm >> 2], q2[$l + 552 >> 2] = am + q2[456 + cm >> 2], q2[$l + 548 >> 2] = Jl + am, q2[$l + 544 >> 2] = Il + am, q2[$l + 560 >> 2] = am + q2[460 + cm >> 2], Il = q2[a2 + 704 >> 2], gm = am + q2[464 + cm >> 2] | 0, q2[$l + 568 >> 2] = gm, 1 <= (0 | (fm = q2[Il + 48 >> 2]))) {
                        for (bm = am + q2[468 + cm >> 2] | 0, Il = am + q2[472 + cm >> 2] | 0, em = am + q2[476 + cm >> 2] | 0, hm = q2[a2 + 1072 >> 2], Jl = 0; ; ) if (dm = gm + w2(Jl, 36) | 0, q2[dm + 20 >> 2] = em, q2[dm + 16 >> 2] = Il, q2[dm >> 2] = bm, dm = q2[hm + (Jl << 2) >> 2], bm = (dm << 2) + bm | 0, em = (dm = 1 << dm << 2) + em | 0, Il = Il + dm | 0, (0 | fm) == (0 | (Jl = Jl + 1 | 0))) break;
                      }
                      if (Il = q2[a2 + 704 >> 2], dm = am + q2[516 + cm >> 2] | 0, q2[$l + 484 >> 2] = dm, 1 <= (0 | (Il = q2[Il + 72 >> 2]))) {
                        for (bm = am + q2[520 + cm >> 2] | 0, em = q2[a2 + 1212 >> 2], Jl = 0; ; ) if (q2[12 + (dm + w2(Jl, 28) | 0) >> 2] = bm, bm = (q2[em + (Jl << 2) >> 2] << 4) + bm | 0, (0 | Il) == (0 | (Jl = Jl + 1 | 0))) break;
                      }
                      q2[$l + 488 >> 2] = am + q2[524 + cm >> 2], q2[$l + 492 >> 2] = am + q2[528 + cm >> 2], q2[$l + 496 >> 2] = am + q2[532 + cm >> 2], q2[$l + 504 >> 2] = am + q2[536 + cm >> 2], q2[$l + 536 >> 2] = am + q2[540 + cm >> 2], q2[$l + 512 >> 2] = am + q2[544 + cm >> 2], q2[$l + 520 >> 2] = am + q2[548 + cm >> 2], q2[$l + 524 >> 2] = am + q2[552 + cm >> 2], q2[$l + 528 >> 2] = am + q2[556 + cm >> 2], q2[$l + 532 >> 2] = am + q2[560 + cm >> 2];
                      c: {
                        if (4 <= (fm = r2[a2 + 4 | 0]) >>> 0) {
                          if (q2[$l + 576 >> 2] = am + q2[480 + cm >> 2], q2[$l + 584 >> 2] = am + q2[484 + cm >> 2], Il = q2[a2 + 704 >> 2], Jl = q2[492 + cm >> 2], dm = am + q2[488 + cm >> 2] | 0, q2[$l + 592 >> 2] = dm, 1 <= (0 | (Il = q2[Il + 104 >> 2]))) {
                            for (bm = Jl + am | 0, em = q2[a2 + 1104 >> 2], Jl = 0; ; ) if (q2[40 + (dm + w2(Jl, 48) | 0) >> 2] = bm, bm = (q2[em + (Jl << 2) >> 2] << 2) + bm | 0, (0 | Il) == (0 | (Jl = Jl + 1 | 0))) break;
                          }
                          q2[$l + 608 >> 2] = am + q2[500 + cm >> 2], q2[$l + 624 >> 2] = am + q2[508 + cm >> 2];
                        } else {
                          if (Il = q2[572 + cm >> 2], Jl = q2[568 + cm >> 2], q2[$l + 636 >> 2] = am + q2[564 + cm >> 2], q2[$l + 640 >> 2] = Jl + am, q2[q2[a2 + 704 >> 2] + 20 >> 2] < 1) break c;
                          for (dm = Il + am | 0, gm = 0; ; ) {
                            e: {
                              if ((0 | (bm = q2[(Il = gm << 2) + q2[a2 + 952 >> 2] >> 2])) <= 0) Il = Il + q2[$l + 636 >> 2] | 0;
                              else {
                                for (Jl = q2[Il + q2[a2 + 948 >> 2] >> 2], em = bm + Jl | 0, hm = q2[a2 + 1060 >> 2], bm = 0; ; ) if (bm = q2[hm + (Jl << 2) >> 2] + bm | 0, !((0 | (Jl = Jl + 1 | 0)) < (0 | em))) break;
                                if (Il = Il + q2[$l + 636 >> 2] | 0, Jl = dm, bm) break e;
                              }
                              Jl = bm = 0;
                            }
                            if (q2[Il >> 2] = Jl, dm = (bm << 2) + dm | 0, !((0 | (gm = gm + 1 | 0)) < q2[q2[a2 + 704 >> 2] + 20 >> 2])) break;
                          }
                        }
                        fm >>> 0 < 5 || (q2[$l + 600 >> 2] = am + q2[496 + cm >> 2], q2[$l + 616 >> 2] = am + q2[504 + cm >> 2], q2[$l + 632 >> 2] = am + q2[512 + cm >> 2]);
                      }
                      q2[$l + 644 >> 2] = 1, q2[$l >> 2] = a2, q2[$l + 648 >> 2] = 1 & o[q2[a2 + 708 >> 2] + 20 | 0], am = q2[a2 + 704 >> 2], gm = q2[am + 20 >> 2], q2[$l + 540 >> 2] = gm;
                      g: if (!((0 | gm) < 1)) {
                        if (Il = gm + -1 | 0, hm = q2[a2 + 952 >> 2], im = q2[a2 + 940 >> 2], jm = q2[a2 + 932 >> 2], km = q2[a2 + 936 >> 2], lm = q2[a2 + 924 >> 2], mm = q2[a2 + 928 >> 2], om = q2[$l + 552 >> 2], qm = q2[$l + 544 >> 2], fm >>> 0 < 4) {
                          for (; ; ) if (Jl = qm + w2(Il, 52) | 0, q2[Jl >> 2] = 0, bm = (dm = Il << 2) + mm | 0, q2[Jl + 4 >> 2] = q2[bm >> 2], em = dm + lm | 0, q2[Jl + 8 >> 2] = q2[em >> 2], u2[Jl + 12 >> 2] = u2[em >> 2] - u2[bm >> 2], q2[Jl + 16 >> 2] = q2[dm + km >> 2], bm = dm + jm | 0, q2[Jl + 44 >> 2] = q2[bm >> 2], nm = Aa2(x2(q2[dm + im >> 2])), u2[Jl + 20 >> 2] = nm, u2[Jl + 24 >> 2] = nm * x2(1.5), pm = q2[dm + hm >> 2], q2[Jl + 32 >> 2] = pm, em = 0, em = pm ? q2[$l + 560 >> 2] + w2(q2[dm + q2[a2 + 948 >> 2] >> 2], 28) | 0 : em, q2[Jl + 48 >> 2] = 1, q2[Jl + 28 >> 2] = em, q2[dm + om >> 2] = q2[bm >> 2], Jl = 0 < (0 | Il), Il = Il + -1 | 0, !Jl) break g;
                        }
                        for (pm = q2[a2 + 960 >> 2], sm = q2[a2 + 944 >> 2]; ; ) if (Jl = qm + w2(Il, 52) | 0, bm = Il << 2, q2[Jl >> 2] = q2[bm + sm >> 2], dm = bm + mm | 0, q2[Jl + 4 >> 2] = q2[dm >> 2], em = bm + lm | 0, q2[Jl + 8 >> 2] = q2[em >> 2], u2[Jl + 12 >> 2] = u2[em >> 2] - u2[dm >> 2], q2[Jl + 16 >> 2] = q2[bm + km >> 2], rm = bm + jm | 0, q2[Jl + 44 >> 2] = q2[rm >> 2], nm = Aa2(x2(q2[bm + im >> 2])), u2[Jl + 20 >> 2] = nm, u2[Jl + 24 >> 2] = nm * x2(1.5), em = q2[bm + hm >> 2], q2[Jl + 32 >> 2] = em, q2[Jl + 28 >> 2] = em ? q2[$l + 560 >> 2] + w2(q2[bm + q2[a2 + 948 >> 2] >> 2], 28) | 0 : 0, dm = q2[bm + pm >> 2], dm = (q2[Jl + 40 >> 2] = dm) ? q2[$l + 584 >> 2] + w2(q2[bm + q2[a2 + 956 >> 2] >> 2], 28) | 0 : 0, q2[Jl + 48 >> 2] = 1, q2[Jl + 36 >> 2] = dm, q2[bm + om >> 2] = q2[rm >> 2], Jl = 0 < (0 | Il), Il = Il + -1 | 0, !Jl) break;
                      }
                      if (4 <= fm >>> 0 ? (q2[$l + 548 >> 2] = q2[a2 + 944 >> 2], dm = a2) : (ca2(q2[$l + 548 >> 2], 0, gm << 2), dm = q2[$l >> 2], am = q2[dm + 704 >> 2]), bm = q2[am + 52 >> 2], 1 <= (0 | (q2[$l + 556 >> 2] = bm))) {
                        for (Jl = q2[dm + 1056 >> 2], em = q2[dm + 1192 >> 2], gm = q2[dm + 1060 >> 2], fm = q2[$l + 560 >> 2]; ; ) if (Il = fm + w2(bm = bm + -1 | 0, 28) | 0, hm = bm << 2, q2[Il >> 2] = q2[hm + gm >> 2], hm = q2[Jl + hm >> 2], q2[Il + 24 >> 2] = 1, q2[Il + 16 >> 2] = 0, q2[Il + 20 >> 2] = 1, q2[Il + 8 >> 2] = 0, q2[Il + 12 >> 2] = 0, q2[Il + 4 >> 2] = em + (hm << 2), !(0 < (0 | bm))) break;
                      }
                      if (bm = q2[am + 48 >> 2], 1 <= (0 | (q2[$l + 564 >> 2] = bm))) {
                        for (; ; ) {
                          if (bm = bm + -1 | 0, Il = q2[$l + 568 >> 2] + w2(bm, 36) | 0, em = q2[(am = bm << 2) + q2[dm + 1072 >> 2] >> 2], 1 <= (0 | (q2[Il + 4 >> 2] = em))) {
                            for (Jl = 0; ; ) if (q2[q2[Il >> 2] + (Jl << 2) >> 2] = q2[$l + 560 >> 2] + w2(q2[q2[dm + 1064 >> 2] + (q2[am + q2[dm + 1068 >> 2] >> 2] + Jl << 2) >> 2], 28), (0 | em) == (0 | (Jl = Jl + 1 | 0))) break;
                          }
                          if (q2[Il + 24 >> 2] = 1, q2[Il + 28 >> 2] = 1, q2[Il + 8 >> 2] = 1 << em, !(0 < (0 | bm))) break;
                        }
                        dm = q2[$l >> 2], am = q2[dm + 704 >> 2];
                      }
                      if (Il = q2[am >> 2], (0 | (q2[$l + 4 >> 2] = Il)) < 1) Jl = 0;
                      else {
                        for (hm = q2[dm + 732 >> 2], im = q2[dm + 736 >> 2], jm = q2[dm + 740 >> 2], em = q2[dm + 720 >> 2], km = q2[$l + 52 >> 2], gm = q2[$l + 568 >> 2], lm = q2[$l + 8 >> 2], bm = Il; ; ) if (fm = lm + w2(bm = bm + -1 | 0, 12) | 0, Jl = bm << 2, q2[fm >> 2] = gm + w2(q2[Jl + em >> 2], 36), q2[fm + 4 >> 2] = q2[Jl + jm >> 2], q2[fm + 8 >> 2] = q2[Jl + im >> 2], u2[Jl + km >> 2] = q2[Jl + hm >> 2] ? x2(1) : x2(0), !(0 < (0 | bm))) break;
                        for (fm = q2[$l + 16 >> 2], Jl = 0; ; ) if (bm = q2[8 + (gm + w2(q2[(hm = (Il = Il + -1 | 0) << 2) + em >> 2], 36) | 0) >> 2], q2[fm + hm >> 2] = bm, Jl = Jl + bm | 0, !(0 < (0 | Il))) break;
                        Il = q2[$l + 4 >> 2];
                      }
                      if (q2[$l + 12 >> 2] = Il, q2[$l + 20 >> 2] = Jl, Il = q2[am + 4 >> 2], 1 <= (0 | (q2[$l + 304 >> 2] = Il))) {
                        for (; ; ) if (Il = Il + -1 | 0, Jl = q2[$l + 308 >> 2] + (Il << 5) | 0, bm = Il << 2, q2[Jl >> 2] = q2[$l + 568 >> 2] + w2(q2[bm + q2[dm + 752 >> 2] >> 2], 36), q2[Jl + 4 >> 2] = q2[bm + q2[dm + 764 >> 2] >> 2], q2[Jl + 8 >> 2] = q2[bm + q2[dm + 768 >> 2] >> 2], em = q2[bm + q2[dm + 772 >> 2] >> 2], q2[Jl + 12 >> 2] = em, am = q2[bm + q2[dm + 776 >> 2] >> 2], q2[Jl + 16 >> 2] = am, q2[Jl + 28 >> 2] = q2[bm + q2[dm + 760 >> 2] >> 2], em >>> 0 <= 1 ? em - 1 ? (q2[20 + (q2[$l + 60 >> 2] + w2(am, 24) | 0) >> 2] = Il, q2[Jl + 24 >> 2] = 1, q2[Jl + 20 >> 2] = 2) : (q2[8 + (q2[$l + 168 >> 2] + w2(am, 12) | 0) >> 2] = Il, q2[Jl + 24 >> 2] = 3, q2[Jl + 20 >> 2] = 4) : Y3(4, 1179, 0), !(0 < (0 | Il))) break;
                        dm = q2[$l >> 2], am = q2[dm + 704 >> 2];
                      }
                      bm = q2[am + 8 >> 2], q2[$l + 56 >> 2] = bm;
                      k: if (!((0 | bm) < 1)) {
                        if (Jl = bm + -1 | 0, gm = q2[dm + 796 >> 2], fm = q2[dm + 804 >> 2], hm = q2[dm + 800 >> 2], im = q2[dm + 780 >> 2], jm = q2[$l + 568 >> 2], km = q2[$l + 60 >> 2], r2[dm + 4 | 0] < 2) {
                          for (; ; ) if (Il = km + w2(Jl, 24) | 0, em = Jl << 2, q2[Il >> 2] = jm + w2(q2[em + im >> 2], 36), q2[Il + 4 >> 2] = q2[em + hm >> 2], q2[Il + 8 >> 2] = q2[em + fm >> 2], em = q2[em + gm >> 2], q2[Il + 12 >> 2] = 0, q2[Il + 16 >> 2] = em, Il = 0 < (0 | Jl), Jl = Jl + -1 | 0, !Il) break k;
                        }
                        for (lm = q2[dm + 808 >> 2]; ; ) if (Il = km + w2(Jl, 24) | 0, em = Jl << 2, q2[Il >> 2] = jm + w2(q2[em + im >> 2], 36), q2[Il + 4 >> 2] = q2[em + hm >> 2], q2[Il + 8 >> 2] = q2[em + fm >> 2], q2[Il + 16 >> 2] = q2[em + gm >> 2], q2[Il + 12 >> 2] = q2[em + lm >> 2], Il = 0 < (0 | Jl), Jl = Jl + -1 | 0, !Il) break;
                      }
                      if (Jl = q2[am + 12 >> 2], 1 <= (0 | (q2[$l + 164 >> 2] = Jl))) {
                        for (em = q2[dm + 828 >> 2], gm = q2[dm + 812 >> 2], fm = q2[$l + 568 >> 2], hm = q2[$l + 168 >> 2], Il = Jl; ; ) if (im = hm + w2(Il = Il + -1 | 0, 12) | 0, jm = Il << 2, q2[im >> 2] = fm + w2(q2[jm + gm >> 2], 36), q2[im + 4 >> 2] = q2[em + jm >> 2], !(0 < (0 | Il))) break;
                      }
                      if (((Il = 0) | bm) < 1) em = 0;
                      else {
                        for (gm = q2[$l + 68 >> 2], fm = q2[$l + 60 >> 2], em = 0; ; ) if (Jl = q2[q2[fm + w2(bm = bm + -1 | 0, 24) >> 2] + 8 >> 2], q2[gm + (bm << 2) >> 2] = Jl, em = Jl + em | 0, !(0 < (0 | bm))) break;
                        Jl = q2[$l + 164 >> 2], bm = q2[$l + 56 >> 2];
                      }
                      if (q2[$l + 64 >> 2] = bm, q2[$l + 72 >> 2] = em, bm = $l, 1 <= (0 | Jl)) {
                        for (gm = q2[$l + 176 >> 2], fm = q2[$l + 168 >> 2]; ; ) if (em = q2[q2[fm + w2(Jl = Jl + -1 | 0, 12) >> 2] + 8 >> 2], q2[gm + (Jl << 2) >> 2] = em, Il = Il + em | 0, !(0 < (0 | Jl))) break;
                        Jl = q2[$l + 164 >> 2];
                      }
                      if (q2[bm + 172 >> 2] = Jl, q2[$l + 180 >> 2] = Il, em = q2[am + 16 >> 2], 1 <= (0 | (q2[$l + 332 >> 2] = em))) {
                        for (hm = q2[dm + 872 >> 2], im = q2[dm + 892 >> 2], jm = q2[dm + 880 >> 2], km = q2[dm + 876 >> 2], gm = q2[dm + 852 >> 2], fm = q2[$l + 568 >> 2], lm = q2[$l + 336 >> 2], Il = em; ; ) if (Jl = lm + w2(Il = Il + -1 | 0, 20) | 0, bm = Il << 2, q2[Jl >> 2] = fm + w2(q2[bm + gm >> 2], 36), q2[Jl + 4 >> 2] = q2[bm + km >> 2], q2[Jl + 8 >> 2] = q2[bm + jm >> 2], q2[Jl + 16 >> 2] = q2[bm + im >> 2], q2[Jl + 12 >> 2] = q2[bm + hm >> 2], !(0 < (0 | Il))) break;
                        for (bm = q2[$l + 344 >> 2], Jl = 0; ; ) if (Il = q2[8 + (fm + w2(q2[(hm = (em = em + -1 | 0) << 2) + gm >> 2], 36) | 0) >> 2], q2[bm + hm >> 2] = Il, Jl = Il + Jl | 0, !(0 < (0 | em))) break;
                        if (q2[$l + 348 >> 2] = Jl, em = q2[$l + 332 >> 2], !((0 | (q2[$l + 340 >> 2] = em)) < 1)) {
                          for (Jl = em << 2, bm = q2[$l + 456 >> 2], gm = q2[$l + 452 >> 2]; ; ) if (q2[(fm = (Il = Jl + -4 | 0) << 2) + gm >> 2] = 1065353216, q2[(hm = (Jl <<= 2) + -4 | 0) + gm >> 2] = 1065353216, q2[(im = (Jl = Jl + -12 | 0) + gm | 0) >> 2] = 1065353216, q2[im + 4 >> 2] = 1065353216, q2[bm + fm >> 2] = 0, q2[bm + hm >> 2] = 1065353216, q2[(Jl = Jl + bm | 0) >> 2] = 0, q2[Jl + 4 >> 2] = 0, Jl = Il, !(0 < (0 | (em = em + -1 | 0)))) break;
                        }
                      } else q2[$l + 340 >> 2] = em, q2[$l + 348 >> 2] = 0;
                      if (em = q2[am + 72 >> 2], 1 <= (0 | (q2[$l + 480 >> 2] = em))) for (hm = q2[dm + 1208 >> 2], im = q2[dm + 1224 >> 2], jm = q2[dm + 1220 >> 2], km = q2[dm + 1216 >> 2], lm = q2[dm + 1212 >> 2], mm = q2[$l + 484 >> 2], bm = 0; ; ) {
                        if (Il = mm + w2(bm, 28) | 0, gm = q2[(Jl = bm << 2) + lm >> 2], q2[Il + 4 >> 2] = gm, q2[Il >> 2] = q2[Jl + km >> 2], fm = q2[Jl + jm >> 2], q2[Il + 16 >> 2] = fm, om = q2[Jl + im >> 2], q2[Il + 20 >> 2] = om, q2[Il + 8 >> 2] = 0, q2[Il + 24 >> 2] = 1 + (fm - om | 0), 1 <= (0 | gm)) {
                          for (om = q2[Jl + hm >> 2], qm = q2[Il + 12 >> 2], pm = q2[dm + 1236 >> 2], sm = q2[dm + 1228 >> 2], rm = q2[dm + 1232 >> 2], Jl = 0; ; ) if (fm = Jl + om << 2, q2[(Il = qm + (Jl << 4) | 0) + 4 >> 2] = q2[fm + rm >> 2], q2[Il >> 2] = q2[fm + sm >> 2], fm = q2[fm + pm >> 2], q2[Il + 12 >> 2] = 0, q2[Il + 8 >> 2] = fm, (0 | gm) == (0 | (Jl = Jl + 1 | 0))) break;
                        }
                        if ((0 | em) == (0 | (bm = bm + 1 | 0))) break;
                      }
                      if (Jl = q2[am + 80 >> 2], (0 | (q2[$l + 500 >> 2] = Jl)) < 1) bm = 0;
                      else {
                        for (fm = q2[dm + 1280 >> 2], hm = q2[dm + 1268 >> 2], im = q2[dm + 1276 >> 2], jm = q2[dm + 1272 >> 2], km = q2[dm + 1264 >> 2], lm = q2[dm + 1260 >> 2], em = q2[dm + 1248 >> 2], gm = q2[$l + 568 >> 2], mm = q2[$l + 504 >> 2]; ; ) if (Il = mm + w2(Jl = Jl + -1 | 0, 24) | 0, bm = Jl << 2, q2[Il >> 2] = gm + w2(q2[bm + em >> 2], 36), q2[Il + 4 >> 2] = q2[bm + lm >> 2], q2[Il + 8 >> 2] = q2[bm + km >> 2], q2[Il + 12 >> 2] = q2[bm + jm >> 2], bm = q2[bm + hm >> 2], q2[Il + 20 >> 2] = fm + (bm << 1), q2[Il + 16 >> 2] = im + (bm << 2), !(0 < (0 | Jl))) break;
                        if ((0 | (Jl = q2[$l + 500 >> 2])) < 1) bm = 0;
                        else {
                          for (fm = q2[$l + 512 >> 2], bm = 0; ; ) if (Il = q2[8 + (gm + w2(q2[(hm = (Jl = Jl + -1 | 0) << 2) + em >> 2], 36) | 0) >> 2], q2[fm + hm >> 2] = Il, bm = Il + bm | 0, !(0 < (0 | Jl))) break;
                          Jl = q2[$l + 500 >> 2];
                        }
                      }
                      q2[$l + 508 >> 2] = Jl, q2[$l + 516 >> 2] = bm;
                      o: if (4 <= r2[a2 + 4 | 0]) {
                        if (!((em = r2[dm + 4 | 0]) >>> 0 < 4)) {
                          if (Jl = q2[am + 120 >> 2], 1 <= (0 | (q2[$l + 572 >> 2] = Jl))) {
                            for (fm = q2[dm + 1172 >> 2], hm = q2[$l + 576 >> 2]; ; ) if (am = q2[(Il = (Jl = Jl + -1 | 0) << 2) + fm >> 2], em = (0 | am) < 0 ? am = gm = bm = 0 : (em = q2[Il + q2[dm + 1176 >> 2] >> 2] << 2, bm = em + q2[dm + 1188 >> 2] | 0, gm = q2[Il + q2[dm + 1180 >> 2] >> 2], am = q2[$l + 544 >> 2] + w2(am, 52) | 0, em + q2[dm + 1184 >> 2] | 0), Il = hm + w2(Jl, 20) | 0, q2[Il + 12 >> 2] = gm, q2[Il + 8 >> 2] = bm, q2[Il + 4 >> 2] = em, q2[Il >> 2] = am, !(0 < (0 | Jl))) break;
                            if (dm = q2[$l >> 2], (em = r2[dm + 4 | 0]) >>> 0 < 4) break o;
                          }
                          if (am = q2[dm + 704 >> 2], bm = q2[am + 100 >> 2], 1 <= (0 | (q2[$l + 580 >> 2] = bm))) {
                            for (gm = q2[dm + 1084 >> 2], fm = q2[dm + 1076 >> 2], hm = q2[dm + 1192 >> 2], im = q2[dm + 1080 >> 2], jm = q2[$l + 584 >> 2]; ; ) if (Il = jm + w2(bm = bm + -1 | 0, 28) | 0, Jl = bm << 2, q2[Il >> 2] = q2[Jl + im >> 2], q2[Il + 4 >> 2] = hm + (q2[Jl + fm >> 2] << 2), Jl = q2[Jl + gm >> 2], q2[Il + 20 >> 2] = 1, q2[Il + 24 >> 2] = 1, q2[Il + 12 >> 2] = 0, q2[Il + 16 >> 2] = 0, q2[Il + 8 >> 2] = Jl, !(0 < (0 | bm))) break;
                          }
                          if (bm = q2[am + 104 >> 2], 1 <= (0 | (q2[$l + 588 >> 2] = bm))) {
                            for (; ; ) {
                              if (bm = bm + -1 | 0, Il = q2[$l + 592 >> 2] + w2(bm, 48) | 0, em = bm << 2, q2[Il >> 2] = q2[$l + 584 >> 2] + w2(q2[em + q2[dm + 1088 >> 2] >> 2], 28), Jl = q2[em + q2[dm + 1092 >> 2] >> 2], q2[Il + 28 >> 2] = 1, q2[Il + 32 >> 2] = 1, q2[Il + 8 >> 2] = 0, q2[Il + 4 >> 2] = Jl, am = q2[em + q2[dm + 1104 >> 2] >> 2], 1 <= (0 | (q2[Il + 36 >> 2] = am))) {
                                for (Jl = 0; ; ) if (q2[q2[Il + 40 >> 2] + (Jl << 2) >> 2] = q2[$l + 576 >> 2] + w2(q2[q2[dm + 1168 >> 2] + (q2[em + q2[dm + 1100 >> 2] >> 2] + Jl << 2) >> 2], 20), (0 | am) == (0 | (Jl = Jl + 1 | 0))) break;
                              }
                              if (!(1 <= (0 | bm))) break;
                            }
                            dm = q2[$l >> 2], em = r2[dm + 4 | 0];
                          }
                          if (!(em >>> 0 < 4)) {
                            if (em = q2[a2 + 704 >> 2], Jl = q2[em + 108 >> 2], 1 <= (0 | (q2[$l + 604 >> 2] = Jl))) {
                              for (am = q2[a2 + 1124 >> 2], gm = q2[a2 + 1128 >> 2], fm = q2[a2 + 1120 >> 2], hm = q2[$l + 592 >> 2], im = q2[$l + 608 >> 2]; ; ) if (Il = im + w2(Jl = Jl + -1 | 0, 12) | 0, bm = Jl << 2, q2[Il >> 2] = q2[bm + fm >> 2], q2[Il + 4 >> 2] = q2[bm + gm >> 2], q2[Il + 8 >> 2] = hm + w2(q2[am + bm >> 2], 48), !(0 < (0 | Jl))) break;
                            }
                            if (Jl = q2[em + 112 >> 2], 1 <= (0 | (q2[$l + 620 >> 2] = Jl))) {
                              for (em = q2[a2 + 1148 >> 2], am = q2[a2 + 1152 >> 2], gm = q2[a2 + 1144 >> 2], fm = q2[$l + 592 >> 2], hm = q2[$l + 624 >> 2]; ; ) if (Il = hm + w2(Jl = Jl + -1 | 0, 12) | 0, bm = Jl << 2, q2[Il >> 2] = q2[bm + gm >> 2], q2[Il + 4 >> 2] = q2[am + bm >> 2], q2[Il + 8 >> 2] = fm + w2(q2[bm + em >> 2], 48), !(0 < (0 | Jl))) break;
                            }
                            if (bm = q2[dm + 1192 >> 2], Il = q2[q2[dm + 704 >> 2] + 20 >> 2], q2[$l + 640 >> 2] = q2[dm + 972 >> 2], em = q2[dm + 964 >> 2], q2[$l + 636 >> 2] = em, !((0 | Il) < (Jl = 1)) && (q2[em >> 2] = bm + (q2[q2[dm + 968 >> 2] >> 2] << 2), 1 != (0 | Il))) {
                              for (; ; ) if (q2[(em = Jl << 2) + q2[$l + 636 >> 2] >> 2] = bm + (q2[em + q2[dm + 968 >> 2] >> 2] << 2), (0 | Il) == (0 | (Jl = Jl + 1 | 0))) break;
                            }
                          }
                        }
                      } else if (!(q2[am + 20 >> 2] < 1)) for (am = 0; ; ) {
                        if (bm = q2[(gm = am << 2) + q2[$l + 636 >> 2] >> 2], 1 <= ((Il = 0) | (Jl = q2[gm + q2[dm + 952 >> 2] >> 2]))) for (fm = q2[gm + q2[dm + 948 >> 2] >> 2], im = Jl + fm | 0, jm = q2[dm + 1060 >> 2], km = q2[dm + 1056 >> 2]; ; ) {
                          if (1 <= (0 | (hm = q2[(Jl = fm << 2) + jm >> 2]))) for (em = q2[Jl + km >> 2], lm = hm + em | 0, mm = q2[dm + 1192 >> 2]; ; ) {
                            hm = bm + (Il << 2) | 0, nm = u2[mm + (em << 2) >> 2], Jl = bm;
                            q: {
                              if (0 < (0 | Il)) for (; ; ) {
                                if (u2[Jl >> 2] == nm) break q;
                                if (!((Jl = Jl + 4 | 0) >>> 0 < hm >>> 0)) break;
                              }
                              u2[hm >> 2] = nm, Il = Il + 1 | 0;
                            }
                            if (!((0 | (em = em + 1 | 0)) < (0 | lm))) break;
                          }
                          if (!((0 | (fm = fm + 1 | 0)) < (0 | im))) break;
                        }
                        if (!function(a3, Sm) {
                          var un = 0, xn = 0, yn = 0, Jn = 0, Kn = 0;
                          q2[8 + (L2 = un = L2 - 208 | 0) >> 2] = 1, q2[12 + un >> 2] = 0;
                          a: if (Kn = Sm << 2) {
                            for (q2[16 + un >> 2] = 4, q2[20 + un >> 2] = 4, Jn = Sm = 4, xn = 2; ; ) if (Sm = (Jn + 4 | 0) + (yn = Sm) | 0, q2[(16 + un | 0) + (xn << 2) >> 2] = Sm, xn = xn + 1 | 0, Jn = yn, !(Sm >>> 0 < Kn >>> 0)) break;
                            if ((yn = (a3 + Kn | 0) - 4 | 0) >>> 0 <= a3 >>> 0) Sm = xn = 1;
                            else for (Sm = xn = 1; ; ) if (Sm = 3 == (3 & xn) ? (ta2(a3, Sm, 16 + un | 0), ma2(8 + un | 0, 2), Sm + 2 | 0) : (t3[(16 + un | 0) + ((Jn = Sm + -1 | 0) << 2) >> 2] >= yn - a3 >>> 0 ? la2(a3, 8 + un | 0, Sm, 0, 16 + un | 0) : ta2(a3, Sm, 16 + un | 0), 1 == (0 | Sm) ? (ka2(8 + un | 0, 1), 0) : (ka2(8 + un | 0, Jn), 1)), xn = 1 | q2[8 + un >> 2], q2[8 + un >> 2] = xn, !((a3 = a3 + 4 | 0) >>> 0 < yn >>> 0)) break;
                            for (la2(a3, 8 + un | 0, Sm, 0, 16 + un | 0); ; ) {
                              e: {
                                f: {
                                  g: {
                                    if (!(1 != (0 | Sm) | 1 != (0 | xn))) {
                                      if (q2[12 + un >> 2]) break g;
                                      break a;
                                    }
                                    if (1 < (0 | Sm)) break f;
                                  }
                                  yn = Oa(8 + un | 0), ma2(8 + un | 0, yn), xn = q2[8 + un >> 2], Sm = Sm + yn | 0;
                                  break e;
                                }
                                ka2(8 + un | 0, 2), q2[8 + un >> 2] = 7 ^ q2[8 + un >> 2], ma2(8 + un | 0, 1), la2((Jn = a3 + -4 | 0) - q2[(16 + un | 0) + ((yn = Sm + -2 | 0) << 2) >> 2] | 0, 8 + un | 0, Sm + -1 | 0, 1, 16 + un | 0), ka2(8 + un | 0, 1), xn = 1 | q2[8 + un >> 2], q2[8 + un >> 2] = xn, la2(Jn, 8 + un | 0, yn, 1, 16 + un | 0), Sm = yn;
                              }
                              a3 = a3 + -4 | 0;
                            }
                          }
                          L2 = 208 + un | 0;
                        }(bm, Il), q2[gm + q2[$l + 640 >> 2] >> 2] = Il, !((0 | (am = am + 1 | 0)) < q2[q2[dm + 704 >> 2] + 20 >> 2])) break;
                      }
                      if (!(r2[a2 + 4 | 0] < 5 | r2[q2[$l >> 2] + 4 | 0] < 4)) {
                        if (Il = q2[a2 + 704 >> 2], Jl = q2[Il + 128 >> 2], 1 <= (0 | (q2[$l + 596 >> 2] = Jl))) {
                          for (em = q2[a2 + 1112 >> 2], am = q2[a2 + 1116 >> 2], gm = q2[a2 + 1108 >> 2], fm = q2[$l + 592 >> 2], hm = q2[$l + 600 >> 2]; ; ) if (dm = hm + w2(Jl = Jl + -1 | 0, 12) | 0, bm = Jl << 2, q2[dm >> 2] = q2[bm + gm >> 2], q2[dm + 4 >> 2] = q2[am + bm >> 2], q2[dm + 8 >> 2] = fm + w2(q2[bm + em >> 2], 48), !(0 < (0 | Jl))) break;
                        }
                        if (Jl = q2[Il + 132 >> 2], 1 <= (0 | (q2[$l + 612 >> 2] = Jl))) {
                          for (em = q2[a2 + 1136 >> 2], am = q2[a2 + 1140 >> 2], gm = q2[a2 + 1132 >> 2], fm = q2[$l + 592 >> 2], hm = q2[$l + 616 >> 2]; ; ) if (dm = hm + w2(Jl = Jl + -1 | 0, 12) | 0, bm = Jl << 2, q2[dm >> 2] = q2[bm + gm >> 2], q2[dm + 4 >> 2] = q2[am + bm >> 2], q2[dm + 8 >> 2] = fm + w2(q2[bm + em >> 2], 48), !(0 < (0 | Jl))) break;
                        }
                        if (Jl = q2[Il + 136 >> 2], !((0 | (q2[$l + 628 >> 2] = Jl)) < 1)) {
                          for (dm = q2[a2 + 1160 >> 2], bm = q2[a2 + 1164 >> 2], em = q2[a2 + 1156 >> 2], am = q2[$l + 592 >> 2], gm = q2[$l + 632 >> 2]; ; ) if (a2 = gm + w2(Jl = Jl + -1 | 0, 12) | 0, Il = Jl << 2, q2[a2 >> 2] = q2[Il + em >> 2], q2[a2 + 4 >> 2] = q2[Il + bm >> 2], q2[a2 + 8 >> 2] = am + w2(q2[Il + dm >> 2], 48), !(0 < (0 | Jl))) break;
                        }
                      }
                      ua($l);
                    }
                    return L2 = 576 + cm | 0, $l;
                  }(a, Wa, Xa)) break a;
                  q2[36 + Ya >> 2] = 2209, q2[32 + Ya >> 2] = 2361, Y3(4, 1294, 32 + Ya | 0);
                }
                else q2[20 + Ya >> 2] = 1444, q2[16 + Ya >> 2] = 2361, Y3(4, 1294, 16 + Ya | 0);
                else q2[4 + Ya >> 2] = 2132, q2[Ya >> 2] = 2361, Y3(4, 1294, Ya);
                Wa = 0;
              }
              return L2 = Ya + 64 | 0, 0 | Wa;
            }
            function xa2(a) {
              var Wa;
              return L2 = Wa = L2 - 16 | 0, a = (a |= 0) ? function(a2) {
                var Il = 0;
                return ca2(16 + (L2 = Il = L2 - 576 | 0) | 0, 0, 560), Fa(a2, 16 + Il | 0, 12 + Il | 0), L2 = 576 + Il | 0, q2[12 + Il >> 2];
              }(a) : (q2[4 + Wa >> 2] = 2132, q2[Wa >> 2] = 2343, Y3(4, 1294, Wa), 0), L2 = 16 + Wa | 0, 0 | a;
            }
            function ya2(a) {
              var Xa = r2[a + 4 | 0];
              X3(q2[a + 704 >> 2], 4, 64), da2(q2[a + 708 >> 2], 4), da2(q2[a + 708 >> 2] + 4 | 0, 4), da2(q2[a + 708 >> 2] + 8 | 0, 4), da2(q2[a + 708 >> 2] + 12 | 0, 4), da2(q2[a + 708 >> 2] + 16 | 0, 4), da2(q2[a + 708 >> 2] + 20 | 0, 1), X3(q2[a + 720 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 724 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 728 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 732 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 736 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 740 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 752 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 756 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 760 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 764 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 768 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 772 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 776 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 780 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 784 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 788 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 796 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 800 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 804 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 812 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 816 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 820 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 828 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 852 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 856 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 860 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 868 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 872 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 876 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 880 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 884 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 888 >> 2], 1, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 892 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 896 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 900 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 904 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 908 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 912 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 924 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 928 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 932 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 936 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 940 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 948 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 952 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 976 >> 2], 4, q2[q2[a + 704 >> 2] + 24 >> 2]), X3(q2[a + 980 >> 2], 4, q2[q2[a + 704 >> 2] + 28 >> 2]), X3(q2[a + 984 >> 2], 4, q2[q2[a + 704 >> 2] + 28 >> 2]), X3(q2[a + 996 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1e3 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1004 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1008 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1012 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1016 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1020 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1032 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1036 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1040 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1052 >> 2], 4, q2[q2[a + 704 >> 2] + 40 >> 2]), X3(q2[a + 1064 >> 2], 4, q2[q2[a + 704 >> 2] + 44 >> 2]), X3(q2[a + 1068 >> 2], 4, q2[q2[a + 704 >> 2] + 48 >> 2]), X3(q2[a + 1072 >> 2], 4, q2[q2[a + 704 >> 2] + 48 >> 2]), X3(q2[a + 1056 >> 2], 4, q2[q2[a + 704 >> 2] + 52 >> 2]), X3(q2[a + 1060 >> 2], 4, q2[q2[a + 704 >> 2] + 52 >> 2]), X3(q2[a + 1192 >> 2], 4, q2[q2[a + 704 >> 2] + 56 >> 2]), X3(q2[a + 1196 >> 2], 4, q2[q2[a + 704 >> 2] + 60 >> 2]), X3(q2[a + 1200 >> 2], 2, q2[q2[a + 704 >> 2] + 64 >> 2]), X3(q2[a + 1204 >> 2], 4, q2[q2[a + 704 >> 2] + 68 >> 2]), X3(q2[a + 1208 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1212 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1216 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1220 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1224 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1228 >> 2], 4, q2[q2[a + 704 >> 2] + 76 >> 2]), X3(q2[a + 1232 >> 2], 4, q2[q2[a + 704 >> 2] + 76 >> 2]), X3(q2[a + 1236 >> 2], 4, q2[q2[a + 704 >> 2] + 76 >> 2]), X3(q2[a + 1248 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1252 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1256 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1260 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1264 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1268 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1272 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1276 >> 2], 4, q2[q2[a + 704 >> 2] + 84 >> 2]), X3(q2[a + 1280 >> 2], 2, q2[q2[a + 704 >> 2] + 84 >> 2]), X3(q2[a + 1284 >> 2], 4, q2[q2[a + 704 >> 2] + 88 >> 2]), Xa >>> 0 < 2 || (X3(q2[a + 808 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), Xa >>> 0 < 4) || (X3(q2[a + 968 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 972 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 792 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 824 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 864 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 1288 >> 2], 4, q2[q2[a + 704 >> 2] + 92 >> 2]), X3(q2[a + 1292 >> 2], 4, q2[q2[a + 704 >> 2] + 92 >> 2]), X3(q2[a + 1296 >> 2], 4, q2[q2[a + 704 >> 2] + 92 >> 2]), X3(q2[a + 1300 >> 2], 4, q2[q2[a + 704 >> 2] + 96 >> 2]), X3(q2[a + 1304 >> 2], 4, q2[q2[a + 704 >> 2] + 96 >> 2]), X3(q2[a + 1308 >> 2], 4, q2[q2[a + 704 >> 2] + 96 >> 2]), X3(q2[a + 944 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 956 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 960 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 1076 >> 2], 4, q2[q2[a + 704 >> 2] + 100 >> 2]), X3(q2[a + 1080 >> 2], 4, q2[q2[a + 704 >> 2] + 100 >> 2]), X3(q2[a + 1084 >> 2], 4, q2[q2[a + 704 >> 2] + 100 >> 2]), X3(q2[a + 1088 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1092 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1096 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1100 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1104 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1120 >> 2], 4, q2[q2[a + 704 >> 2] + 108 >> 2]), X3(q2[a + 1124 >> 2], 4, q2[q2[a + 704 >> 2] + 108 >> 2]), X3(q2[a + 1128 >> 2], 4, q2[q2[a + 704 >> 2] + 108 >> 2]), X3(q2[a + 1144 >> 2], 4, q2[q2[a + 704 >> 2] + 112 >> 2]), X3(q2[a + 1148 >> 2], 4, q2[q2[a + 704 >> 2] + 112 >> 2]), X3(q2[a + 1152 >> 2], 4, q2[q2[a + 704 >> 2] + 112 >> 2]), X3(q2[a + 1168 >> 2], 4, q2[q2[a + 704 >> 2] + 116 >> 2]), X3(q2[a + 1172 >> 2], 4, q2[q2[a + 704 >> 2] + 120 >> 2]), X3(q2[a + 1176 >> 2], 4, q2[q2[a + 704 >> 2] + 120 >> 2]), X3(q2[a + 1180 >> 2], 4, q2[q2[a + 704 >> 2] + 120 >> 2]), X3(q2[a + 1184 >> 2], 4, q2[q2[a + 704 >> 2] + 124 >> 2]), X3(q2[a + 1188 >> 2], 4, q2[q2[a + 704 >> 2] + 124 >> 2]), 4 != (0 | Xa) && (X3(q2[a + 988 >> 2], 4, q2[q2[a + 704 >> 2] + 28 >> 2]), X3(q2[a + 992 >> 2], 4, q2[q2[a + 704 >> 2] + 28 >> 2]), X3(q2[a + 1024 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1028 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1044 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1048 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1108 >> 2], 4, q2[q2[a + 704 >> 2] + 128 >> 2]), X3(q2[a + 1112 >> 2], 4, q2[q2[a + 704 >> 2] + 128 >> 2]), X3(q2[a + 1116 >> 2], 4, q2[q2[a + 704 >> 2] + 128 >> 2]), X3(q2[a + 1132 >> 2], 4, q2[q2[a + 704 >> 2] + 132 >> 2]), X3(q2[a + 1136 >> 2], 4, q2[q2[a + 704 >> 2] + 132 >> 2]), X3(q2[a + 1140 >> 2], 4, q2[q2[a + 704 >> 2] + 132 >> 2]), X3(q2[a + 1156 >> 2], 4, q2[q2[a + 704 >> 2] + 136 >> 2]), X3(q2[a + 1160 >> 2], 4, q2[q2[a + 704 >> 2] + 136 >> 2]), X3(q2[a + 1164 >> 2], 4, q2[q2[a + 704 >> 2] + 136 >> 2])));
            }
            function za(a, Za) {
              var _a = 0, lb = 0, mb = 0, ob = 0, pb = 0, rb = 0, nb = a + Za | 0;
              a: {
                b: if (!(1 & (_a = q2[a + 4 >> 2]))) {
                  if (!(3 & _a)) break a;
                  if (Za = (_a = q2[a >> 2]) + Za | 0, (0 | (a = a - _a | 0)) != q2[2092]) if (_a >>> 0 <= 255) mb = _a >>> 3, _a = q2[a + 8 >> 2], (0 | (lb = q2[a + 12 >> 2])) == (0 | _a) ? (rb = q2[2087] & dd(mb), q2[8348 >> 2] = rb) : (q2[_a + 12 >> 2] = lb, q2[lb + 8 >> 2] = _a);
                  else {
                    if (pb = q2[a + 24 >> 2], (0 | (_a = q2[a + 12 >> 2])) != (0 | a)) lb = q2[a + 8 >> 2], q2[lb + 12 >> 2] = _a, q2[_a + 8 >> 2] = lb;
                    else if ((mb = q2[(lb = a + 20 | 0) >> 2]) || (mb = q2[(lb = a + 16 | 0) >> 2])) {
                      for (; ; ) if (ob = lb, !((mb = q2[(lb = (_a = mb) + 20 | 0) >> 2]) || (lb = _a + 16 | 0, mb = q2[_a + 16 >> 2]))) break;
                      q2[ob >> 2] = 0;
                    } else _a = 0;
                    if (pb) {
                      lb = q2[a + 28 >> 2];
                      e: {
                        if (q2[(mb = 8652 + (lb << 2) | 0) >> 2] == (0 | a)) {
                          if (q2[mb >> 2] = _a) break e;
                          rb = q2[2088] & dd(lb), q2[8352 >> 2] = rb;
                          break b;
                        }
                        if (!(q2[pb + (q2[pb + 16 >> 2] == (0 | a) ? 16 : 20) >> 2] = _a)) break b;
                      }
                      q2[_a + 24 >> 2] = pb, (lb = q2[a + 16 >> 2]) && (q2[_a + 16 >> 2] = lb, q2[lb + 24 >> 2] = _a), (lb = q2[a + 20 >> 2]) && (q2[_a + 20 >> 2] = lb, q2[lb + 24 >> 2] = _a);
                    }
                  }
                  else if (3 == (3 & (_a = q2[4 + nb >> 2]))) return q2[2089] = Za, q2[4 + nb >> 2] = -2 & _a, q2[a + 4 >> 2] = 1 | Za, void (q2[nb >> 2] = Za);
                }
                f: {
                  if (!(2 & (_a = q2[4 + nb >> 2]))) {
                    if (q2[2093] == (0 | nb)) {
                      if (q2[2093] = a, Za = q2[2090] + Za | 0, q2[2090] = Za, q2[a + 4 >> 2] = 1 | Za, q2[2092] != (0 | a)) break a;
                      return q2[2089] = 0, void (q2[2092] = 0);
                    }
                    if (q2[2092] == (0 | nb)) return q2[2092] = a, Za = q2[2089] + Za | 0, q2[2089] = Za, q2[a + 4 >> 2] = 1 | Za, void (q2[a + Za >> 2] = Za);
                    Za = (-8 & _a) + Za | 0;
                    g: if (_a >>> 0 <= 255) mb = _a >>> 3, _a = q2[8 + nb >> 2], (0 | (lb = q2[12 + nb >> 2])) == (0 | _a) ? (rb = q2[2087] & dd(mb), q2[8348 >> 2] = rb) : (q2[_a + 12 >> 2] = lb, q2[lb + 8 >> 2] = _a);
                    else {
                      if (pb = q2[24 + nb >> 2], (0 | nb) != (0 | (_a = q2[12 + nb >> 2]))) lb = q2[8 + nb >> 2], q2[lb + 12 >> 2] = _a, q2[_a + 8 >> 2] = lb;
                      else if ((mb = q2[(lb = 20 + nb | 0) >> 2]) || (mb = q2[(lb = 16 + nb | 0) >> 2])) {
                        for (; ; ) if (ob = lb, !((mb = q2[(lb = (_a = mb) + 20 | 0) >> 2]) || (lb = _a + 16 | 0, mb = q2[_a + 16 >> 2]))) break;
                        q2[ob >> 2] = 0;
                      } else _a = 0;
                      if (pb) {
                        lb = q2[28 + nb >> 2];
                        j: {
                          if (q2[(mb = 8652 + (lb << 2) | 0) >> 2] == (0 | nb)) {
                            if (q2[mb >> 2] = _a) break j;
                            rb = q2[2088] & dd(lb), q2[8352 >> 2] = rb;
                            break g;
                          }
                          if (!(q2[pb + (q2[pb + 16 >> 2] == (0 | nb) ? 16 : 20) >> 2] = _a)) break g;
                        }
                        q2[_a + 24 >> 2] = pb, (lb = q2[16 + nb >> 2]) && (q2[_a + 16 >> 2] = lb, q2[lb + 24 >> 2] = _a), (lb = q2[20 + nb >> 2]) && (q2[_a + 20 >> 2] = lb, q2[lb + 24 >> 2] = _a);
                      }
                    }
                    if (q2[a + 4 >> 2] = 1 | Za, q2[a + Za >> 2] = Za, q2[2092] != (0 | a)) break f;
                    return void (q2[2089] = Za);
                  }
                  q2[4 + nb >> 2] = -2 & _a, q2[a + 4 >> 2] = 1 | Za, q2[a + Za >> 2] = Za;
                }
                if (Za >>> 0 <= 255) return Za = 8388 + ((_a = Za >>> 3) << 3) | 0, _a = (lb = q2[2087]) & (_a = 1 << _a) ? q2[Za + 8 >> 2] : (q2[2087] = _a | lb, Za), q2[Za + 8 >> 2] = a, q2[_a + 12 >> 2] = a, q2[a + 12 >> 2] = Za, void (q2[a + 8 >> 2] = _a);
                q2[a + 16 >> 2] = 0, _a = q2[a + 20 >> 2] = 0, (mb = Za >>> 8) && (_a = 31, 16777215 < Za >>> 0 || (_a = 28 + ((_a = ((nb = (mb <<= ob = mb + 1048320 >>> 16 & 8) << (_a = mb + 520192 >>> 16 & 4)) << (mb = 245760 + nb >>> 16 & 2) >>> 15) - (mb | _a | ob) | 0) << 1 | Za >>> _a + 21 & 1) | 0)), mb = 8652 + ((q2[(lb = a) + 28 >> 2] = _a) << 2) | 0;
                m: {
                  if ((lb = q2[2088]) & (ob = 1 << _a)) {
                    for (lb = Za << (31 == (0 | _a) ? 0 : 25 - (_a >>> 1) | 0), _a = q2[mb >> 2]; ; ) {
                      if ((-8 & q2[(mb = _a) + 4 >> 2]) == (0 | Za)) break m;
                      if (_a = lb >>> 29, lb <<= 1, !(_a = q2[(ob = mb + (4 & _a) | 0) + 16 >> 2])) break;
                    }
                    q2[ob + 16 >> 2] = a;
                  } else q2[2088] = lb | ob, q2[mb >> 2] = a;
                  return q2[a + 24 >> 2] = mb, q2[a + 12 >> 2] = a, void (q2[a + 8 >> 2] = a);
                }
                Za = q2[mb + 8 >> 2], q2[Za + 12 >> 2] = a, q2[mb + 8 >> 2] = a, q2[a + 24 >> 2] = 0, q2[a + 12 >> 2] = mb, q2[a + 8 >> 2] = Za;
              }
            }
            function Aa2(a) {
              var vb, xb, yb, Ab, Bb, Cb, Za = x2(0), sb = x2(0), tb = 0, ub = 0, wb = (x2(0), x2(0)), zb = (x2(0), x2(0), 0);
              x2(0), x2(0);
              a: {
                b: {
                  if (j(a), ub = 2147483647 & (tb = b2[0])) {
                    if (!(ub >>> 0 < 2139095041)) return x2(x2(0.10000000149011612) + a);
                    if (1065353216 == (0 | ub)) return x2(-1 < (0 | tb) ? 0.10000000149011612 : 10);
                    if (2139095040 == (0 | ub)) return x2(-1 < (0 | tb) ? 0 : -a);
                    if (1073741824 == (0 | tb)) return x2(0.010000000707805157);
                    if (1056964608 == (0 | tb)) return x2(0.3162277638912201);
                    if (1291845633 <= ub >>> 0) return x2((0 | tb) < 0 ? H2 : 0);
                    if (vb = u2[1701], wb = x2(x2(1.600000023841858) - vb), xb = x2(x2(1) / x2(vb + x2(1.600000023841858))), f(0, -4096 & (j(sb = x2(wb * xb)), b2[0])), Za = k(), yb = x2(Za * Za), Bb = u2[1705], vb = x2(xb * x2(x2(wb - x2((Ab = Za) * x2(3.099609375))) - x2(Za * x2(x2(1.600000023841858) - x2(x2(3.099609375) - vb))))), xb = x2(x2(sb + Za) * vb), Za = x2(sb * sb), wb = x2(xb + x2(x2(Za * Za) * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(0.20697501301765442)) + x2(0.23066075146198273))) + x2(0.2727281153202057))) + x2(0.3333333432674408))) + x2(0.4285714328289032))) + x2(0.6000000238418579)))), f(0, -4096 & (j(x2(x2(yb + x2(3)) + wb)), b2[0])), Za = k(), xb = x2(Ab * Za), sb = x2(x2(vb * Za) + x2(sb * x2(wb - x2(x2(Za + x2(-3)) - yb)))), f(0, -4096 & (j(x2(xb + sb)), b2[0])), Za = k(), vb = x2(Za * x2(0.9619140625)), yb = x2(u2[1703] + x2(x2(x2(sb - x2(Za - xb)) * x2(0.9617967009544373)) + x2(Za * x2(-11736857413779944e-20)))), f(0, -4096 & (j(x2(x2(Bb + x2(vb + yb)) + x2(-4))), b2[0])), sb = k(), f(0, -4096 & tb), wb = k(), Za = x2(sb * wb), a = x2(x2(x2(yb - x2(x2(x2(sb - x2(-4)) - Bb) - vb)) * a) + x2(x2(a - wb) * sb)), j(sb = x2(Za + a)), 1124073473 <= (0 | (tb = b2[0]))) break b;
                    d: {
                      if ((ub = 1124073472) == (0 | tb)) {
                        if (x2(a + x2(4299566569443414e-23)) > x2(sb - Za)) break b;
                      } else {
                        if (ub = 2147483647 & tb, !(a <= x2(sb - Za) ^ 1 | -1021968384 != (0 | tb)) | 1125515265 <= ub >>> 0) break a;
                        if (ub >>> 0 < 1056964609) break d;
                      }
                      zb = (8388607 & (ub = (8388608 >>> (ub >>> 23) - 126) + tb | 0) | 8388608) >>> 150 - (Cb = ub >>> 23 & 255), zb = (0 | tb) < 0 ? 0 - zb | 0 : zb, Za = x2(Za - (f(0, ub & -8388608 >> Cb - 127), k())), j(x2(a + Za)), tb = b2[0];
                    }
                    f(0, -32768 & tb), sb = k(), vb = x2(sb * x2(0.693145751953125)), sb = x2(x2(sb * x2(14286065379565116e-22)) + x2(x2(a - x2(sb - Za)) * x2(0.6931471824645996))), a = x2(vb + sb), Za = x2(a * a), Za = x2(a - x2(Za * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(4138136944220605e-23)) + x2(-16533901998627698e-22))) + x2(661375597701408e-19))) + x2(-0.0027777778450399637))) + x2(0.1666666716337204)))), Ab = x2(x2(a * Za) / x2(Za + x2(-2))), Za = x2(sb - x2(a - vb)), a = (0 | (tb = 0 | (j(a = x2(x2(a - x2(Ab - x2(Za + x2(a * Za)))) + x2(1))), b2[0] + (zb << 23)))) <= 8388607 ? function(a2, Vk) {
                      var zl = 0;
                      128 <= (0 | Vk) ? (a2 = x2(a2 * x2(17014118346046923e22)), Vk = (0 | (zl = Vk + -127 | 0)) < 128 ? zl : (a2 = x2(a2 * x2(17014118346046923e22)), ((0 | Vk) < 381 ? Vk : 381) + -254 | 0)) : -127 < (0 | Vk) || (a2 = x2(a2 * x2(11754943508222875e-54)), Vk = -127 < (0 | (zl = Vk + 126 | 0)) ? zl : (a2 = x2(a2 * x2(11754943508222875e-54)), (-378 < (0 | Vk) ? Vk : -378) + 252 | 0));
                      return x2(a2 * (f(0, 1065353216 + (Vk << 23) | 0), k()));
                    }(a, zb) : (f(0, tb), k()), a = x2(x2(1) * a);
                  } else a = x2(1);
                  return a;
                }
                return x2(H2);
              }
              return x2(0);
            }
            function Ba2(a, Db) {
              var Jb, Eb = 0, Fb = 0, Gb = 0, Hb = 0, Ib = x2(0);
              if (j(Db), !((Gb = 2147483647 & (Eb = b2[0])) >>> 0 <= 2139095040 && (j(a), (Fb = 2147483647 & (Hb = b2[0])) >>> 0 < 2139095041))) return x2(a + Db);
              if (1065353216 == (0 | Eb)) return Ca2(a);
              Eb = (Jb = Eb >>> 30 & 2) | Hb >>> 31;
              b: {
                c: {
                  d: {
                    e: {
                      if (!Fb) {
                        f: switch (Eb - 2 | 0) {
                          case 0:
                            break e;
                          case 1:
                            break f;
                          default:
                            break d;
                        }
                        return x2(-3.1415927410125732);
                      }
                      if (2139095040 != (0 | Gb)) {
                        if (!Gb | !(Fb >>> 0 <= Gb + 218103808 >>> 0 && 2139095040 != (0 | Fb))) break b;
                        if (a = Ib = Fb + 218103808 >>> 0 < Gb >>> 0 && (Ib = x2(0), Jb) ? Ib : Ca2(x2(y2(x2(a / Db)))), Eb >>> 0 <= 2) {
                          h: switch (Eb - 1 | 0) {
                            case 0:
                              return x2(-a);
                            case 1:
                              break h;
                            default:
                              break d;
                          }
                          return x2(x2(3.1415927410125732) - x2(a + x2(8742277657347586e-23)));
                        }
                        return x2(x2(a + x2(8742277657347586e-23)) + x2(-3.1415927410125732));
                      }
                      if (2139095040 == (0 | Fb)) break c;
                      return u2[6784 + (Eb << 2) >> 2];
                    }
                    a = x2(3.1415927410125732);
                  }
                  return a;
                }
                return u2[6768 + (Eb << 2) >> 2];
              }
              return x2((0 | Hb) < 0 ? -1.5707963705062866 : 1.5707963705062866);
            }
            function Ca2(a) {
              var Kb, Nb, Ob, Db = 0, Lb = (x2(0), 0), Mb = 0;
              x2(0), x2(0);
              j(a);
              a: {
                if (1283457024 <= (Db = 2147483647 & (Mb = b2[0])) >>> 0) {
                  if (2139095040 < Db >>> 0) break a;
                  return x2((0 | Mb) < 0 ? -1.570796251296997 : 1.570796251296997);
                }
                b: {
                  if (Db >>> 0 <= 1054867455) {
                    if (Lb = -1, 964689920 <= Db >>> 0) break b;
                    break a;
                  }
                  a = x2(y2(a)), Db >>> 0 <= 1066926079 ? Lb = Db >>> 0 <= 1060110335 ? (a = x2(x2(x2(a + a) + x2(-1)) / x2(a + x2(2))), 0) : (a = x2(x2(a + x2(-1)) / x2(a + x2(1))), 1) : Lb = Db >>> 0 <= 1075576831 ? (a = x2(x2(a + x2(-1.5)) / x2(x2(a * x2(1.5)) + x2(1))), 2) : (a = x2(x2(-1) / a), 3);
                }
                if (Db = Lb, Nb = x2(a * a), Kb = x2(Nb * Nb), Ob = x2(Kb * x2(x2(Kb * x2(-0.106480173766613)) + x2(-0.19999158382415771))), Kb = x2(Nb * x2(x2(Kb * x2(x2(Kb * x2(0.06168760731816292)) + x2(0.14253635704517365))) + x2(0.333333283662796))), (0 | Db) <= -1) return x2(a - x2(a * x2(Ob + Kb)));
                a = x2(u2[6736 + (Db <<= 2) >> 2] - x2(x2(x2(a * x2(Ob + Kb)) - u2[6752 + Db >> 2]) - a)), a = (0 | Mb) < 0 ? x2(-a) : a;
              }
              return a;
            }
            function Da(a, Pb) {
              var Ub, Sb, Qb = 0, Rb = 0, Tb = 0;
              return L2 = Sb = L2 - 16 | 0, j(a), (Qb = 2147483647 & (Tb = b2[0])) >>> 0 <= 1305022426 ? (v2[Pb >> 3] = (Ub = +a) + -1.5707963109016418 * (Rb = 0.6366197723675814 * Ub + 6755399441055744 - 6755399441055744) + -15893254773528196e-24 * Rb, Qb = y2(Rb) < 2147483648 ? ~~Rb : -2147483648) : 2139095040 <= Qb >>> 0 ? (v2[Pb >> 3] = x2(a - a), Qb = 0) : (Ub = Qb, v2[8 + Sb >> 3] = (f(0, Ub - ((Qb = (Qb >>> 23) - 150 | 0) << 23) | 0), k()), Qb = function(a2, Il, Jl) {
                var Kl = 0, Ll = 0, Ml = 0, Nl = 0, Ol = 0, Pl = 0, Ql = 0, Rl = 0, Sl = 0, Tl = 0, Ul = 0, Vl = 0, Wl = 0, Xl = 0, Yl = 0, Zl = 0, _l = 0;
                if (L2 = Nl = L2 - 560 | 0, Rl = (Ll = Jl) + w2(Wl = 0 < (0 | (Jl = (Jl + -3 | 0) / 24 | 0)) ? Jl : 0, -24) | 0, 0 <= (0 | (Sl = q2[972]))) {
                  for (Ll = Sl + 1 | 0, Jl = Wl; ; ) if (v2[(320 + Nl | 0) + (Ml << 3) >> 3] = (0 | Jl) < 0 ? 0 : +q2[3904 + (Jl << 2) >> 2], Jl = Jl + 1 | 0, (0 | Ll) == (0 | (Ml = Ml + 1 | 0))) break;
                }
                Pl = Rl + -24 | 0, Ll = 0;
                for (; ; ) {
                  for (Kl = Jl = 0; ; ) if (Kl += v2[(Jl << 3) + a2 >> 3] * v2[(320 + Nl | 0) + (Ll - Jl << 3) >> 3], 1 == (0 | (Jl = Jl + 1 | 0))) break;
                  if (v2[(Ll << 3) + Nl >> 3] = Kl, Jl = (0 | Ll) < (0 | Sl), Ll = Ll + 1 | 0, !Jl) break;
                }
                _l = 23 - Pl | 0, Xl = 24 - Pl | 0, Ll = Sl;
                a: {
                  for (; ; ) {
                    if (Kl = v2[(Ll << 3) + Nl >> 3], !(Ul = ((Jl = 0) | (Ml = Ll)) < 1)) {
                      for (; ; ) if (Ql = (480 + Nl | 0) + (Jl << 2) | 0, Tl = Kl, Ol = y2(Kl *= 5960464477539063e-23) < 2147483648 ? ~~Kl : -2147483648, Ol = y2(Tl += -16777216 * (Kl = 0 | Ol)) < 2147483648 ? ~~Tl : -2147483648, q2[Ql >> 2] = Ol, Kl = v2[((Ml = Ml + -1 | 0) << 3) + Nl >> 3] + Kl, (0 | Ll) == (0 | (Jl = Jl + 1 | 0))) break;
                    }
                    Kl = ja2(Kl, Pl), Kl += -8 * C2(0.125 * Kl), Ql = y2(Kl) < 2147483648 ? ~~Kl : -2147483648, Kl -= 0 | Ql;
                    e: {
                      f: {
                        g: {
                          if (Yl = (0 | Pl) < 1) {
                            if (Pl) break g;
                            Ol = q2[476 + ((Ll << 2) + Nl | 0) >> 2] >> 23;
                          } else Ol = q2[(Ml = (Ll << 2) + Nl | 0) + 476 >> 2], Vl = Ml, Ml = Ol - ((Jl = Ol >> Xl) << Xl) | 0, q2[Vl + 476 >> 2] = Ml, Ql = Jl + Ql | 0, Ol = Ml >> _l;
                          if ((0 | Ol) < 1) break e;
                          break f;
                        }
                        if (Ol = 2, !(0.5 <= Kl)) {
                          Ol = 0;
                          break e;
                        }
                      }
                      if (Ml = Jl = 0, !Ul) for (; ; ) {
                        Ul = q2[(Zl = (480 + Nl | 0) + (Jl << 2) | 0) >> 2], Vl = 16777215;
                        i: {
                          j: {
                            if (!Ml) {
                              if (!Ul) break j;
                              Vl = 16777216, Ml = 1;
                            }
                            q2[Zl >> 2] = Vl - Ul;
                            break i;
                          }
                          Ml = 0;
                        }
                        if ((0 | Ll) == (0 | (Jl = Jl + 1 | 0))) break;
                      }
                      Yl || 1 < (Jl = Pl + -1 | 0) >>> 0 || (q2[(Jl = (Ll << 2) + Nl | 0) + 476 >> 2] = Jl - 1 ? 8388607 & q2[Jl + 476 >> 2] : 4194303 & q2[Jl + 476 >> 2]), Ql = Ql + 1 | 0, 2 == (0 | Ol) && (Kl = 1 - Kl, Ol = 2, Ml) && (Kl -= ja2(1, Pl));
                    }
                    if (0 != Kl) break;
                    if (!(((Ml = 0) | (Jl = Ll)) <= (0 | Sl))) {
                      for (; ; ) if (Ml = q2[(480 + Nl | 0) + ((Jl = Jl + -1 | 0) << 2) >> 2] | Ml, !((0 | Sl) < (0 | Jl))) break;
                      if (Ml) {
                        for (Rl = Pl; ; ) if (Rl = Rl + -24 | 0, q2[(480 + Nl | 0) + ((Ll = Ll + -1 | 0) << 2) >> 2]) break;
                        break a;
                      }
                    }
                    for (Jl = 1; ; ) if (Jl = (Ml = Jl) + 1 | 0, q2[(480 + Nl | 0) + (Sl - Ml << 2) >> 2]) break;
                    for (Ml = Ll + Ml | 0; ; ) {
                      for (Ll = Ql = Ll + 1 | 0, v2[(320 + Nl | 0) + (Ql << 3) >> 3] = q2[3904 + (Wl + Ll << 2) >> 2], Kl = Jl = 0; ; ) if (Kl += v2[(Jl << 3) + a2 >> 3] * v2[(320 + Nl | 0) + (Ql - Jl << 3) >> 3], 1 == (0 | (Jl = Jl + 1 | 0))) break;
                      if (v2[(Ll << 3) + Nl >> 3] = Kl, !((0 | Ll) < (0 | Ml))) break;
                    }
                    Ll = Ml;
                  }
                  16777216 <= (Kl = ja2(Kl, 0 - Pl | 0)) ? (a2 = (480 + Nl | 0) + (Ll << 2) | 0, Tl = Kl, Jl = y2(Kl *= 5960464477539063e-23) < 2147483648 ? ~~Kl : -2147483648, Ml = y2(Kl = Tl + -16777216 * (0 | Jl)) < 2147483648 ? ~~Kl : -2147483648, q2[a2 >> 2] = Ml, Ll = Ll + 1 | 0) : (Jl = y2(Kl) < 2147483648 ? ~~Kl : -2147483648, Rl = Pl), q2[(480 + Nl | 0) + (Ll << 2) >> 2] = Jl;
                }
                Kl = ja2(1, Rl);
                if (!((0 | Ll) <= -1)) {
                  for (Jl = Ll; ; ) if (v2[(Jl << 3) + Nl >> 3] = Kl * +q2[(480 + Nl | 0) + (Jl << 2) >> 2], Kl *= 5960464477539063e-23, a2 = 0 < (0 | Jl), Jl = Jl + -1 | 0, !a2) break;
                  if (!((0 | Ll) <= -1)) for (Jl = Ll; ; ) {
                    for (Pl = Ll - (a2 = Jl) | 0, Jl = Kl = 0; ; ) if (Kl += v2[6672 + (Jl << 3) >> 3] * v2[(a2 + Jl << 3) + Nl >> 3], (0 | Sl) <= (0 | Jl) || (Rl = Jl >>> 0 < Pl >>> 0, Jl = Jl + 1 | 0, !Rl)) break;
                    if (v2[(160 + Nl | 0) + (Pl << 3) >> 3] = Kl, Jl = a2 + -1 | 0, !(0 < (0 | a2))) break;
                  }
                }
                if (0 <= (Ll | (Kl = 0))) {
                  for (; ; ) if (Kl += v2[(160 + Nl | 0) + (Ll << 3) >> 3], a2 = 0 < (0 | Ll), Ll = Ll + -1 | 0, !a2) break;
                }
                return v2[Il >> 3] = Ol ? -Kl : Kl, L2 = 560 + Nl | 0, 7 & Ql;
              }(8 + Sb | 0, Sb, Qb), Rb = v2[Sb >> 3], (0 | Tb) <= -1 ? (v2[Pb >> 3] = -Rb, Qb = 0 - Qb | 0) : v2[Pb >> 3] = Rb), L2 = 16 + Sb | 0, Qb;
            }
            function Ea(a, Pb) {
              return a ? function(a2, Il) {
                a: {
                  if (a2) {
                    if (Il >>> 0 <= 127) break a;
                    if (q2[q2[1789] >> 2]) {
                      if (Il >>> 0 <= 2047) return o[a2 + 1 | 0] = 63 & Il | 128, o[0 | a2] = Il >>> 6 | 192, 2;
                      if (!(57344 != (-8192 & Il) && 55296 <= Il >>> 0)) return o[a2 + 2 | 0] = 63 & Il | 128, o[0 | a2] = Il >>> 12 | 224, o[a2 + 1 | 0] = Il >>> 6 & 63 | 128, 3;
                      if (Il + -65536 >>> 0 <= 1048575) return o[a2 + 3 | 0] = 63 & Il | 128, o[0 | a2] = Il >>> 18 | 240, o[a2 + 2 | 0] = Il >>> 6 & 63 | 128, o[a2 + 1 | 0] = Il >>> 12 & 63 | 128, 4;
                    } else if (57216 == (-128 & Il)) break a;
                    q2[2086] = 25, a2 = -1;
                  } else a2 = 1;
                  return a2;
                }
                return o[0 | a2] = Il, 1;
              }(a, Pb) : 0;
            }
            function Fa(a, Pb, Wb) {
              var fc, gc, Xb = 0, Yb = 0, Zb = 0, _b = 0, $b = 0, ac = 0, bc = 0, cc = 0, dc = 0, ec = r2[a + 4 | 0];
              if (q2[Pb >> 2] = 652, Yb = q2[a + 704 >> 2], 1 <= (0 | (_b = q2[Yb >> 2]))) {
                for ($b = q2[a + 720 >> 2], bc = q2[a + 1072 >> 2]; ; ) if (Zb = (1 << q2[bc + (q2[$b + (Xb << 2) >> 2] << 2) >> 2]) + Zb | 0, (0 | _b) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = Zb << 2;
              }
              if (q2[Pb + 4 >> 2] = w2(_b, 12), q2[Pb + 8 >> 2] = q2[Yb >> 2] << 2, q2[Pb + 12 >> 2] = q2[Yb >> 2] << 2, q2[Pb + 16 >> 2] = q2[Yb >> 2] << 2, q2[Pb + 20 >> 2] = q2[Yb >> 2] << 2, Zb = q2[Yb >> 2], q2[Pb + 28 >> 2] = Xb, q2[Pb + 24 >> 2] = Zb << 2, Zb = q2[Yb >> 2], q2[Pb + 40 >> 2] = Xb, q2[Pb + 36 >> 2] = Xb, q2[Pb + 32 >> 2] = Zb << 2, q2[Pb + 44 >> 2] = q2[Yb + 4 >> 2] << 5, q2[Pb + 48 >> 2] = q2[Yb + 4 >> 2] << 2, q2[Pb + 52 >> 2] = q2[Yb + 4 >> 2] << 2, q2[Pb + 56 >> 2] = q2[Yb + 4 >> 2] << 2, q2[Pb + 60 >> 2] = q2[Yb + 4 >> 2] << 4, q2[Pb + 64 >> 2] = q2[Yb + 4 >> 2] << 4, 1 <= ((Xb = 0) | (_b = q2[Yb + 8 >> 2]))) {
                for ($b = q2[a + 780 >> 2], bc = q2[a + 1072 >> 2], dc = q2[a + 796 >> 2], Zb = 0; ; ) if (ac = (15 + (q2[(cc = Xb << 2) + dc >> 2] << 3) & -16) + ac | 0, Zb = (1 << q2[bc + (q2[$b + cc >> 2] << 2) >> 2]) + Zb | 0, (0 | _b) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = Zb << 2;
              }
              if (q2[Pb + 68 >> 2] = w2(_b, 24), q2[Pb + 72 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 76 >> 2] = q2[Yb + 8 >> 2] << 2, Zb = q2[Yb + 8 >> 2], q2[Pb + 84 >> 2] = ac, q2[Pb + 80 >> 2] = Zb << 2, q2[Pb + 88 >> 2] = q2[Yb + 8 >> 2] << 4, q2[Pb + 92 >> 2] = q2[Yb + 8 >> 2] << 4, Zb = q2[Yb + 8 >> 2], q2[Pb + 100 >> 2] = Xb, q2[Pb + 96 >> 2] = Zb << 2, Zb = q2[Yb + 8 >> 2], q2[Pb + 140 >> 2] = Xb, q2[Pb + 136 >> 2] = Xb, q2[Pb + 132 >> 2] = Xb, q2[Pb + 128 >> 2] = Xb, q2[Pb + 124 >> 2] = Xb, q2[Pb + 120 >> 2] = Xb, q2[Pb + 116 >> 2] = Xb, q2[Pb + 112 >> 2] = Xb, q2[Pb + 108 >> 2] = Xb, q2[Pb + 104 >> 2] = Zb << 2, q2[Pb + 144 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 148 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 152 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 156 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 160 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 164 >> 2] = q2[Yb + 8 >> 2] << 2, 1 <= ((Xb = ac = 0) | (_b = q2[Yb + 12 >> 2]))) {
                for ($b = q2[a + 812 >> 2], bc = q2[a + 1072 >> 2], Zb = 0; ; ) if (Zb = (1 << q2[bc + (q2[$b + (Xb << 2) >> 2] << 2) >> 2]) + Zb | 0, (0 | _b) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = Zb << 2;
              }
              if (q2[Pb + 168 >> 2] = w2(_b, 12), q2[Pb + 172 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 176 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 180 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 184 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 188 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 192 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 196 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 200 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 204 >> 2] = q2[Yb + 12 >> 2] << 4, q2[Pb + 208 >> 2] = q2[Yb + 12 >> 2] << 4, Zb = q2[Yb + 12 >> 2], q2[Pb + 216 >> 2] = Xb, q2[Pb + 212 >> 2] = Zb << 2, Zb = q2[Yb + 12 >> 2], q2[Pb + 268 >> 2] = Xb, q2[Pb + 264 >> 2] = Xb, q2[Pb + 260 >> 2] = Xb, q2[Pb + 256 >> 2] = Xb, q2[Pb + 252 >> 2] = Xb, q2[Pb + 248 >> 2] = Xb, q2[Pb + 244 >> 2] = Xb, q2[Pb + 240 >> 2] = Xb, q2[Pb + 236 >> 2] = Xb, q2[Pb + 232 >> 2] = Xb, q2[Pb + 228 >> 2] = Xb, q2[Pb + 224 >> 2] = Xb, q2[Pb + 220 >> 2] = Zb << 2, q2[Pb + 272 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 276 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 280 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 284 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 288 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 292 >> 2] = q2[Yb + 12 >> 2] << 2, 1 <= ((Xb = 0) | (Zb = q2[Yb + 16 >> 2]))) {
                for ($b = q2[a + 852 >> 2], bc = q2[a + 1072 >> 2], dc = q2[a + 892 >> 2], _b = 0; ; ) if (ac = (15 + (q2[(cc = Xb << 2) + dc >> 2] << 3) & -16) + ac | 0, _b = (1 << q2[bc + (q2[$b + cc >> 2] << 2) >> 2]) + _b | 0, (0 | Zb) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = _b << 2;
              }
              if (q2[Pb + 296 >> 2] = w2(Zb, 20), q2[Pb + 300 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 304 >> 2] = q2[Yb + 16 >> 2], q2[Pb + 308 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 312 >> 2] = q2[Yb + 16 >> 2] << 2, Zb = q2[Yb + 16 >> 2], q2[Pb + 320 >> 2] = ac, q2[Pb + 316 >> 2] = Zb << 2, q2[Pb + 324 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 328 >> 2] = q2[Yb + 16 >> 2] << 4, q2[Pb + 332 >> 2] = q2[Yb + 16 >> 2] << 4, q2[Pb + 336 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 340 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 344 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 348 >> 2] = q2[Yb + 16 >> 2] << 4, q2[Pb + 352 >> 2] = q2[Yb + 16 >> 2] << 4, Zb = q2[Yb + 16 >> 2], q2[Pb + 360 >> 2] = Xb, q2[Pb + 356 >> 2] = Zb << 2, Zb = q2[Yb + 16 >> 2], q2[Pb + 404 >> 2] = Xb, q2[Pb + 400 >> 2] = Xb, q2[Pb + 396 >> 2] = Xb, q2[Pb + 392 >> 2] = Xb, q2[Pb + 388 >> 2] = Xb, q2[Pb + 384 >> 2] = Xb, q2[Pb + 380 >> 2] = Xb, q2[Pb + 376 >> 2] = Xb, q2[Pb + 372 >> 2] = Xb, q2[Pb + 368 >> 2] = Xb, q2[Pb + 364 >> 2] = Zb << 2, q2[Pb + 408 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 412 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 416 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 420 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 424 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 428 >> 2] = q2[Yb + 16 >> 2] << 2, $b = q2[a + 704 >> 2], q2[Pb + 432 >> 2] = w2(q2[$b + 20 >> 2], 52), q2[Pb + 436 >> 2] = ec >>> (Xb = _b = 0) <= 3 ? q2[$b + 20 >> 2] << 2 : 0, q2[Pb + 440 >> 2] = q2[$b + 20 >> 2] << 2, q2[Pb + 444 >> 2] = w2(q2[$b + 52 >> 2], 28), 1 <= (0 | (Yb = q2[$b + 48 >> 2]))) {
                for (Zb = q2[a + 1072 >> 2], ac = 0; ; ) if (ac = (bc = q2[Zb + (Xb << 2) >> 2]) + ac | 0, _b = (1 << bc) + _b | 0, (0 | Yb) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = _b << 2, _b = ac << 2;
              }
              if (q2[Pb + 460 >> 2] = Xb, q2[Pb + 456 >> 2] = Xb, q2[Pb + 452 >> 2] = _b, q2[Pb + 448 >> 2] = w2(Yb, 36), q2[Pb + 500 >> 2] = w2(q2[$b + 72 >> 2], 28), 1 <= ((ac = Xb = Zb = 0) | (bc = q2[$b + 72 >> 2]))) {
                for (dc = q2[a + 1224 >> 2], cc = q2[a + 1220 >> 2], gc = q2[a + 1212 >> 2], _b = 0; ; ) if (_b = (0 | (fc = q2[(Yb = ac << 2) + cc >> 2] - q2[Yb + dc >> 2] | 0)) < (0 | _b) ? _b : 1 + fc | 0, Xb = (0 | Xb) < (0 | (Yb = q2[Yb + gc >> 2])) ? Yb : Xb, (0 | bc) == (0 | (ac = ac + 1 | 0))) break;
                ac = Xb << 2, Xb = _b << 2;
              }
              if (Yb = q2[$b + 76 >> 2], q2[Pb + 516 >> 2] = Xb, q2[Pb + 512 >> 2] = ac, q2[Pb + 508 >> 2] = Xb, q2[Pb + 504 >> 2] = Yb << 4, 1 <= (0 | (Yb = q2[$b + 80 >> 2]))) {
                for (Zb = q2[a + 1248 >> 2], ac = q2[a + 1072 >> 2], _b = Xb = 0; ; ) if (_b = (1 << q2[ac + (q2[Zb + (Xb << 2) >> 2] << 2) >> 2]) + _b | 0, (0 | Yb) == (0 | (Xb = Xb + 1 | 0))) break;
                Zb = _b << 2;
              }
              if (q2[Pb + 520 >> 2] = w2(Yb, 24), q2[Pb + 524 >> 2] = q2[$b + 80 >> 2] << 2, Yb = q2[$b + 80 >> 2], q2[Pb + 532 >> 2] = Zb, q2[Pb + 528 >> 2] = Yb << 2, Yb = q2[$b + 80 >> 2], q2[Pb + 544 >> 2] = Zb, q2[Pb + 540 >> 2] = Zb, q2[Pb + 536 >> 2] = Yb << 2, Yb = Pb, 4 <= ec >>> 0) {
                if (q2[Pb + 464 >> 2] = w2(q2[$b + 120 >> 2], 20), q2[Pb + 468 >> 2] = w2(q2[$b + 100 >> 2], 28), Zb = Pb, 1 <= ((Xb = ac = 0) | (bc = q2[$b + 104 >> 2]))) {
                  for (a = q2[a + 1104 >> 2], _b = 0; ; ) if (_b = q2[a + (Xb << 2) >> 2] + _b | 0, (0 | bc) == (0 | (Xb = Xb + 1 | 0))) break;
                  a = _b << 2;
                } else a = 0;
                q2[Zb + 476 >> 2] = a, q2[Pb + 472 >> 2] = w2(bc, 48), q2[Pb + 484 >> 2] = w2(q2[$b + 108 >> 2], 12), a = q2[$b + 112 >> 2], q2[Pb + 552 >> 2] = 0, q2[Pb + 492 >> 2] = w2(a, 12), a = 0;
              } else {
                if ((0 | (ac = q2[$b + 20 >> 2])) < 1) _b = 0;
                else for (bc = q2[a + 1060 >> 2], dc = q2[a + 952 >> 2], a = q2[a + 948 >> 2], Zb = _b = 0; ; ) {
                  if (1 <= (0 | (cc = q2[(Xb = Zb << 2) + dc >> 2]))) {
                    for (cc = (Xb = bc + (q2[a + Xb >> 2] << 2) | 0) + (cc << 2) | 0; ; ) if (_b = q2[Xb >> 2] + _b | 0, !((Xb = Xb + 4 | 0) >>> 0 < cc >>> 0)) break;
                  }
                  if ((0 | ac) == (0 | (Zb = Zb + 1 | 0))) break;
                }
                q2[Pb + 552 >> 2] = ac << 2, ac = q2[$b + 20 >> 2] << 2, a = _b << 2;
              }
              for (q2[Yb + 556 >> 2] = a, q2[Pb + 548 >> 2] = ac, 4 < ec >>> 0 && (q2[Pb + 480 >> 2] = w2(q2[$b + 128 >> 2], 12), q2[Pb + 488 >> 2] = w2(q2[$b + 132 >> 2], 12), q2[Pb + 496 >> 2] = w2(q2[$b + 136 >> 2], 12)), Xb = _b = 0; ; ) if (Xb = ((Yb = q2[(a = (_b << 2) + Pb | 0) >> 2]) + 15 & -16) + (q2[a >> 2] = Xb) | 0, 140 == (0 | (_b = _b + 1 | 0))) break;
              q2[Wb >> 2] = Xb;
            }
            function Ga(a, Pb, Wb, hc) {
              a: {
                if (!(20 < Pb >>> 0 || 9 < (Pb = Pb + -9 | 0) >>> 0)) {
                  c: switch (Pb - 1 | 0) {
                    default:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, void (q2[a >> 2] = q2[Pb >> 2]);
                    case 0:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, Pb = q2[Pb >> 2], q2[a >> 2] = Pb, void (q2[a + 4 >> 2] = Pb >> 31);
                    case 1:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, q2[a >> 2] = q2[Pb >> 2], void (q2[a + 4 >> 2] = 0);
                    case 3:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, Pb = p2[Pb >> 1], q2[a >> 2] = Pb, void (q2[a + 4 >> 2] = Pb >> 31);
                    case 4:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, q2[a >> 2] = s[Pb >> 1], void (q2[a + 4 >> 2] = 0);
                    case 5:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, Pb = o[0 | Pb], q2[a >> 2] = Pb, void (q2[a + 4 >> 2] = Pb >> 31);
                    case 6:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, q2[a >> 2] = r2[0 | Pb], void (q2[a + 4 >> 2] = 0);
                    case 2:
                    case 7:
                      break a;
                    case 8:
                      break c;
                  }
                  n2[hc](a, Wb);
                }
                return;
              }
              Pb = q2[Wb >> 2] + 7 & -8, q2[Wb >> 2] = Pb + 8, Wb = q2[Pb + 4 >> 2], q2[a >> 2] = q2[Pb >> 2], q2[a + 4 >> 2] = Wb;
            }
            function Ha(a) {
              var Pb, hc, Wb = 0;
              if (ha2(o[q2[a >> 2]])) {
                for (; ; ) if (Pb = q2[a >> 2], hc = o[0 | Pb], q2[a >> 2] = Pb + 1, Wb = (w2(Wb, 10) + hc | 0) - 48 | 0, !ha2(o[Pb + 1 | 0])) break;
              }
              return Wb;
            }
            function Ia(a, ic, jc, kc, lc) {
              var oc, mc;
              q2[204 + (L2 = mc = L2 - 208 | 0) >> 2] = jc, ca2(160 + mc | (jc = 0), 0, 40), q2[200 + mc >> 2] = q2[204 + mc >> 2], (0 | ra2(0, ic, 200 + mc | 0, 80 + mc | 0, 160 + mc | 0, kc, lc)) < 0 || (jc = 0 <= q2[a + 76 >> 2] ? 1 : jc, jc = q2[a >> 2], o[a + 74 | 0] <= 0 && (q2[a >> 2] = -33 & jc), oc = 32 & jc, q2[a + 48 >> 2] ? ra2(a, ic, 200 + mc | 0, 80 + mc | 0, 160 + mc | 0, kc, lc) : (q2[a + 48 >> 2] = 80, q2[a + 16 >> 2] = 80 + mc, q2[a + 28 >> 2] = mc, q2[a + 20 >> 2] = mc, jc = q2[a + 44 >> 2], ra2(a, ic, 200 + (q2[a + 44 >> 2] = mc) | 0, 80 + mc | 0, 160 + mc | 0, kc, lc), jc && (n2[q2[a + 36 >> 2]](a, 0, 0), q2[a + 48 >> 2] = 0, q2[a + 44 >> 2] = jc, q2[a + 28 >> 2] = 0, q2[a + 16 >> 2] = 0, q2[a + 20 >> 2] = 0)), q2[a >> 2] = q2[a >> 2] | oc), L2 = 208 + mc | 0;
            }
            function Ka(a, ic, pc) {
              var rc, qc;
              $(8 + (L2 = qc = L2 - 160 | 0) | 0, 3192, 144), q2[52 + qc >> 2] = a, q2[28 + qc >> 2] = a, q2[56 + qc >> 2] = rc = (rc = -2 - a | 0) >>> 0 < 256 ? rc : 256, q2[36 + qc >> 2] = a = a + rc | 0, q2[24 + qc >> 2] = a, Ia(8 + qc | 0, ic, pc, 11, 12), rc && (a = q2[28 + qc >> 2], o[a - ((0 | a) == q2[24 + qc >> 2]) | 0] = 0), L2 = 160 + qc | 0;
            }
            function La(a, ic) {
              var sc, tc, pc = 0, pc = 0 != (0 | ic);
              a: {
                b: {
                  c: {
                    d: if (!(!ic | !(3 & a))) for (; ; ) {
                      if (!r2[0 | a]) break c;
                      if (a = a + 1 | 0, pc = 0 != (0 | (ic = ic + -1 | 0)), !ic) break d;
                      if (!(3 & a)) break;
                    }
                    if (!pc) break b;
                  }
                  if (!r2[0 | a]) break a;
                  e: {
                    if (4 <= ic >>> 0) {
                      for (pc = (pc = ic + -4 | 0) - (sc = -4 & pc) | 0, sc = 4 + (a + sc | 0) | 0; ; ) {
                        if ((-1 ^ (tc = q2[a >> 2])) & tc + -16843009 & -2139062144) break e;
                        if (a = a + 4 | 0, !(3 < (ic = ic + -4 | 0) >>> 0)) break;
                      }
                      ic = pc, a = sc;
                    }
                    if (!ic) break b;
                  }
                  for (; ; ) {
                    if (!r2[0 | a]) break a;
                    if (a = a + 1 | 0, !(ic = ic + -1 | 0)) break;
                  }
                }
                return 0;
              }
              return a;
            }
            function Ma(a) {
              var uc, ic = 0;
              if (!a) return 32;
              if (!(1 & a)) {
                for (; ; ) if (ic = ic + 1 | 0, uc = 2 & a, a >>>= 1, uc) break;
              }
              return ic;
            }
            function Na(a, vc) {
              var zc, Ac, Bc, yc, wc = 0, xc = 0, xc = 4;
              L2 = yc = L2 - 256 | 0;
              a: if (!((0 | vc) < 2)) for (wc = q2[(Bc = (vc << 2) + a | 0) >> 2] = yc; ; ) {
                for ($(wc, q2[a >> 2], zc = xc >>> 0 < 256 ? xc : 256), wc = 0; ; ) if ($(q2[(Ac = (wc << 2) + a | 0) >> 2], q2[((wc = wc + 1 | 0) << 2) + a >> 2], zc), q2[Ac >> 2] = q2[Ac >> 2] + zc, (0 | vc) == (0 | wc)) break;
                if (!(xc = xc - zc | 0)) break a;
                wc = q2[Bc >> 2];
              }
              L2 = 256 + yc | 0;
            }
            function Oa(a) {
              var vc;
              return (vc = Ma(q2[a >> 2] + -1 | 0)) || ((a = Ma(q2[a + 4 >> 2])) ? a + 32 | 0 : 0);
            }
            function Sa(a) {
              var Hc;
              q2[(L2 = Hc = L2 - 16 | 0) >> 2] = a, function(a2, Il) {
                var Jl = 0;
                q2[12 + (L2 = Jl = L2 - 16 | 0) >> 2] = Il, Ia(a2, 1432, Il, 0, 0), L2 = 16 + Jl | 0;
              }(q2[970], Hc), L2 = 16 + Hc | 0;
            }
            function Cc(a, Il, Jl, tm) {
              var zm, wm, um = 0, vm = 0, xm = 0, ym = 0;
              return L2 = wm = L2 - 32 | 0, um = (ym = um = 2147483647 & tm) + -1006698496 | 0, vm = um = (zm = vm = xm = Jl) >>> 0 < 0 ? um + 1 | 0 : um, um = ym + -1140785152 | 0, (0 | (um = xm >>> 0 < 0 ? um + 1 | 0 : um)) == (0 | vm) & zm >>> 0 < xm >>> 0 | vm >>> 0 < um >>> 0 ? (um = tm << 4 | Jl >>> 28, Jl = Jl << 4 | Il >>> 28, 134217728 == (0 | (xm = Il &= 268435455)) & 1 <= a >>> 0 | 134217728 < Il >>> 0 ? (um = um + 1073741824 | 0, (a = Jl + 1 | 0) >>> 0 < 1 && (um = um + 1 | 0), vm = a) : (um = um - (((vm = Jl) >>> 0 < 0) + -1073741824 | 0) | 0, a | 134217728 ^ xm || ((a = vm + (1 & vm) | 0) >>> 0 < vm >>> 0 && (um = um + 1 | 0), vm = a))) : (!xm & 2147418112 == (0 | ym) ? !(a | Il) : 2147418112 == (0 | ym) & xm >>> 0 < 0 | ym >>> 0 < 2147418112) ? (um = 2146435072, 1140785151 == ((vm = 0) | ym) & 4294967295 < xm >>> 0 | 1140785151 < ym >>> 0 || (xm = ym >>> 16) >>> (um = 0) < 15249 || (function(a2, Il2, Jl2, tm2, Bm, Cm) {
                var Hm = 0, Im = 0, Jm = 0, Km = 0;
                a: if (64 & Cm) Il2 = 31 & (Jl2 = Cm + -64 | 0), Il2 = 32 <= (63 & Jl2) >>> 0 ? (Jl2 = 0, Bm >>> Il2) : (Jl2 = Bm >>> Il2, ((1 << Il2) - 1 & Bm) << 32 - Il2 | tm2 >>> Il2), Bm = tm2 = 0;
                else {
                  if (!Cm) break a;
                  Im = Bm, Jm = tm2, Hm = 31 & (Km = 64 - Cm | 0), Km = 32 <= (63 & Km) >>> 0 ? (Im = Jm << Hm, 0) : (Im = (1 << Hm) - 1 & Jm >>> 32 - Hm | Im << Hm, Jm << Hm), Jm = Il2, Il2 = 31 & (Hm = Cm), Il2 = 32 <= (63 & Hm) >>> 0 ? (Hm = 0, Jl2 >>> Il2) : (Hm = Jl2 >>> Il2, ((1 << Il2) - 1 & Jl2) << 32 - Il2 | Jm >>> Il2), Il2 |= Km, Jl2 = Hm | Im, Hm = tm2, tm2 = 31 & Cm, tm2 = 32 <= (63 & Cm) >>> 0 ? (Im = 0, Bm >>> tm2) : (Im = Bm >>> tm2, ((1 << tm2) - 1 & Bm) << 32 - tm2 | Hm >>> tm2), Bm = Im;
                }
                q2[a2 >> 2] = Il2, q2[a2 + 4 >> 2] = Jl2, q2[a2 + 8 >> 2] = tm2, q2[a2 + 12 >> 2] = Bm;
              }(wm, a, Il, Jl, um = 65535 & tm | 65536, 15361 - xm | 0), function(a2, Il2, Jl2, tm2, Bm, Cm) {
                var Dm = 0, Em = 0, Fm = 0, Gm = 0;
                64 & Cm ? (tm2 = Il2, Il2 = 31 & (Bm = Cm + -64 | 0), 32 <= (63 & Bm) >>> 0 ? (Bm = tm2 << Il2, tm2 = 0) : (Bm = (1 << Il2) - 1 & tm2 >>> 32 - Il2 | Jl2 << Il2, tm2 <<= Il2), Jl2 = Il2 = 0) : Cm && (Dm = tm2, tm2 = 31 & (Fm = Cm), Gm = 32 <= (63 & Cm) >>> 0 ? (Em = Dm << tm2, 0) : (Em = (1 << tm2) - 1 & Dm >>> 32 - tm2 | Bm << tm2, Dm << tm2), tm2 = Jl2, Dm = Il2, Bm = 31 & (Cm = 64 - Cm | 0), 32 <= (63 & Cm) >>> 0 ? (Cm = 0, tm2 >>>= Bm) : (Cm = tm2 >>> Bm, tm2 = ((1 << Bm) - 1 & tm2) << 32 - Bm | Dm >>> Bm), tm2 |= Gm, Bm = Cm | Em, Cm = Il2, Il2 = 31 & Fm, Il2 = 32 <= (63 & Fm) >>> 0 ? (Em = Cm << Il2, 0) : (Em = (1 << Il2) - 1 & Cm >>> 32 - Il2 | Jl2 << Il2, Cm << Il2), Jl2 = Em);
                q2[a2 >> 2] = Il2, q2[a2 + 4 >> 2] = Jl2, q2[a2 + 8 >> 2] = tm2, q2[a2 + 12 >> 2] = Bm;
              }(16 + wm | 0, a, Il, Jl, um, xm + -15233 | 0), Jl = q2[4 + wm >> 2], a = q2[8 + wm >> 2], um = q2[12 + wm >> 2] << 4 | a >>> 28, vm = a << 4 | Jl >>> 28, 134217728 == (0 | (Jl = a = 268435455 & Jl)) & 1 <= (Il = q2[wm >> 2] | (0 != (q2[16 + wm >> 2] | q2[24 + wm >> 2]) | 0 != (q2[20 + wm >> 2] | q2[28 + wm >> 2]))) >>> 0 | 134217728 < a >>> 0 ? ((a = vm + 1 | 0) >>> 0 < 1 && (um = um + 1 | 0), vm = a) : Il | 134217728 ^ Jl || ((a = vm + (1 & vm) | 0) >>> 0 < vm >>> 0 && (um = um + 1 | 0), vm = a))) : (vm = Jl << 4 | Il >>> 28, um = 524287 & (um = tm << 4 | Jl >>> 28) | 2146959360), L2 = 32 + wm | 0, f(0, 0 | vm), f(1, -2147483648 & tm | um), +g();
            }
            function Zc(a, $o) {
              a = 0 | a, $o = 0 | $o, b2[0] = a, b2[1] = $o;
            }
            function ad(a, $o, ap) {
              return function(a2, $o2, ap2) {
                var ep, cp, bp, dp, fp = w2(cp = ap2 >>> 16, bp = a2 >>> 16);
                return a2 = (65535 & (bp = ((ep = w2(dp = 65535 & ap2, a2 &= 65535)) >>> 16) + w2(bp, dp) | 0)) + w2(a2, cp) | 0, M2 = ((fp + w2($o2, ap2) | 0) + (bp >>> 16) | 0) + (a2 >>> 16) | 0, 65535 & ep | a2 << 16;
              }(a, $o, ap);
            }
            function bd(a, $o, ap) {
              return function(a2, $o2, ap2) {
                var np, gp = 0, hp = 0, ip = 0, jp = 0, kp = 0, lp = 0, mp = 0, op = 0;
                a: {
                  b: {
                    c: {
                      d: {
                        e: {
                          if (!(hp = $o2)) return Zc(($o2 = a2) - w2(a2 = (a2 >>> 0) / (ap2 >>> 0) | 0, ap2) | 0, 0), M2 = 0, a2;
                          if (gp = ap2) {
                            if (!((jp = gp + -1 | 0) & gp)) break e;
                            kp = 0 - (jp = (z2(gp) + 33 | 0) - z2(hp) | 0) | 0;
                            break c;
                          }
                          if (!a2) return Zc(0, hp - w2(a2 = (hp >>> 0) / 0 | 0, 0) | 0), M2 = 0, a2;
                          if ((gp = 32 - z2(hp) | 0) >>> 0 < 31) break d;
                          break b;
                        }
                        if (Zc(a2 & jp, 0), 1 == (0 | gp)) break a;
                        return ap2 = 31 & (gp = gp ? 31 - z2(gp + -1 ^ gp) | 0 : 32), a2 = 32 <= (63 & gp) >>> 0 ? (hp = 0, $o2 >>> ap2) : (hp = $o2 >>> ap2, ((1 << ap2) - 1 & $o2) << 32 - ap2 | a2 >>> ap2), M2 = hp, a2;
                      }
                      jp = gp + 1 | 0, kp = 63 - gp | 0;
                    }
                    if (gp = $o2, ip = 31 & (hp = 63 & jp), ip = 32 <= hp >>> 0 ? (hp = 0, gp >>> ip) : (hp = gp >>> ip, ((1 << ip) - 1 & gp) << 32 - ip | a2 >>> ip), gp = 31 & (kp &= 63), 32 <= kp >>> 0 ? ($o2 = a2 << gp, a2 = 0) : ($o2 = (1 << gp) - 1 & a2 >>> 32 - gp | $o2 << gp, a2 <<= gp), jp) {
                      for ((kp = ap2 + (gp = -1) | 0) >>> 0 < 4294967295 && (gp = 0); ; ) if (ip = (mp = lp = ip << 1 | $o2 >>> 31) - (np = ap2 & (lp = gp - ((hp = hp << 1 | ip >>> 31) + (kp >>> 0 < lp >>> 0) | 0) >> 31)) | 0, hp = hp - (mp >>> 0 < np >>> 0) | 0, $o2 = $o2 << 1 | a2 >>> 31, a2 = op | a2 << 1, op = lp &= 1, !(jp = jp + -1 | 0)) break;
                    }
                    return Zc(ip, hp), M2 = $o2 << 1 | a2 >>> 31, lp | a2 << 1;
                  }
                  Zc(a2, $o2), $o2 = a2 = 0;
                }
                return M2 = $o2, a2;
              }(a, $o, ap);
            }
            function dd(a) {
              var pp;
              return (-1 >>> (pp = 31 & a) & -2) << pp | (-1 << (a = 0 - a & 31) & -2) >>> a;
            }
            function N2() {
              return buffer2.byteLength / 65536 | 0;
            }
          }(H, I, J) };
        }
        l2 = null, b.wasmBinary && (F = b.wasmBinary);
        var WebAssembly = {}, F = [];
        "object" != typeof WebAssembly && E("no native wasm support detected");
        var I, J = new function(a) {
          var c = Array(16);
          return c.grow = function() {
            17 <= c.length && B("Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH."), c.push(null);
          }, c.set = function(a2, e) {
            c[a2] = e;
          }, c.get = function(a2) {
            return c[a2];
          }, c;
        }(), K = false;
        function assert(a, c) {
          a || B("Assertion failed: " + c);
        }
        var buffer, M, L, N, ha = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function ia(a, c, d) {
          var e = c + d;
          for (d = c; a[d] && !(e <= d); ) ++d;
          if (16 < d - c && a.subarray && ha) return ha.decode(a.subarray(c, d));
          for (e = ""; c < d; ) {
            var g, m, f = a[c++];
            128 & f ? (g = 63 & a[c++], 192 == (224 & f) ? e += String.fromCharCode((31 & f) << 6 | g) : (m = 63 & a[c++], (f = 224 == (240 & f) ? (15 & f) << 12 | g << 6 | m : (7 & f) << 18 | g << 12 | m << 6 | 63 & a[c++]) < 65536 ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | 1023 & f)))) : e += String.fromCharCode(f);
          }
          return e;
        }
        function ja(a, c) {
          return a ? ia(L, a, c) : "";
        }
        function ka(a) {
          return 0 < a % 65536 && (a += 65536 - a % 65536), a;
        }
        function la(a) {
          buffer = a, b.HEAP8 = M = new Int8Array(a), b.HEAP16 = new Int16Array(a), b.HEAP32 = N = new Int32Array(a), b.HEAPU8 = L = new Uint8Array(a), b.HEAPU16 = new Uint16Array(a), b.HEAPU32 = new Uint32Array(a), b.HEAPF32 = new Float32Array(a), b.HEAPF64 = new Float64Array(a);
        }
        "undefined" != typeof TextDecoder && new TextDecoder("utf-16le");
        var G = b.TOTAL_MEMORY || 16777216;
        function O(a) {
          for (; 0 < a.length; ) {
            var d, c = a.shift();
            "function" == typeof c ? c() : "number" == typeof (d = c.ea) ? void 0 === c.da ? b.dynCall_v(d) : b.dynCall_vi(d, c.da) : d(void 0 === c.da ? null : c.da);
          }
        }
        (I = b.wasmMemory || new function() {
          return { buffer: new ArrayBuffer(G / 65536 * 65536), grow: function(a) {
            return ca(a);
          } };
        }()) && (buffer = I.buffer), G = buffer.byteLength, la(buffer), N[2216] = 5251936;
        var ra, ma = [], na = [], oa = [], pa = [];
        Math.imul && -5 === Math.imul(4294967295, 5) || (Math.imul = function(a, c) {
          var d = 65535 & a, e = 65535 & c;
          return d * e + ((a >>> 16) * e + d * (c >>> 16) << 16) | 0;
        }), Math.fround || (ra = new Float32Array(1), Math.fround = function(a) {
          return ra[0] = a, ra[0];
        }), Math.clz32 || (Math.clz32 = function(a) {
          var c = 32, d = a >> 16;
          return d && (c -= 16, a = d), (d = a >> 8) && (c -= 8, a = d), (d = a >> 4) && (c -= 4, a = d), (d = a >> 2) && (c -= 2, a = d), a >> 1 ? c - 2 : c - a;
        }), Math.trunc || (Math.trunc = function(a) {
          return a < 0 ? Math.ceil(a) : Math.floor(a);
        });
        var P = 0, Q = null, U = null;
        function B(a) {
          throw b.onAbort && b.onAbort(a), D(a), E(a), K = true, "abort(" + a + "). Build with -s ASSERTIONS=1 for more info.";
        }
        b.preloadedImages = {}, b.preloadedAudios = {};
        var V = "data:application/octet-stream;base64,";
        function W(a) {
          return String.prototype.startsWith ? a.startsWith(V) : 0 === a.indexOf(V);
        }
        var X2 = "_em_module.wasm";
        function ta() {
          try {
            if (F) return new Uint8Array(F);
            var a = z(X2);
            if (a) return a;
            if (w) return w(X2);
            throw "both async and sync fetching of the wasm failed";
          } catch (c) {
            B(c);
          }
        }
        W(X2) || (t2 = X2, X2 = b.locateFile ? b.locateFile(t2, u) : u + t2), na.push({ ea: function() {
          va();
        } });
        var wa = [null, [], []], xa = false;
        function C(a) {
          for (var c = [], d = 0; d < a.length; d++) {
            var e = a[d];
            255 < e && (xa && assert(false, "Character code " + e + " (" + String.fromCharCode(e) + ")  at offset " + d + " not in 0x00-0xFF."), e &= 255), c.push(String.fromCharCode(e));
          }
          return c.join("");
        }
        var ya = "function" == typeof atob ? atob : function(a) {
          var c = "", d = 0;
          a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), e = e << 2 | f >> 4, f = (15 & f) << 4 | g >> 2, h = (3 & g) << 6 | m;
          } while (c += String.fromCharCode(e), 64 !== g && (c += String.fromCharCode(f)), 64 !== m && (c += String.fromCharCode(h)), d < a.length);
          return c;
        };
        function z(a) {
          if (W(a)) {
            if (a = a.slice(V.length), "boolean" == typeof r && r) {
              try {
                var c = Buffer.from(a, "base64");
              } catch (g) {
                c = new Buffer(a, "base64");
              }
              var d = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else try {
              for (var e = ya(a), f = new Uint8Array(e.length), c = 0; c < e.length; ++c) f[c] = e.charCodeAt(c);
              d = f;
            } catch (g) {
              throw Error("Converting base64 string to bytes failed.");
            }
            return d;
          }
        }
        var Y2, H = { a: function(a, c, d) {
          L.set(L.subarray(c, c + d), a);
        }, b: function(a) {
          if (2147418112 < a) return false;
          for (var c = Math.max(M.length, 16777216); c < a; ) c = c <= 536870912 ? ka(2 * c) : Math.min(ka((3 * c + 2147483648) / 4), 2147418112);
          a: {
            try {
              I.grow(c - buffer.byteLength + 65535 >> 16), la(I.buffer);
              var d = 1;
              break a;
            } catch (e) {
            }
            d = void 0;
          }
          return !!d;
        }, c: function(a, c, d, e) {
          try {
            for (var f = 0, g = 0; g < d; g++) {
              for (var m = N[c + 8 * g >> 2], h = N[c + (8 * g + 4) >> 2], A = 0; A < h; A++) {
                var R = L[m + A], S = wa[a];
                0 === R || 10 === R ? ((1 === a ? D : E)(ia(S, 0)), S.length = 0) : S.push(R);
              }
              f += h;
            }
            return N[e >> 2] = f, 0;
          } catch (T) {
            return "undefined" != typeof FS && T instanceof FS.fa || B(T), T.ga;
          }
        }, memory: I, table: J }, u = function() {
          function a(a2) {
            b.asm = a2.exports, P--, b.monitorRunDependencies && b.monitorRunDependencies(P), 0 == P && (null !== Q && (clearInterval(Q), Q = null), U) && (a2 = U, U = null, a2());
          }
          function c(c2) {
            a(c2.instance);
          }
          function d(a2) {
            return (F || !p && !q || "function" != typeof fetch ? new Promise(function(a3) {
              a3(ta());
            }) : fetch(X2, { credentials: "same-origin" }).then(function(a3) {
              if (a3.ok) return a3.arrayBuffer();
              throw "failed to load wasm binary file at '" + X2 + "'";
            }).catch(ta)).then(function() {
              return { then: function(a3) {
                a3({ instance: new da() });
              } };
            }).then(a2, function(a3) {
              E("failed to asynchronously prepare wasm: " + a3), B(a3);
            });
          }
          var e = { env: H, wasi_unstable: H };
          if (P++, b.monitorRunDependencies && b.monitorRunDependencies(P), b.instantiateWasm) try {
            return b.instantiateWasm(e, a);
          } catch (f) {
            return E("Module.instantiateWasm callback failed with error: " + f), false;
          }
          return F || "function" != typeof WebAssembly.instantiateStreaming || W(X2) || "function" != typeof fetch ? d(c) : fetch(X2, { credentials: "same-origin" }).then(function(a2) {
            return WebAssembly.instantiateStreaming(a2, e).then(c, function(a3) {
              E("wasm streaming compile failed: " + a3), E("falling back to ArrayBuffer instantiation"), d(c);
            });
          }), {};
        }(), va = (b.asm = u, b.___wasm_call_ctors = function() {
          return b.asm.d.apply(null, arguments);
        }), Aa = (b._csmGetVersion = function() {
          return b.asm.e.apply(null, arguments);
        }, b._csmGetLatestMocVersion = function() {
          return b.asm.f.apply(null, arguments);
        }, b._csmGetMocVersion = function() {
          return b.asm.g.apply(null, arguments);
        }, b._csmHasMocConsistency = function() {
          return b.asm.h.apply(null, arguments);
        }, b._csmSetLogFunction = function() {
          return b.asm.i.apply(null, arguments);
        }, b._csmReviveMocInPlace = function() {
          return b.asm.j.apply(null, arguments);
        }, b._csmReadCanvasInfo = function() {
          return b.asm.k.apply(null, arguments);
        }, b._csmGetSizeofModel = function() {
          return b.asm.l.apply(null, arguments);
        }, b._csmInitializeModelInPlace = function() {
          return b.asm.m.apply(null, arguments);
        }, b._csmUpdateModel = function() {
          return b.asm.n.apply(null, arguments);
        }, b._csmGetParameterCount = function() {
          return b.asm.o.apply(null, arguments);
        }, b._csmGetParameterIds = function() {
          return b.asm.p.apply(null, arguments);
        }, b._csmGetParameterTypes = function() {
          return b.asm.q.apply(null, arguments);
        }, b._csmGetParameterMinimumValues = function() {
          return b.asm.r.apply(null, arguments);
        }, b._csmGetParameterMaximumValues = function() {
          return b.asm.s.apply(null, arguments);
        }, b._csmGetParameterDefaultValues = function() {
          return b.asm.t.apply(null, arguments);
        }, b._csmGetParameterValues = function() {
          return b.asm.u.apply(null, arguments);
        }, b._csmGetPartCount = function() {
          return b.asm.v.apply(null, arguments);
        }, b._csmGetPartIds = function() {
          return b.asm.w.apply(null, arguments);
        }, b._csmGetPartOpacities = function() {
          return b.asm.x.apply(null, arguments);
        }, b._csmGetPartParentPartIndices = function() {
          return b.asm.y.apply(null, arguments);
        }, b._csmGetDrawableCount = function() {
          return b.asm.z.apply(null, arguments);
        }, b._csmGetDrawableIds = function() {
          return b.asm.A.apply(null, arguments);
        }, b._csmGetDrawableConstantFlags = function() {
          return b.asm.B.apply(null, arguments);
        }, b._csmGetDrawableDynamicFlags = function() {
          return b.asm.C.apply(null, arguments);
        }, b._csmGetDrawableTextureIndices = function() {
          return b.asm.D.apply(null, arguments);
        }, b._csmGetDrawableDrawOrders = function() {
          return b.asm.E.apply(null, arguments);
        }, b._csmGetDrawableRenderOrders = function() {
          return b.asm.F.apply(null, arguments);
        }, b._csmGetDrawableOpacities = function() {
          return b.asm.G.apply(null, arguments);
        }, b._csmGetDrawableMaskCounts = function() {
          return b.asm.H.apply(null, arguments);
        }, b._csmGetDrawableMasks = function() {
          return b.asm.I.apply(null, arguments);
        }, b._csmGetDrawableVertexCounts = function() {
          return b.asm.J.apply(null, arguments);
        }, b._csmGetDrawableVertexPositions = function() {
          return b.asm.K.apply(null, arguments);
        }, b._csmGetDrawableVertexUvs = function() {
          return b.asm.L.apply(null, arguments);
        }, b._csmGetDrawableIndexCounts = function() {
          return b.asm.M.apply(null, arguments);
        }, b._csmGetDrawableIndices = function() {
          return b.asm.N.apply(null, arguments);
        }, b._csmGetDrawableMultiplyColors = function() {
          return b.asm.O.apply(null, arguments);
        }, b._csmGetDrawableScreenColors = function() {
          return b.asm.P.apply(null, arguments);
        }, b._csmGetDrawableParentPartIndices = function() {
          return b.asm.Q.apply(null, arguments);
        }, b._csmResetDrawableDynamicFlags = function() {
          return b.asm.R.apply(null, arguments);
        }, b._csmGetParameterKeyCounts = function() {
          return b.asm.S.apply(null, arguments);
        }, b._csmGetParameterKeyValues = function() {
          return b.asm.T.apply(null, arguments);
        }, b._csmMallocMoc = function() {
          return b.asm.U.apply(null, arguments);
        }, b._csmMallocModelAndInitialize = function() {
          return b.asm.V.apply(null, arguments);
        }, b._csmMalloc = function() {
          return b.asm.W.apply(null, arguments);
        }, b._csmFree = function() {
          return b.asm.X.apply(null, arguments);
        }, b._csmInitializeAmountOfMemory = function() {
          return b.asm.Y.apply(null, arguments);
        }, b.stackSave = function() {
          return b.asm.Z.apply(null, arguments);
        }), Ba = b.stackAlloc = function() {
          return b.asm._.apply(null, arguments);
        }, Ca = b.stackRestore = function() {
          return b.asm.$.apply(null, arguments);
        }, ca = b.__growWasmMemory = function() {
          return b.asm.aa.apply(null, arguments);
        };
        function Z() {
          function a() {
            if (!Y2 && (Y2 = true, !K)) {
              if (O(na), O(oa), b.onRuntimeInitialized && b.onRuntimeInitialized(), b.postRun) for ("function" == typeof b.postRun && (b.postRun = [b.postRun]); b.postRun.length; ) {
                var a2 = b.postRun.shift();
                pa.unshift(a2);
              }
              O(pa);
            }
          }
          if (!(0 < P)) {
            if (b.preRun) for ("function" == typeof b.preRun && (b.preRun = [b.preRun]); b.preRun.length; ) !function() {
              var a2 = b.preRun.shift();
              ma.unshift(a2);
            }();
            O(ma), 0 < P || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                b.setStatus("");
              }, 1), a();
            }, 1)) : a());
          }
        }
        if (b.dynCall_vi = function() {
          return b.asm.ba.apply(null, arguments);
        }, b.asm = u, b.ccall = function(a, c, d, e) {
          var f = { string: function(a2) {
            var c2 = 0;
            if (null != a2 && 0 !== a2) {
              var d2 = 1 + (a2.length << 2), e2 = c2 = Ba(d2), f2 = L;
              if (0 < d2) {
                for (var d2 = e2 + d2 - 1, g2 = 0; g2 < a2.length; ++g2) {
                  var k = a2.charCodeAt(g2);
                  if ((k = 55296 <= k && k <= 57343 ? 65536 + ((1023 & k) << 10) | 1023 & a2.charCodeAt(++g2) : k) <= 127) {
                    if (d2 <= e2) break;
                    f2[e2++] = k;
                  } else {
                    if (k <= 2047) {
                      if (d2 <= e2 + 1) break;
                      f2[e2++] = 192 | k >> 6;
                    } else {
                      if (k <= 65535) {
                        if (d2 <= e2 + 2) break;
                        f2[e2++] = 224 | k >> 12;
                      } else {
                        if (d2 <= e2 + 3) break;
                        f2[e2++] = 240 | k >> 18, f2[e2++] = 128 | k >> 12 & 63;
                      }
                      f2[e2++] = 128 | k >> 6 & 63;
                    }
                    f2[e2++] = 128 | 63 & k;
                  }
                }
                f2[e2] = 0;
              }
            }
            return c2;
          }, array: function(a2) {
            var c2 = Ba(a2.length);
            return M.set(a2, c2), c2;
          } }, g = function(a2) {
            var c2 = b["_" + a2];
            return assert(c2, "Cannot call unknown function " + a2 + ", make sure it is exported"), c2;
          }(a), m = [];
          if (a = 0, e) for (var h = 0; h < e.length; h++) {
            var A = f[d[h]];
            A ? (0 === a && (a = Aa()), m[h] = A(e[h])) : m[h] = e[h];
          }
          return d = function(a2) {
            return "string" === c ? ja(a2) : "boolean" === c ? !!a2 : a2;
          }(d = g.apply(null, m)), 0 !== a && Ca(a), d;
        }, b.UTF8ToString = ja, b.addFunction = function(a, c) {
          var d = J.length;
          try {
            J.grow(1);
          } catch (e) {
            if (!e instanceof RangeError) throw e;
            throw "Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.";
          }
          try {
            J.set(d, a);
          } catch (e) {
            if (!e instanceof TypeError) throw e;
            assert(void 0 !== c, "Missing signature argument to addFunction"), J.set(d, a);
          }
          return d;
        }, b.then = function(a) {
          var c;
          return Y2 ? a(b) : (c = b.onRuntimeInitialized, b.onRuntimeInitialized = function() {
            c && c(), a(b);
          }), b;
        }, U = function Da() {
          Y2 || Z(), Y2 || (U = Da);
        }, b.run = Z, b.preInit) for ("function" == typeof b.preInit && (b.preInit = [b.preInit]); 0 < b.preInit.length; ) b.preInit.pop()();
        return Z(), _em_module2;
      };
    }();
    "object" == typeof exports && "object" == typeof module ? module.exports = _em_module : "function" == typeof define && define.amd ? define([], function() {
      return _em_module;
    }) : "object" == typeof exports && (exports._em_module = _em_module);
    var _em = _em_module();
  })(Live2DCubismCore2 || (Live2DCubismCore2 = {}));
  if (typeof globalThis !== "undefined") {
    globalThis.Live2DCubismCore = Live2DCubismCore2;
  } else if (typeof window !== "undefined") {
    window.Live2DCubismCore = Live2DCubismCore2;
  }

  // prebuild.js
  var Browser = {
    isDomPresent: true,
    navigator,
    window,
    document,
    ajax: function(url) {
      const xhr = new XMLHttpRequest();
      xhr.open("GET", url, false);
      if (xhr.overrideMimeType) {
        xhr.overrideMimeType("text/plain");
      }
      xhr.setRequestHeader("If-Modified-Since", "Fri, 01 Jan 1960 00:00:00 GMT");
      xhr.send(null);
      if (xhr.status !== 200 && xhr.status !== 0) {
        throw new Error("XMLHttpRequest failed, status code " + xhr.status);
      }
      return xhr.responseText;
    }
  };
  window.Processing = src_default(Browser);
})();
