(() => {
  var __defProp = Object.defineProperty;
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

  // src/Helpers/virtEquals.js
  function virtEquals(obj, other) {
    if (obj === null || other === null) {
      return obj === null && other === null;
    }
    if (typeof obj === "string") {
      return obj === other;
    }
    if (typeof obj !== "object") {
      return obj === other;
    }
    if (obj.equals instanceof Function) {
      return obj.equals(other);
    }
    return obj === other;
  }

  // src/Helpers/virtHashCode.js
  function virtHashCode(obj, undef) {
    if (typeof obj === "string") {
      var hash = 0;
      for (var i = 0; i < obj.length; ++i) {
        hash = hash * 31 + obj.charCodeAt(i) & 4294967295;
      }
      return hash;
    }
    if (typeof obj !== "object") {
      return obj & 4294967295;
    }
    if (obj.hashCode instanceof Function) {
      return obj.hashCode();
    }
    if (obj.$id === undef) {
      obj.$id = Math.floor(Math.random() * 65536) - 32768 << 16 | Math.floor(Math.random() * 65536);
    }
    return obj.$id;
  }

  // src/Helpers/ObjectIterator.js
  function ObjectIterator(obj) {
    if (obj instanceof Array) {
      var index = -1;
      this.hasNext = function() {
        return ++index < obj.length;
      };
      this.next = function() {
        return obj[index];
      };
    } else if (obj.iterator instanceof Function) {
      return obj.iterator();
    } else {
      throw "Unable to iterate: " + obj;
    }
  }

  // src/Helpers/PConstants.js
  var PConstants2 = {
    X: 0,
    Y: 1,
    Z: 2,
    R: 3,
    G: 4,
    B: 5,
    A: 6,
    U: 7,
    V: 8,
    NX: 9,
    NY: 10,
    NZ: 11,
    EDGE: 12,
    // Stroke
    SR: 13,
    SG: 14,
    SB: 15,
    SA: 16,
    SW: 17,
    // Transformations (2D and 3D)
    TX: 18,
    TY: 19,
    TZ: 20,
    VX: 21,
    VY: 22,
    VZ: 23,
    VW: 24,
    // Material properties
    AR: 25,
    AG: 26,
    AB: 27,
    DR: 3,
    DG: 4,
    DB: 5,
    DA: 6,
    SPR: 28,
    SPG: 29,
    SPB: 30,
    SHINE: 31,
    ER: 32,
    EG: 33,
    EB: 34,
    BEEN_LIT: 35,
    VERTEX_FIELD_COUNT: 36,
    // Renderers
    P2D: 1,
    JAVA2D: 1,
    WEBGL: 2,
    P3D: 2,
    OPENGL: 2,
    PDF: 0,
    DXF: 0,
    // Platform IDs
    OTHER: 0,
    WINDOWS: 1,
    MAXOSX: 2,
    LINUX: 3,
    EPSILON: 1e-4,
    MAX_FLOAT: 34028235e31,
    MIN_FLOAT: -34028235e31,
    MAX_INT: 2147483647,
    MIN_INT: -2147483648,
    PI: Math.PI,
    TWO_PI: 2 * Math.PI,
    TAU: 2 * Math.PI,
    HALF_PI: Math.PI / 2,
    THIRD_PI: Math.PI / 3,
    QUARTER_PI: Math.PI / 4,
    DEG_TO_RAD: Math.PI / 180,
    RAD_TO_DEG: 180 / Math.PI,
    WHITESPACE: " 	\n\r\f\xA0",
    // Color modes
    RGB: 1,
    ARGB: 2,
    HSB: 3,
    ALPHA: 4,
    CMYK: 5,
    // Image file types
    TIFF: 0,
    TARGA: 1,
    JPEG: 2,
    GIF: 3,
    // Filter/convert types
    BLUR: 11,
    GRAY: 12,
    INVERT: 13,
    OPAQUE: 14,
    POSTERIZE: 15,
    THRESHOLD: 16,
    ERODE: 17,
    DILATE: 18,
    // Blend modes
    REPLACE: 0,
    BLEND: 1 << 0,
    ADD: 1 << 1,
    SUBTRACT: 1 << 2,
    LIGHTEST: 1 << 3,
    DARKEST: 1 << 4,
    DIFFERENCE: 1 << 5,
    EXCLUSION: 1 << 6,
    MULTIPLY: 1 << 7,
    SCREEN: 1 << 8,
    OVERLAY: 1 << 9,
    HARD_LIGHT: 1 << 10,
    SOFT_LIGHT: 1 << 11,
    DODGE: 1 << 12,
    BURN: 1 << 13,
    // Color component bit masks
    ALPHA_MASK: 4278190080,
    RED_MASK: 16711680,
    GREEN_MASK: 65280,
    BLUE_MASK: 255,
    // Projection matrices
    CUSTOM: 0,
    ORTHOGRAPHIC: 2,
    PERSPECTIVE: 3,
    // Shapes
    POINT: 2,
    POINTS: 2,
    LINE: 4,
    LINES: 4,
    TRIANGLE: 8,
    TRIANGLES: 9,
    TRIANGLE_STRIP: 10,
    TRIANGLE_FAN: 11,
    QUAD: 16,
    QUADS: 16,
    QUAD_STRIP: 17,
    POLYGON: 20,
    PATH: 21,
    RECT: 30,
    ELLIPSE: 31,
    ARC: 32,
    SPHERE: 40,
    BOX: 41,
    // Arc drawing modes
    //OPEN:          1, // shared with Shape closing modes   
    CHORD: 2,
    PIE: 3,
    GROUP: 0,
    PRIMITIVE: 1,
    //PATH:         21, // shared with Shape PATH
    GEOMETRY: 3,
    // Shape Vertex
    VERTEX: 0,
    BEZIER_VERTEX: 1,
    CURVE_VERTEX: 2,
    BREAK: 3,
    CLOSESHAPE: 4,
    // Shape closing modes
    OPEN: 1,
    CLOSE: 2,
    // Shape drawing modes
    CORNER: 0,
    // Draw mode convention to use (x, y) to (width, height)
    CORNERS: 1,
    // Draw mode convention to use (x1, y1) to (x2, y2) coordinates
    RADIUS: 2,
    // Draw mode from the center, and using the radius
    CENTER_RADIUS: 2,
    // Deprecated! Use RADIUS instead
    CENTER: 3,
    // Draw from the center, using second pair of values as the diameter
    DIAMETER: 3,
    // Synonym for the CENTER constant. Draw from the center
    CENTER_DIAMETER: 3,
    // Deprecated! Use DIAMETER instead
    // Text vertical alignment modes
    BASELINE: 0,
    // Default vertical alignment for text placement
    TOP: 101,
    // Align text to the top
    BOTTOM: 102,
    // Align text from the bottom, using the baseline
    // UV Texture coordinate modes
    NORMAL: 1,
    NORMALIZED: 1,
    IMAGE: 2,
    // Text placement modes
    MODEL: 4,
    SHAPE: 5,
    // Stroke modes
    SQUARE: "butt",
    ROUND: "round",
    PROJECT: "square",
    MITER: "miter",
    BEVEL: "bevel",
    // Lighting modes
    AMBIENT: 0,
    DIRECTIONAL: 1,
    //POINT:     2, Shared with Shape constant
    SPOT: 3,
    // Key constants
    // Both key and keyCode will be equal to these values
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 10,
    RETURN: 13,
    ESC: 27,
    DELETE: 127,
    CODED: 65535,
    // p.key will be CODED and p.keyCode will be this value
    SHIFT: 16,
    CONTROL: 17,
    ALT: 18,
    CAPSLK: 20,
    PGUP: 33,
    PGDN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUMLK: 144,
    META: 157,
    INSERT: 155,
    // Cursor types
    ARROW: "default",
    CROSS: "crosshair",
    HAND: "pointer",
    MOVE: "move",
    TEXT: "text",
    WAIT: "wait",
    NOCURSOR: "url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto",
    // Hints
    DISABLE_OPENGL_2X_SMOOTH: 1,
    ENABLE_OPENGL_2X_SMOOTH: -1,
    ENABLE_OPENGL_4X_SMOOTH: 2,
    ENABLE_NATIVE_FONTS: 3,
    DISABLE_DEPTH_TEST: 4,
    ENABLE_DEPTH_TEST: -4,
    ENABLE_DEPTH_SORT: 5,
    DISABLE_DEPTH_SORT: -5,
    DISABLE_OPENGL_ERROR_REPORT: 6,
    ENABLE_OPENGL_ERROR_REPORT: -6,
    ENABLE_ACCURATE_TEXTURES: 7,
    DISABLE_ACCURATE_TEXTURES: -7,
    HINT_COUNT: 10,
    // PJS defined constants
    SINCOS_LENGTH: 720,
    // every half degree
    PRECISIONB: 15,
    // fixed point precision is limited to 15 bits!!
    PRECISIONF: 1 << 15,
    PREC_MAXVAL: (1 << 15) - 1,
    PREC_ALPHA_SHIFT: 24 - 15,
    PREC_RED_SHIFT: 16 - 15,
    NORMAL_MODE_AUTO: 0,
    NORMAL_MODE_SHAPE: 1,
    NORMAL_MODE_VERTEX: 2,
    MAX_LIGHTS: 8
  };
  var PConstants_default = PConstants2;

  // src/Objects/ArrayList.js
  function HashMap(options) {
    var virtHashCode2 = options.virtHashCode, virtEquals2 = options.virtEquals;
    function Iterator(array) {
      var index = -1;
      this.hasNext = function() {
        return index + 1 < array.length;
      };
      this.next = function() {
        return array[++index];
      };
      this.remove = function() {
        array.splice(index--, 1);
      };
    }
    function ArrayList(a) {
      var array = [];
      if (a && a.toArray) {
        array = a.toArray();
      }
      this.get = function(i) {
        return array[i];
      };
      this.contains = function(item) {
        return this.indexOf(item) > -1;
      };
      this.indexOf = function(item) {
        for (var i = 0, len = array.length; i < len; ++i) {
          if (virtEquals2(item, array[i])) {
            return i;
          }
        }
        return -1;
      };
      this.lastIndexOf = function(item) {
        for (var i = array.length - 1; i >= 0; --i) {
          if (virtEquals2(item, array[i])) {
            return i;
          }
        }
        return -1;
      };
      this.add = function() {
        if (arguments.length === 1) {
          array.push(arguments[0]);
        } else if (arguments.length === 2) {
          var arg0 = arguments[0];
          if (typeof arg0 === "number") {
            if (arg0 >= 0 && arg0 <= array.length) {
              array.splice(arg0, 0, arguments[1]);
            } else {
              throw arg0 + " is not a valid index";
            }
          } else {
            throw typeof arg0 + " is not a number";
          }
        } else {
          throw "Please use the proper number of parameters.";
        }
      };
      this.addAll = function(arg1, arg2) {
        var it;
        if (typeof arg1 === "number") {
          if (arg1 < 0 || arg1 > array.length) {
            throw "Index out of bounds for addAll: " + arg1 + " greater or equal than " + array.length;
          }
          it = new ObjectIterator(arg2);
          while (it.hasNext()) {
            array.splice(arg1++, 0, it.next());
          }
        } else {
          it = new ObjectIterator(arg1);
          while (it.hasNext()) {
            array.push(it.next());
          }
        }
      };
      this.set = function() {
        if (arguments.length === 2) {
          var arg0 = arguments[0];
          if (typeof arg0 === "number") {
            if (arg0 >= 0 && arg0 < array.length) {
              array.splice(arg0, 1, arguments[1]);
            } else {
              throw arg0 + " is not a valid index.";
            }
          } else {
            throw typeof arg0 + " is not a number";
          }
        } else {
          throw "Please use the proper number of parameters.";
        }
      };
      this.size = function() {
        return array.length;
      };
      this.clear = function() {
        array.length = 0;
      };
      this.remove = function(item) {
        if (typeof item === "number") {
          return array.splice(item, 1)[0];
        }
        item = this.indexOf(item);
        if (item > -1) {
          array.splice(item, 1);
          return true;
        }
        return false;
      };
      this.removeAll = function(c) {
        var i, x, item, newList = new ArrayList();
        newList.addAll(this);
        this.clear();
        for (i = 0, x = 0; i < newList.size(); i++) {
          item = newList.get(i);
          if (!c.contains(item)) {
            this.add(x++, item);
          }
        }
        if (this.size() < newList.size()) {
          return true;
        }
        return false;
      };
      this.isEmpty = function() {
        return !array.length;
      };
      this.clone = function() {
        return new ArrayList(this);
      };
      this.toArray = function() {
        return array.slice(0);
      };
      this.iterator = function() {
        return new Iterator(array);
      };
    }
    return ArrayList;
  }
  var ArrayList_default = HashMap;

  // src/Objects/HashMap.js
  function HashMap2(options) {
    var virtHashCode2 = options.virtHashCode, virtEquals2 = options.virtEquals;
    function HashMap3() {
      if (arguments.length === 1 && arguments[0] instanceof HashMap3) {
        return arguments[0].clone();
      }
      var initialCapacity = arguments.length > 0 ? arguments[0] : 16;
      var loadFactor = arguments.length > 1 ? arguments[1] : 0.75;
      var buckets = [];
      buckets.length = initialCapacity;
      var count = 0;
      var hashMap = this;
      function getBucketIndex(key) {
        var index = virtHashCode2(key) % buckets.length;
        return index < 0 ? buckets.length + index : index;
      }
      function ensureLoad() {
        if (count <= loadFactor * buckets.length) {
          return;
        }
        var allEntries = [];
        for (var i = 0; i < buckets.length; ++i) {
          if (buckets[i] !== void 0) {
            allEntries = allEntries.concat(buckets[i]);
          }
        }
        var newBucketsLength = buckets.length * 2;
        buckets = [];
        buckets.length = newBucketsLength;
        for (var j = 0; j < allEntries.length; ++j) {
          var index = getBucketIndex(allEntries[j].key);
          var bucket = buckets[index];
          if (bucket === void 0) {
            buckets[index] = bucket = [];
          }
          bucket.push(allEntries[j]);
        }
      }
      function Iterator(conversion, removeItem) {
        var bucketIndex = 0;
        var itemIndex = -1;
        var endOfBuckets = false;
        var currentItem;
        function findNext() {
          while (!endOfBuckets) {
            ++itemIndex;
            if (bucketIndex >= buckets.length) {
              endOfBuckets = true;
            } else if (buckets[bucketIndex] === void 0 || itemIndex >= buckets[bucketIndex].length) {
              itemIndex = -1;
              ++bucketIndex;
            } else {
              return;
            }
          }
        }
        this.hasNext = function() {
          return !endOfBuckets;
        };
        this.next = function() {
          currentItem = conversion(buckets[bucketIndex][itemIndex]);
          findNext();
          return currentItem;
        };
        this.remove = function() {
          if (currentItem !== void 0) {
            removeItem(currentItem);
            --itemIndex;
            findNext();
          }
        };
        findNext();
      }
      function Set(conversion, isIn, removeItem) {
        this.clear = function() {
          hashMap.clear();
        };
        this.contains = function(o) {
          return isIn(o);
        };
        this.containsAll = function(o) {
          var it = o.iterator();
          while (it.hasNext()) {
            if (!this.contains(it.next())) {
              return false;
            }
          }
          return true;
        };
        this.isEmpty = function() {
          return hashMap.isEmpty();
        };
        this.iterator = function() {
          return new Iterator(conversion, removeItem);
        };
        this.remove = function(o) {
          if (this.contains(o)) {
            removeItem(o);
            return true;
          }
          return false;
        };
        this.removeAll = function(c) {
          var it = c.iterator();
          var changed = false;
          while (it.hasNext()) {
            var item = it.next();
            if (this.contains(item)) {
              removeItem(item);
              changed = true;
            }
          }
          return true;
        };
        this.retainAll = function(c) {
          var it = this.iterator();
          var toRemove = [];
          while (it.hasNext()) {
            var entry = it.next();
            if (!c.contains(entry)) {
              toRemove.push(entry);
            }
          }
          for (var i = 0; i < toRemove.length; ++i) {
            removeItem(toRemove[i]);
          }
          return toRemove.length > 0;
        };
        this.size = function() {
          return hashMap.size();
        };
        this.toArray = function() {
          var result = [];
          var it = this.iterator();
          while (it.hasNext()) {
            result.push(it.next());
          }
          return result;
        };
      }
      function Entry(pair) {
        this._isIn = function(map) {
          return map === hashMap && pair.removed === void 0;
        };
        this.equals = function(o) {
          return virtEquals2(pair.key, o.getKey());
        };
        this.getKey = function() {
          return pair.key;
        };
        this.getValue = function() {
          return pair.value;
        };
        this.hashCode = function(o) {
          return virtHashCode2(pair.key);
        };
        this.setValue = function(value) {
          var old = pair.value;
          pair.value = value;
          return old;
        };
      }
      this.clear = function() {
        count = 0;
        buckets = [];
        buckets.length = initialCapacity;
      };
      this.clone = function() {
        var map = new HashMap3();
        map.putAll(this);
        return map;
      };
      this.containsKey = function(key) {
        var index = getBucketIndex(key);
        var bucket = buckets[index];
        if (bucket === void 0) {
          return false;
        }
        for (var i = 0; i < bucket.length; ++i) {
          if (virtEquals2(bucket[i].key, key)) {
            return true;
          }
        }
        return false;
      };
      this.containsValue = function(value) {
        for (var i = 0; i < buckets.length; ++i) {
          var bucket = buckets[i];
          if (bucket === void 0) {
            continue;
          }
          for (var j = 0; j < bucket.length; ++j) {
            if (virtEquals2(bucket[j].value, value)) {
              return true;
            }
          }
        }
        return false;
      };
      this.entrySet = function() {
        return new Set(
          function(pair) {
            return new Entry(pair);
          },
          function(pair) {
            return pair instanceof Entry && pair._isIn(hashMap);
          },
          function(pair) {
            return hashMap.remove(pair.getKey());
          }
        );
      };
      this.get = function(key) {
        var index = getBucketIndex(key);
        var bucket = buckets[index];
        if (bucket === void 0) {
          return null;
        }
        for (var i = 0; i < bucket.length; ++i) {
          if (virtEquals2(bucket[i].key, key)) {
            return bucket[i].value;
          }
        }
        return null;
      };
      this.isEmpty = function() {
        return count === 0;
      };
      this.keySet = function() {
        return new Set(
          // get key from pair
          function(pair) {
            return pair.key;
          },
          // is-in test
          function(key) {
            return hashMap.containsKey(key);
          },
          // remove from hashmap by key
          function(key) {
            return hashMap.remove(key);
          }
        );
      };
      this.values = function() {
        return new Set(
          // get value from pair
          function(pair) {
            return pair.value;
          },
          // is-in test
          function(value) {
            return hashMap.containsValue(value);
          },
          // remove from hashmap by value
          function(value) {
            return hashMap.removeByValue(value);
          }
        );
      };
      this.put = function(key, value) {
        var index = getBucketIndex(key);
        var bucket = buckets[index];
        if (bucket === void 0) {
          ++count;
          buckets[index] = [{
            key,
            value
          }];
          ensureLoad();
          return null;
        }
        for (var i = 0; i < bucket.length; ++i) {
          if (virtEquals2(bucket[i].key, key)) {
            var previous = bucket[i].value;
            bucket[i].value = value;
            return previous;
          }
        }
        ++count;
        bucket.push({
          key,
          value
        });
        ensureLoad();
        return null;
      };
      this.putAll = function(m) {
        var it = m.entrySet().iterator();
        while (it.hasNext()) {
          var entry = it.next();
          this.put(entry.getKey(), entry.getValue());
        }
      };
      this.remove = function(key) {
        var index = getBucketIndex(key);
        var bucket = buckets[index];
        if (bucket === void 0) {
          return null;
        }
        for (var i = 0; i < bucket.length; ++i) {
          if (virtEquals2(bucket[i].key, key)) {
            --count;
            var previous = bucket[i].value;
            bucket[i].removed = true;
            if (bucket.length > 1) {
              bucket.splice(i, 1);
            } else {
              buckets[index] = void 0;
            }
            return previous;
          }
        }
        return null;
      };
      this.removeByValue = function(value) {
        var bucket, i, ilen, pair;
        for (bucket in buckets) {
          if (buckets.hasOwnProperty(bucket)) {
            for (i = 0, ilen = buckets[bucket].length; i < ilen; i++) {
              pair = buckets[bucket][i];
              if (pair.value === value) {
                buckets[bucket].splice(i, 1);
                return true;
              }
            }
          }
        }
        return false;
      };
      this.size = function() {
        return count;
      };
    }
    return HashMap3;
  }
  var HashMap_default = HashMap2;

  // src/Objects/PVector.js
  function PVector2(options, undef) {
    var PConstants3 = options.PConstants;
    function PVector3(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    }
    PVector3.fromAngle = function(angle, v) {
      if (v === undef || v === null) {
        v = new PVector3();
      }
      v.x = Math.cos(angle);
      v.y = Math.sin(angle);
      return v;
    };
    PVector3.random2D = function(v) {
      return PVector3.fromAngle(Math.random() * PConstants3.TWO_PI, v);
    };
    PVector3.random3D = function(v) {
      var angle = Math.random() * PConstants3.TWO_PI;
      var vz = Math.random() * 2 - 1;
      var mult = Math.sqrt(1 - vz * vz);
      var vx = mult * Math.cos(angle);
      var vy = mult * Math.sin(angle);
      if (v === undef || v === null) {
        v = new PVector3(vx, vy, vz);
      } else {
        v.set(vx, vy, vz);
      }
      return v;
    };
    PVector3.dist = function(v1, v2) {
      return v1.dist(v2);
    };
    PVector3.dot = function(v1, v2) {
      return v1.dot(v2);
    };
    PVector3.cross = function(v1, v2) {
      return v1.cross(v2);
    };
    PVector3.sub = function(v1, v2) {
      return new PVector3(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
    };
    PVector3.angleBetween = function(v1, v2) {
      return Math.acos(v1.dot(v2) / Math.sqrt(v1.magSq() * v2.magSq()));
    };
    PVector3.lerp = function(v1, v2, amt) {
      var retval = new PVector3(v1.x, v1.y, v1.z);
      retval.lerp(v2, amt);
      return retval;
    };
    PVector3.prototype = {
      set: function(v, y, z) {
        if (arguments.length === 1) {
          this.set(
            v.x || v[0] || 0,
            v.y || v[1] || 0,
            v.z || v[2] || 0
          );
        } else {
          this.x = v;
          this.y = y;
          this.z = z;
        }
      },
      get: function() {
        return new PVector3(this.x, this.y, this.z);
      },
      mag: function() {
        var x = this.x, y = this.y, z = this.z;
        return Math.sqrt(x * x + y * y + z * z);
      },
      magSq: function() {
        var x = this.x, y = this.y, z = this.z;
        return x * x + y * y + z * z;
      },
      setMag: function(v_or_len, len) {
        if (len === undef) {
          len = v_or_len;
          this.normalize();
          this.mult(len);
        } else {
          var v = v_or_len;
          v.normalize();
          v.mult(len);
          return v;
        }
      },
      add: function(v, y, z) {
        if (arguments.length === 1) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
        } else if (arguments.length === 2) {
          this.x += v;
          this.y += y;
        } else {
          this.x += v;
          this.y += y;
          this.z += z;
        }
      },
      sub: function(v, y, z) {
        if (arguments.length === 1) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
        } else if (arguments.length === 2) {
          this.x -= v;
          this.y -= y;
        } else {
          this.x -= v;
          this.y -= y;
          this.z -= z;
        }
      },
      mult: function(v) {
        if (typeof v === "number") {
          this.x *= v;
          this.y *= v;
          this.z *= v;
        } else {
          this.x *= v.x;
          this.y *= v.y;
          this.z *= v.z;
        }
      },
      div: function(v) {
        if (typeof v === "number") {
          this.x /= v;
          this.y /= v;
          this.z /= v;
        } else {
          this.x /= v.x;
          this.y /= v.y;
          this.z /= v.z;
        }
      },
      rotate: function(angle) {
        var prev_x = this.x;
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.x = c * this.x - s * this.y;
        this.y = s * prev_x + c * this.y;
      },
      dist: function(v) {
        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      },
      dot: function(v, y, z) {
        if (arguments.length === 1) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        }
        return this.x * v + this.y * y + this.z * z;
      },
      cross: function(v) {
        var x = this.x, y = this.y, z = this.z;
        return new PVector3(
          y * v.z - v.y * z,
          z * v.x - v.z * x,
          x * v.y - v.x * y
        );
      },
      lerp: function(v_or_x, amt_or_y, z, amt) {
        var lerp_val = function(start, stop, amt2) {
          return start + (stop - start) * amt2;
        };
        var x, y;
        if (arguments.length === 2) {
          amt = amt_or_y;
          x = v_or_x.x;
          y = v_or_x.y;
          z = v_or_x.z;
        } else {
          x = v_or_x;
          y = amt_or_y;
        }
        this.x = lerp_val(this.x, x, amt);
        this.y = lerp_val(this.y, y, amt);
        this.z = lerp_val(this.z, z, amt);
      },
      normalize: function() {
        var m = this.mag();
        if (m > 0) {
          this.div(m);
        }
      },
      limit: function(high) {
        if (this.mag() > high) {
          this.normalize();
          this.mult(high);
        }
      },
      heading: function() {
        return -Math.atan2(-this.y, this.x);
      },
      heading2D: function() {
        return this.heading();
      },
      toString: function() {
        return "[" + this.x + ", " + this.y + ", " + this.z + "]";
      },
      array: function() {
        return [this.x, this.y, this.z];
      }
    };
    function createPVectorMethod(method2) {
      return function(v1, v2) {
        var v = v1.get();
        v[method2](v2);
        return v;
      };
    }
    for (var method in PVector3.prototype) {
      if (PVector3.prototype.hasOwnProperty(method) && !PVector3.hasOwnProperty(method)) {
        PVector3[method] = createPVectorMethod(method);
      }
    }
    return PVector3;
  }
  var PVector_default = PVector2;

  // src/Objects/PFont.js
  function PFont2(options, undef) {
    var window2 = options.Browser.window, document2 = options.Browser.document, noop = options.noop;
    function computeFontMetrics(pfont) {
      var emQuad = 250, correctionFactor = pfont.size / emQuad, canvas = document2.createElement("canvas");
      canvas.width = 2 * emQuad;
      canvas.height = 2 * emQuad;
      canvas.style.opacity = 0;
      var cfmFont = pfont.getCSSDefinition(emQuad + "px", "normal"), ctx = canvas.getContext("2d");
      ctx.font = cfmFont;
      var protrusions = "dbflkhyjqpg";
      canvas.width = ctx.measureText(protrusions).width;
      ctx.font = cfmFont;
      var leadDiv = document2.createElement("div");
      leadDiv.style.position = "absolute";
      leadDiv.style.opacity = 0;
      leadDiv.style.fontFamily = '"' + pfont.name + '"';
      leadDiv.style.fontSize = emQuad + "px";
      leadDiv.innerHTML = protrusions + "<br/>" + protrusions;
      document2.body.appendChild(leadDiv);
      var w = canvas.width, h = canvas.height, baseline = h / 2;
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = "black";
      ctx.fillText(protrusions, 0, baseline);
      var pixelData = ctx.getImageData(0, 0, w, h).data;
      var i = 0, w4 = w * 4, len = pixelData.length;
      while (++i < len && pixelData[i] === 255) {
        noop();
      }
      var ascent = Math.round(i / w4);
      i = len - 1;
      while (--i > 0 && pixelData[i] === 255) {
        noop();
      }
      var descent = Math.round(i / w4);
      pfont.ascent = correctionFactor * (baseline - ascent);
      pfont.descent = correctionFactor * (descent - baseline);
      if (document2.defaultView.getComputedStyle) {
        var leadDivHeight = document2.defaultView.getComputedStyle(leadDiv, null).getPropertyValue("height");
        leadDivHeight = correctionFactor * leadDivHeight.replace("px", "");
        if (leadDivHeight >= pfont.size * 2) {
          pfont.leading = Math.round(leadDivHeight / 2);
        }
      }
      document2.body.removeChild(leadDiv);
      if (pfont.caching) {
        return ctx;
      }
    }
    function PFont3(name, size) {
      if (name === undef) {
        name = "";
      }
      this.name = name;
      if (size === undef) {
        size = 0;
      }
      this.size = size;
      this.glyph = false;
      this.ascent = 0;
      this.descent = 0;
      this.leading = 1.2 * size;
      var illegalIndicator = name.indexOf(" Italic Bold");
      if (illegalIndicator !== -1) {
        name = name.substring(0, illegalIndicator);
      }
      this.style = "normal";
      var italicsIndicator = name.indexOf(" Italic");
      if (italicsIndicator !== -1) {
        name = name.substring(0, italicsIndicator);
        this.style = "italic";
      }
      this.weight = "normal";
      var boldIndicator = name.indexOf(" Bold");
      if (boldIndicator !== -1) {
        name = name.substring(0, boldIndicator);
        this.weight = "bold";
      }
      this.family = "sans-serif";
      if (name !== undef) {
        switch (name) {
          case "sans-serif":
          case "serif":
          case "monospace":
          case "fantasy":
          case "cursive":
            this.family = name;
            break;
          default:
            this.family = '"' + name + '", sans-serif';
            break;
        }
      }
      this.context2d = computeFontMetrics(this);
      this.css = this.getCSSDefinition();
      if (this.context2d) {
        this.context2d.font = this.css;
      }
    }
    PFont3.prototype.caching = true;
    PFont3.prototype.getCSSDefinition = function(fontSize, lineHeight) {
      if (fontSize === undef) {
        fontSize = this.size + "px";
      }
      if (lineHeight === undef) {
        lineHeight = this.leading + "px";
      }
      var components = [this.style, "normal", this.weight, fontSize + "/" + lineHeight, this.family];
      return components.join(" ");
    };
    PFont3.prototype.measureTextWidth = function(string) {
      return this.context2d.measureText(string).width;
    };
    PFont3.prototype.measureTextWidthFallback = function(string) {
      var canvas = document2.createElement("canvas"), ctx = canvas.getContext("2d");
      ctx.font = this.css;
      return ctx.measureText(string).width;
    };
    PFont3.PFontCache = { length: 0 };
    PFont3.get = function(fontName, fontSize) {
      fontSize = (fontSize * 10 + 0.5 | 0) / 10;
      var cache = PFont3.PFontCache, idx = fontName + "/" + fontSize;
      if (!cache[idx]) {
        cache[idx] = new PFont3(fontName, fontSize);
        cache.length++;
        if (cache.length === 50) {
          PFont3.prototype.measureTextWidth = PFont3.prototype.measureTextWidthFallback;
          PFont3.prototype.caching = false;
          var entry;
          for (entry in cache) {
            if (entry !== "length") {
              cache[entry].context2d = null;
            }
          }
          return new PFont3(fontName, fontSize);
        }
        if (cache.length === 400) {
          PFont3.PFontCache = {};
          PFont3.get = PFont3.getFallback;
          return new PFont3(fontName, fontSize);
        }
      }
      return cache[idx];
    };
    PFont3.getFallback = function(fontName, fontSize) {
      return new PFont3(fontName, fontSize);
    };
    PFont3.list = function() {
      return ["sans-serif", "serif", "monospace", "fantasy", "cursive"];
    };
    PFont3.preloading = {
      // template element used to compare font sizes
      template: {},
      // indicates whether or not the reference tiny font has been loaded
      initialized: false,
      // load the reference tiny font via a css @font-face rule
      initialize: function() {
        var generateTinyFont = function() {
          var encoded = "#E3KAI2wAgT1MvMg7Eo3VmNtYX7ABi3CxnbHlm7Abw3kaGVhZ7ACs3OGhoZWE7A53CRobXR47AY3AGbG9jYQ7G03Bm1heH7ABC3CBuYW1l7Ae3AgcG9zd7AI3AE#B3AQ2kgTY18PPPUACwAg3ALSRoo3#yld0xg32QAB77#E777773B#E3C#I#Q77773E#Q7777777772CMAIw7AB77732B#M#Q3wAB#g3B#E#E2BB//82BB////w#B7#gAEg3E77x2B32B#E#Q#MTcBAQ32gAe#M#QQJ#E32M#QQJ#I#g32Q77#";
          var expand = function(input) {
            return "AAAAAAAA".substr(~~input ? 7 - input : 6);
          };
          return encoded.replace(/[#237]/g, expand);
        };
        var fontface = document2.createElement("style");
        fontface.setAttribute("type", "text/css");
        fontface.innerHTML = `@font-face {
  font-family: "PjsEmptyFont";
  src: url('data:application/x-font-ttf;base64,` + generateTinyFont() + "')\n       format('truetype');\n}";
        document2.head.appendChild(fontface);
        var element = document2.createElement("span");
        element.style.cssText = 'position: absolute; top: -1000; left: 0; opacity: 0; font-family: "PjsEmptyFont", fantasy;';
        element.innerHTML = "AAAAAAAA";
        document2.body.appendChild(element);
        this.template = element;
        this.initialized = true;
      },
      // Shorthand function to get the computed width for an element.
      getElementWidth: function(element) {
        return document2.defaultView.getComputedStyle(element, "").getPropertyValue("width");
      },
      // time taken so far in attempting to load a font
      timeAttempted: 0,
      // returns false if no fonts are pending load, or true otherwise.
      pending: function(intervallength) {
        if (!this.initialized) {
          this.initialize();
        }
        var element, computedWidthFont, computedWidthRef = this.getElementWidth(this.template);
        for (var i = 0; i < this.fontList.length; i++) {
          element = this.fontList[i];
          computedWidthFont = this.getElementWidth(element);
          if (this.timeAttempted < 4e3 && computedWidthFont === computedWidthRef) {
            this.timeAttempted += intervallength;
            return true;
          } else {
            document2.body.removeChild(element);
            this.fontList.splice(i--, 1);
            this.timeAttempted = 0;
          }
        }
        if (this.fontList.length === 0) {
          return false;
        }
        return true;
      },
      // fontList contains elements to compare font sizes against a template
      fontList: [],
      // addedList contains the fontnames of all the fonts loaded via @font-face
      addedList: {},
      // adds a font to the font cache
      // creates an element using the font, to start loading the font,
      // and compare against a default font to see if the custom font is loaded
      add: function(fontSrc) {
        if (!this.initialized) {
          this.initialize();
        }
        var fontName = typeof fontSrc === "object" ? fontSrc.fontFace : fontSrc, fontUrl = typeof fontSrc === "object" ? fontSrc.url : fontSrc;
        if (this.addedList[fontName]) {
          return;
        }
        var style = document2.createElement("style");
        style.setAttribute("type", "text/css");
        style.innerHTML = "@font-face{\n  font-family: '" + fontName + "';\n  src:  url('" + fontUrl + "');\n}\n";
        document2.head.appendChild(style);
        this.addedList[fontName] = true;
        var element = document2.createElement("span");
        element.style.cssText = "position: absolute; top: 0; left: 0; opacity: 0;";
        element.style.fontFamily = '"' + fontName + '", "PjsEmptyFont", fantasy';
        element.innerHTML = "AAAAAAAA";
        document2.body.appendChild(element);
        this.fontList.push(element);
      }
    };
    return PFont3;
  }
  var PFont_default = PFont2;

  // src/Objects/Char.js
  function buildChar(charMap, undef) {
    var Char2 = function(chr) {
      if (typeof chr === "string" && chr.length === 1) {
        this.code = chr.charCodeAt(0);
      } else if (typeof chr === "number") {
        this.code = chr;
      } else if (chr instanceof Char2) {
        this.code = chr;
      } else {
        this.code = NaN;
      }
      return charMap[this.code] === undef ? charMap[this.code] = this : charMap[this.code];
    };
    Char2.prototype.toString = function() {
      return String.fromCharCode(this.code);
    };
    Char2.prototype.valueOf = function() {
      return this.code;
    };
    return Char2;
  }
  var Char = buildChar({}, void 0);
  var Char_default = Char;

  // src/Objects/XMLAttribute.js
  function XMLAttribute_default() {
    var XMLAttribute = function(fname, n, nameSpace, v, t2) {
      this.fullName = fname || "";
      this.name = n || "";
      this.namespace = nameSpace || "";
      this.value = v;
      this.type = t2;
    };
    XMLAttribute.prototype = {
      /**
       * @member XMLAttribute
       * The getName() function returns the short name of the attribute
       *
       * @return {String} the short name of the attribute
       */
      getName: function() {
        return this.name;
      },
      /**
       * @member XMLAttribute
       * The getFullName() function returns the full name of the attribute
       *
       * @return {String} the full name of the attribute
       */
      getFullName: function() {
        return this.fullName;
      },
      /**
       * @member XMLAttribute
       * The getNamespace() function returns the namespace of the attribute
       *
       * @return {String} the namespace of the attribute
       */
      getNamespace: function() {
        return this.namespace;
      },
      /**
       * @member XMLAttribute
       * The getValue() function returns the value of the attribute
       *
       * @return {String} the value of the attribute
       */
      getValue: function() {
        return this.value;
      },
      /**
       * @member XMLAttribute
       * The getValue() function returns the type of the attribute
       *
       * @return {String} the type of the attribute
       */
      getType: function() {
        return this.type;
      },
      /**
       * @member XMLAttribute
       * The setValue() function sets the value of the attribute
       *
       * @param {String} newval the new value
       */
      setValue: function(newval) {
        this.value = newval;
      }
    };
    return XMLAttribute;
  }

  // src/Objects/XMLElement.js
  function XMLElement_default(options, undef) {
    var Browser2 = options.Browser, ajax = Browser2.ajax, window2 = Browser2.window, XMLHttpRequest2 = window2.XMLHttpRequest, DOMParser = window2.DOMParser, XMLAttribute = options.XMLAttribute;
    var XMLElement = function(selector, uri, sysid, line) {
      this.attributes = [];
      this.children = [];
      this.fullName = null;
      this.name = null;
      this.namespace = "";
      this.content = null;
      this.parent = null;
      this.lineNr = "";
      this.systemID = "";
      this.type = "ELEMENT";
      if (selector) {
        if (typeof selector === "string") {
          if (uri === undef && selector.indexOf("<") > -1) {
            this.parse(selector);
          } else {
            this.fullName = selector;
            this.namespace = uri;
            this.systemId = sysid;
            this.lineNr = line;
          }
        } else {
          this.parse(uri, true);
        }
      }
    };
    XMLElement.prototype = {
      /**
       * @member XMLElement
       * The parse() function retrieves the file via ajax() and uses DOMParser()
       * parseFromString method to make an XML document
       * @addon
       *
       * @param {String} filename name of the XML/SVG file to load
       *
       * @throws ExceptionType Error loading document
       *
       * @see XMLElement#parseChildrenRecursive
       */
      parse: function(textstring, stringIsURI) {
        var xmlDoc;
        try {
          if (stringIsURI) {
            textstring = ajax(textstring);
          }
          xmlDoc = new DOMParser().parseFromString(textstring, "text/xml");
          var elements = xmlDoc.documentElement;
          if (elements) {
            this.parseChildrenRecursive(null, elements);
          } else {
            throw "Error loading document";
          }
          return this;
        } catch (e) {
          throw e;
        }
      },
      /**
       * @member XMLElement
       * Internal helper function for parse().
       * Loops through the
       * @addon
       *
       * @param {XMLElement} parent                      the parent node
       * @param {XML document childNodes} elementpath    the remaining nodes that need parsing
       *
       * @return {XMLElement} the new element and its children elements
       */
      parseChildrenRecursive: function(parent, elementpath) {
        var xmlelement, xmlattribute, tmpattrib, l2, m, child;
        if (!parent) {
          this.fullName = elementpath.localName;
          this.name = elementpath.nodeName;
          xmlelement = this;
        } else {
          xmlelement = new XMLElement(elementpath.nodeName);
          xmlelement.parent = parent;
        }
        if (elementpath.nodeType === 3 && elementpath.textContent !== "") {
          return this.createPCDataElement(elementpath.textContent);
        }
        if (elementpath.nodeType === 4) {
          return this.createCDataElement(elementpath.textContent);
        }
        if (elementpath.attributes) {
          for (l2 = 0, m = elementpath.attributes.length; l2 < m; l2++) {
            tmpattrib = elementpath.attributes[l2];
            xmlattribute = new XMLAttribute(
              tmpattrib.getname,
              tmpattrib.nodeName,
              tmpattrib.namespaceURI,
              tmpattrib.nodeValue,
              tmpattrib.nodeType
            );
            xmlelement.attributes.push(xmlattribute);
          }
        }
        if (elementpath.childNodes) {
          for (l2 = 0, m = elementpath.childNodes.length; l2 < m; l2++) {
            var node = elementpath.childNodes[l2];
            child = xmlelement.parseChildrenRecursive(xmlelement, node);
            if (child !== null) {
              xmlelement.children.push(child);
            }
          }
        }
        return xmlelement;
      },
      /**
       * @member XMLElement
       * The createElement() function Creates an empty element
       *
       * @param {String} fullName   the full name of the element
       * @param {String} namespace  the namespace URI
       * @param {String} systemID   the system ID of the XML data where the element starts
       * @param {int} lineNr    the line in the XML data where the element starts
       */
      createElement: function(fullname, namespaceuri, sysid, line) {
        if (sysid === undef) {
          return new XMLElement(fullname, namespaceuri);
        }
        return new XMLElement(fullname, namespaceuri, sysid, line);
      },
      /**
       * @member XMLElement
       * The createPCDataElement() function creates an element to be used for #PCDATA content.
       * Because Processing discards whitespace TEXT nodes, this method will not build an element
       * if the passed content is empty after trimming for whitespace.
       *
       * @return {XMLElement} new "pcdata" XMLElement, or null if content consists only of whitespace
       */
      createPCDataElement: function(content, isCDATA) {
        if (content.replace(/^\s+$/g, "") === "") {
          return null;
        }
        var pcdata = new XMLElement();
        pcdata.type = "TEXT";
        pcdata.content = content;
        return pcdata;
      },
      /**
       * @member XMLElement
       * The createCDataElement() function creates an element to be used for CDATA content.
       *
       * @return {XMLElement} new "cdata" XMLElement, or null if content consists only of whitespace
       */
      createCDataElement: function(content) {
        var cdata = this.createPCDataElement(content);
        if (cdata === null) {
          return null;
        }
        cdata.type = "CDATA";
        var htmlentities = { "<": "&lt;", ">": "&gt;", "'": "&apos;", '"': "&quot;" }, entity;
        for (entity in htmlentities) {
          if (!Object.hasOwnProperty(htmlentities, entity)) {
            content = content.replace(new RegExp(entity, "g"), htmlentities[entity]);
          }
        }
        cdata.cdata = content;
        return cdata;
      },
      /**
       * @member XMLElement
       * The hasAttribute() function returns whether an attribute exists
       *
       * @param {String} name      name of the attribute
       * @param {String} namespace the namespace URI of the attribute
       *
       * @return {boolean} true if the attribute exists
       */
      hasAttribute: function() {
        if (arguments.length === 1) {
          return this.getAttribute(arguments[0]) !== null;
        }
        if (arguments.length === 2) {
          return this.getAttribute(arguments[0], arguments[1]) !== null;
        }
      },
      /**
       * @member XMLElement
       * The equals() function checks to see if the XMLElement being passed in equals another XMLElement
       *
       * @param {XMLElement} rawElement the element to compare to
       *
       * @return {boolean} true if the element equals another element
       */
      equals: function(other) {
        if (!(other instanceof XMLElement)) {
          return false;
        }
        var i, j;
        if (this.fullName !== other.fullName) {
          return false;
        }
        if (this.attributes.length !== other.getAttributeCount()) {
          return false;
        }
        if (this.attributes.length !== other.attributes.length) {
          return false;
        }
        var attr_name, attr_ns, attr_value, attr_type, attr_other;
        for (i = 0, j = this.attributes.length; i < j; i++) {
          attr_name = this.attributes[i].getName();
          attr_ns = this.attributes[i].getNamespace();
          attr_other = other.findAttribute(attr_name, attr_ns);
          if (attr_other === null) {
            return false;
          }
          if (this.attributes[i].getValue() !== attr_other.getValue()) {
            return false;
          }
          if (this.attributes[i].getType() !== attr_other.getType()) {
            return false;
          }
        }
        if (this.children.length !== other.getChildCount()) {
          return false;
        }
        if (this.children.length > 0) {
          var child1, child2;
          for (i = 0, j = this.children.length; i < j; i++) {
            child1 = this.getChild(i);
            child2 = other.getChild(i);
            if (!child1.equals(child2)) {
              return false;
            }
          }
          return true;
        }
        return this.content === other.content;
      },
      /**
       * @member XMLElement
       * The getContent() function returns the content of an element. If there is no such content, null is returned
       *
       * @return {String} the (possibly null) content
       */
      getContent: function() {
        if (this.type === "TEXT" || this.type === "CDATA") {
          return this.content;
        }
        var children = this.children;
        if (children.length === 1 && (children[0].type === "TEXT" || children[0].type === "CDATA")) {
          return children[0].content;
        }
        return null;
      },
      /**
       * @member XMLElement
       * The getAttribute() function returns the value of an attribute
       *
       * @param {String} name         the non-null full name of the attribute
       * @param {String} namespace    the namespace URI, which may be null
       * @param {String} defaultValue the default value of the attribute
       *
       * @return {String} the value, or defaultValue if the attribute does not exist
       */
      getAttribute: function() {
        var attribute;
        if (arguments.length === 2) {
          attribute = this.findAttribute(arguments[0]);
          if (attribute) {
            return attribute.getValue();
          }
          return arguments[1];
        } else if (arguments.length === 1) {
          attribute = this.findAttribute(arguments[0]);
          if (attribute) {
            return attribute.getValue();
          }
          return null;
        } else if (arguments.length === 3) {
          attribute = this.findAttribute(arguments[0], arguments[1]);
          if (attribute) {
            return attribute.getValue();
          }
          return arguments[2];
        }
      },
      /**
       * @member XMLElement
       * The getStringAttribute() function returns the string attribute of the element
       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.
       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.
       *
       * @param name         the name of the attribute
       * @param defaultValue value returned if the attribute is not found
       *
       * @return {String} the value, or defaultValue if the attribute does not exist
       */
      getStringAttribute: function() {
        if (arguments.length === 1) {
          return this.getAttribute(arguments[0]);
        }
        if (arguments.length === 2) {
          return this.getAttribute(arguments[0], arguments[1]);
        }
        return this.getAttribute(arguments[0], arguments[1], arguments[2]);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic String
       * attribute getter. This may only take one argument.
       */
      getString: function(attributeName) {
        return this.getStringAttribute(attributeName);
      },
      /**
       * @member XMLElement
       * The getFloatAttribute() function returns the float attribute of the element.
       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.
       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.
       *
       * @param name         the name of the attribute
       * @param defaultValue value returned if the attribute is not found
       *
       * @return {float} the value, or defaultValue if the attribute does not exist
       */
      getFloatAttribute: function() {
        if (arguments.length === 1) {
          return parseFloat(this.getAttribute(arguments[0], 0));
        }
        if (arguments.length === 2) {
          return this.getAttribute(arguments[0], arguments[1]);
        }
        return this.getAttribute(arguments[0], arguments[1], arguments[2]);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic float
       * attribute getter. This may only take one argument.
       */
      getFloat: function(attributeName) {
        return this.getFloatAttribute(attributeName);
      },
      /**
       * @member XMLElement
       * The getIntAttribute() function returns the integer attribute of the element.
       * If the <b>defaultValue</b> parameter is used and the attribute doesn't exist, the <b>defaultValue</b> value is returned.
       * When calling the function without the <b>defaultValue</b> parameter, if the attribute doesn't exist, the value 0 is returned.
       *
       * @param name         the name of the attribute
       * @param defaultValue value returned if the attribute is not found
       *
       * @return {int} the value, or defaultValue if the attribute does not exist
       */
      getIntAttribute: function() {
        if (arguments.length === 1) {
          return this.getAttribute(arguments[0], 0);
        }
        if (arguments.length === 2) {
          return this.getAttribute(arguments[0], arguments[1]);
        }
        return this.getAttribute(arguments[0], arguments[1], arguments[2]);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic int
       * attribute getter. This may only take one argument.
       */
      getInt: function(attributeName) {
        return this.getIntAttribute(attributeName);
      },
      /**
       * @member XMLElement
       * The hasChildren() function returns whether the element has children.
       *
       * @return {boolean} true if the element has children.
       */
      hasChildren: function() {
        return this.children.length > 0;
      },
      /**
       * @member XMLElement
       * The addChild() function adds a child element
       *
       * @param {XMLElement} child the non-null child to add.
       */
      addChild: function(child) {
        if (child !== null) {
          child.parent = this;
          this.children.push(child);
        }
      },
      /**
       * @member XMLElement
       * The insertChild() function inserts a child element at the index provided
       *
       * @param {XMLElement} child  the non-null child to add.
       * @param {int} index     where to put the child.
       */
      insertChild: function(child, index) {
        if (child) {
          if (child.getLocalName() === null && !this.hasChildren()) {
            var lastChild = this.children[this.children.length - 1];
            if (lastChild.getLocalName() === null) {
              lastChild.setContent(lastChild.getContent() + child.getContent());
              return;
            }
          }
          child.parent = this;
          this.children.splice(index, 0, child);
        }
      },
      /**
       * @member XMLElement
       * The getChild() returns the child XMLElement as specified by the <b>index</b> parameter.
       * The value of the <b>index</b> parameter must be less than the total number of children to avoid going out of the array storing the child elements.
       * When the <b>path</b> parameter is specified, then it will return all children that match that path. The path is a series of elements and sub-elements, separated by slashes.
       *
       * @param {int} index     where to put the child.
       * @param {String} path       path to a particular element
       *
       * @return {XMLElement} the element
       */
      getChild: function(selector) {
        if (typeof selector === "number") {
          return this.children[selector];
        }
        if (selector.indexOf("/") !== -1) {
          return this.getChildRecursive(selector.split("/"), 0);
        }
        var kid, kidName;
        for (var i = 0, j = this.getChildCount(); i < j; i++) {
          kid = this.getChild(i);
          kidName = kid.getName();
          if (kidName !== null && kidName === selector) {
            return kid;
          }
        }
        return null;
      },
      /**
       * @member XMLElement
       * The getChildren() returns all of the children as an XMLElement array.
       * When the <b>path</b> parameter is specified, then it will return all children that match that path.
       * The path is a series of elements and sub-elements, separated by slashes.
       *
       * @param {String} path       element name or path/to/element
       *
       * @return {XMLElement} array of child elements that match
       *
       * @see XMLElement#getChildCount()
       * @see XMLElement#getChild()
       */
      getChildren: function() {
        if (arguments.length === 1) {
          if (typeof arguments[0] === "number") {
            return this.getChild(arguments[0]);
          }
          if (arguments[0].indexOf("/") !== -1) {
            return this.getChildrenRecursive(arguments[0].split("/"), 0);
          }
          var matches = [];
          var kid, kidName;
          for (var i = 0, j = this.getChildCount(); i < j; i++) {
            kid = this.getChild(i);
            kidName = kid.getName();
            if (kidName !== null && kidName === arguments[0]) {
              matches.push(kid);
            }
          }
          return matches;
        }
        return this.children;
      },
      /**
       * @member XMLElement
       * The getChildCount() returns the number of children for the element.
       *
       * @return {int} the count
       *
       * @see XMLElement#getChild()
       * @see XMLElement#getChildren()
       */
      getChildCount: function() {
        return this.children.length;
      },
      /**
       * @member XMLElement
       * Internal helper function for getChild().
       *
       * @param {String[]} items   result of splitting the query on slashes
       * @param {int} offset   where in the items[] array we're currently looking
       *
       * @return {XMLElement} matching element or null if no match
       */
      getChildRecursive: function(items, offset) {
        if (offset === items.length) {
          return this;
        }
        var kid, kidName, matchName = items[offset];
        for (var i = 0, j = this.getChildCount(); i < j; i++) {
          kid = this.getChild(i);
          kidName = kid.getName();
          if (kidName !== null && kidName === matchName) {
            return kid.getChildRecursive(items, offset + 1);
          }
        }
        return null;
      },
      /**
       * @member XMLElement
       * Internal helper function for getChildren().
       *
       * @param {String[]} items   result of splitting the query on slashes
       * @param {int} offset   where in the items[] array we're currently looking
       *
       * @return {XMLElement[]} matching elements or empty array if no match
       */
      getChildrenRecursive: function(items, offset) {
        if (offset === items.length - 1) {
          return this.getChildren(items[offset]);
        }
        var matches = this.getChildren(items[offset]);
        var kidMatches = [];
        for (var i = 0; i < matches.length; i++) {
          kidMatches = kidMatches.concat(matches[i].getChildrenRecursive(items, offset + 1));
        }
        return kidMatches;
      },
      /**
       * @member XMLElement
       * The isLeaf() function returns whether the element is a leaf element.
       *
       * @return {boolean} true if the element has no children.
       */
      isLeaf: function() {
        return !this.hasChildren();
      },
      /**
       * @member XMLElement
       * The listChildren() function put the names of all children into an array. Same as looping through
       * each child and calling getName() on each XMLElement.
       *
       * @return {String[]} a list of element names.
       */
      listChildren: function() {
        var arr = [];
        for (var i = 0, j = this.children.length; i < j; i++) {
          arr.push(this.getChild(i).getName());
        }
        return arr;
      },
      /**
       * @member XMLElement
       * The removeAttribute() function removes an attribute
       *
       * @param {String} name        the non-null name of the attribute.
       * @param {String} namespace   the namespace URI of the attribute, which may be null.
       */
      removeAttribute: function(name, namespace) {
        this.namespace = namespace || "";
        for (var i = 0, j = this.attributes.length; i < j; i++) {
          if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {
            this.attributes.splice(i, 1);
            break;
          }
        }
      },
      /**
       * @member XMLElement
       * The removeChild() removes a child element.
       *
       * @param {XMLElement} child      the the non-null child to be renoved
       */
      removeChild: function(child) {
        if (child) {
          for (var i = 0, j = this.children.length; i < j; i++) {
            if (this.children[i].equals(child)) {
              this.children.splice(i, 1);
              break;
            }
          }
        }
      },
      /**
       * @member XMLElement
       * The removeChildAtIndex() removes the child located at a certain index
       *
       * @param {int} index      the index of the child, where the first child has index 0
       */
      removeChildAtIndex: function(index) {
        if (this.children.length > index) {
          this.children.splice(index, 1);
        }
      },
      /**
       * @member XMLElement
       * The findAttribute() function searches an attribute
       *
       * @param {String} name        fullName the non-null full name of the attribute
       * @param {String} namespace   the name space, which may be null
       *
       * @return {XMLAttribute} the attribute, or null if the attribute does not exist.
       */
      findAttribute: function(name, namespace) {
        this.namespace = namespace || "";
        for (var i = 0, j = this.attributes.length; i < j; i++) {
          if (this.attributes[i].getName() === name && this.attributes[i].getNamespace() === this.namespace) {
            return this.attributes[i];
          }
        }
        return null;
      },
      /**
       * @member XMLElement
       * The setAttribute() function sets an attribute.
       *
       * @param {String} name        the non-null full name of the attribute
       * @param {String} namespace   the non-null value of the attribute
       */
      setAttribute: function() {
        var attr;
        if (arguments.length === 3) {
          var index = arguments[0].indexOf(":");
          var name = arguments[0].substring(index + 1);
          attr = this.findAttribute(name, arguments[1]);
          if (attr) {
            attr.setValue(arguments[2]);
          } else {
            attr = new XMLAttribute(arguments[0], name, arguments[1], arguments[2], "CDATA");
            this.attributes.push(attr);
          }
        } else {
          attr = this.findAttribute(arguments[0]);
          if (attr) {
            attr.setValue(arguments[1]);
          } else {
            attr = new XMLAttribute(arguments[0], arguments[0], null, arguments[1], "CDATA");
            this.attributes.push(attr);
          }
        }
      },
      /**
       * Processing 1.5 XML API wrapper for the generic String
       * attribute setter. This must take two arguments.
       */
      setString: function(attribute, value) {
        this.setAttribute(attribute, value);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic int
       * attribute setter. This must take two arguments.
       */
      setInt: function(attribute, value) {
        this.setAttribute(attribute, value);
      },
      /**
       * Processing 1.5 XML API wrapper for the generic float
       * attribute setter. This must take two arguments.
       */
      setFloat: function(attribute, value) {
        this.setAttribute(attribute, value);
      },
      /**
       * @member XMLElement
       * The setContent() function sets the #PCDATA content. It is an error to call this method with a
       * non-null value if there are child objects.
       *
       * @param {String} content     the (possibly null) content
       */
      setContent: function(content) {
        if (this.children.length > 0) {
          Processing.debug("Tried to set content for XMLElement with children");
        }
        this.content = content;
      },
      /**
       * @member XMLElement
       * The setName() function sets the full name. This method also sets the short name and clears the
       * namespace URI.
       *
       * @param {String} name        the non-null name
       * @param {String} namespace   the namespace URI, which may be null.
       */
      setName: function() {
        if (arguments.length === 1) {
          this.name = arguments[0];
          this.fullName = arguments[0];
          this.namespace = null;
        } else {
          var index = arguments[0].indexOf(":");
          if (arguments[1] === null || index < 0) {
            this.name = arguments[0];
          } else {
            this.name = arguments[0].substring(index + 1);
          }
          this.fullName = arguments[0];
          this.namespace = arguments[1];
        }
      },
      /**
       * @member XMLElement
       * The getName() function returns the full name (i.e. the name including an eventual namespace
       * prefix) of the element.
       *
       * @return {String} the name, or null if the element only contains #PCDATA.
       */
      getName: function() {
        return this.fullName;
      },
      /**
       * @member XMLElement
       * The getLocalName() function returns the local name (i.e. the name excluding an eventual namespace
       * prefix) of the element.
       *
       * @return {String} the name, or null if the element only contains #PCDATA.
       */
      getLocalName: function() {
        return this.name;
      },
      /**
       * @member XMLElement
       * The getAttributeCount() function returns the number of attributes for the node
       * that this XMLElement represents.
       *
       * @return {int} the number of attributes in this XMLElement
       */
      getAttributeCount: function() {
        return this.attributes.length;
      },
      /**
       * @member XMLElement
       * The toString() function returns the XML definition of an XMLElement.
       *
       * @return {String} the XML definition of this XMLElement
       */
      toString: function() {
        if (this.type === "TEXT") {
          return this.content || "";
        }
        if (this.type === "CDATA") {
          return this.cdata || "";
        }
        var tagstring = this.fullName;
        var xmlstring = "<" + tagstring;
        var a, c;
        for (a = 0; a < this.attributes.length; a++) {
          var attr = this.attributes[a];
          xmlstring += " " + attr.getName() + '="' + attr.getValue() + '"';
        }
        if (this.children.length === 0) {
          if (this.content === "" || this.content === null || this.content === void 0) {
            xmlstring += "/>";
          } else {
            xmlstring += ">" + this.content + "</" + tagstring + ">";
          }
        } else {
          xmlstring += ">";
          for (c = 0; c < this.children.length; c++) {
            xmlstring += this.children[c].toString();
          }
          xmlstring += "</" + tagstring + ">";
        }
        return xmlstring;
      }
    };
    XMLElement.parse = function(xmlstring) {
      var element = new XMLElement();
      element.parse(xmlstring);
      return element;
    };
    return XMLElement;
  }

  // src/Objects/PMatrix2D.js
  function PMatrix2D(options, undef) {
    var p = options.p;
    var PMatrix2D2 = function() {
      if (arguments.length === 0) {
        this.reset();
      } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
        this.set(arguments[0].array());
      } else if (arguments.length === 6) {
        this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
      }
    };
    PMatrix2D2.prototype = {
      /**
       * @member PMatrix2D
       * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.
       *
       * @param {PMatrix2D} matrix    the matrix to set this matrix to
       * @param {float[]} elements    an array of elements to set this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the third element of the matrix
       * @param {float} m10           the fourth element of the matrix
       * @param {float} m11           the fith element of the matrix
       * @param {float} m12           the sixth element of the matrix
       */
      set: function() {
        if (arguments.length === 6) {
          var a = arguments;
          this.set([
            a[0],
            a[1],
            a[2],
            a[3],
            a[4],
            a[5]
          ]);
        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
          this.elements = arguments[0].array();
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          this.elements = arguments[0].slice();
        }
      },
      /**
       * @member PMatrix2D
       * The get() function returns a copy of this PMatrix2D.
       *
       * @return {PMatrix2D} a copy of this PMatrix2D
       */
      get: function() {
        var outgoing = new PMatrix2D2();
        outgoing.set(this.elements);
        return outgoing;
      },
      /**
       * @member PMatrix2D
       * The reset() function sets this PMatrix2D to the identity matrix.
       */
      reset: function() {
        this.set([1, 0, 0, 0, 1, 0]);
      },
      /**
       * @member PMatrix2D
       * The array() function returns a copy of the element values.
       * @addon
       *
       * @return {float[]} returns a copy of the element values
       */
      array: function array() {
        return this.elements.slice();
      },
      /**
       * @member PMatrix2D
       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.
       *
       * @param {float} tx  the x-axis coordinate to move to
       * @param {float} ty  the y-axis coordinate to move to
       */
      translate: function(tx, ty) {
        this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];
        this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];
      },
      /**
       * @member PMatrix2D
       * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.
       *
       * @param {float} tx  the x-axis coordinate to move to
       * @param {float} ty  the y-axis coordinate to move to
       */
      invTranslate: function(tx, ty) {
        this.translate(-tx, -ty);
      },
      /**
      * @member PMatrix2D
      * The transpose() function is not used in processingjs.
      */
      transpose: function() {
      },
      /**
       * @member PMatrix2D
       * The mult() function multiplied this matrix.
       * If two array elements are passed in the function will multiply a two element vector against this matrix.
       * If target is null or not length four, a new float array will be returned.
       * The values for vec and target can be the same (though that's less efficient).
       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.
       *
       * @param {PVector} source, target  the PVectors used to multiply this matrix
       * @param {float[]} source, target  the arrays used to multiply this matrix
       *
       * @return {PVector|float[]} returns a PVector or an array representing the new matrix
       */
      mult: function(source2, target) {
        var x, y;
        if (source2 instanceof PVector) {
          x = source2.x;
          y = source2.y;
          if (!target) {
            target = new PVector();
          }
        } else if (source2 instanceof Array) {
          x = source2[0];
          y = source2[1];
          if (!target) {
            target = [];
          }
        }
        if (target instanceof Array) {
          target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];
          target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];
        } else if (target instanceof PVector) {
          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];
          target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];
          target.z = 0;
        }
        return target;
      },
      /**
       * @member PMatrix2D
       * The multX() function calculates the x component of a vector from a transformation.
       *
       * @param {float} x the x component of the vector being transformed
       * @param {float} y the y component of the vector being transformed
       *
       * @return {float} returnes the result of the calculation
       */
      multX: function(x, y) {
        return x * this.elements[0] + y * this.elements[1] + this.elements[2];
      },
      /**
       * @member PMatrix2D
       * The multY() function calculates the y component of a vector from a transformation.
       *
       * @param {float} x the x component of the vector being transformed
       * @param {float} y the y component of the vector being transformed
       *
       * @return {float} returnes the result of the calculation
       */
      multY: function(x, y) {
        return x * this.elements[3] + y * this.elements[4] + this.elements[5];
      },
      /**
       * @member PMatrix2D
       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      skewX: function(angle) {
        this.apply(1, 0, 1, angle, 0, 0);
      },
      /**
       * @member PMatrix2D
       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      skewY: function(angle) {
        this.apply(1, 0, 1, 0, angle, 0);
      },
      /**
       * @member PMatrix2D
       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      shearX: function(angle) {
        this.apply(1, 0, 1, Math.tan(angle), 0, 0);
      },
      /**
       * @member PMatrix2D
       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      shearY: function(angle) {
        this.apply(1, 0, 1, 0, Math.tan(angle), 0);
      },
      /**
       * @member PMatrix2D
       * The determinant() function calvculates the determinant of this matrix.
       *
       * @return {float} the determinant of the matrix
       */
      determinant: function() {
        return this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3];
      },
      /**
       * @member PMatrix2D
       * The invert() function inverts this matrix
       *
       * @return {boolean} true if successful
       */
      invert: function() {
        var d = this.determinant();
        if (Math.abs(d) > PConstants.MIN_INT) {
          var old00 = this.elements[0];
          var old01 = this.elements[1];
          var old02 = this.elements[2];
          var old10 = this.elements[3];
          var old11 = this.elements[4];
          var old12 = this.elements[5];
          this.elements[0] = old11 / d;
          this.elements[3] = -old10 / d;
          this.elements[1] = -old01 / d;
          this.elements[4] = old00 / d;
          this.elements[2] = (old01 * old12 - old11 * old02) / d;
          this.elements[5] = (old10 * old02 - old00 * old12) / d;
          return true;
        }
        return false;
      },
      /**
       * @member PMatrix2D
       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.
       * This is equivalent to a two parameter call.
       *
       * @param {float} sx  the amount to scale on the x-axis
       * @param {float} sy  the amount to scale on the y-axis
       */
      scale: function(sx, sy) {
        if (sx && sy === undef) {
          sy = sx;
        }
        if (sx && sy) {
          this.elements[0] *= sx;
          this.elements[1] *= sy;
          this.elements[3] *= sx;
          this.elements[4] *= sy;
        }
      },
      /**
       * @member PMatrix2D
       * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.
       * This is equivalent to a two parameter call.
       *
       * @param {float} sx  the amount to scale on the x-axis
       * @param {float} sy  the amount to scale on the y-axis
       */
      invScale: function(sx, sy) {
        if (sx && !sy) {
          sy = sx;
        }
        this.scale(1 / sx, 1 / sy);
      },
      /**
       * @member PMatrix2D
       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.
       *
       * @param {PMatrix2D} matrix    the matrix to apply this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the third element of the matrix
       * @param {float} m10           the fourth element of the matrix
       * @param {float} m11           the fith element of the matrix
       * @param {float} m12           the sixth element of the matrix
       */
      apply: function() {
        var source2;
        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
          source2 = arguments[0].array();
        } else if (arguments.length === 6) {
          source2 = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          source2 = arguments[0];
        }
        var result = [
          0,
          0,
          this.elements[2],
          0,
          0,
          this.elements[5]
        ];
        var e = 0;
        for (var row = 0; row < 2; row++) {
          for (var col = 0; col < 3; col++, e++) {
            result[e] += this.elements[row * 3 + 0] * source2[col + 0] + this.elements[row * 3 + 1] * source2[col + 3];
          }
        }
        this.elements = result.slice();
      },
      /**
       * @member PMatrix2D
       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.
       *
       * @param {PMatrix2D} matrix    the matrix to apply this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the third element of the matrix
       * @param {float} m10           the fourth element of the matrix
       * @param {float} m11           the fith element of the matrix
       * @param {float} m12           the sixth element of the matrix
       */
      preApply: function() {
        var source2;
        if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
          source2 = arguments[0].array();
        } else if (arguments.length === 6) {
          source2 = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          source2 = arguments[0];
        }
        var result = [
          0,
          0,
          source2[2],
          0,
          0,
          source2[5]
        ];
        result[2] = source2[2] + this.elements[2] * source2[0] + this.elements[5] * source2[1];
        result[5] = source2[5] + this.elements[2] * source2[3] + this.elements[5] * source2[4];
        result[0] = this.elements[0] * source2[0] + this.elements[3] * source2[1];
        result[3] = this.elements[0] * source2[3] + this.elements[3] * source2[4];
        result[1] = this.elements[1] * source2[0] + this.elements[4] * source2[1];
        result[4] = this.elements[1] * source2[3] + this.elements[4] * source2[4];
        this.elements = result.slice();
      },
      /**
       * @member PMatrix2D
       * The rotate() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotate: function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var temp1 = this.elements[0];
        var temp2 = this.elements[1];
        this.elements[0] = c * temp1 + s * temp2;
        this.elements[1] = -s * temp1 + c * temp2;
        temp1 = this.elements[3];
        temp2 = this.elements[4];
        this.elements[3] = c * temp1 + s * temp2;
        this.elements[4] = -s * temp1 + c * temp2;
      },
      /**
       * @member PMatrix2D
       * The rotateZ() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotateZ: function(angle) {
        this.rotate(angle);
      },
      /**
       * @member PMatrix2D
       * The invRotateZ() function rotates the matrix in opposite direction.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      invRotateZ: function(angle) {
        this.rotateZ(angle - Math.PI);
      },
      /**
       * @member PMatrix2D
       * The print() function prints out the elements of this matrix
       */
      print: function() {
        var digits = printMatrixHelper(this.elements);
        var output = "" + p.nfs(this.elements[0], digits, 4) + " " + p.nfs(this.elements[1], digits, 4) + " " + p.nfs(this.elements[2], digits, 4) + "\n" + p.nfs(this.elements[3], digits, 4) + " " + p.nfs(this.elements[4], digits, 4) + " " + p.nfs(this.elements[5], digits, 4) + "\n\n";
        p.println(output);
      }
    };
    return PMatrix2D2;
  }
  var PMatrix2D_default = PMatrix2D;

  // src/Objects/PMatrix3D.js
  function PMatrix3D(options, undef) {
    var p = options.p;
    var PMatrix3D2 = function() {
      this.reset();
    };
    PMatrix3D2.prototype = {
      /**
       * @member PMatrix2D
       * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.
       *
       * @param {PMatrix3D} matrix    the initial matrix to set to
       * @param {float[]} elements    an array of elements to set this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the second element of the matrix
       * @param {float} m02           the third element of the matrix
       * @param {float} m03           the fourth element of the matrix
       * @param {float} m10           the fifth element of the matrix
       * @param {float} m11           the sixth element of the matrix
       * @param {float} m12           the seventh element of the matrix
       * @param {float} m13           the eight element of the matrix
       * @param {float} m20           the nineth element of the matrix
       * @param {float} m21           the tenth element of the matrix
       * @param {float} m22           the eleventh element of the matrix
       * @param {float} m23           the twelveth element of the matrix
       * @param {float} m30           the thirteenth element of the matrix
       * @param {float} m31           the fourtheenth element of the matrix
       * @param {float} m32           the fivetheenth element of the matrix
       * @param {float} m33           the sixteenth element of the matrix
       */
      set: function() {
        if (arguments.length === 16) {
          this.elements = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
          this.elements = arguments[0].array();
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          this.elements = arguments[0].slice();
        }
      },
      /**
       * @member PMatrix3D
       * The get() function returns a copy of this PMatrix3D.
       *
       * @return {PMatrix3D} a copy of this PMatrix3D
       */
      get: function() {
        var outgoing = new PMatrix3D2();
        outgoing.set(this.elements);
        return outgoing;
      },
      /**
       * @member PMatrix3D
       * The reset() function sets this PMatrix3D to the identity matrix.
       */
      reset: function() {
        this.elements = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      },
      /**
       * @member PMatrix3D
       * The array() function returns a copy of the element values.
       * @addon
       *
       * @return {float[]} returns a copy of the element values
       */
      array: function array() {
        return this.elements.slice();
      },
      /**
       * @member PMatrix3D
       * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.
       *
       * @param {float} tx  the x-axis coordinate to move to
       * @param {float} ty  the y-axis coordinate to move to
       * @param {float} tz  the z-axis coordinate to move to
       */
      translate: function(tx, ty, tz) {
        if (tz === undef) {
          tz = 0;
        }
        this.elements[3] += tx * this.elements[0] + ty * this.elements[1] + tz * this.elements[2];
        this.elements[7] += tx * this.elements[4] + ty * this.elements[5] + tz * this.elements[6];
        this.elements[11] += tx * this.elements[8] + ty * this.elements[9] + tz * this.elements[10];
        this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];
      },
      /**
       * @member PMatrix3D
       * The transpose() function transpose this matrix.
       */
      transpose: function() {
        var temp = this.elements[4];
        this.elements[4] = this.elements[1];
        this.elements[1] = temp;
        temp = this.elements[8];
        this.elements[8] = this.elements[2];
        this.elements[2] = temp;
        temp = this.elements[6];
        this.elements[6] = this.elements[9];
        this.elements[9] = temp;
        temp = this.elements[3];
        this.elements[3] = this.elements[12];
        this.elements[12] = temp;
        temp = this.elements[7];
        this.elements[7] = this.elements[13];
        this.elements[13] = temp;
        temp = this.elements[11];
        this.elements[11] = this.elements[14];
        this.elements[14] = temp;
      },
      /**
       * @member PMatrix3D
       * The mult() function multiplied this matrix.
       * If two array elements are passed in the function will multiply a two element vector against this matrix.
       * If target is null or not length four, a new float array will be returned.
       * The values for vec and target can be the same (though that's less efficient).
       * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.
       *
       * @param {PVector} source, target  the PVectors used to multiply this matrix
       * @param {float[]} source, target  the arrays used to multiply this matrix
       *
       * @return {PVector|float[]} returns a PVector or an array representing the new matrix
       */
      mult: function(source2, target) {
        var x, y, z, w;
        if (source2 instanceof PVector) {
          x = source2.x;
          y = source2.y;
          z = source2.z;
          w = 1;
          if (!target) {
            target = new PVector();
          }
        } else if (source2 instanceof Array) {
          x = source2[0];
          y = source2[1];
          z = source2[2];
          w = source2[3] || 1;
          if (!target || target.length !== 3 && target.length !== 4) {
            target = [0, 0, 0];
          }
        }
        if (target instanceof Array) {
          if (target.length === 3) {
            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
          } else if (target.length === 4) {
            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;
            target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;
            target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;
            target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;
          }
        }
        if (target instanceof PVector) {
          target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
          target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
          target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
        }
        return target;
      },
      /**
       * @member PMatrix3D
       * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.
       *
       * @param {PMatrix3D} matrix    the matrix to apply this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the second element of the matrix
       * @param {float} m02           the third element of the matrix
       * @param {float} m03           the fourth element of the matrix
       * @param {float} m10           the fifth element of the matrix
       * @param {float} m11           the sixth element of the matrix
       * @param {float} m12           the seventh element of the matrix
       * @param {float} m13           the eight element of the matrix
       * @param {float} m20           the nineth element of the matrix
       * @param {float} m21           the tenth element of the matrix
       * @param {float} m22           the eleventh element of the matrix
       * @param {float} m23           the twelveth element of the matrix
       * @param {float} m30           the thirteenth element of the matrix
       * @param {float} m31           the fourtheenth element of the matrix
       * @param {float} m32           the fivetheenth element of the matrix
       * @param {float} m33           the sixteenth element of the matrix
       */
      preApply: function() {
        var source2;
        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
          source2 = arguments[0].array();
        } else if (arguments.length === 16) {
          source2 = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          source2 = arguments[0];
        }
        var result = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        var e = 0;
        for (var row = 0; row < 4; row++) {
          for (var col = 0; col < 4; col++, e++) {
            result[e] += this.elements[col + 0] * source2[row * 4 + 0] + this.elements[col + 4] * source2[row * 4 + 1] + this.elements[col + 8] * source2[row * 4 + 2] + this.elements[col + 12] * source2[row * 4 + 3];
          }
        }
        this.elements = result.slice();
      },
      /**
       * @member PMatrix3D
       * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.
       *
       * @param {PMatrix3D} matrix    the matrix to apply this matrix to
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the second element of the matrix
       * @param {float} m02           the third element of the matrix
       * @param {float} m03           the fourth element of the matrix
       * @param {float} m10           the fifth element of the matrix
       * @param {float} m11           the sixth element of the matrix
       * @param {float} m12           the seventh element of the matrix
       * @param {float} m13           the eight element of the matrix
       * @param {float} m20           the nineth element of the matrix
       * @param {float} m21           the tenth element of the matrix
       * @param {float} m22           the eleventh element of the matrix
       * @param {float} m23           the twelveth element of the matrix
       * @param {float} m30           the thirteenth element of the matrix
       * @param {float} m31           the fourtheenth element of the matrix
       * @param {float} m32           the fivetheenth element of the matrix
       * @param {float} m33           the sixteenth element of the matrix
       */
      apply: function() {
        var source2;
        if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
          source2 = arguments[0].array();
        } else if (arguments.length === 16) {
          source2 = Array.prototype.slice.call(arguments);
        } else if (arguments.length === 1 && arguments[0] instanceof Array) {
          source2 = arguments[0];
        }
        var result = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0
        ];
        var e = 0;
        for (var row = 0; row < 4; row++) {
          for (var col = 0; col < 4; col++, e++) {
            result[e] += this.elements[row * 4 + 0] * source2[col + 0] + this.elements[row * 4 + 1] * source2[col + 4] + this.elements[row * 4 + 2] * source2[col + 8] + this.elements[row * 4 + 3] * source2[col + 12];
          }
        }
        this.elements = result.slice();
      },
      /**
       * @member PMatrix3D
       * The rotate() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotate: function(angle, v0, v1, v2) {
        if (!v1) {
          this.rotateZ(angle);
        } else {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var t2 = 1 - c;
          this.apply(
            t2 * v0 * v0 + c,
            t2 * v0 * v1 - s * v2,
            t2 * v0 * v2 + s * v1,
            0,
            t2 * v0 * v1 + s * v2,
            t2 * v1 * v1 + c,
            t2 * v1 * v2 - s * v0,
            0,
            t2 * v0 * v2 - s * v1,
            t2 * v1 * v2 + s * v0,
            t2 * v2 * v2 + c,
            0,
            0,
            0,
            0,
            1
          );
        }
      },
      /**
       * @member PMatrix3D
       * The invApply() function applies the inverted matrix to this matrix.
       *
       * @param {float} m00           the first element of the matrix
       * @param {float} m01           the second element of the matrix
       * @param {float} m02           the third element of the matrix
       * @param {float} m03           the fourth element of the matrix
       * @param {float} m10           the fifth element of the matrix
       * @param {float} m11           the sixth element of the matrix
       * @param {float} m12           the seventh element of the matrix
       * @param {float} m13           the eight element of the matrix
       * @param {float} m20           the nineth element of the matrix
       * @param {float} m21           the tenth element of the matrix
       * @param {float} m22           the eleventh element of the matrix
       * @param {float} m23           the twelveth element of the matrix
       * @param {float} m30           the thirteenth element of the matrix
       * @param {float} m31           the fourtheenth element of the matrix
       * @param {float} m32           the fivetheenth element of the matrix
       * @param {float} m33           the sixteenth element of the matrix
       *
       * @return {boolean} returns true if the operation was successful.
       */
      invApply: function() {
        if (inverseCopy === undef) {
          inverseCopy = new PMatrix3D2();
        }
        var a = arguments;
        inverseCopy.set(
          a[0],
          a[1],
          a[2],
          a[3],
          a[4],
          a[5],
          a[6],
          a[7],
          a[8],
          a[9],
          a[10],
          a[11],
          a[12],
          a[13],
          a[14],
          a[15]
        );
        if (!inverseCopy.invert()) {
          return false;
        }
        this.preApply(inverseCopy);
        return true;
      },
      /**
       * @member PMatrix3D
       * The rotateZ() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotateX: function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);
      },
      /**
       * @member PMatrix3D
       * The rotateY() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotateY: function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);
      },
      /**
       * @member PMatrix3D
       * The rotateZ() function rotates the matrix.
       *
       * @param {float} angle         the angle of rotation in radiants
       */
      rotateZ: function(angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      },
      /**
       * @member PMatrix3D
       * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.
       * This is equivalent to a three parameter call.
       *
       * @param {float} sx  the amount to scale on the x-axis
       * @param {float} sy  the amount to scale on the y-axis
       * @param {float} sz  the amount to scale on the z-axis
       */
      scale: function(sx, sy, sz) {
        if (sx && sy === undef && sz === undef) {
          sy = sz = sx;
        } else if (sx && sy && sz === undef) {
          sz = 1;
        }
        if (sx && sy && sz) {
          this.elements[0] *= sx;
          this.elements[1] *= sy;
          this.elements[2] *= sz;
          this.elements[4] *= sx;
          this.elements[5] *= sy;
          this.elements[6] *= sz;
          this.elements[8] *= sx;
          this.elements[9] *= sy;
          this.elements[10] *= sz;
          this.elements[12] *= sx;
          this.elements[13] *= sy;
          this.elements[14] *= sz;
        }
      },
      /**
       * @member PMatrix3D
       * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      skewX: function(angle) {
        var t2 = Math.tan(angle);
        this.apply(1, t2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      /**
       * @member PMatrix3D
       * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of skew specified in radians
       */
      skewY: function(angle) {
        var t2 = Math.tan(angle);
        this.apply(1, 0, 0, 0, t2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      /**
       * @member PMatrix3D
       * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of shear specified in radians
       */
      shearX: function(angle) {
        var t2 = Math.tan(angle);
        this.apply(1, t2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      /**
       * @member PMatrix3D
       * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.
       * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
       *
       * @param {float} angle  angle of shear specified in radians
       */
      shearY: function(angle) {
        var t2 = Math.tan(angle);
        this.apply(1, 0, 0, 0, t2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      },
      multX: function(x, y, z, w) {
        if (!z) {
          return this.elements[0] * x + this.elements[1] * y + this.elements[3];
        }
        if (!w) {
          return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
        }
        return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;
      },
      multY: function(x, y, z, w) {
        if (!z) {
          return this.elements[4] * x + this.elements[5] * y + this.elements[7];
        }
        if (!w) {
          return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
        }
        return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;
      },
      multZ: function(x, y, z, w) {
        if (!w) {
          return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
        }
        return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;
      },
      multW: function(x, y, z, w) {
        if (!w) {
          return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];
        }
        return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;
      },
      /**
       * @member PMatrix3D
       * The invert() function inverts this matrix
       *
       * @return {boolean} true if successful
       */
      invert: function() {
        var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];
        var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];
        var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];
        var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];
        var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];
        var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];
        var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];
        var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];
        var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];
        var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];
        var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];
        var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];
        var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;
        if (Math.abs(fDet) <= 1e-9) {
          return false;
        }
        var kInv = [];
        kInv[0] = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;
        kInv[4] = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;
        kInv[8] = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;
        kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;
        kInv[1] = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;
        kInv[5] = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;
        kInv[9] = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;
        kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;
        kInv[2] = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;
        kInv[6] = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;
        kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;
        kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;
        kInv[3] = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;
        kInv[7] = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;
        kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;
        kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;
        var fInvDet = 1 / fDet;
        kInv[0] *= fInvDet;
        kInv[1] *= fInvDet;
        kInv[2] *= fInvDet;
        kInv[3] *= fInvDet;
        kInv[4] *= fInvDet;
        kInv[5] *= fInvDet;
        kInv[6] *= fInvDet;
        kInv[7] *= fInvDet;
        kInv[8] *= fInvDet;
        kInv[9] *= fInvDet;
        kInv[10] *= fInvDet;
        kInv[11] *= fInvDet;
        kInv[12] *= fInvDet;
        kInv[13] *= fInvDet;
        kInv[14] *= fInvDet;
        kInv[15] *= fInvDet;
        this.elements = kInv.slice();
        return true;
      },
      toString: function() {
        var str = "";
        for (var i = 0; i < 15; i++) {
          str += this.elements[i] + ", ";
        }
        str += this.elements[15];
        return str;
      },
      /**
       * @member PMatrix3D
       * The print() function prints out the elements of this matrix
       */
      print: function() {
        var digits = printMatrixHelper(this.elements);
        var output = "" + p.nfs(this.elements[0], digits, 4) + " " + p.nfs(this.elements[1], digits, 4) + " " + p.nfs(this.elements[2], digits, 4) + " " + p.nfs(this.elements[3], digits, 4) + "\n" + p.nfs(this.elements[4], digits, 4) + " " + p.nfs(this.elements[5], digits, 4) + " " + p.nfs(this.elements[6], digits, 4) + " " + p.nfs(this.elements[7], digits, 4) + "\n" + p.nfs(this.elements[8], digits, 4) + " " + p.nfs(this.elements[9], digits, 4) + " " + p.nfs(this.elements[10], digits, 4) + " " + p.nfs(this.elements[11], digits, 4) + "\n" + p.nfs(this.elements[12], digits, 4) + " " + p.nfs(this.elements[13], digits, 4) + " " + p.nfs(this.elements[14], digits, 4) + " " + p.nfs(this.elements[15], digits, 4) + "\n\n";
        p.println(output);
      },
      invTranslate: function(tx, ty, tz) {
        this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);
      },
      invRotateX: function(angle) {
        var c = Math.cos(-angle);
        var s = Math.sin(-angle);
        this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);
      },
      invRotateY: function(angle) {
        var c = Math.cos(-angle);
        var s = Math.sin(-angle);
        this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);
      },
      invRotateZ: function(angle) {
        var c = Math.cos(-angle);
        var s = Math.sin(-angle);
        this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      },
      invScale: function(x, y, z) {
        this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);
      }
    };
    return PMatrix3D2;
  }
  var PMatrix3D_default = PMatrix3D;

  // src/Objects/PShape.js
  function PShape_default(options) {
    var PConstants3 = options.PConstants, PMatrix2D2 = options.PMatrix2D, PMatrix3D2 = options.PMatrix3D;
    var PShape = function(family) {
      this.family = family || PConstants3.GROUP;
      this.visible = true;
      this.style = true;
      this.children = [];
      this.nameTable = [];
      this.params = [];
      this.name = "";
      this.image = null;
      this.matrix = null;
      this.kind = null;
      this.close = null;
      this.width = null;
      this.height = null;
      this.parent = null;
    };
    PShape.prototype = {
      /**
       * @member PShape
       * The isVisible() function returns a boolean value "true" if the image is set to be visible, "false" if not. This is modified with the <b>setVisible()</b> parameter.
       * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.
       * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.
       *
       * @return {boolean}  returns "true" if the image is set to be visible, "false" if not
       */
      isVisible: function() {
        return this.visible;
      },
      /**
       * @member PShape
       * The setVisible() function sets the shape to be visible or invisible. This is determined by the value of the <b>visible</b> parameter.
       * <br><br>The visibility of a shape is usually controlled by whatever program created the SVG file.
       * For instance, this parameter is controlled by showing or hiding the shape in the layers palette in Adobe Illustrator.
       *
       * @param {boolean} visible "false" makes the shape invisible and "true" makes it visible
       */
      setVisible: function(visible) {
        this.visible = visible;
      },
      /**
       * @member PShape
       * The disableStyle() function disables the shape's style data and uses Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.
       * Overrides this shape's style information and uses PGraphics styles and colors. Identical to ignoreStyles(true). Also disables styles for all child shapes.
       */
      disableStyle: function() {
        this.style = false;
        for (var i = 0, j = this.children.length; i < j; i++) {
          this.children[i].disableStyle();
        }
      },
      /**
       * @member PShape
       * The enableStyle() function enables the shape's style data and ignores Processing's current styles. Styles include attributes such as colors, stroke weight, and stroke joints.
       */
      enableStyle: function() {
        this.style = true;
        for (var i = 0, j = this.children.length; i < j; i++) {
          this.children[i].enableStyle();
        }
      },
      /**
       * @member PShape
       * The getFamily function returns the shape type
       *
       * @return {int} the shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY
       */
      getFamily: function() {
        return this.family;
      },
      /**
       * @member PShape
       * The getWidth() function gets the width of the drawing area (not necessarily the shape boundary).
       */
      getWidth: function() {
        return this.width;
      },
      /**
       * @member PShape
       * The getHeight() function gets the height of the drawing area (not necessarily the shape boundary).
       */
      getHeight: function() {
        return this.height;
      },
      /**
       * @member PShape
       * The setName() function sets the name of the shape
       *
       * @param {String} name the name of the shape
       */
      setName: function(name) {
        this.name = name;
      },
      /**
       * @member PShape
       * The getName() function returns the name of the shape
       *
       * @return {String} the name of the shape
       */
      getName: function() {
        return this.name;
      },
      /**
       * @member PShape
       * Called by the following (the shape() command adds the g)
       * PShape s = loadShapes("blah.svg");
       * shape(s);
       */
      draw: function(renderContext) {
        if (!renderContext) {
          throw "render context missing for draw() in PShape";
        }
        if (this.visible) {
          this.pre(renderContext);
          this.drawImpl(renderContext);
          this.post(renderContext);
        }
      },
      /**
       * @member PShape
       * the drawImpl() function draws the SVG document.
       */
      drawImpl: function(renderContext) {
        if (this.family === PConstants3.GROUP) {
          this.drawGroup(renderContext);
        } else if (this.family === PConstants3.PRIMITIVE) {
          this.drawPrimitive(renderContext);
        } else if (this.family === PConstants3.GEOMETRY) {
          this.drawGeometry(renderContext);
        } else if (this.family === PConstants3.PATH) {
          this.drawPath(renderContext);
        }
      },
      /**
       * @member PShape
       * The drawPath() function draws the <path> part of the SVG document.
       */
      drawPath: function(renderContext) {
        var i, j;
        if (this.vertices.length === 0) {
          return;
        }
        renderContext.beginShape();
        if (this.vertexCodes.length === 0) {
          if (this.vertices[0].length === 2) {
            for (i = 0, j = this.vertices.length; i < j; i++) {
              renderContext.vertex(this.vertices[i][0], this.vertices[i][1]);
            }
          } else {
            for (i = 0, j = this.vertices.length; i < j; i++) {
              renderContext.vertex(
                this.vertices[i][0],
                this.vertices[i][1],
                this.vertices[i][2]
              );
            }
          }
        } else {
          var index = 0;
          if (this.vertices[0].length === 2) {
            for (i = 0, j = this.vertexCodes.length; i < j; i++) {
              if (this.vertexCodes[i] === PConstants3.VERTEX) {
                renderContext.vertex(this.vertices[index][0], this.vertices[index][1], this.vertices[index].moveTo);
                renderContext.breakShape = false;
                index++;
              } else if (this.vertexCodes[i] === PConstants3.BEZIER_VERTEX) {
                renderContext.bezierVertex(
                  this.vertices[index + 0][0],
                  this.vertices[index + 0][1],
                  this.vertices[index + 1][0],
                  this.vertices[index + 1][1],
                  this.vertices[index + 2][0],
                  this.vertices[index + 2][1]
                );
                index += 3;
              } else if (this.vertexCodes[i] === PConstants3.CURVE_VERTEX) {
                renderContext.curveVertex(
                  this.vertices[index][0],
                  this.vertices[index][1]
                );
                index++;
              } else if (this.vertexCodes[i] === PConstants3.BREAK) {
                renderContext.breakShape = true;
              }
            }
          } else {
            for (i = 0, j = this.vertexCodes.length; i < j; i++) {
              if (this.vertexCodes[i] === PConstants3.VERTEX) {
                renderContext.vertex(
                  this.vertices[index][0],
                  this.vertices[index][1],
                  this.vertices[index][2]
                );
                if (this.vertices[index].moveTo === true) {
                  vertArray[vertArray.length - 1].moveTo = true;
                } else if (this.vertices[index].moveTo === false) {
                  vertArray[vertArray.length - 1].moveTo = false;
                }
                renderContext.breakShape = false;
              } else if (this.vertexCodes[i] === PConstants3.BEZIER_VERTEX) {
                renderContext.bezierVertex(
                  this.vertices[index + 0][0],
                  this.vertices[index + 0][1],
                  this.vertices[index + 0][2],
                  this.vertices[index + 1][0],
                  this.vertices[index + 1][1],
                  this.vertices[index + 1][2],
                  this.vertices[index + 2][0],
                  this.vertices[index + 2][1],
                  this.vertices[index + 2][2]
                );
                index += 3;
              } else if (this.vertexCodes[i] === PConstants3.CURVE_VERTEX) {
                renderContext.curveVertex(
                  this.vertices[index][0],
                  this.vertices[index][1],
                  this.vertices[index][2]
                );
                index++;
              } else if (this.vertexCodes[i] === PConstants3.BREAK) {
                renderContext.breakShape = true;
              }
            }
          }
        }
        renderContext.endShape(this.close ? PConstants3.CLOSE : PConstants3.OPEN);
      },
      /**
       * @member PShape
       * The drawGeometry() function draws the geometry part of the SVG document.
       */
      drawGeometry: function(renderContext) {
        var i, j;
        renderContext.beginShape(this.kind);
        if (this.style) {
          for (i = 0, j = this.vertices.length; i < j; i++) {
            renderContext.vertex(this.vertices[i]);
          }
        } else {
          for (i = 0, j = this.vertices.length; i < j; i++) {
            var vert = this.vertices[i];
            if (vert[2] === 0) {
              renderContext.vertex(vert[0], vert[1]);
            } else {
              renderContext.vertex(vert[0], vert[1], vert[2]);
            }
          }
        }
        renderContext.endShape();
      },
      /**
       * @member PShape
       * The drawGroup() function draws the <g> part of the SVG document.
       */
      drawGroup: function(renderContext) {
        for (var i = 0, j = this.children.length; i < j; i++) {
          this.children[i].draw(renderContext);
        }
      },
      /**
       * @member PShape
       * The drawPrimitive() function draws SVG document shape elements. These can be point, line, triangle, quad, rect, ellipse, arc, box, or sphere.
       */
      drawPrimitive: function(renderContext) {
        if (this.kind === PConstants3.POINT) {
          renderContext.point(this.params[0], this.params[1]);
        } else if (this.kind === PConstants3.LINE) {
          if (this.params.length === 4) {
            renderContext.line(
              this.params[0],
              this.params[1],
              this.params[2],
              this.params[3]
            );
          } else {
            renderContext.line(
              this.params[0],
              this.params[1],
              this.params[2],
              this.params[3],
              this.params[4],
              this.params[5]
            );
          }
        } else if (this.kind === PConstants3.TRIANGLE) {
          renderContext.triangle(
            this.params[0],
            this.params[1],
            this.params[2],
            this.params[3],
            this.params[4],
            this.params[5]
          );
        } else if (this.kind === PConstants3.QUAD) {
          renderContext.quad(
            this.params[0],
            this.params[1],
            this.params[2],
            this.params[3],
            this.params[4],
            this.params[5],
            this.params[6],
            this.params[7]
          );
        } else if (this.kind === PConstants3.RECT) {
          if (this.image !== null) {
            var imMode = imageModeConvert;
            renderContext.imageMode(PConstants3.CORNER);
            renderContext.image(
              this.image,
              this.params[0],
              this.params[1],
              this.params[2],
              this.params[3]
            );
            imageModeConvert = imMode;
          } else {
            var rcMode = renderContext.curRectMode;
            renderContext.rectMode(PConstants3.CORNER);
            renderContext.rect(
              this.params[0],
              this.params[1],
              this.params[2],
              this.params[3]
            );
            renderContext.curRectMode = rcMode;
          }
        } else if (this.kind === PConstants3.ELLIPSE) {
          var elMode = renderContext.curEllipseMode;
          renderContext.ellipseMode(PConstants3.CORNER);
          renderContext.ellipse(
            this.params[0],
            this.params[1],
            this.params[2],
            this.params[3]
          );
          renderContext.curEllipseMode = elMode;
        } else if (this.kind === PConstants3.ARC) {
          var eMode = curEllipseMode;
          renderContext.ellipseMode(PConstants3.CORNER);
          renderContext.arc(
            this.params[0],
            this.params[1],
            this.params[2],
            this.params[3],
            this.params[4],
            this.params[5]
          );
          curEllipseMode = eMode;
        } else if (this.kind === PConstants3.BOX) {
          if (this.params.length === 1) {
            renderContext.box(this.params[0]);
          } else {
            renderContext.box(this.params[0], this.params[1], this.params[2]);
          }
        } else if (this.kind === PConstants3.SPHERE) {
          renderContext.sphere(this.params[0]);
        }
      },
      /**
       * @member PShape
       * The pre() function performs the preparations before the SVG is drawn. This includes doing transformations and storing previous styles.
       */
      pre: function(renderContext) {
        if (this.matrix) {
          renderContext.pushMatrix();
          renderContext.transform(this.matrix);
        }
        if (this.style) {
          renderContext.pushStyle();
          this.styles(renderContext);
        }
      },
      /**
       * @member PShape
       * The post() function performs the necessary actions after the SVG is drawn. This includes removing transformations and removing added styles.
       */
      post: function(renderContext) {
        if (this.matrix) {
          renderContext.popMatrix();
        }
        if (this.style) {
          renderContext.popStyle();
        }
      },
      /**
       * @member PShape
       * The styles() function changes the Processing's current styles
       */
      styles: function(renderContext) {
        if (this.stroke) {
          renderContext.stroke(this.strokeColor);
          renderContext.strokeWeight(this.strokeWeight);
          renderContext.strokeCap(this.strokeCap);
          renderContext.strokeJoin(this.strokeJoin);
        } else {
          renderContext.noStroke();
        }
        if (this.fill) {
          renderContext.fill(this.fillColor);
        } else {
          renderContext.noFill();
        }
      },
      /**
       * @member PShape
       * The getChild() function extracts a child shape from a parent shape. Specify the name of the shape with the <b>target</b> parameter or the
       * layer position of the shape to get with the <b>index</b> parameter.
       * The shape is returned as a <b>PShape</b> object, or <b>null</b> is returned if there is an error.
       *
       * @param {String} target   the name of the shape to get
       * @param {int} index   the layer position of the shape to get
       *
       * @return {PShape} returns a child element of a shape as a PShape object or null if there is an error
       */
      getChild: function(child) {
        var i, j;
        if (typeof child === "number") {
          return this.children[child];
        }
        var found;
        if (child === "" || this.name === child) {
          return this;
        }
        if (this.nameTable.length > 0) {
          for (i = 0, j = this.nameTable.length; i < j || found; i++) {
            if (this.nameTable[i].getName === child) {
              found = this.nameTable[i];
              break;
            }
          }
          if (found) {
            return found;
          }
        }
        for (i = 0, j = this.children.length; i < j; i++) {
          found = this.children[i].getChild(child);
          if (found) {
            return found;
          }
        }
        return null;
      },
      /**
       * @member PShape
       * The getChildCount() returns the number of children
       *
       * @return {int} returns a count of children
       */
      getChildCount: function() {
        return this.children.length;
      },
      /**
       * @member PShape
       * The addChild() adds a child to the PShape.
       *
       * @param {PShape} child the child to add
       */
      addChild: function(child) {
        this.children.push(child);
        child.parent = this;
        if (child.getName() !== null) {
          this.addName(child.getName(), child);
        }
      },
      /**
       * @member PShape
       * The addName() functions adds a shape to the name lookup table.
       *
       * @param {String} name   the name to be added
       * @param {PShape} shape  the shape
       */
      addName: function(name, shape) {
        if (this.parent !== null) {
          this.parent.addName(name, shape);
        } else {
          this.nameTable.push([name, shape]);
        }
      },
      /**
       * @member PShape
       * The translate() function specifies an amount to displace the shape. The <b>x</b> parameter specifies left/right translation, the <b>y</b> parameter specifies up/down translation, and the <b>z</b> parameter specifies translations toward/away from the screen.
       * Subsequent calls to the method accumulates the effect. For example, calling <b>translate(50, 0)</b> and then <b>translate(20, 0)</b> is the same as <b>translate(70, 0)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>Using this method with the <b>z</b> parameter requires using the P3D or OPENGL parameter in combination with size.
       *
       * @param {int|float} x left/right translation
       * @param {int|float} y up/down translation
       * @param {int|float} z forward/back translation
       *
       * @see PMatrix2D#translate
       * @see PMatrix3D#translate
       */
      translate: function() {
        if (arguments.length === 2) {
          this.checkMatrix(2);
          this.matrix.translate(arguments[0], arguments[1]);
        } else {
          this.checkMatrix(3);
          this.matrix.translate(arguments[0], arguments[1], 0);
        }
      },
      /**
       * @member PShape
       * The checkMatrix() function makes sure that the shape's matrix is 1) not null, and 2) has a matrix
       * that can handle <em>at least</em> the specified number of dimensions.
       *
       * @param {int} dimensions the specified number of dimensions
       */
      checkMatrix: function(dimensions) {
        if (this.matrix === null) {
          if (dimensions === 2) {
            this.matrix = new PMatrix2D2();
          } else {
            this.matrix = new PMatrix3D2();
          }
        } else if (dimensions === 3 && this.matrix instanceof PMatrix2D2) {
          this.matrix = new PMatrix3D2();
        }
      },
      /**
       * @member PShape
       * The rotateX() function rotates a shape around the x-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.
       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.
       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateX(HALF_PI)</b> and then <b>rotateX(HALF_PI)</b> is the same as <b>rotateX(PI)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.
       *
       * @param {float}angle angle of rotation specified in radians
       *
       * @see PMatrix3D#rotateX
       */
      rotateX: function(angle) {
        this.rotate(angle, 1, 0, 0);
      },
      /**
       * @member PShape
       * The rotateY() function rotates a shape around the y-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.
       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.
       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateY(HALF_PI)</b> and then <b>rotateY(HALF_PI)</b> is the same as <b>rotateY(PI)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.
       *
       * @param {float}angle angle of rotation specified in radians
       *
       * @see PMatrix3D#rotateY
       */
      rotateY: function(angle) {
        this.rotate(angle, 0, 1, 0);
      },
      /**
       * @member PShape
       * The rotateZ() function rotates a shape around the z-axis the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.
       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.
       * Subsequent calls to the method accumulates the effect. For example, calling <b>rotateZ(HALF_PI)</b> and then <b>rotateZ(HALF_PI)</b> is the same as <b>rotateZ(PI)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>This method requires a 3D renderer. You need to pass P3D or OPENGL as a third parameter into the <b>size()</b> method as shown in the example above.
       *
       * @param {float}angle angle of rotation specified in radians
       *
       * @see PMatrix3D#rotateZ
       */
      rotateZ: function(angle) {
        this.rotate(angle, 0, 0, 1);
      },
      /**
       * @member PShape
       * The rotate() function rotates a shape the amount specified by the <b>angle</b> parameter. Angles should be specified in radians (values from 0 to TWO_PI) or converted to radians with the <b>radians()</b> method.
       * <br><br>Shapes are always rotated around the upper-left corner of their bounding box. Positive numbers rotate objects in a clockwise direction.
       * Transformations apply to everything that happens after and subsequent calls to the method accumulates the effect.
       * For example, calling <b>rotate(HALF_PI)</b> and then <b>rotate(HALF_PI)</b> is the same as <b>rotate(PI)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * If optional parameters x,y,z are supplied, the rotate is about the point (x, y, z).
       *
       * @param {float}angle  angle of rotation specified in radians
       * @param {float}x      x-coordinate of the point
       * @param {float}y      y-coordinate of the point
       * @param {float}z      z-coordinate of the point
       * @see PMatrix2D#rotate
       * @see PMatrix3D#rotate
       */
      rotate: function() {
        if (arguments.length === 1) {
          this.checkMatrix(2);
          this.matrix.rotate(arguments[0]);
        } else {
          this.checkMatrix(3);
          this.matrix.rotate(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3]
          );
        }
      },
      /**
       * @member PShape
       * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. Shapes always scale from the relative origin of their bounding box.
       * Scale values are specified as decimal percentages. For example, the method call <b>scale(2.0)</b> increases the dimension of a shape by 200%.
       * Subsequent calls to the method multiply the effect. For example, calling <b>scale(2.0)</b> and then <b>scale(1.5)</b> is the same as <b>scale(3.0)</b>.
       * This transformation is applied directly to the shape, it's not refreshed each time <b>draw()</b> is run.
       * <br><br>Using this fuction with the <b>z</b> parameter requires passing P3D or OPENGL into the size() parameter.
       *
       * @param {float}s      percentage to scale the object
       * @param {float}x      percentage to scale the object in the x-axis
       * @param {float}y      percentage to scale the object in the y-axis
       * @param {float}z      percentage to scale the object in the z-axis
       *
       * @see PMatrix2D#scale
       * @see PMatrix3D#scale
       */
      scale: function() {
        if (arguments.length === 2) {
          this.checkMatrix(2);
          this.matrix.scale(arguments[0], arguments[1]);
        } else if (arguments.length === 3) {
          this.checkMatrix(2);
          this.matrix.scale(arguments[0], arguments[1], arguments[2]);
        } else {
          this.checkMatrix(2);
          this.matrix.scale(arguments[0]);
        }
      },
      /**
       * @member PShape
       * The resetMatrix() function resets the matrix
       *
       * @see PMatrix2D#reset
       * @see PMatrix3D#reset
       */
      resetMatrix: function() {
        this.checkMatrix(2);
        this.matrix.reset();
      },
      /**
       * @member PShape
       * The applyMatrix() function multiplies this matrix by another matrix of type PMatrix3D or PMatrix2D.
       * Individual elements can also be provided
       *
       * @param {PMatrix3D|PMatrix2D} matrix   the matrix to multiply by
       *
       * @see PMatrix2D#apply
       * @see PMatrix3D#apply
       */
      applyMatrix: function(matrix) {
        if (arguments.length === 1) {
          this.applyMatrix(
            matrix.elements[0],
            matrix.elements[1],
            0,
            matrix.elements[2],
            matrix.elements[3],
            matrix.elements[4],
            0,
            matrix.elements[5],
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          );
        } else if (arguments.length === 6) {
          this.checkMatrix(2);
          this.matrix.apply(
            arguments[0],
            arguments[1],
            arguments[2],
            0,
            arguments[3],
            arguments[4],
            arguments[5],
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          );
        } else if (arguments.length === 16) {
          this.checkMatrix(3);
          this.matrix.apply(
            arguments[0],
            arguments[1],
            arguments[2],
            arguments[3],
            arguments[4],
            arguments[5],
            arguments[6],
            arguments[7],
            arguments[8],
            arguments[9],
            arguments[10],
            arguments[11],
            arguments[12],
            arguments[13],
            arguments[14],
            arguments[15]
          );
        }
      }
    };
    return PShape;
  }

  // src/Objects/webcolors.js
  var webcolors_default = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgrey: "#d3d3d3",
    lightgreen: "#90ee90",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370d8",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#d87093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };

  // src/Objects/PShapeSVG.js
  function PShapeSVG(options) {
    var CommonFunctions = options.CommonFunctions();
    var PConstants3 = options.PConstants;
    var PShape = options.PShape;
    var XMLElement = options.XMLElement;
    var colors = options.colors;
    var PShapeSVG2 = function() {
      PShape.call(this);
      if (arguments.length === 1) {
        this.element = arguments[0];
        this.vertexCodes = [];
        this.vertices = [];
        this.opacity = 1;
        this.stroke = false;
        this.strokeColor = PConstants3.ALPHA_MASK;
        this.strokeWeight = 1;
        this.strokeCap = PConstants3.SQUARE;
        this.strokeJoin = PConstants3.MITER;
        this.strokeGradient = null;
        this.strokeGradientPaint = null;
        this.strokeName = null;
        this.strokeOpacity = 1;
        this.fill = true;
        this.fillColor = PConstants3.ALPHA_MASK;
        this.fillGradient = null;
        this.fillGradientPaint = null;
        this.fillName = null;
        this.fillOpacity = 1;
        if (this.element.getName() !== "svg") {
          throw "root is not <svg>, it's <" + this.element.getName() + ">";
        }
      } else if (arguments.length === 2) {
        if (typeof arguments[1] === "string") {
          if (arguments[1].indexOf(".svg") > -1) {
            this.element = new XMLElement(true, arguments[1]);
            this.vertexCodes = [];
            this.vertices = [];
            this.opacity = 1;
            this.stroke = false;
            this.strokeColor = PConstants3.ALPHA_MASK;
            this.strokeWeight = 1;
            this.strokeCap = PConstants3.SQUARE;
            this.strokeJoin = PConstants3.MITER;
            this.strokeGradient = "";
            this.strokeGradientPaint = "";
            this.strokeName = "";
            this.strokeOpacity = 1;
            this.fill = true;
            this.fillColor = PConstants3.ALPHA_MASK;
            this.fillGradient = null;
            this.fillGradientPaint = null;
            this.fillOpacity = 1;
          }
        } else {
          if (arguments[0]) {
            this.element = arguments[1];
            this.vertexCodes = arguments[0].vertexCodes.slice();
            this.vertices = arguments[0].vertices.slice();
            this.stroke = arguments[0].stroke;
            this.strokeColor = arguments[0].strokeColor;
            this.strokeWeight = arguments[0].strokeWeight;
            this.strokeCap = arguments[0].strokeCap;
            this.strokeJoin = arguments[0].strokeJoin;
            this.strokeGradient = arguments[0].strokeGradient;
            this.strokeGradientPaint = arguments[0].strokeGradientPaint;
            this.strokeName = arguments[0].strokeName;
            this.fill = arguments[0].fill;
            this.fillColor = arguments[0].fillColor;
            this.fillGradient = arguments[0].fillGradient;
            this.fillGradientPaint = arguments[0].fillGradientPaint;
            this.fillName = arguments[0].fillName;
            this.strokeOpacity = arguments[0].strokeOpacity;
            this.fillOpacity = arguments[0].fillOpacity;
            this.opacity = arguments[0].opacity;
          }
        }
      }
      this.name = this.element.getStringAttribute("id");
      var displayStr = this.element.getStringAttribute("display", "inline");
      this.visible = displayStr !== "none";
      var str = this.element.getAttribute("transform");
      if (str) {
        this.matrix = this.parseMatrix(str);
      }
      var viewBoxStr = this.element.getStringAttribute("viewBox");
      if (viewBoxStr !== null) {
        var viewBox = viewBoxStr.split(" ");
        this.width = viewBox[2];
        this.height = viewBox[3];
      }
      var unitWidth = this.element.getStringAttribute("width");
      var unitHeight = this.element.getStringAttribute("height");
      if (unitWidth !== null) {
        this.width = this.parseUnitSize(unitWidth);
        this.height = this.parseUnitSize(unitHeight);
      } else {
        if (this.width === 0 || this.height === 0) {
          this.width = 1;
          this.height = 1;
          throw "The width and/or height is not readable in the <svg> tag of this file.";
        }
      }
      this.parseColors(this.element);
      this.parseChildren(this.element);
    };
    PShapeSVG2.prototype = new PShape();
    PShapeSVG2.prototype.parseMatrix = /* @__PURE__ */ function() {
      function getCoords(s) {
        var m = [];
        s.replace(/\((.*?)\)/, /* @__PURE__ */ function() {
          return function(all, params) {
            m = params.replace(/,+/g, " ").split(/\s+/);
          };
        }());
        return m;
      }
      return function(str) {
        this.checkMatrix(2);
        var pieces = [];
        str.replace(/\s*(\w+)\((.*?)\)/g, function(all) {
          pieces.push(CommonFunctions.trim(all));
        });
        if (pieces.length === 0) {
          return null;
        }
        for (var i = 0, j = pieces.length; i < j; i++) {
          var m = getCoords(pieces[i]);
          if (pieces[i].indexOf("matrix") !== -1) {
            this.matrix.set(m[0], m[2], m[4], m[1], m[3], m[5]);
          } else if (pieces[i].indexOf("translate") !== -1) {
            var tx = m[0];
            var ty = m.length === 2 ? m[1] : 0;
            this.matrix.translate(tx, ty);
          } else if (pieces[i].indexOf("scale") !== -1) {
            var sx = m[0];
            var sy = m.length === 2 ? m[1] : m[0];
            this.matrix.scale(sx, sy);
          } else if (pieces[i].indexOf("rotate") !== -1) {
            var angle = m[0];
            if (m.length === 1) {
              this.matrix.rotate(CommonFunctions.radians(angle));
            } else if (m.length === 3) {
              this.matrix.translate(m[1], m[2]);
              this.matrix.rotate(CommonFunctions.radians(m[0]));
              this.matrix.translate(-m[1], -m[2]);
            }
          } else if (pieces[i].indexOf("skewX") !== -1) {
            this.matrix.skewX(parseFloat(m[0]));
          } else if (pieces[i].indexOf("skewY") !== -1) {
            this.matrix.skewY(m[0]);
          } else if (pieces[i].indexOf("shearX") !== -1) {
            this.matrix.shearX(m[0]);
          } else if (pieces[i].indexOf("shearY") !== -1) {
            this.matrix.shearY(m[0]);
          }
        }
        return this.matrix;
      };
    }();
    PShapeSVG2.prototype.parseChildren = function(element) {
      var newelement = element.getChildren();
      var base = new PShape();
      var i, j;
      for (i = 0, j = newelement.length; i < j; i++) {
        var kid = this.parseChild(newelement[i]);
        if (kid) {
          base.addChild(kid);
        }
      }
      for (i = 0, j = base.children.length; i < j; i++) {
        this.children.push(base.children[i]);
      }
    };
    PShapeSVG2.prototype.getName = function() {
      return this.name;
    };
    PShapeSVG2.prototype.parseChild = function(elem) {
      var name = elem.getName();
      var shape;
      if (name === "g") {
        shape = new PShapeSVG2(this, elem);
      } else if (name === "defs") {
        shape = new PShapeSVG2(this, elem);
      } else if (name === "line") {
        shape = new PShapeSVG2(this, elem);
        shape.parseLine();
      } else if (name === "circle") {
        shape = new PShapeSVG2(this, elem);
        shape.parseEllipse(true);
      } else if (name === "ellipse") {
        shape = new PShapeSVG2(this, elem);
        shape.parseEllipse(false);
      } else if (name === "rect") {
        shape = new PShapeSVG2(this, elem);
        shape.parseRect();
      } else if (name === "polygon") {
        shape = new PShapeSVG2(this, elem);
        shape.parsePoly(true);
      } else if (name === "polyline") {
        shape = new PShapeSVG2(this, elem);
        shape.parsePoly(false);
      } else if (name === "path") {
        shape = new PShapeSVG2(this, elem);
        shape.parsePath();
      } else if (name === "radialGradient") {
        unimplemented("PShapeSVG.prototype.parseChild, name = radialGradient");
      } else if (name === "linearGradient") {
        unimplemented("PShapeSVG.prototype.parseChild, name = linearGradient");
      } else if (name === "text") {
        unimplemented("PShapeSVG.prototype.parseChild, name = text");
      } else if (name === "filter") {
        unimplemented("PShapeSVG.prototype.parseChild, name = filter");
      } else if (name === "mask") {
        unimplemented("PShapeSVG.prototype.parseChild, name = mask");
      } else {
      }
      return shape;
    };
    PShapeSVG2.prototype.parsePath = function() {
      this.family = PConstants3.PATH;
      this.kind = 0;
      var pathDataChars = [];
      var c;
      var pathData = CommonFunctions.trim(this.element.getStringAttribute("d").replace(/[\s,]+/g, " "));
      if (pathData === null) {
        return;
      }
      pathData = pathData.split("");
      var cx = 0, cy = 0, ctrlX = 0, ctrlY = 0, ctrlX1 = 0, ctrlX2 = 0, ctrlY1 = 0, ctrlY2 = 0, endX = 0, endY = 0, ppx = 0, ppy = 0, px = 0, py = 0, i = 0, valOf = 0;
      var str = "";
      var tmpArray = [];
      var flag = false;
      var lastInstruction;
      var command;
      var j, k;
      while (i < pathData.length) {
        valOf = pathData[i].charCodeAt(0);
        if (valOf >= 65 && valOf <= 90 || valOf >= 97 && valOf <= 122) {
          j = i;
          i++;
          if (i < pathData.length) {
            tmpArray = [];
            valOf = pathData[i].charCodeAt(0);
            while (!(valOf >= 65 && valOf <= 90 || valOf >= 97 && valOf <= 100 || valOf >= 102 && valOf <= 122) && flag === false) {
              if (valOf === 32) {
                if (str !== "") {
                  tmpArray.push(parseFloat(str));
                  str = "";
                }
                i++;
              } else if (valOf === 45) {
                if (pathData[i - 1].charCodeAt(0) === 101) {
                  str += pathData[i].toString();
                  i++;
                } else {
                  if (str !== "") {
                    tmpArray.push(parseFloat(str));
                  }
                  str = pathData[i].toString();
                  i++;
                }
              } else {
                str += pathData[i].toString();
                i++;
              }
              if (i === pathData.length) {
                flag = true;
              } else {
                valOf = pathData[i].charCodeAt(0);
              }
            }
          }
          if (str !== "") {
            tmpArray.push(parseFloat(str));
            str = "";
          }
          command = pathData[j];
          valOf = command.charCodeAt(0);
          if (valOf === 77) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              cx = tmpArray[0];
              cy = tmpArray[1];
              this.parsePathMoveto(cx, cy);
              if (tmpArray.length > 2) {
                for (j = 2, k = tmpArray.length; j < k; j += 2) {
                  cx = tmpArray[j];
                  cy = tmpArray[j + 1];
                  this.parsePathLineto(cx, cy);
                }
              }
            }
          } else if (valOf === 109) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              cx += tmpArray[0];
              cy += tmpArray[1];
              this.parsePathMoveto(cx, cy);
              if (tmpArray.length > 2) {
                for (j = 2, k = tmpArray.length; j < k; j += 2) {
                  cx += tmpArray[j];
                  cy += tmpArray[j + 1];
                  this.parsePathLineto(cx, cy);
                }
              }
            }
          } else if (valOf === 76) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 2) {
                cx = tmpArray[j];
                cy = tmpArray[j + 1];
                this.parsePathLineto(cx, cy);
              }
            }
          } else if (valOf === 108) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 2) {
                cx += tmpArray[j];
                cy += tmpArray[j + 1];
                this.parsePathLineto(cx, cy);
              }
            }
          } else if (valOf === 72) {
            for (j = 0, k = tmpArray.length; j < k; j++) {
              cx = tmpArray[j];
              this.parsePathLineto(cx, cy);
            }
          } else if (valOf === 104) {
            for (j = 0, k = tmpArray.length; j < k; j++) {
              cx += tmpArray[j];
              this.parsePathLineto(cx, cy);
            }
          } else if (valOf === 86) {
            for (j = 0, k = tmpArray.length; j < k; j++) {
              cy = tmpArray[j];
              this.parsePathLineto(cx, cy);
            }
          } else if (valOf === 118) {
            for (j = 0, k = tmpArray.length; j < k; j++) {
              cy += tmpArray[j];
              this.parsePathLineto(cx, cy);
            }
          } else if (valOf === 67) {
            if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 6) {
                ctrlX1 = tmpArray[j];
                ctrlY1 = tmpArray[j + 1];
                ctrlX2 = tmpArray[j + 2];
                ctrlY2 = tmpArray[j + 3];
                endX = tmpArray[j + 4];
                endY = tmpArray[j + 5];
                this.parsePathCurveto(
                  ctrlX1,
                  ctrlY1,
                  ctrlX2,
                  ctrlY2,
                  endX,
                  endY
                );
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 99) {
            if (tmpArray.length >= 6 && tmpArray.length % 6 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 6) {
                ctrlX1 = cx + tmpArray[j];
                ctrlY1 = cy + tmpArray[j + 1];
                ctrlX2 = cx + tmpArray[j + 2];
                ctrlY2 = cy + tmpArray[j + 3];
                endX = cx + tmpArray[j + 4];
                endY = cy + tmpArray[j + 5];
                this.parsePathCurveto(
                  ctrlX1,
                  ctrlY1,
                  ctrlX2,
                  ctrlY2,
                  endX,
                  endY
                );
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 83) {
            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 4) {
                if (lastInstruction.toLowerCase() === "c" || lastInstruction.toLowerCase() === "s") {
                  ppx = this.vertices[this.vertices.length - 2][0];
                  ppy = this.vertices[this.vertices.length - 2][1];
                  px = this.vertices[this.vertices.length - 1][0];
                  py = this.vertices[this.vertices.length - 1][1];
                  ctrlX1 = px + (px - ppx);
                  ctrlY1 = py + (py - ppy);
                } else {
                  ctrlX1 = this.vertices[this.vertices.length - 1][0];
                  ctrlY1 = this.vertices[this.vertices.length - 1][1];
                }
                ctrlX2 = tmpArray[j];
                ctrlY2 = tmpArray[j + 1];
                endX = tmpArray[j + 2];
                endY = tmpArray[j + 3];
                this.parsePathCurveto(
                  ctrlX1,
                  ctrlY1,
                  ctrlX2,
                  ctrlY2,
                  endX,
                  endY
                );
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 115) {
            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 4) {
                if (lastInstruction.toLowerCase() === "c" || lastInstruction.toLowerCase() === "s") {
                  ppx = this.vertices[this.vertices.length - 2][0];
                  ppy = this.vertices[this.vertices.length - 2][1];
                  px = this.vertices[this.vertices.length - 1][0];
                  py = this.vertices[this.vertices.length - 1][1];
                  ctrlX1 = px + (px - ppx);
                  ctrlY1 = py + (py - ppy);
                } else {
                  ctrlX1 = this.vertices[this.vertices.length - 1][0];
                  ctrlY1 = this.vertices[this.vertices.length - 1][1];
                }
                ctrlX2 = cx + tmpArray[j];
                ctrlY2 = cy + tmpArray[j + 1];
                endX = cx + tmpArray[j + 2];
                endY = cy + tmpArray[j + 3];
                this.parsePathCurveto(
                  ctrlX1,
                  ctrlY1,
                  ctrlX2,
                  ctrlY2,
                  endX,
                  endY
                );
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 81) {
            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 4) {
                ctrlX = tmpArray[j];
                ctrlY = tmpArray[j + 1];
                endX = tmpArray[j + 2];
                endY = tmpArray[j + 3];
                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 113) {
            if (tmpArray.length >= 4 && tmpArray.length % 4 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 4) {
                ctrlX = cx + tmpArray[j];
                ctrlY = cy + tmpArray[j + 1];
                endX = cx + tmpArray[j + 2];
                endY = cy + tmpArray[j + 3];
                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 84) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 2) {
                if (lastInstruction.toLowerCase() === "q" || lastInstruction.toLowerCase() === "t") {
                  ppx = this.vertices[this.vertices.length - 2][0];
                  ppy = this.vertices[this.vertices.length - 2][1];
                  px = this.vertices[this.vertices.length - 1][0];
                  py = this.vertices[this.vertices.length - 1][1];
                  ctrlX = px + (px - ppx);
                  ctrlY = py + (py - ppy);
                } else {
                  ctrlX = cx;
                  ctrlY = cy;
                }
                endX = tmpArray[j];
                endY = tmpArray[j + 1];
                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 116) {
            if (tmpArray.length >= 2 && tmpArray.length % 2 === 0) {
              for (j = 0, k = tmpArray.length; j < k; j += 2) {
                if (lastInstruction.toLowerCase() === "q" || lastInstruction.toLowerCase() === "t") {
                  ppx = this.vertices[this.vertices.length - 2][0];
                  ppy = this.vertices[this.vertices.length - 2][1];
                  px = this.vertices[this.vertices.length - 1][0];
                  py = this.vertices[this.vertices.length - 1][1];
                  ctrlX = px + (px - ppx);
                  ctrlY = py + (py - ppy);
                } else {
                  ctrlX = cx;
                  ctrlY = cy;
                }
                endX = cx + tmpArray[j];
                endY = cy + tmpArray[j + 1];
                this.parsePathQuadto(cx, cy, ctrlX, ctrlY, endX, endY);
                cx = endX;
                cy = endY;
              }
            }
          } else if (valOf === 90 || valOf === 122) {
            this.close = true;
          }
          lastInstruction = command.toString();
        } else {
          i++;
        }
      }
    };
    PShapeSVG2.prototype.parsePathQuadto = function(x1, y1, cx, cy, x2, y2) {
      if (this.vertices.length > 0) {
        this.parsePathCode(PConstants3.BEZIER_VERTEX);
        this.parsePathVertex(x1 + (cx - x1) * 2 / 3, y1 + (cy - y1) * 2 / 3);
        this.parsePathVertex(x2 + (cx - x2) * 2 / 3, y2 + (cy - y2) * 2 / 3);
        this.parsePathVertex(x2, y2);
      } else {
        throw "Path must start with M/m";
      }
    };
    PShapeSVG2.prototype.parsePathCurveto = function(x1, y1, x2, y2, x3, y3) {
      if (this.vertices.length > 0) {
        this.parsePathCode(PConstants3.BEZIER_VERTEX);
        this.parsePathVertex(x1, y1);
        this.parsePathVertex(x2, y2);
        this.parsePathVertex(x3, y3);
      } else {
        throw "Path must start with M/m";
      }
    };
    PShapeSVG2.prototype.parsePathLineto = function(px, py) {
      if (this.vertices.length > 0) {
        this.parsePathCode(PConstants3.VERTEX);
        this.parsePathVertex(px, py);
        this.vertices[this.vertices.length - 1].moveTo = false;
      } else {
        throw "Path must start with M/m";
      }
    };
    PShapeSVG2.prototype.parsePathMoveto = function(px, py) {
      if (this.vertices.length > 0) {
        this.parsePathCode(PConstants3.BREAK);
      }
      this.parsePathCode(PConstants3.VERTEX);
      this.parsePathVertex(px, py);
      this.vertices[this.vertices.length - 1].moveTo = true;
    };
    PShapeSVG2.prototype.parsePathVertex = function(x, y) {
      var verts = [];
      verts[0] = x;
      verts[1] = y;
      this.vertices.push(verts);
    };
    PShapeSVG2.prototype.parsePathCode = function(what) {
      this.vertexCodes.push(what);
    };
    PShapeSVG2.prototype.parsePoly = function(val) {
      this.family = PConstants3.PATH;
      this.close = val;
      var pointsAttr = CommonFunctions.trim(this.element.getStringAttribute("points").replace(/[,\s]+/g, " "));
      if (pointsAttr !== null) {
        var pointsBuffer = pointsAttr.split(" ");
        if (pointsBuffer.length % 2 === 0) {
          for (var i = 0, j = pointsBuffer.length; i < j; i++) {
            var verts = [];
            verts[0] = pointsBuffer[i];
            verts[1] = pointsBuffer[++i];
            this.vertices.push(verts);
          }
        } else {
          throw "Error parsing polygon points: odd number of coordinates provided";
        }
      }
    };
    PShapeSVG2.prototype.parseRect = function() {
      this.kind = PConstants3.RECT;
      this.family = PConstants3.PRIMITIVE;
      this.params = [];
      this.params[0] = this.element.getFloatAttribute("x");
      this.params[1] = this.element.getFloatAttribute("y");
      this.params[2] = this.element.getFloatAttribute("width");
      this.params[3] = this.element.getFloatAttribute("height");
      if (this.params[2] < 0 || this.params[3] < 0) {
        throw "svg error: negative width or height found while parsing <rect>";
      }
    };
    PShapeSVG2.prototype.parseEllipse = function(val) {
      this.kind = PConstants3.ELLIPSE;
      this.family = PConstants3.PRIMITIVE;
      this.params = [];
      this.params[0] = this.element.getFloatAttribute("cx") | 0;
      this.params[1] = this.element.getFloatAttribute("cy") | 0;
      var rx, ry;
      if (val) {
        rx = ry = this.element.getFloatAttribute("r");
        if (rx < 0) {
          throw "svg error: negative radius found while parsing <circle>";
        }
      } else {
        rx = this.element.getFloatAttribute("rx");
        ry = this.element.getFloatAttribute("ry");
        if (rx < 0 || ry < 0) {
          throw "svg error: negative x-axis radius or y-axis radius found while parsing <ellipse>";
        }
      }
      this.params[0] -= rx;
      this.params[1] -= ry;
      this.params[2] = rx * 2;
      this.params[3] = ry * 2;
    };
    PShapeSVG2.prototype.parseLine = function() {
      this.kind = PConstants3.LINE;
      this.family = PConstants3.PRIMITIVE;
      this.params = [];
      this.params[0] = this.element.getFloatAttribute("x1");
      this.params[1] = this.element.getFloatAttribute("y1");
      this.params[2] = this.element.getFloatAttribute("x2");
      this.params[3] = this.element.getFloatAttribute("y2");
    };
    PShapeSVG2.prototype.parseColors = function(element) {
      if (element.hasAttribute("opacity")) {
        this.setOpacity(element.getAttribute("opacity"));
      }
      if (element.hasAttribute("stroke")) {
        this.setStroke(element.getAttribute("stroke"));
      }
      if (element.hasAttribute("stroke-width")) {
        this.setStrokeWeight(element.getAttribute("stroke-width"));
      }
      if (element.hasAttribute("stroke-linejoin")) {
        this.setStrokeJoin(element.getAttribute("stroke-linejoin"));
      }
      if (element.hasAttribute("stroke-linecap")) {
        this.setStrokeCap(element.getStringAttribute("stroke-linecap"));
      }
      if (element.hasAttribute("fill")) {
        this.setFill(element.getStringAttribute("fill"));
      }
      if (element.hasAttribute("style")) {
        var styleText = element.getStringAttribute("style");
        var styleTokens = styleText.toString().split(";");
        for (var i = 0, j = styleTokens.length; i < j; i++) {
          var tokens = CommonFunctions.trim(styleTokens[i].split(":"));
          if (tokens[0] === "fill") {
            this.setFill(tokens[1]);
          } else if (tokens[0] === "fill-opacity") {
            this.setFillOpacity(tokens[1]);
          } else if (tokens[0] === "stroke") {
            this.setStroke(tokens[1]);
          } else if (tokens[0] === "stroke-width") {
            this.setStrokeWeight(tokens[1]);
          } else if (tokens[0] === "stroke-linecap") {
            this.setStrokeCap(tokens[1]);
          } else if (tokens[0] === "stroke-linejoin") {
            this.setStrokeJoin(tokens[1]);
          } else if (tokens[0] === "stroke-opacity") {
            this.setStrokeOpacity(tokens[1]);
          } else if (tokens[0] === "opacity") {
            this.setOpacity(tokens[1]);
          }
        }
      }
    };
    PShapeSVG2.prototype.setFillOpacity = function(opacityText) {
      this.fillOpacity = parseFloat(opacityText);
      this.fillColor = this.fillOpacity * 255 << 24 | this.fillColor & 16777215;
    };
    PShapeSVG2.prototype.setFill = function(fillText) {
      var opacityMask = this.fillColor & 4278190080;
      if (fillText === "none") {
        this.fill = false;
      } else if (fillText.indexOf("#") === 0) {
        this.fill = true;
        if (fillText.length === 4) {
          fillText = fillText.replace(/#(.)(.)(.)/, "#$1$1$2$2$3$3");
        }
        this.fillColor = opacityMask | parseInt(fillText.substring(1), 16) & 16777215;
      } else if (fillText.indexOf("rgb") === 0) {
        this.fill = true;
        this.fillColor = opacityMask | this.parseRGB(fillText);
      } else if (fillText.indexOf("url(#") === 0) {
        this.fillName = fillText.substring(5, fillText.length - 1);
      } else if (colors[fillText]) {
        this.fill = true;
        this.fillColor = opacityMask | parseInt(colors[fillText].substring(1), 16) & 16777215;
      }
    };
    PShapeSVG2.prototype.setOpacity = function(opacity) {
      this.strokeColor = parseFloat(opacity) * 255 << 24 | this.strokeColor & 16777215;
      this.fillColor = parseFloat(opacity) * 255 << 24 | this.fillColor & 16777215;
    };
    PShapeSVG2.prototype.setStroke = function(strokeText) {
      var opacityMask = this.strokeColor & 4278190080;
      if (strokeText === "none") {
        this.stroke = false;
      } else if (strokeText.charAt(0) === "#") {
        this.stroke = true;
        if (strokeText.length === 4) {
          strokeText = strokeText.replace(/#(.)(.)(.)/, "#$1$1$2$2$3$3");
        }
        this.strokeColor = opacityMask | parseInt(strokeText.substring(1), 16) & 16777215;
      } else if (strokeText.indexOf("rgb") === 0) {
        this.stroke = true;
        this.strokeColor = opacityMask | this.parseRGB(strokeText);
      } else if (strokeText.indexOf("url(#") === 0) {
        this.strokeName = strokeText.substring(5, strokeText.length - 1);
      } else if (colors[strokeText]) {
        this.stroke = true;
        this.strokeColor = opacityMask | parseInt(colors[strokeText].substring(1), 16) & 16777215;
      }
    };
    PShapeSVG2.prototype.setStrokeWeight = function(weight) {
      this.strokeWeight = this.parseUnitSize(weight);
    };
    PShapeSVG2.prototype.setStrokeJoin = function(linejoin) {
      if (linejoin === "miter") {
        this.strokeJoin = PConstants3.MITER;
      } else if (linejoin === "round") {
        this.strokeJoin = PConstants3.ROUND;
      } else if (linejoin === "bevel") {
        this.strokeJoin = PConstants3.BEVEL;
      }
    };
    PShapeSVG2.prototype.setStrokeCap = function(linecap) {
      if (linecap === "butt") {
        this.strokeCap = PConstants3.SQUARE;
      } else if (linecap === "round") {
        this.strokeCap = PConstants3.ROUND;
      } else if (linecap === "square") {
        this.strokeCap = PConstants3.PROJECT;
      }
    };
    PShapeSVG2.prototype.setStrokeOpacity = function(opacityText) {
      this.strokeOpacity = parseFloat(opacityText);
      this.strokeColor = this.strokeOpacity * 255 << 24 | this.strokeColor & 16777215;
    };
    PShapeSVG2.prototype.parseRGB = function(color) {
      var sub = color.substring(color.indexOf("(") + 1, color.indexOf(")"));
      var values = sub.split(", ");
      return values[0] << 16 | values[1] << 8 | values[2];
    };
    PShapeSVG2.prototype.parseUnitSize = function(text) {
      var len = text.length - 2;
      if (len < 0) {
        return text;
      }
      if (text.indexOf("pt") === len) {
        return parseFloat(text.substring(0, len)) * 1.25;
      }
      if (text.indexOf("pc") === len) {
        return parseFloat(text.substring(0, len)) * 15;
      }
      if (text.indexOf("mm") === len) {
        return parseFloat(text.substring(0, len)) * 3.543307;
      }
      if (text.indexOf("cm") === len) {
        return parseFloat(text.substring(0, len)) * 35.43307;
      }
      if (text.indexOf("in") === len) {
        return parseFloat(text.substring(0, len)) * 90;
      }
      if (text.indexOf("px") === len) {
        return parseFloat(text.substring(0, len));
      }
      return parseFloat(text);
    };
    return PShapeSVG2;
  }
  var PShapeSVG_default = PShapeSVG;

  // src/P5Functions/commonFunctions.js
  function commonFunctions(undef) {
    var CommonFunctions = {
      /**
       * Remove whitespace characters from the beginning and ending
       * of a String or a String array. Works like String.trim() but includes the
       * unicode nbsp character as well. If an array is passed in the function will return a new array not effecting the array passed in.
       *
       * @param {String} str    the string to trim
       * @param {String[]} str  the string array to trim
       *
       * @return {String|String[]} retrurns a string or an array will removed whitespaces
       */
      trim: function(str) {
        if (str instanceof Array) {
          var arr = [];
          for (var i = 0; i < str.length; i++) {
            arr.push(str[i].replace(/^\s*/, "").replace(/\s*$/, "").replace(/\r*$/, ""));
          }
          return arr;
        }
        return str.replace(/^\s*/, "").replace(/\s*$/, "").replace(/\r*$/, "");
      },
      /**
       * Converts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of
       * measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example,
       * 90 degrees = PI/2 = 1.5707964. All trigonometric methods in Processing require their parameters to be specified in radians.
       *
       * @param {int|float} value        an angle in radians
       *
       * @returns {float}
       *
       * @see degrees
       */
      radians: function(aAngle) {
        return aAngle / 180 * Math.PI;
      },
      /**
       * Number-to-String formatting function. Prepends "plus" or "minus" depending
       * on whether the value is positive or negative, respectively, after padding
       * the value with zeroes on the left and right, the number of zeroes used dictated
       * by the values 'leftDigits' and 'rightDigits'. 'value' cannot be an array.
       *
       * @param {int|float} value                 the number to format
       * @param {String} plus                     the prefix for positive numbers
       * @param {String} minus                    the prefix for negative numbers
       * @param {int} left                        number of digits to the left of the decimal point
       * @param {int} right                       number of digits to the right of the decimal point
       * @param {String} group                    string delimited for groups, such as the comma in "1,000"
       *
       * @returns {String or String[]}
       *
       * @see nfCore
       */
      nfCoreScalar: function(value, plus, minus, leftDigits, rightDigits, group) {
        var sign2 = value < 0 ? minus : plus;
        var autoDetectDecimals = rightDigits === 0;
        var rightDigitsOfDefault = rightDigits === undef || rightDigits < 0 ? 0 : rightDigits;
        var absValue = Math.abs(value);
        if (autoDetectDecimals) {
          rightDigitsOfDefault = 1;
          absValue *= 10;
          while (Math.abs(Math.round(absValue) - absValue) > 1e-6 && rightDigitsOfDefault < 7) {
            ++rightDigitsOfDefault;
            absValue *= 10;
          }
        } else if (rightDigitsOfDefault !== 0) {
          absValue *= Math.pow(10, rightDigitsOfDefault);
        }
        var number, doubled = absValue * 2;
        if (Math.floor(absValue) === absValue) {
          number = absValue;
        } else if (Math.floor(doubled) === doubled) {
          var floored = Math.floor(absValue);
          number = floored + floored % 2;
        } else {
          number = Math.round(absValue);
        }
        var buffer = "";
        var totalDigits = leftDigits + rightDigitsOfDefault;
        while (totalDigits > 0 || number > 0) {
          totalDigits--;
          buffer = "" + number % 10 + buffer;
          number = Math.floor(number / 10);
        }
        if (group !== undef) {
          var i = buffer.length - 3 - rightDigitsOfDefault;
          while (i > 0) {
            buffer = buffer.substring(0, i) + group + buffer.substring(i);
            i -= 3;
          }
        }
        if (rightDigitsOfDefault > 0) {
          return sign2 + buffer.substring(0, buffer.length - rightDigitsOfDefault) + "." + buffer.substring(buffer.length - rightDigitsOfDefault, buffer.length);
        }
        return sign2 + buffer;
      },
      /**
      * Number-to-String formatting function. Prepends "plus" or "minus" depending
      * on whether the value is positive or negative, respectively, after padding
      * the value with zeroes on the left and right, the number of zeroes used dictated
      * by the values 'leftDigits' and 'rightDigits'. 'value' can be an array;
      * if the input is an array, each value in it is formatted separately, and
      * an array with formatted values is returned.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {String} plus                     the prefix for positive numbers
      * @param {String} minus                    the prefix for negative numbers
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      * @param {String} group                    string delimited for groups, such as the comma in "1,000"
      *
      * @returns {String or String[]}
      *
      * @see nfCoreScalar
      */
      nfCore: function(value, plus, minus, leftDigits, rightDigits, group) {
        if (value instanceof Array) {
          var arr = [];
          for (var i = 0, len = value.length; i < len; i++) {
            arr.push(CommonFunctions.nfCoreScalar(value[i], plus, minus, leftDigits, rightDigits, group));
          }
          return arr;
        }
        return CommonFunctions.nfCoreScalar(value, plus, minus, leftDigits, rightDigits, group);
      },
      /**
      * Utility function for formatting numbers into strings. There are two versions, one for
      * formatting floats and one for formatting ints. The values for the digits, left, and
      * right parameters should always be positive integers.
      * As shown in the above example, nf() is used to add zeros to the left and/or right
      * of a number. This is typically for aligning a list of numbers. To remove digits from
      * a floating-point number, use the int(), ceil(), floor(), or round() functions.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      *
      * @returns {String or String[]}
      *
      * @see nfs
      * @see nfp
      * @see nfc
      */
      nf: function(value, leftDigits, rightDigits) {
        return CommonFunctions.nfCore(value, "", "-", leftDigits, rightDigits);
      },
      /**
      * Utility function for formatting numbers into strings. Similar to nf()  but leaves a blank space in front
      * of positive numbers so they align with negative numbers in spite of the minus symbol. There are two
      * versions, one for formatting floats and one for formatting ints. The values for the digits, left,
      * and right parameters should always be positive integers.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      *
      * @returns {String or String[]}
      *
      * @see nf
      * @see nfp
      * @see nfc
      */
      nfs: function(value, leftDigits, rightDigits) {
        return CommonFunctions.nfCore(value, " ", "-", leftDigits, rightDigits);
      },
      /**
      * Utility function for formatting numbers into strings. Similar to nf()  but puts a "+" in front of
      * positive numbers and a "-" in front of negative numbers. There are two versions, one for formatting
      * floats and one for formatting ints. The values for the digits, left, and right parameters should
      * always be positive integers.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      *
      * @returns {String or String[]}
      *
      * @see nfs
      * @see nf
      * @see nfc
      */
      nfp: function(value, leftDigits, rightDigits) {
        return CommonFunctions.nfCore(value, "+", "-", leftDigits, rightDigits);
      },
      /**
      * Utility function for formatting numbers into strings and placing appropriate commas to mark
      * units of 1000. There are two versions, one for formatting ints and one for formatting an array
      * of ints. The value for the digits parameter should always be a positive integer.
      *
      * @param {int|int[]|float|float[]} value   the number(s) to format
      * @param {int} left                        number of digits to the left of the decimal point
      * @param {int} right                       number of digits to the right of the decimal point
      *
      * @returns {String or String[]}
      *
      * @see nf
      * @see nfs
      * @see nfp
      */
      nfc: function(value, rightDigits) {
        return CommonFunctions.nfCore(value, "", "-", 0, rightDigits, ",");
      },
      // used to bind all common functions to "p"
      withCommonFunctions: function withCommonFunctions(p) {
        ["trim", "radians", "nf", "nfs", "nfp", "nfc"].forEach(function(f) {
          p[f] = CommonFunctions[f];
        });
      }
    };
    return CommonFunctions;
  }

  // src/Helpers/defaultScope.js
  function defaultScope_default(options) {
    function DefaultScope() {
    }
    DefaultScope.prototype = options.PConstants;
    var defaultScope2 = new DefaultScope();
    Object.keys(options).forEach(function(prop) {
      defaultScope2[prop] = options[prop];
    });
    defaultScope2.defineProperty = function(obj, name, desc) {
      if ("defineProperty" in Object) {
        Object.defineProperty(obj, name, desc);
      } else {
        if (desc.hasOwnProperty("get")) {
          obj.__defineGetter__(name, desc.get);
        }
        if (desc.hasOwnProperty("set")) {
          obj.__defineSetter__(name, desc.set);
        }
      }
    };
    function overloadBaseClassFunction(object, name, basefn) {
      if (!object.hasOwnProperty(name) || typeof object[name] !== "function") {
        object[name] = basefn;
        return;
      }
      var fn = object[name];
      if ("$overloads" in fn) {
        fn.$defaultOverload = basefn;
        return;
      }
      if (!("$overloads" in basefn) && fn.length === basefn.length) {
        return;
      }
      var overloads, defaultOverload;
      if ("$overloads" in basefn) {
        overloads = basefn.$overloads.slice(0);
        overloads[fn.length] = fn;
        defaultOverload = basefn.$defaultOverload;
      } else {
        overloads = [];
        overloads[basefn.length] = basefn;
        overloads[fn.length] = fn;
        defaultOverload = fn;
      }
      var hubfn = function() {
        var fn2 = hubfn.$overloads[arguments.length] || ("$methodArgsIndex" in hubfn && arguments.length > hubfn.$methodArgsIndex ? hubfn.$overloads[hubfn.$methodArgsIndex] : null) || hubfn.$defaultOverload;
        return fn2.apply(this, arguments);
      };
      hubfn.$overloads = overloads;
      if ("$methodArgsIndex" in basefn) {
        hubfn.$methodArgsIndex = basefn.$methodArgsIndex;
      }
      hubfn.$defaultOverload = defaultOverload;
      Object.defineProperty(hubfn, "name", { value: name, writable: false });
      object[name] = hubfn;
    }
    function extendClass(subClass, baseClass) {
      function extendGetterSetter(propertyName2) {
        defaultScope2.defineProperty(subClass, propertyName2, {
          get: function() {
            return baseClass[propertyName2];
          },
          set: function(v) {
            baseClass[propertyName2] = v;
          },
          enumerable: true
        });
      }
      var properties = [];
      for (var propertyName in baseClass) {
        if (typeof baseClass[propertyName] === "function") {
          overloadBaseClassFunction(subClass, propertyName, baseClass[propertyName]);
        } else if (propertyName.charAt(0) !== "$" && !(propertyName in subClass)) {
          properties.push(propertyName);
        }
      }
      while (properties.length > 0) {
        extendGetterSetter(properties.shift());
      }
      subClass.$super = baseClass;
    }
    defaultScope2.extendClassChain = function(base) {
      var path = [base];
      for (var self2 = base.$upcast; self2; self2 = self2.$upcast) {
        extendClass(self2, base);
        path.push(self2);
        base = self2;
      }
      while (path.length > 0) {
        path.pop().$self = base;
      }
    };
    defaultScope2.extendStaticMembers = function(derived, base) {
      extendClass(derived, base);
    };
    defaultScope2.extendInterfaceMembers = function(derived, base) {
      extendClass(derived, base);
    };
    defaultScope2.addMethod = function(object, name, fn, hasMethodArgs) {
      var existingfn = object[name];
      if (existingfn || hasMethodArgs) {
        var args = fn.length;
        if ("$overloads" in existingfn) {
          existingfn.$overloads[args] = fn;
        } else {
          var hubfn = function() {
            var fn2 = hubfn.$overloads[arguments.length] || ("$methodArgsIndex" in hubfn && arguments.length > hubfn.$methodArgsIndex ? hubfn.$overloads[hubfn.$methodArgsIndex] : null) || hubfn.$defaultOverload;
            return fn2.apply(this, arguments);
          };
          var overloads = [];
          if (existingfn) {
            overloads[existingfn.length] = existingfn;
          }
          overloads[args] = fn;
          hubfn.$overloads = overloads;
          hubfn.$defaultOverload = existingfn || fn;
          if (hasMethodArgs) {
            hubfn.$methodArgsIndex = args;
          }
          Object.defineProperty(hubfn, "name", { value: name, writable: false });
          object[name] = hubfn;
        }
      } else {
        object[name] = fn;
      }
    };
    function isNumericalJavaType(type) {
      if (typeof type !== "string") {
        return false;
      }
      return ["byte", "int", "char", "color", "float", "long", "double"].indexOf(type) !== -1;
    }
    defaultScope2.createJavaArray = function(type, bounds) {
      var result = null, defaultValue = null;
      if (typeof type === "string") {
        if (type === "boolean") {
          defaultValue = false;
        } else if (isNumericalJavaType(type)) {
          defaultValue = 0;
        }
      }
      if (typeof bounds[0] === "number") {
        var itemsCount = 0 | bounds[0];
        if (bounds.length <= 1) {
          result = [];
          result.length = itemsCount;
          for (var i = 0; i < itemsCount; ++i) {
            result[i] = defaultValue;
          }
        } else {
          result = [];
          var newBounds = bounds.slice(1);
          for (var j = 0; j < itemsCount; ++j) {
            result.push(defaultScope2.createJavaArray(type, newBounds));
          }
        }
      }
      return result;
    };
    defaultScope2.defineProperty(
      defaultScope2,
      "screenWidth",
      { get: function() {
        return window.innerWidth;
      } }
    );
    defaultScope2.defineProperty(
      defaultScope2,
      "screenHeight",
      { get: function() {
        return window.innerHeight;
      } }
    );
    return defaultScope2;
  }

  // src/Processing.js
  function Processing2(options, undef) {
    var defaultScope2 = options.defaultScope;
    var extend = options.extend;
    var Browser2 = options.Browser;
    var ajax = Browser2.ajax;
    var navigator2 = Browser2.navigator;
    var window2 = Browser2.window;
    var XMLHttpRequest2 = window2.XMLHttpRequest;
    var document2 = Browser2.document;
    var noop = options.noop;
    var PConstants3 = defaultScope2.PConstants;
    var PFont3 = defaultScope2.PFont;
    var PShapeSVG2 = defaultScope2.PShapeSVG;
    var PVector3 = defaultScope2.PVector;
    var Char2 = defaultScope2.Char;
    var Character = defaultScope2.Char;
    var ObjectIterator2 = defaultScope2.ObjectIterator;
    var XMLElement = defaultScope2.XMLElement;
    var XML = defaultScope2.XML;
    var HTMLCanvasElement = window2.HTMLCanvasElement;
    var HTMLImageElement = window2.HTMLImageElement;
    var localStorage;
    try {
      localStorage = window2.localStorage;
    } catch (e) {
      localStorage = {};
    }
    var isDOMPresent = "document" in this && !("fake" in this.document);
    if (!document2.head) {
      document2.head = document2.getElementsByTagName("head")[0];
    }
    var Float32Array2 = setupTypedArray("Float32Array", "WebGLFloatArray"), Int32Array2 = setupTypedArray("Int32Array", "WebGLIntArray"), Uint16Array2 = setupTypedArray("Uint16Array", "WebGLUnsignedShortArray"), Uint8Array2 = setupTypedArray("Uint8Array", "WebGLUnsignedByteArray");
    function setupTypedArray(name, fallback) {
      if (name in window2) {
        return window2[name];
      }
      if (typeof window2[fallback] === "function") {
        return window2[fallback];
      }
      return function(obj) {
        if (obj instanceof Array) {
          return obj;
        }
        if (typeof obj === "number") {
          var arr = [];
          arr.length = obj;
          return arr;
        }
      };
    }
    if (document2.documentMode >= 9 && !document2.doctype) {
      throw "The doctype directive is missing. The recommended doctype in Internet Explorer is the HTML5 doctype: <!DOCTYPE html>";
    }
    var processingInstances = [];
    var processingInstanceIds = {};
    var addInstance = function(processing) {
      if (processing.externals.canvas.id === undef || !processing.externals.canvas.id.length) {
        processing.externals.canvas.id = "__processing" + processingInstances.length;
      }
      processingInstanceIds[processing.externals.canvas.id] = processingInstances.length;
      processingInstances.push(processing);
    };
    var removeInstance = function(id) {
      processingInstances.splice(processingInstanceIds[id], 1);
      delete processingInstanceIds[id];
    };
    var Processing3 = this.Processing = function(aCanvas, aCode, aFunctions) {
      if (!(this instanceof Processing3)) {
        throw "called Processing constructor as if it were a function: missing 'new'.";
      }
      var curElement = {}, pgraphicsMode = aCanvas === undef && aCode === undef;
      if (pgraphicsMode) {
        curElement = document2.createElement("canvas");
      } else {
        curElement = typeof aCanvas === "string" ? document2.getElementById(aCanvas) : aCanvas;
      }
      if (!("getContext" in curElement)) {
        throw "called Processing constructor without passing canvas element reference or id.";
      }
      function unimplemented2(s) {
        Processing3.debug("Unimplemented - " + s);
      }
      var eventHandlers = [];
      function attachEventHandler(elem, type, fn) {
        if (elem.addEventListener) {
          elem.addEventListener(type, fn, false);
        } else {
          elem.attachEvent("on" + type, fn);
        }
        eventHandlers.push({ elem, type, fn });
      }
      function detachEventHandler2(eventHandler) {
        var elem = eventHandler.elem, type = eventHandler.type, fn = eventHandler.fn;
        if (elem.removeEventListener) {
          elem.removeEventListener(type, fn, false);
        } else if (elem.detachEvent) {
          elem.detachEvent("on" + type, fn);
        }
      }
      function detachEventHandlersByType(element, types) {
        Object.keys(eventHandlers).forEach(function(eventHandler) {
          if (types.indexOf(eventHandler.type) > -1 && eventHandler.elem == element) {
            detachEventHandler2(eventHandler.type);
          }
        });
      }
      function removeFirstArgument(args) {
        return Array.prototype.slice.call(args, 1);
      }
      var p = this;
      p.Char = p.Character = Char2;
      eventHandlers = [];
      extend.withCommonFunctions(p);
      extend.withMath(p);
      extend.withProxyFunctions(p, removeFirstArgument);
      extend.withTouch(p, curElement, attachEventHandler, detachEventHandlersByType, document2, PConstants3);
      if (aFunctions) {
        Object.keys(aFunctions).forEach(function(name) {
          p[name] = aFunctions[name];
        });
      }
      p.externals = {
        canvas: curElement,
        context: undef,
        sketch: undef,
        window: window2
      };
      p.name = "Processing.js Instance";
      p.use3DContext = false;
      p.focused = false;
      p.breakShape = false;
      p.glyphTable = {};
      p.pmouseX = 0;
      p.pmouseY = 0;
      p.mouseX = 0;
      p.mouseY = 0;
      p.mouseButton = 0;
      p.mouseScroll = 0;
      p.mouseClicked = undef;
      p.mouseDragged = undef;
      p.mouseMoved = undef;
      p.mousePressed = undef;
      p.mouseReleased = undef;
      p.mouseScrolled = undef;
      p.mouseOver = undef;
      p.mouseOut = undef;
      p.touchStart = undef;
      p.touchEnd = undef;
      p.touchMove = undef;
      p.touchCancel = undef;
      p.key = undef;
      p.keyCode = undef;
      p.keyPressed = noop;
      p.keyReleased = noop;
      p.keyTyped = noop;
      p.draw = undef;
      p.setup = undef;
      p.__mousePressed = false;
      p.__keyPressed = false;
      p.__frameRate = 60;
      p.frameCount = 0;
      p.width = 100;
      p.height = 100;
      var curContext, curSketch, drawing, doFill = true, fillStyle = [1, 1, 1, 1], currentFillColor = 4294967295, isFillDirty = true, doStroke = true, strokeStyle = [0, 0, 0, 1], currentStrokeColor = 4278190080, isStrokeDirty = true, lineWidth = 1, loopStarted = false, renderSmooth = false, doLoop = true, looping = 0, curRectMode = PConstants3.CORNER, curEllipseMode2 = PConstants3.CENTER, normalX = 0, normalY = 0, normalZ = 0, normalMode = PConstants3.NORMAL_MODE_AUTO, curFrameRate = 60, curMsPerFrame = 1e3 / curFrameRate, curCursor = PConstants3.ARROW, oldCursor = curElement.style.cursor, curShape = PConstants3.POLYGON, curShapeCount = 0, curvePoints = [], curTightness = 0, curveDet = 20, curveInited = false, backgroundObj = -3355444, bezDetail = 20, colorModeA = 255, colorModeX = 255, colorModeY = 255, colorModeZ = 255, pathOpen = false, mouseDragging = false, pmouseXLastFrame = 0, pmouseYLastFrame = 0, curColorMode = PConstants3.RGB, curTint = null, curTint3d = null, getLoaded = false, start = Date.now(), timeSinceLastFPS = start, framesSinceLastFPS = 0, textcanvas, curveBasisMatrix, curveToBezierMatrix, curveDrawMatrix, bezierDrawMatrix, bezierBasisInverse, bezierBasisMatrix, curContextCache = { attributes: {}, locations: {} }, programObject3D, programObject2D, programObjectUnlitShape, boxBuffer, boxNormBuffer, boxOutlineBuffer, rectBuffer, rectNormBuffer, sphereBuffer, lineBuffer, fillBuffer, fillColorBuffer, strokeColorBuffer, pointBuffer, shapeTexVBO, canTex, textTex, curTexture = { width: 0, height: 0 }, curTextureMode = PConstants3.IMAGE, usingTexture = false, textBuffer, textureBuffer, indexBuffer, horizontalTextAlignment = PConstants3.LEFT, verticalTextAlignment = PConstants3.BASELINE, textMode = PConstants3.MODEL, curFontName = "Arial", curTextSize = 12, curTextAscent = 9, curTextDescent = 2, curTextLeading = 14, curTextFont = PFont3.get(curFontName, curTextSize), originalContext, proxyContext = null, isContextReplaced = false, setPixelsCached, maxPixelsCached = 1e3, pressedKeysMap = [], lastPressedKeyCode = null, codedKeys = [
        PConstants3.SHIFT,
        PConstants3.CONTROL,
        PConstants3.ALT,
        PConstants3.CAPSLK,
        PConstants3.PGUP,
        PConstants3.PGDN,
        PConstants3.END,
        PConstants3.HOME,
        PConstants3.LEFT,
        PConstants3.UP,
        PConstants3.RIGHT,
        PConstants3.DOWN,
        PConstants3.NUMLK,
        PConstants3.INSERT,
        PConstants3.F1,
        PConstants3.F2,
        PConstants3.F3,
        PConstants3.F4,
        PConstants3.F5,
        PConstants3.F6,
        PConstants3.F7,
        PConstants3.F8,
        PConstants3.F9,
        PConstants3.F10,
        PConstants3.F11,
        PConstants3.F12,
        PConstants3.META
      ];
      var lightCount = 0;
      var sphereDetailV = 0, sphereDetailU = 0, sphereX = [], sphereY = [], sphereZ = [], sinLUT = new Float32Array2(PConstants3.SINCOS_LENGTH), cosLUT = new Float32Array2(PConstants3.SINCOS_LENGTH), sphereVerts, sphereNorms;
      var cam, cameraInv, modelView, modelViewInv, userMatrixStack, userReverseMatrixStack, inverseCopy2, projection, manipulatingCamera = false, frustumMode = false, cameraFOV = 60 * (Math.PI / 180), cameraX = p.width / 2, cameraY = p.height / 2, cameraZ = cameraY / Math.tan(cameraFOV / 2), cameraNear = cameraZ / 10, cameraFar = cameraZ * 10, cameraAspect = p.width / p.height;
      var vertArray2 = [], curveVertArray = [], curveVertCount = 0, isCurve = false, isBezier = false, firstVert = true;
      var curShapeMode = PConstants3.CORNER;
      var styleArray = [];
      var boxVerts = new Float32Array2([
        0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5
      ]);
      var boxOutlineVerts = new Float32Array2([
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        -0.5,
        0.5,
        -0.5,
        -0.5,
        0.5,
        0.5,
        -0.5,
        0.5
      ]);
      var boxNorms = new Float32Array2([
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        -1,
        0,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0
      ]);
      var rectVerts = new Float32Array2([0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0]);
      var rectNorms = new Float32Array2([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
      var vertexShaderSrcUnlitShape = "varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec4 aColor;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;void main(void) {  vFrontColor = aColor;  gl_PointSize = uPointSize;  gl_Position = uProjection * uView * vec4(aVertex, 1.0);}";
      var fragmentShaderSrcUnlitShape = "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 vFrontColor;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  gl_FragColor = vFrontColor;}";
      var vertexShaderSrc2D = "varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec2 aTextureCoord;uniform vec4 uColor;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;varying vec2 vTextureCoord;void main(void) {  gl_PointSize = uPointSize;  vFrontColor = uColor;  gl_Position = uProjection * uView * uModel * vec4(aVertex, 1.0);  vTextureCoord = aTextureCoord;}";
      var fragmentShaderSrc2D = "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 vFrontColor;varying vec2 vTextureCoord;uniform sampler2D uSampler;uniform int uIsDrawingText;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  if(uIsDrawingText == 1){    float alpha = texture2D(uSampler, vTextureCoord).a;    gl_FragColor = vec4(vFrontColor.rgb * alpha, alpha);  }  else{    gl_FragColor = vFrontColor;  }}";
      var webglMaxTempsWorkaround = /Windows/.test(navigator2.userAgent);
      var vertexShaderSrc3D = "varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec3 aNormal;attribute vec4 aColor;attribute vec2 aTexture;varying   vec2 vTexture;uniform vec4 uColor;uniform bool uUsingMat;uniform vec3 uSpecular;uniform vec3 uMaterialEmissive;uniform vec3 uMaterialAmbient;uniform vec3 uMaterialSpecular;uniform float uShininess;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform mat4 uNormalTransform;uniform int uLightCount;uniform vec3 uFalloff;struct Light {  int type;  vec3 color;  vec3 position;  vec3 direction;  float angle;  vec3 halfVector;  float concentration;};uniform Light uLights0;uniform Light uLights1;uniform Light uLights2;uniform Light uLights3;uniform Light uLights4;uniform Light uLights5;uniform Light uLights6;uniform Light uLights7;Light getLight(int index){  if(index == 0) return uLights0;  if(index == 1) return uLights1;  if(index == 2) return uLights2;  if(index == 3) return uLights3;  if(index == 4) return uLights4;  if(index == 5) return uLights5;  if(index == 6) return uLights6;  return uLights7;}void AmbientLight( inout vec3 totalAmbient, in vec3 ecPos, in Light light ) {  float d = length( light.position - ecPos );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  totalAmbient += light.color * attenuation;}void DirectionalLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor = 0.0;  float nDotVP = max(0.0, dot( vertNormal, normalize(-light.position) ));  float nDotVH = max(0.0, dot( vertNormal, normalize(-light.position-normalize(ecPos) )));  if( nDotVP != 0.0 ){    powerFactor = pow( nDotVH, uShininess );  }  col += light.color * nDotVP;  spec += uSpecular * powerFactor;}void PointLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor;   vec3 VP = light.position - ecPos;  float d = length( VP );   VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  float nDotVP = max( 0.0, dot( vertNormal, VP ));  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ));  if( nDotVP == 0.0 ) {    powerFactor = 0.0;  }  else {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void SpotLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float spotAttenuation;  float powerFactor = 0.0;  vec3 VP = light.position - ecPos;  vec3 ldir = normalize( -light.direction );  float d = length( VP );  VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ) );  float spotDot = dot( VP, ldir );" + // If the vertex falls inside the cone
      (webglMaxTempsWorkaround ? (
        // Windows reports max temps error if light.angle is used
        "  spotAttenuation = 1.0; "
      ) : "  if( spotDot > cos( light.angle ) ) {    spotAttenuation = pow( spotDot, light.concentration );  }  else{    spotAttenuation = 0.0;  }  attenuation *= spotAttenuation;") + "  float nDotVP = max( 0.0, dot( vertNormal, VP ) );  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ) );  if( nDotVP != 0.0 ) {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void main(void) {  vec3 finalAmbient = vec3( 0.0 );  vec3 finalDiffuse = vec3( 0.0 );  vec3 finalSpecular = vec3( 0.0 );  vec4 col = uColor;  if ( uColor[0] == -1.0 ){    col = aColor;  }  vec3 norm = normalize(vec3( uNormalTransform * vec4( aNormal, 0.0 ) ));  vec4 ecPos4 = uView * uModel * vec4(aVertex, 1.0);  vec3 ecPos = (vec3(ecPos4))/ecPos4.w;  if( uLightCount == 0 ) {    vFrontColor = col + vec4(uMaterialSpecular, 1.0);  }  else {    for( int i = 0; i < 8; i++ ) {      Light l = getLight(i);      if( i >= uLightCount ){        break;      }      if( l.type == 0 ) {        AmbientLight( finalAmbient, ecPos, l );      }      else if( l.type == 1 ) {        DirectionalLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }      else if( l.type == 2 ) {        PointLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }      else {        SpotLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }    }   if( uUsingMat == false ) {     vFrontColor = vec4(       vec3( col ) * finalAmbient +       vec3( col ) * finalDiffuse +       vec3( col ) * finalSpecular,       col[3] );   }   else{     vFrontColor = vec4(        uMaterialEmissive +        (vec3(col) * uMaterialAmbient * finalAmbient ) +        (vec3(col) * finalDiffuse) +        (uMaterialSpecular * finalSpecular),        col[3] );    }  }  vTexture.xy = aTexture.xy;  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );}";
      var fragmentShaderSrc3D = "#ifdef GL_ES\nprecision highp float;\n#endif\nvarying vec4 vFrontColor;uniform sampler2D uSampler;uniform bool uUsingTexture;varying vec2 vTexture;void main(void){  if( uUsingTexture ){    gl_FragColor = vec4(texture2D(uSampler, vTexture.xy)) * vFrontColor;  }  else{    gl_FragColor = vFrontColor;  }}";
      function uniformf(cacheId, programObj, varName, varValue) {
        var varLocation = curContextCache.locations[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getUniformLocation(programObj, varName);
          curContextCache.locations[cacheId] = varLocation;
        }
        if (varLocation !== null) {
          if (varValue.length === 4) {
            curContext.uniform4fv(varLocation, varValue);
          } else if (varValue.length === 3) {
            curContext.uniform3fv(varLocation, varValue);
          } else if (varValue.length === 2) {
            curContext.uniform2fv(varLocation, varValue);
          } else {
            curContext.uniform1f(varLocation, varValue);
          }
        }
      }
      function uniformi(cacheId, programObj, varName, varValue) {
        var varLocation = curContextCache.locations[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getUniformLocation(programObj, varName);
          curContextCache.locations[cacheId] = varLocation;
        }
        if (varLocation !== null) {
          if (varValue.length === 4) {
            curContext.uniform4iv(varLocation, varValue);
          } else if (varValue.length === 3) {
            curContext.uniform3iv(varLocation, varValue);
          } else if (varValue.length === 2) {
            curContext.uniform2iv(varLocation, varValue);
          } else {
            curContext.uniform1i(varLocation, varValue);
          }
        }
      }
      function uniformMatrix(cacheId, programObj, varName, transpose, matrix) {
        var varLocation = curContextCache.locations[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getUniformLocation(programObj, varName);
          curContextCache.locations[cacheId] = varLocation;
        }
        if (varLocation !== -1) {
          if (matrix.length === 16) {
            curContext.uniformMatrix4fv(varLocation, transpose, matrix);
          } else if (matrix.length === 9) {
            curContext.uniformMatrix3fv(varLocation, transpose, matrix);
          } else {
            curContext.uniformMatrix2fv(varLocation, transpose, matrix);
          }
        }
      }
      function vertexAttribPointer(cacheId, programObj, varName, size, VBO) {
        var varLocation = curContextCache.attributes[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getAttribLocation(programObj, varName);
          curContextCache.attributes[cacheId] = varLocation;
        }
        if (varLocation !== -1) {
          curContext.bindBuffer(curContext.ARRAY_BUFFER, VBO);
          curContext.vertexAttribPointer(varLocation, size, curContext.FLOAT, false, 0, 0);
          curContext.enableVertexAttribArray(varLocation);
        }
      }
      function disableVertexAttribPointer(cacheId, programObj, varName) {
        var varLocation = curContextCache.attributes[cacheId];
        if (varLocation === undef) {
          varLocation = curContext.getAttribLocation(programObj, varName);
          curContextCache.attributes[cacheId] = varLocation;
        }
        if (varLocation !== -1) {
          curContext.disableVertexAttribArray(varLocation);
        }
      }
      var createProgramObject = function(curContext2, vetexShaderSource, fragmentShaderSource) {
        var vertexShaderObject = curContext2.createShader(curContext2.VERTEX_SHADER);
        curContext2.shaderSource(vertexShaderObject, vetexShaderSource);
        curContext2.compileShader(vertexShaderObject);
        if (!curContext2.getShaderParameter(vertexShaderObject, curContext2.COMPILE_STATUS)) {
          throw curContext2.getShaderInfoLog(vertexShaderObject);
        }
        var fragmentShaderObject = curContext2.createShader(curContext2.FRAGMENT_SHADER);
        curContext2.shaderSource(fragmentShaderObject, fragmentShaderSource);
        curContext2.compileShader(fragmentShaderObject);
        if (!curContext2.getShaderParameter(fragmentShaderObject, curContext2.COMPILE_STATUS)) {
          throw curContext2.getShaderInfoLog(fragmentShaderObject);
        }
        var programObject = curContext2.createProgram();
        curContext2.attachShader(programObject, vertexShaderObject);
        curContext2.attachShader(programObject, fragmentShaderObject);
        curContext2.linkProgram(programObject);
        if (!curContext2.getProgramParameter(programObject, curContext2.LINK_STATUS)) {
          throw "Error linking shaders.";
        }
        return programObject;
      };
      var imageModeCorner = function(x, y, w, h, whAreSizes) {
        return {
          x,
          y,
          w,
          h
        };
      };
      var imageModeConvert2 = imageModeCorner;
      var imageModeCorners = function(x, y, w, h, whAreSizes) {
        return {
          x,
          y,
          w: whAreSizes ? w : w - x,
          h: whAreSizes ? h : h - y
        };
      };
      var imageModeCenter = function(x, y, w, h, whAreSizes) {
        return {
          x: x - w / 2,
          y: y - h / 2,
          w,
          h
        };
      };
      var DrawingShared = function() {
      };
      var Drawing2D = function() {
      };
      var Drawing3D = function() {
      };
      var DrawingPre = function() {
      };
      Drawing2D.prototype = new DrawingShared();
      Drawing2D.prototype.constructor = Drawing2D;
      Drawing3D.prototype = new DrawingShared();
      Drawing3D.prototype.constructor = Drawing3D;
      DrawingPre.prototype = new DrawingShared();
      DrawingPre.prototype.constructor = DrawingPre;
      DrawingShared.prototype.a3DOnlyFunction = noop;
      p.shape = function(shape, x, y, width, height) {
        if (arguments.length >= 1 && arguments[0] !== null) {
          if (shape.isVisible()) {
            p.pushMatrix();
            if (curShapeMode === PConstants3.CENTER) {
              if (arguments.length === 5) {
                p.translate(x - width / 2, y - height / 2);
                p.scale(width / shape.getWidth(), height / shape.getHeight());
              } else if (arguments.length === 3) {
                p.translate(x - shape.getWidth() / 2, -shape.getHeight() / 2);
              } else {
                p.translate(-shape.getWidth() / 2, -shape.getHeight() / 2);
              }
            } else if (curShapeMode === PConstants3.CORNER) {
              if (arguments.length === 5) {
                p.translate(x, y);
                p.scale(width / shape.getWidth(), height / shape.getHeight());
              } else if (arguments.length === 3) {
                p.translate(x, y);
              }
            } else if (curShapeMode === PConstants3.CORNERS) {
              if (arguments.length === 5) {
                width -= x;
                height -= y;
                p.translate(x, y);
                p.scale(width / shape.getWidth(), height / shape.getHeight());
              } else if (arguments.length === 3) {
                p.translate(x, y);
              }
            }
            shape.draw(p);
            if (arguments.length === 1 && curShapeMode === PConstants3.CENTER || arguments.length > 1) {
              p.popMatrix();
            }
          }
        }
      };
      p.shapeMode = function(mode) {
        curShapeMode = mode;
      };
      p.loadShape = function(filename) {
        if (arguments.length === 1) {
          if (filename.indexOf(".svg") > -1) {
            return new PShapeSVG2(null, filename);
          }
        }
        return null;
      };
      p.loadXML = function(uri) {
        return new XML(p, uri);
      };
      p.parseXML = function(xmlstring) {
        var element = new XML();
        element.parse(xmlstring);
        return element;
      };
      var printMatrixHelper2 = function(elements) {
        var big = 0;
        for (var i2 = 0; i2 < elements.length; i2++) {
          if (i2 !== 0) {
            big = Math.max(big, Math.abs(elements[i2]));
          } else {
            big = Math.abs(elements[i2]);
          }
        }
        var digits = (big + "").indexOf(".");
        if (digits === 0) {
          digits = 1;
        } else if (digits === -1) {
          digits = (big + "").length;
        }
        return digits;
      };
      var PMatrix2D2 = p.PMatrix2D = function() {
        if (arguments.length === 0) {
          this.reset();
        } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
          this.set(arguments[0].array());
        } else if (arguments.length === 6) {
          this.set(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
      };
      PMatrix2D2.prototype = {
        /**
         * @member PMatrix2D
         * The set() function sets the matrix elements. The function accepts either another PMatrix2D, an array of elements, or a list of six floats.
         *
         * @param {PMatrix2D} matrix    the matrix to set this matrix to
         * @param {float[]} elements    an array of elements to set this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the third element of the matrix
         * @param {float} m10           the fourth element of the matrix
         * @param {float} m11           the fith element of the matrix
         * @param {float} m12           the sixth element of the matrix
         */
        set: function() {
          if (arguments.length === 6) {
            var a = arguments;
            this.set([
              a[0],
              a[1],
              a[2],
              a[3],
              a[4],
              a[5]
            ]);
          } else if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
            this.elements = arguments[0].array();
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            this.elements = arguments[0].slice();
          }
        },
        /**
         * @member PMatrix2D
         * The get() function returns a copy of this PMatrix2D.
         *
         * @return {PMatrix2D} a copy of this PMatrix2D
         */
        get: function() {
          var outgoing = new PMatrix2D2();
          outgoing.set(this.elements);
          return outgoing;
        },
        /**
         * @member PMatrix2D
         * The reset() function sets this PMatrix2D to the identity matrix.
         */
        reset: function() {
          this.set([1, 0, 0, 0, 1, 0]);
        },
        /**
         * @member PMatrix2D
         * The array() function returns a copy of the element values.
         * @addon
         *
         * @return {float[]} returns a copy of the element values
         */
        array: function array() {
          return this.elements.slice();
        },
        /**
         * @member PMatrix2D
         * The translate() function translates this matrix by moving the current coordinates to the location specified by tx and ty.
         *
         * @param {float} tx  the x-axis coordinate to move to
         * @param {float} ty  the y-axis coordinate to move to
         */
        translate: function(tx, ty) {
          this.elements[2] = tx * this.elements[0] + ty * this.elements[1] + this.elements[2];
          this.elements[5] = tx * this.elements[3] + ty * this.elements[4] + this.elements[5];
        },
        /**
         * @member PMatrix2D
         * The invTranslate() function translates this matrix by moving the current coordinates to the negative location specified by tx and ty.
         *
         * @param {float} tx  the x-axis coordinate to move to
         * @param {float} ty  the y-axis coordinate to move to
         */
        invTranslate: function(tx, ty) {
          this.translate(-tx, -ty);
        },
        /**
        * @member PMatrix2D
        * The transpose() function is not used in processingjs.
        */
        transpose: function() {
        },
        /**
         * @member PMatrix2D
         * The mult() function multiplied this matrix.
         * If two array elements are passed in the function will multiply a two element vector against this matrix.
         * If target is null or not length four, a new float array will be returned.
         * The values for vec and target can be the same (though that's less efficient).
         * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.
         *
         * @param {PVector} source, target  the PVectors used to multiply this matrix
         * @param {float[]} source, target  the arrays used to multiply this matrix
         *
         * @return {PVector|float[]} returns a PVector or an array representing the new matrix
         */
        mult: function(source2, target) {
          var x, y;
          if (source2 instanceof PVector3) {
            x = source2.x;
            y = source2.y;
            if (!target) {
              target = new PVector3();
            }
          } else if (source2 instanceof Array) {
            x = source2[0];
            y = source2[1];
            if (!target) {
              target = [];
            }
          }
          if (target instanceof Array) {
            target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2];
            target[1] = this.elements[3] * x + this.elements[4] * y + this.elements[5];
          } else if (target instanceof PVector3) {
            target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2];
            target.y = this.elements[3] * x + this.elements[4] * y + this.elements[5];
            target.z = 0;
          }
          return target;
        },
        /**
         * @member PMatrix2D
         * The multX() function calculates the x component of a vector from a transformation.
         *
         * @param {float} x the x component of the vector being transformed
         * @param {float} y the y component of the vector being transformed
         *
         * @return {float} returnes the result of the calculation
         */
        multX: function(x, y) {
          return x * this.elements[0] + y * this.elements[1] + this.elements[2];
        },
        /**
         * @member PMatrix2D
         * The multY() function calculates the y component of a vector from a transformation.
         *
         * @param {float} x the x component of the vector being transformed
         * @param {float} y the y component of the vector being transformed
         *
         * @return {float} returnes the result of the calculation
         */
        multY: function(x, y) {
          return x * this.elements[3] + y * this.elements[4] + this.elements[5];
        },
        /**
         * @member PMatrix2D
         * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        skewX: function(angle) {
          this.apply(1, 0, 1, angle, 0, 0);
        },
        /**
         * @member PMatrix2D
         * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        skewY: function(angle) {
          this.apply(1, 0, 1, 0, angle, 0);
        },
        /**
         * @member PMatrix2D
         * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        shearX: function(angle) {
          this.apply(1, 0, 1, Math.tan(angle), 0, 0);
        },
        /**
         * @member PMatrix2D
         * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        shearY: function(angle) {
          this.apply(1, 0, 1, 0, Math.tan(angle), 0);
        },
        /**
         * @member PMatrix2D
         * The determinant() function calvculates the determinant of this matrix.
         *
         * @return {float} the determinant of the matrix
         */
        determinant: function() {
          return this.elements[0] * this.elements[4] - this.elements[1] * this.elements[3];
        },
        /**
         * @member PMatrix2D
         * The invert() function inverts this matrix
         *
         * @return {boolean} true if successful
         */
        invert: function() {
          var d = this.determinant();
          if (Math.abs(d) > PConstants3.MIN_INT) {
            var old00 = this.elements[0];
            var old01 = this.elements[1];
            var old02 = this.elements[2];
            var old10 = this.elements[3];
            var old11 = this.elements[4];
            var old12 = this.elements[5];
            this.elements[0] = old11 / d;
            this.elements[3] = -old10 / d;
            this.elements[1] = -old01 / d;
            this.elements[4] = old00 / d;
            this.elements[2] = (old01 * old12 - old11 * old02) / d;
            this.elements[5] = (old10 * old02 - old00 * old12) / d;
            return true;
          }
          return false;
        },
        /**
         * @member PMatrix2D
         * The scale() function increases or decreases the size of a shape by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.
         * This is equivalent to a two parameter call.
         *
         * @param {float} sx  the amount to scale on the x-axis
         * @param {float} sy  the amount to scale on the y-axis
         */
        scale: function(sx, sy) {
          if (sx && !sy) {
            sy = sx;
          }
          if (sx && sy) {
            this.elements[0] *= sx;
            this.elements[1] *= sy;
            this.elements[3] *= sx;
            this.elements[4] *= sy;
          }
        },
        /**
         * @member PMatrix2D
         * The invScale() function decreases or increases the size of a shape by contracting and expanding vertices. When only one parameter is specified scale will occur in all dimensions.
         * This is equivalent to a two parameter call.
         *
         * @param {float} sx  the amount to scale on the x-axis
         * @param {float} sy  the amount to scale on the y-axis
         */
        invScale: function(sx, sy) {
          if (sx && !sy) {
            sy = sx;
          }
          this.scale(1 / sx, 1 / sy);
        },
        /**
         * @member PMatrix2D
         * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix2D or a list of floats can be passed in.
         *
         * @param {PMatrix2D} matrix    the matrix to apply this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the third element of the matrix
         * @param {float} m10           the fourth element of the matrix
         * @param {float} m11           the fith element of the matrix
         * @param {float} m12           the sixth element of the matrix
         */
        apply: function() {
          var source2;
          if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
            source2 = arguments[0].array();
          } else if (arguments.length === 6) {
            source2 = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            source2 = arguments[0];
          }
          var result = [
            0,
            0,
            this.elements[2],
            0,
            0,
            this.elements[5]
          ];
          var e = 0;
          for (var row = 0; row < 2; row++) {
            for (var col = 0; col < 3; col++, e++) {
              result[e] += this.elements[row * 3 + 0] * source2[col + 0] + this.elements[row * 3 + 1] * source2[col + 3];
            }
          }
          this.elements = result.slice();
        },
        /**
         * @member PMatrix2D
         * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix2D or elements of a matrix can be passed in.
         *
         * @param {PMatrix2D} matrix    the matrix to apply this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the third element of the matrix
         * @param {float} m10           the fourth element of the matrix
         * @param {float} m11           the fith element of the matrix
         * @param {float} m12           the sixth element of the matrix
         */
        preApply: function() {
          var source2;
          if (arguments.length === 1 && arguments[0] instanceof PMatrix2D2) {
            source2 = arguments[0].array();
          } else if (arguments.length === 6) {
            source2 = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            source2 = arguments[0];
          }
          var result = [
            0,
            0,
            source2[2],
            0,
            0,
            source2[5]
          ];
          result[2] = source2[2] + this.elements[2] * source2[0] + this.elements[5] * source2[1];
          result[5] = source2[5] + this.elements[2] * source2[3] + this.elements[5] * source2[4];
          result[0] = this.elements[0] * source2[0] + this.elements[3] * source2[1];
          result[3] = this.elements[0] * source2[3] + this.elements[3] * source2[4];
          result[1] = this.elements[1] * source2[0] + this.elements[4] * source2[1];
          result[4] = this.elements[1] * source2[3] + this.elements[4] * source2[4];
          this.elements = result.slice();
        },
        /**
         * @member PMatrix2D
         * The rotate() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotate: function(angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          var temp1 = this.elements[0];
          var temp2 = this.elements[1];
          this.elements[0] = c * temp1 + s * temp2;
          this.elements[1] = -s * temp1 + c * temp2;
          temp1 = this.elements[3];
          temp2 = this.elements[4];
          this.elements[3] = c * temp1 + s * temp2;
          this.elements[4] = -s * temp1 + c * temp2;
        },
        /**
         * @member PMatrix2D
         * The rotateZ() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotateZ: function(angle) {
          this.rotate(angle);
        },
        /**
         * @member PMatrix2D
         * The invRotateZ() function rotates the matrix in opposite direction.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        invRotateZ: function(angle) {
          this.rotateZ(angle - Math.PI);
        },
        /**
         * @member PMatrix2D
         * The print() function prints out the elements of this matrix
         */
        print: function() {
          var digits = printMatrixHelper2(this.elements);
          var output = "" + p.nfs(this.elements[0], digits, 4) + " " + p.nfs(this.elements[1], digits, 4) + " " + p.nfs(this.elements[2], digits, 4) + "\n" + p.nfs(this.elements[3], digits, 4) + " " + p.nfs(this.elements[4], digits, 4) + " " + p.nfs(this.elements[5], digits, 4) + "\n\n";
          p.println(output);
        }
      };
      var PMatrix3D2 = p.PMatrix3D = function() {
        this.reset();
      };
      PMatrix3D2.prototype = {
        /**
         * @member PMatrix2D
         * The set() function sets the matrix elements. The function accepts either another PMatrix3D, an array of elements, or a list of six or sixteen floats.
         *
         * @param {PMatrix3D} matrix    the initial matrix to set to
         * @param {float[]} elements    an array of elements to set this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the second element of the matrix
         * @param {float} m02           the third element of the matrix
         * @param {float} m03           the fourth element of the matrix
         * @param {float} m10           the fifth element of the matrix
         * @param {float} m11           the sixth element of the matrix
         * @param {float} m12           the seventh element of the matrix
         * @param {float} m13           the eight element of the matrix
         * @param {float} m20           the nineth element of the matrix
         * @param {float} m21           the tenth element of the matrix
         * @param {float} m22           the eleventh element of the matrix
         * @param {float} m23           the twelveth element of the matrix
         * @param {float} m30           the thirteenth element of the matrix
         * @param {float} m31           the fourtheenth element of the matrix
         * @param {float} m32           the fivetheenth element of the matrix
         * @param {float} m33           the sixteenth element of the matrix
         */
        set: function() {
          if (arguments.length === 16) {
            this.elements = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
            this.elements = arguments[0].array();
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            this.elements = arguments[0].slice();
          }
        },
        /**
         * @member PMatrix3D
         * The get() function returns a copy of this PMatrix3D.
         *
         * @return {PMatrix3D} a copy of this PMatrix3D
         */
        get: function() {
          var outgoing = new PMatrix3D2();
          outgoing.set(this.elements);
          return outgoing;
        },
        /**
         * @member PMatrix3D
         * The reset() function sets this PMatrix3D to the identity matrix.
         */
        reset: function() {
          this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ];
        },
        /**
         * @member PMatrix3D
         * The array() function returns a copy of the element values.
         * @addon
         *
         * @return {float[]} returns a copy of the element values
         */
        array: function array() {
          return this.elements.slice();
        },
        /**
         * @member PMatrix3D
         * The translate() function translates this matrix by moving the current coordinates to the location specified by tx, ty, and tz.
         *
         * @param {float} tx  the x-axis coordinate to move to
         * @param {float} ty  the y-axis coordinate to move to
         * @param {float} tz  the z-axis coordinate to move to
         */
        translate: function(tx, ty, tz) {
          if (tz === undef) {
            tz = 0;
          }
          this.elements[3] += tx * this.elements[0] + ty * this.elements[1] + tz * this.elements[2];
          this.elements[7] += tx * this.elements[4] + ty * this.elements[5] + tz * this.elements[6];
          this.elements[11] += tx * this.elements[8] + ty * this.elements[9] + tz * this.elements[10];
          this.elements[15] += tx * this.elements[12] + ty * this.elements[13] + tz * this.elements[14];
        },
        /**
         * @member PMatrix3D
         * The transpose() function transpose this matrix.
         */
        transpose: function() {
          var temp = this.elements[4];
          this.elements[4] = this.elements[1];
          this.elements[1] = temp;
          temp = this.elements[8];
          this.elements[8] = this.elements[2];
          this.elements[2] = temp;
          temp = this.elements[6];
          this.elements[6] = this.elements[9];
          this.elements[9] = temp;
          temp = this.elements[3];
          this.elements[3] = this.elements[12];
          this.elements[12] = temp;
          temp = this.elements[7];
          this.elements[7] = this.elements[13];
          this.elements[13] = temp;
          temp = this.elements[11];
          this.elements[11] = this.elements[14];
          this.elements[14] = temp;
        },
        /**
         * @member PMatrix3D
         * The mult() function multiplied this matrix.
         * If two array elements are passed in the function will multiply a two element vector against this matrix.
         * If target is null or not length four, a new float array will be returned.
         * The values for vec and target can be the same (though that's less efficient).
         * If two PVectors are passed in the function multiply the x and y coordinates of a PVector against this matrix.
         *
         * @param {PVector} source, target  the PVectors used to multiply this matrix
         * @param {float[]} source, target  the arrays used to multiply this matrix
         *
         * @return {PVector|float[]} returns a PVector or an array representing the new matrix
         */
        mult: function(source2, target) {
          var x, y, z, w;
          if (source2 instanceof PVector3) {
            x = source2.x;
            y = source2.y;
            z = source2.z;
            w = 1;
            if (!target) {
              target = new PVector3();
            }
          } else if (source2 instanceof Array) {
            x = source2[0];
            y = source2[1];
            z = source2[2];
            w = source2[3] || 1;
            if (!target || target.length !== 3 && target.length !== 4) {
              target = [0, 0, 0];
            }
          }
          if (target instanceof Array) {
            if (target.length === 3) {
              target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
              target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
              target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
            } else if (target.length === 4) {
              target[0] = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;
              target[1] = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;
              target[2] = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;
              target[3] = this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;
            }
          }
          if (target instanceof PVector3) {
            target.x = this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
            target.y = this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
            target.z = this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
          }
          return target;
        },
        /**
         * @member PMatrix3D
         * The preApply() function applies another matrix to the left of this one. Note that either a PMatrix3D or elements of a matrix can be passed in.
         *
         * @param {PMatrix3D} matrix    the matrix to apply this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the second element of the matrix
         * @param {float} m02           the third element of the matrix
         * @param {float} m03           the fourth element of the matrix
         * @param {float} m10           the fifth element of the matrix
         * @param {float} m11           the sixth element of the matrix
         * @param {float} m12           the seventh element of the matrix
         * @param {float} m13           the eight element of the matrix
         * @param {float} m20           the nineth element of the matrix
         * @param {float} m21           the tenth element of the matrix
         * @param {float} m22           the eleventh element of the matrix
         * @param {float} m23           the twelveth element of the matrix
         * @param {float} m30           the thirteenth element of the matrix
         * @param {float} m31           the fourtheenth element of the matrix
         * @param {float} m32           the fivetheenth element of the matrix
         * @param {float} m33           the sixteenth element of the matrix
         */
        preApply: function() {
          var source2;
          if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
            source2 = arguments[0].array();
          } else if (arguments.length === 16) {
            source2 = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            source2 = arguments[0];
          }
          var result = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          var e = 0;
          for (var row = 0; row < 4; row++) {
            for (var col = 0; col < 4; col++, e++) {
              result[e] += this.elements[col + 0] * source2[row * 4 + 0] + this.elements[col + 4] * source2[row * 4 + 1] + this.elements[col + 8] * source2[row * 4 + 2] + this.elements[col + 12] * source2[row * 4 + 3];
            }
          }
          this.elements = result.slice();
        },
        /**
         * @member PMatrix3D
         * The apply() function multiplies the current matrix by the one specified through the parameters. Note that either a PMatrix3D or a list of floats can be passed in.
         *
         * @param {PMatrix3D} matrix    the matrix to apply this matrix to
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the second element of the matrix
         * @param {float} m02           the third element of the matrix
         * @param {float} m03           the fourth element of the matrix
         * @param {float} m10           the fifth element of the matrix
         * @param {float} m11           the sixth element of the matrix
         * @param {float} m12           the seventh element of the matrix
         * @param {float} m13           the eight element of the matrix
         * @param {float} m20           the nineth element of the matrix
         * @param {float} m21           the tenth element of the matrix
         * @param {float} m22           the eleventh element of the matrix
         * @param {float} m23           the twelveth element of the matrix
         * @param {float} m30           the thirteenth element of the matrix
         * @param {float} m31           the fourtheenth element of the matrix
         * @param {float} m32           the fivetheenth element of the matrix
         * @param {float} m33           the sixteenth element of the matrix
         */
        apply: function() {
          var source2;
          if (arguments.length === 1 && arguments[0] instanceof PMatrix3D2) {
            source2 = arguments[0].array();
          } else if (arguments.length === 16) {
            source2 = Array.prototype.slice.call(arguments);
          } else if (arguments.length === 1 && arguments[0] instanceof Array) {
            source2 = arguments[0];
          }
          var result = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ];
          var e = 0;
          for (var row = 0; row < 4; row++) {
            for (var col = 0; col < 4; col++, e++) {
              result[e] += this.elements[row * 4 + 0] * source2[col + 0] + this.elements[row * 4 + 1] * source2[col + 4] + this.elements[row * 4 + 2] * source2[col + 8] + this.elements[row * 4 + 3] * source2[col + 12];
            }
          }
          this.elements = result.slice();
        },
        /**
         * @member PMatrix3D
         * The rotate() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotate: function(angle, v0, v1, v2) {
          if (arguments.length < 4) {
            this.rotateZ(angle);
          } else {
            var v = new PVector3(v0, v1, v2);
            var m = v.mag();
            if (m === 0) {
              return;
            } else if (m != 1) {
              v.normalize();
              v0 = v.x;
              v1 = v.y;
              v2 = v.z;
            }
            var c = p.cos(angle);
            var s = p.sin(angle);
            var t2 = 1 - c;
            this.apply(
              t2 * v0 * v0 + c,
              t2 * v0 * v1 - s * v2,
              t2 * v0 * v2 + s * v1,
              0,
              t2 * v0 * v1 + s * v2,
              t2 * v1 * v1 + c,
              t2 * v1 * v2 - s * v0,
              0,
              t2 * v0 * v2 - s * v1,
              t2 * v1 * v2 + s * v0,
              t2 * v2 * v2 + c,
              0,
              0,
              0,
              0,
              1
            );
          }
        },
        /**
         * @member PMatrix3D
         * The invApply() function applies the inverted matrix to this matrix.
         *
         * @param {float} m00           the first element of the matrix
         * @param {float} m01           the second element of the matrix
         * @param {float} m02           the third element of the matrix
         * @param {float} m03           the fourth element of the matrix
         * @param {float} m10           the fifth element of the matrix
         * @param {float} m11           the sixth element of the matrix
         * @param {float} m12           the seventh element of the matrix
         * @param {float} m13           the eight element of the matrix
         * @param {float} m20           the nineth element of the matrix
         * @param {float} m21           the tenth element of the matrix
         * @param {float} m22           the eleventh element of the matrix
         * @param {float} m23           the twelveth element of the matrix
         * @param {float} m30           the thirteenth element of the matrix
         * @param {float} m31           the fourtheenth element of the matrix
         * @param {float} m32           the fivetheenth element of the matrix
         * @param {float} m33           the sixteenth element of the matrix
         *
         * @return {boolean} returns true if the operation was successful.
         */
        invApply: function() {
          if (inverseCopy2 === undef) {
            inverseCopy2 = new PMatrix3D2();
          }
          var a = arguments;
          inverseCopy2.set(
            a[0],
            a[1],
            a[2],
            a[3],
            a[4],
            a[5],
            a[6],
            a[7],
            a[8],
            a[9],
            a[10],
            a[11],
            a[12],
            a[13],
            a[14],
            a[15]
          );
          if (!inverseCopy2.invert()) {
            return false;
          }
          this.preApply(inverseCopy2);
          return true;
        },
        /**
         * @member PMatrix3D
         * The rotateZ() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotateX: function(angle) {
          var c = p.cos(angle);
          var s = p.sin(angle);
          this.apply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);
        },
        /**
         * @member PMatrix3D
         * The rotateY() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotateY: function(angle) {
          var c = p.cos(angle);
          var s = p.sin(angle);
          this.apply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);
        },
        /**
         * @member PMatrix3D
         * The rotateZ() function rotates the matrix.
         *
         * @param {float} angle         the angle of rotation in radiants
         */
        rotateZ: function(angle) {
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          this.apply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        },
        /**
         * @member PMatrix3D
         * The scale() function increases or decreases the size of a matrix by expanding and contracting vertices. When only one parameter is specified scale will occur in all dimensions.
         * This is equivalent to a three parameter call.
         *
         * @param {float} sx  the amount to scale on the x-axis
         * @param {float} sy  the amount to scale on the y-axis
         * @param {float} sz  the amount to scale on the z-axis
         */
        scale: function(sx, sy, sz) {
          if (sx && !sy && !sz) {
            sy = sz = sx;
          } else if (sx && sy && !sz) {
            sz = 1;
          }
          if (sx && sy && sz) {
            this.elements[0] *= sx;
            this.elements[1] *= sy;
            this.elements[2] *= sz;
            this.elements[4] *= sx;
            this.elements[5] *= sy;
            this.elements[6] *= sz;
            this.elements[8] *= sx;
            this.elements[9] *= sy;
            this.elements[10] *= sz;
            this.elements[12] *= sx;
            this.elements[13] *= sy;
            this.elements[14] *= sz;
          }
        },
        /**
         * @member PMatrix3D
         * The skewX() function skews the matrix along the x-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        skewX: function(angle) {
          var t2 = Math.tan(angle);
          this.apply(1, t2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        /**
         * @member PMatrix3D
         * The skewY() function skews the matrix along the y-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of skew specified in radians
         */
        skewY: function(angle) {
          var t2 = Math.tan(angle);
          this.apply(1, 0, 0, 0, t2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        /**
         * @member PMatrix3D
         * The shearX() function shears the matrix along the x-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of shear specified in radians
         */
        shearX: function(angle) {
          var t2 = Math.tan(angle);
          this.apply(1, t2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        /**
         * @member PMatrix3D
         * The shearY() function shears the matrix along the y-axis the amount specified by the angle parameter.
         * Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the <b>radians()</b> function.
         *
         * @param {float} angle  angle of shear specified in radians
         */
        shearY: function(angle) {
          var t2 = Math.tan(angle);
          this.apply(1, 0, 0, 0, t2, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        },
        multX: function(x, y, z, w) {
          if (!z) {
            return this.elements[0] * x + this.elements[1] * y + this.elements[3];
          }
          if (!w) {
            return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3];
          }
          return this.elements[0] * x + this.elements[1] * y + this.elements[2] * z + this.elements[3] * w;
        },
        multY: function(x, y, z, w) {
          if (!z) {
            return this.elements[4] * x + this.elements[5] * y + this.elements[7];
          }
          if (!w) {
            return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7];
          }
          return this.elements[4] * x + this.elements[5] * y + this.elements[6] * z + this.elements[7] * w;
        },
        multZ: function(x, y, z, w) {
          if (!w) {
            return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11];
          }
          return this.elements[8] * x + this.elements[9] * y + this.elements[10] * z + this.elements[11] * w;
        },
        multW: function(x, y, z, w) {
          if (!w) {
            return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15];
          }
          return this.elements[12] * x + this.elements[13] * y + this.elements[14] * z + this.elements[15] * w;
        },
        /**
         * @member PMatrix3D
         * The invert() function inverts this matrix
         *
         * @return {boolean} true if successful
         */
        invert: function() {
          var fA0 = this.elements[0] * this.elements[5] - this.elements[1] * this.elements[4];
          var fA1 = this.elements[0] * this.elements[6] - this.elements[2] * this.elements[4];
          var fA2 = this.elements[0] * this.elements[7] - this.elements[3] * this.elements[4];
          var fA3 = this.elements[1] * this.elements[6] - this.elements[2] * this.elements[5];
          var fA4 = this.elements[1] * this.elements[7] - this.elements[3] * this.elements[5];
          var fA5 = this.elements[2] * this.elements[7] - this.elements[3] * this.elements[6];
          var fB0 = this.elements[8] * this.elements[13] - this.elements[9] * this.elements[12];
          var fB1 = this.elements[8] * this.elements[14] - this.elements[10] * this.elements[12];
          var fB2 = this.elements[8] * this.elements[15] - this.elements[11] * this.elements[12];
          var fB3 = this.elements[9] * this.elements[14] - this.elements[10] * this.elements[13];
          var fB4 = this.elements[9] * this.elements[15] - this.elements[11] * this.elements[13];
          var fB5 = this.elements[10] * this.elements[15] - this.elements[11] * this.elements[14];
          var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;
          if (Math.abs(fDet) <= 1e-9) {
            return false;
          }
          var kInv = [];
          kInv[0] = +this.elements[5] * fB5 - this.elements[6] * fB4 + this.elements[7] * fB3;
          kInv[4] = -this.elements[4] * fB5 + this.elements[6] * fB2 - this.elements[7] * fB1;
          kInv[8] = +this.elements[4] * fB4 - this.elements[5] * fB2 + this.elements[7] * fB0;
          kInv[12] = -this.elements[4] * fB3 + this.elements[5] * fB1 - this.elements[6] * fB0;
          kInv[1] = -this.elements[1] * fB5 + this.elements[2] * fB4 - this.elements[3] * fB3;
          kInv[5] = +this.elements[0] * fB5 - this.elements[2] * fB2 + this.elements[3] * fB1;
          kInv[9] = -this.elements[0] * fB4 + this.elements[1] * fB2 - this.elements[3] * fB0;
          kInv[13] = +this.elements[0] * fB3 - this.elements[1] * fB1 + this.elements[2] * fB0;
          kInv[2] = +this.elements[13] * fA5 - this.elements[14] * fA4 + this.elements[15] * fA3;
          kInv[6] = -this.elements[12] * fA5 + this.elements[14] * fA2 - this.elements[15] * fA1;
          kInv[10] = +this.elements[12] * fA4 - this.elements[13] * fA2 + this.elements[15] * fA0;
          kInv[14] = -this.elements[12] * fA3 + this.elements[13] * fA1 - this.elements[14] * fA0;
          kInv[3] = -this.elements[9] * fA5 + this.elements[10] * fA4 - this.elements[11] * fA3;
          kInv[7] = +this.elements[8] * fA5 - this.elements[10] * fA2 + this.elements[11] * fA1;
          kInv[11] = -this.elements[8] * fA4 + this.elements[9] * fA2 - this.elements[11] * fA0;
          kInv[15] = +this.elements[8] * fA3 - this.elements[9] * fA1 + this.elements[10] * fA0;
          var fInvDet = 1 / fDet;
          kInv[0] *= fInvDet;
          kInv[1] *= fInvDet;
          kInv[2] *= fInvDet;
          kInv[3] *= fInvDet;
          kInv[4] *= fInvDet;
          kInv[5] *= fInvDet;
          kInv[6] *= fInvDet;
          kInv[7] *= fInvDet;
          kInv[8] *= fInvDet;
          kInv[9] *= fInvDet;
          kInv[10] *= fInvDet;
          kInv[11] *= fInvDet;
          kInv[12] *= fInvDet;
          kInv[13] *= fInvDet;
          kInv[14] *= fInvDet;
          kInv[15] *= fInvDet;
          this.elements = kInv.slice();
          return true;
        },
        toString: function() {
          var str = "";
          for (var i2 = 0; i2 < 15; i2++) {
            str += this.elements[i2] + ", ";
          }
          str += this.elements[15];
          return str;
        },
        /**
         * @member PMatrix3D
         * The print() function prints out the elements of this matrix
         */
        print: function() {
          var digits = printMatrixHelper2(this.elements);
          var output = "" + p.nfs(this.elements[0], digits, 4) + " " + p.nfs(this.elements[1], digits, 4) + " " + p.nfs(this.elements[2], digits, 4) + " " + p.nfs(this.elements[3], digits, 4) + "\n" + p.nfs(this.elements[4], digits, 4) + " " + p.nfs(this.elements[5], digits, 4) + " " + p.nfs(this.elements[6], digits, 4) + " " + p.nfs(this.elements[7], digits, 4) + "\n" + p.nfs(this.elements[8], digits, 4) + " " + p.nfs(this.elements[9], digits, 4) + " " + p.nfs(this.elements[10], digits, 4) + " " + p.nfs(this.elements[11], digits, 4) + "\n" + p.nfs(this.elements[12], digits, 4) + " " + p.nfs(this.elements[13], digits, 4) + " " + p.nfs(this.elements[14], digits, 4) + " " + p.nfs(this.elements[15], digits, 4) + "\n\n";
          p.println(output);
        },
        invTranslate: function(tx, ty, tz) {
          this.preApply(1, 0, 0, -tx, 0, 1, 0, -ty, 0, 0, 1, -tz, 0, 0, 0, 1);
        },
        invRotateX: function(angle) {
          var c = Math.cos(-angle);
          var s = Math.sin(-angle);
          this.preApply([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);
        },
        invRotateY: function(angle) {
          var c = Math.cos(-angle);
          var s = Math.sin(-angle);
          this.preApply([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);
        },
        invRotateZ: function(angle) {
          var c = Math.cos(-angle);
          var s = Math.sin(-angle);
          this.preApply([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        },
        invScale: function(x, y, z) {
          this.preApply([1 / x, 0, 0, 0, 0, 1 / y, 0, 0, 0, 0, 1 / z, 0, 0, 0, 0, 1]);
        }
      };
      var PMatrixStack = p.PMatrixStack = function() {
        this.matrixStack = [];
      };
      PMatrixStack.prototype.load = function() {
        var tmpMatrix = drawing.$newPMatrix();
        if (arguments.length === 1) {
          tmpMatrix.set(arguments[0]);
        } else {
          tmpMatrix.set(arguments);
        }
        this.matrixStack.push(tmpMatrix);
      };
      Drawing2D.prototype.$newPMatrix = function() {
        return new PMatrix2D2();
      };
      Drawing3D.prototype.$newPMatrix = function() {
        return new PMatrix3D2();
      };
      PMatrixStack.prototype.push = function() {
        this.matrixStack.push(this.peek());
      };
      PMatrixStack.prototype.pop = function() {
        return this.matrixStack.pop();
      };
      PMatrixStack.prototype.peek = function() {
        var tmpMatrix = drawing.$newPMatrix();
        tmpMatrix.set(this.matrixStack[this.matrixStack.length - 1]);
        return tmpMatrix;
      };
      PMatrixStack.prototype.mult = function(matrix) {
        this.matrixStack[this.matrixStack.length - 1].apply(matrix);
      };
      p.split = function(str, delim) {
        return str.split(delim);
      };
      p.splitTokens = function(str, tokens) {
        if (tokens === undef) {
          return str.split(/\s+/g);
        }
        var chars = tokens.split(/()/g), buffer = "", len = str.length, i2, c, tokenized = [];
        for (i2 = 0; i2 < len; i2++) {
          c = str[i2];
          if (chars.indexOf(c) > -1) {
            if (buffer !== "") {
              tokenized.push(buffer);
            }
            buffer = "";
          } else {
            buffer += c;
          }
        }
        if (buffer !== "") {
          tokenized.push(buffer);
        }
        return tokenized;
      };
      p.append = function(array, element) {
        array[array.length] = element;
        return array;
      };
      p.concat = function(array1, array2) {
        return array1.concat(array2);
      };
      p.sort = function(array, numElem) {
        var ret = [];
        if (array.length > 0) {
          var elemsToCopy = numElem > 0 ? numElem : array.length;
          for (var i2 = 0; i2 < elemsToCopy; i2++) {
            ret.push(array[i2]);
          }
          if (typeof array[0] === "string") {
            ret.sort();
          } else {
            ret.sort(function(a, b) {
              return a - b;
            });
          }
          if (numElem > 0) {
            for (var j = ret.length; j < array.length; j++) {
              ret.push(array[j]);
            }
          }
        }
        return ret;
      };
      p.splice = function(array, value, index) {
        if (value.length === 0) {
          return array;
        }
        if (value instanceof Array) {
          for (var i2 = 0, j = index; i2 < value.length; j++, i2++) {
            array.splice(j, 0, value[i2]);
          }
        } else {
          array.splice(index, 0, value);
        }
        return array;
      };
      p.subset = function(array, offset, length) {
        var end = length !== undef ? offset + length : array.length;
        return array.slice(offset, end);
      };
      p.join = function(array, seperator) {
        return array.join(seperator);
      };
      p.shorten = function(ary) {
        var newary = [];
        var len = ary.length;
        for (var i2 = 0; i2 < len; i2++) {
          newary[i2] = ary[i2];
        }
        newary.pop();
        return newary;
      };
      p.expand = function(ary, targetSize) {
        var temp = ary.slice(0), newSize = targetSize || ary.length * 2;
        temp.length = newSize;
        return temp;
      };
      p.arrayCopy = function() {
        var src, srcPos = 0, dest, destPos = 0, length;
        if (arguments.length === 2) {
          src = arguments[0];
          dest = arguments[1];
          length = src.length;
        } else if (arguments.length === 3) {
          src = arguments[0];
          dest = arguments[1];
          length = arguments[2];
        } else if (arguments.length === 5) {
          src = arguments[0];
          srcPos = arguments[1];
          dest = arguments[2];
          destPos = arguments[3];
          length = arguments[4];
        }
        for (var i2 = srcPos, j = destPos; i2 < length + srcPos; i2++, j++) {
          if (dest[j] !== undef) {
            dest[j] = src[i2];
          } else {
            throw "array index out of bounds exception";
          }
        }
      };
      p.reverse = function(array) {
        return array.reverse();
      };
      p.mix = function(a, b, f) {
        return a + ((b - a) * f >> 8);
      };
      p.peg = function(n) {
        return n < 0 ? 0 : n > 255 ? 255 : n;
      };
      p.modes = function() {
        var ALPHA_MASK = PConstants3.ALPHA_MASK, RED_MASK = PConstants3.RED_MASK, GREEN_MASK = PConstants3.GREEN_MASK, BLUE_MASK = PConstants3.BLUE_MASK, min = Math.min, max = Math.max;
        function applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb) {
          var a = min(((c1 & 4278190080) >>> 24) + f, 255) << 24;
          var r = ar + ((cr - ar) * f >> 8);
          r = (r < 0 ? 0 : r > 255 ? 255 : r) << 16;
          var g = ag + ((cg - ag) * f >> 8);
          g = (g < 0 ? 0 : g > 255 ? 255 : g) << 8;
          var b = ab + ((cb - ab) * f >> 8);
          b = b < 0 ? 0 : b > 255 ? 255 : b;
          return a | r | g | b;
        }
        return {
          replace: function(c1, c2) {
            return c2;
          },
          blend: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = c1 & RED_MASK, ag = c1 & GREEN_MASK, ab = c1 & BLUE_MASK, br = c2 & RED_MASK, bg = c2 & GREEN_MASK, bb = c2 & BLUE_MASK;
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | ar + ((br - ar) * f >> 8) & RED_MASK | ag + ((bg - ag) * f >> 8) & GREEN_MASK | ab + ((bb - ab) * f >> 8) & BLUE_MASK;
          },
          add: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24;
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | min((c1 & RED_MASK) + ((c2 & RED_MASK) >> 8) * f, RED_MASK) & RED_MASK | min((c1 & GREEN_MASK) + ((c2 & GREEN_MASK) >> 8) * f, GREEN_MASK) & GREEN_MASK | min((c1 & BLUE_MASK) + ((c2 & BLUE_MASK) * f >> 8), BLUE_MASK);
          },
          subtract: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24;
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | max((c1 & RED_MASK) - ((c2 & RED_MASK) >> 8) * f, GREEN_MASK) & RED_MASK | max((c1 & GREEN_MASK) - ((c2 & GREEN_MASK) >> 8) * f, BLUE_MASK) & GREEN_MASK | max((c1 & BLUE_MASK) - ((c2 & BLUE_MASK) * f >> 8), 0);
          },
          lightest: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24;
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | max(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f) & RED_MASK | max(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f) & GREEN_MASK | max(c1 & BLUE_MASK, (c2 & BLUE_MASK) * f >> 8);
          },
          darkest: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = c1 & RED_MASK, ag = c1 & GREEN_MASK, ab = c1 & BLUE_MASK, br = min(c1 & RED_MASK, ((c2 & RED_MASK) >> 8) * f), bg = min(c1 & GREEN_MASK, ((c2 & GREEN_MASK) >> 8) * f), bb = min(c1 & BLUE_MASK, (c2 & BLUE_MASK) * f >> 8);
            return min(((c1 & ALPHA_MASK) >>> 24) + f, 255) << 24 | ar + ((br - ar) * f >> 8) & RED_MASK | ag + ((bg - ag) * f >> 8) & GREEN_MASK | ab + ((bb - ab) * f >> 8) & BLUE_MASK;
          },
          difference: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar > br ? ar - br : br - ar, cg = ag > bg ? ag - bg : bg - ag, cb = ab > bb ? ab - bb : bb - ab;
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          exclusion: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar + br - (ar * br >> 7), cg = ag + bg - (ag * bg >> 7), cb = ab + bb - (ab * bb >> 7);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          multiply: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar * br >> 8, cg = ag * bg >> 8, cb = ab * bb >> 8;
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          screen: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = 255 - ((255 - ar) * (255 - br) >> 8), cg = 255 - ((255 - ag) * (255 - bg) >> 8), cb = 255 - ((255 - ab) * (255 - bb) >> 8);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          hard_light: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = br < 128 ? ar * br >> 7 : 255 - ((255 - ar) * (255 - br) >> 7), cg = bg < 128 ? ag * bg >> 7 : 255 - ((255 - ag) * (255 - bg) >> 7), cb = bb < 128 ? ab * bb >> 7 : 255 - ((255 - ab) * (255 - bb) >> 7);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          soft_light: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = (ar * br >> 7) + (ar * ar >> 8) - (ar * ar * br >> 15), cg = (ag * bg >> 7) + (ag * ag >> 8) - (ag * ag * bg >> 15), cb = (ab * bb >> 7) + (ab * ab >> 8) - (ab * ab * bb >> 15);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          overlay: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK, cr = ar < 128 ? ar * br >> 7 : 255 - ((255 - ar) * (255 - br) >> 7), cg = ag < 128 ? ag * bg >> 7 : 255 - ((255 - ag) * (255 - bg) >> 7), cb = ab < 128 ? ab * bb >> 7 : 255 - ((255 - ab) * (255 - bb) >> 7);
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          dodge: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK;
            var cr = 255;
            if (br !== 255) {
              cr = (ar << 8) / (255 - br);
              cr = cr < 0 ? 0 : cr > 255 ? 255 : cr;
            }
            var cg = 255;
            if (bg !== 255) {
              cg = (ag << 8) / (255 - bg);
              cg = cg < 0 ? 0 : cg > 255 ? 255 : cg;
            }
            var cb = 255;
            if (bb !== 255) {
              cb = (ab << 8) / (255 - bb);
              cb = cb < 0 ? 0 : cb > 255 ? 255 : cb;
            }
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          },
          burn: function(c1, c2) {
            var f = (c2 & ALPHA_MASK) >>> 24, ar = (c1 & RED_MASK) >> 16, ag = (c1 & GREEN_MASK) >> 8, ab = c1 & BLUE_MASK, br = (c2 & RED_MASK) >> 16, bg = (c2 & GREEN_MASK) >> 8, bb = c2 & BLUE_MASK;
            var cr = 0;
            if (br !== 0) {
              cr = (255 - ar << 8) / br;
              cr = 255 - (cr < 0 ? 0 : cr > 255 ? 255 : cr);
            }
            var cg = 0;
            if (bg !== 0) {
              cg = (255 - ag << 8) / bg;
              cg = 255 - (cg < 0 ? 0 : cg > 255 ? 255 : cg);
            }
            var cb = 0;
            if (bb !== 0) {
              cb = (255 - ab << 8) / bb;
              cb = 255 - (cb < 0 ? 0 : cb > 255 ? 255 : cb);
            }
            return applyMode(c1, f, ar, ag, ab, br, bg, bb, cr, cg, cb);
          }
        };
      }();
      function color$4(aValue1, aValue2, aValue3, aValue4) {
        var r, g, b, a;
        if (curColorMode === PConstants3.HSB) {
          var rgb = p.color.toRGB(aValue1, aValue2, aValue3);
          r = rgb[0];
          g = rgb[1];
          b = rgb[2];
        } else {
          r = Math.round(255 * (aValue1 / colorModeX));
          g = Math.round(255 * (aValue2 / colorModeY));
          b = Math.round(255 * (aValue3 / colorModeZ));
        }
        a = Math.round(255 * (aValue4 / colorModeA));
        r = r < 0 ? 0 : r;
        g = g < 0 ? 0 : g;
        b = b < 0 ? 0 : b;
        a = a < 0 ? 0 : a;
        r = r > 255 ? 255 : r;
        g = g > 255 ? 255 : g;
        b = b > 255 ? 255 : b;
        a = a > 255 ? 255 : a;
        return a << 24 & PConstants3.ALPHA_MASK | r << 16 & PConstants3.RED_MASK | g << 8 & PConstants3.GREEN_MASK | b & PConstants3.BLUE_MASK;
      }
      function color$2(aValue1, aValue2) {
        var a;
        if (aValue1 & PConstants3.ALPHA_MASK) {
          a = Math.round(255 * (aValue2 / colorModeA));
          a = a > 255 ? 255 : a;
          a = a < 0 ? 0 : a;
          return aValue1 - (aValue1 & PConstants3.ALPHA_MASK) + (a << 24 & PConstants3.ALPHA_MASK);
        }
        if (curColorMode === PConstants3.RGB) {
          return color$4(aValue1, aValue1, aValue1, aValue2);
        }
        if (curColorMode === PConstants3.HSB) {
          return color$4(0, 0, aValue1 / colorModeX * colorModeZ, aValue2);
        }
      }
      function color$1(aValue1) {
        if (aValue1 <= colorModeX && aValue1 >= 0) {
          if (curColorMode === PConstants3.RGB) {
            return color$4(aValue1, aValue1, aValue1, colorModeA);
          }
          if (curColorMode === PConstants3.HSB) {
            return color$4(0, 0, aValue1 / colorModeX * colorModeZ, colorModeA);
          }
        }
        if (aValue1) {
          if (aValue1 > 2147483647) {
            aValue1 -= 4294967296;
          }
          return aValue1;
        }
      }
      p.color = function(aValue1, aValue2, aValue3, aValue4) {
        if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef && aValue4 !== undef) {
          return color$4(aValue1, aValue2, aValue3, aValue4);
        }
        if (aValue1 !== undef && aValue2 !== undef && aValue3 !== undef) {
          return color$4(aValue1, aValue2, aValue3, colorModeA);
        }
        if (aValue1 !== undef && aValue2 !== undef) {
          return color$2(aValue1, aValue2);
        }
        if (typeof aValue1 === "number") {
          return color$1(aValue1);
        }
        return color$4(colorModeX, colorModeY, colorModeZ, colorModeA);
      };
      p.color.toString = function(colorInt) {
        return "rgba(" + ((colorInt & PConstants3.RED_MASK) >>> 16) + "," + ((colorInt & PConstants3.GREEN_MASK) >>> 8) + "," + (colorInt & PConstants3.BLUE_MASK) + "," + ((colorInt & PConstants3.ALPHA_MASK) >>> 24) / 255 + ")";
      };
      p.color.toInt = function(r, g, b, a) {
        return a << 24 & PConstants3.ALPHA_MASK | r << 16 & PConstants3.RED_MASK | g << 8 & PConstants3.GREEN_MASK | b & PConstants3.BLUE_MASK;
      };
      p.color.toArray = function(colorInt) {
        return [
          (colorInt & PConstants3.RED_MASK) >>> 16,
          (colorInt & PConstants3.GREEN_MASK) >>> 8,
          colorInt & PConstants3.BLUE_MASK,
          (colorInt & PConstants3.ALPHA_MASK) >>> 24
        ];
      };
      p.color.toGLArray = function(colorInt) {
        return [
          ((colorInt & PConstants3.RED_MASK) >>> 16) / 255,
          ((colorInt & PConstants3.GREEN_MASK) >>> 8) / 255,
          (colorInt & PConstants3.BLUE_MASK) / 255,
          ((colorInt & PConstants3.ALPHA_MASK) >>> 24) / 255
        ];
      };
      p.color.toRGB = function(h, s, b) {
        h = h > colorModeX ? colorModeX : h;
        s = s > colorModeY ? colorModeY : s;
        b = b > colorModeZ ? colorModeZ : b;
        h = h < 0 ? 0 : h;
        h = h / colorModeX * 360;
        s = s / colorModeY * 100;
        b = b / colorModeZ * 100;
        var br = Math.round(b / 100 * 255);
        if (s === 0) {
          return [br, br, br];
        }
        var hue = h % 360;
        var f = hue % 60;
        var p2 = Math.round(b * (100 - s) / 1e4 * 255);
        var q = Math.round(b * (6e3 - s * f) / 6e5 * 255);
        var t2 = Math.round(b * (6e3 - s * (60 - f)) / 6e5 * 255);
        switch (Math.floor(hue / 60)) {
          case 0:
            return [br, t2, p2];
          case 1:
            return [q, br, p2];
          case 2:
            return [p2, br, t2];
          case 3:
            return [p2, q, br];
          case 4:
            return [t2, p2, br];
          case 5:
            return [br, p2, q];
          default:
            Processing3.debug("Unexpectedly hit default case in toRGB function.");
        }
      };
      function colorToHSB(colorInt) {
        var red, green, blue;
        red = ((colorInt & PConstants3.RED_MASK) >>> 16) / 255;
        green = ((colorInt & PConstants3.GREEN_MASK) >>> 8) / 255;
        blue = (colorInt & PConstants3.BLUE_MASK) / 255;
        var max = p.max(p.max(red, green), blue), min = p.min(p.min(red, green), blue), hue, saturation;
        if (min === max) {
          return [0, 0, max * colorModeZ];
        }
        saturation = (max - min) / max;
        if (red === max) {
          hue = (green - blue) / (max - min);
        } else if (green === max) {
          hue = 2 + (blue - red) / (max - min);
        } else {
          hue = 4 + (red - green) / (max - min);
        }
        hue /= 6;
        if (hue < 0) {
          hue += 1;
        } else if (hue > 1) {
          hue -= 1;
        }
        return [hue * colorModeX, saturation * colorModeY, max * colorModeZ];
      }
      p.brightness = function(colInt) {
        return colorToHSB(colInt)[2];
      };
      p.saturation = function(colInt) {
        return colorToHSB(colInt)[1];
      };
      p.hue = function(colInt) {
        return colorToHSB(colInt)[0];
      };
      p.red = function(aColor) {
        return ((aColor & PConstants3.RED_MASK) >>> 16) / 255 * colorModeX;
      };
      p.green = function(aColor) {
        return ((aColor & PConstants3.GREEN_MASK) >>> 8) / 255 * colorModeY;
      };
      p.blue = function(aColor) {
        return (aColor & PConstants3.BLUE_MASK) / 255 * colorModeZ;
      };
      p.alpha = function(aColor) {
        return ((aColor & PConstants3.ALPHA_MASK) >>> 24) / 255 * colorModeA;
      };
      p.lerpColor = function(c1, c2, amt) {
        var r, g, b, a, r1, g1, b1, a1, r2, g2, b2, a2;
        var hsb1, hsb2, rgb, h, s;
        var colorBits1 = p.color(c1);
        var colorBits2 = p.color(c2);
        if (curColorMode === PConstants3.HSB) {
          hsb1 = colorToHSB(colorBits1);
          a1 = ((colorBits1 & PConstants3.ALPHA_MASK) >>> 24) / colorModeA;
          hsb2 = colorToHSB(colorBits2);
          a2 = ((colorBits2 & PConstants3.ALPHA_MASK) >>> 24) / colorModeA;
          h = p.lerp(hsb1[0], hsb2[0], amt);
          s = p.lerp(hsb1[1], hsb2[1], amt);
          b = p.lerp(hsb1[2], hsb2[2], amt);
          rgb = p.color.toRGB(h, s, b);
          a = p.lerp(a1, a2, amt) * colorModeA + 0.5 | 0;
          return a << 24 & PConstants3.ALPHA_MASK | rgb[0] << 16 & PConstants3.RED_MASK | rgb[1] << 8 & PConstants3.GREEN_MASK | rgb[2] & PConstants3.BLUE_MASK;
        }
        r1 = (colorBits1 & PConstants3.RED_MASK) >>> 16;
        g1 = (colorBits1 & PConstants3.GREEN_MASK) >>> 8;
        b1 = colorBits1 & PConstants3.BLUE_MASK;
        a1 = ((colorBits1 & PConstants3.ALPHA_MASK) >>> 24) / colorModeA;
        r2 = (colorBits2 & PConstants3.RED_MASK) >>> 16;
        g2 = (colorBits2 & PConstants3.GREEN_MASK) >>> 8;
        b2 = colorBits2 & PConstants3.BLUE_MASK;
        a2 = ((colorBits2 & PConstants3.ALPHA_MASK) >>> 24) / colorModeA;
        r = p.lerp(r1, r2, amt) + 0.5 | 0;
        g = p.lerp(g1, g2, amt) + 0.5 | 0;
        b = p.lerp(b1, b2, amt) + 0.5 | 0;
        a = p.lerp(a1, a2, amt) * colorModeA + 0.5 | 0;
        return a << 24 & PConstants3.ALPHA_MASK | r << 16 & PConstants3.RED_MASK | g << 8 & PConstants3.GREEN_MASK | b & PConstants3.BLUE_MASK;
      };
      p.colorMode = function() {
        curColorMode = arguments[0];
        if (arguments.length > 1) {
          colorModeX = arguments[1];
          colorModeY = arguments[2] || arguments[1];
          colorModeZ = arguments[3] || arguments[1];
          colorModeA = arguments[4] || arguments[1];
        }
      };
      p.blendColor = function(c1, c2, mode) {
        if (mode === PConstants3.REPLACE) {
          return p.modes.replace(c1, c2);
        } else if (mode === PConstants3.BLEND) {
          return p.modes.blend(c1, c2);
        } else if (mode === PConstants3.ADD) {
          return p.modes.add(c1, c2);
        } else if (mode === PConstants3.SUBTRACT) {
          return p.modes.subtract(c1, c2);
        } else if (mode === PConstants3.LIGHTEST) {
          return p.modes.lightest(c1, c2);
        } else if (mode === PConstants3.DARKEST) {
          return p.modes.darkest(c1, c2);
        } else if (mode === PConstants3.DIFFERENCE) {
          return p.modes.difference(c1, c2);
        } else if (mode === PConstants3.EXCLUSION) {
          return p.modes.exclusion(c1, c2);
        } else if (mode === PConstants3.MULTIPLY) {
          return p.modes.multiply(c1, c2);
        } else if (mode === PConstants3.SCREEN) {
          return p.modes.screen(c1, c2);
        } else if (mode === PConstants3.HARD_LIGHT) {
          return p.modes.hard_light(c1, c2);
        } else if (mode === PConstants3.SOFT_LIGHT) {
          return p.modes.soft_light(c1, c2);
        } else if (mode === PConstants3.OVERLAY) {
          return p.modes.overlay(c1, c2);
        } else if (mode === PConstants3.DODGE) {
          return p.modes.dodge(c1, c2);
        } else if (mode === PConstants3.BURN) {
          return p.modes.burn(c1, c2);
        }
      };
      function saveContext() {
        curContext.save();
      }
      function restoreContext() {
        curContext.restore();
        isStrokeDirty = true;
        isFillDirty = true;
      }
      p.printMatrix = function() {
        modelView.print();
      };
      Drawing2D.prototype.translate = function(x, y) {
        modelView.translate(x, y);
        modelViewInv.invTranslate(x, y);
        curContext.translate(x, y);
      };
      Drawing3D.prototype.translate = function(x, y, z) {
        modelView.translate(x, y, z);
        modelViewInv.invTranslate(x, y, z);
      };
      Drawing2D.prototype.scale = function(x, y) {
        modelView.scale(x, y);
        modelViewInv.invScale(x, y);
        curContext.scale(x, y || x);
      };
      Drawing3D.prototype.scale = function(x, y, z) {
        modelView.scale(x, y, z);
        modelViewInv.invScale(x, y, z);
      };
      Drawing2D.prototype.transform = function(pmatrix) {
        var e = pmatrix.array();
        curContext.transform(e[0], e[3], e[1], e[4], e[2], e[5]);
      };
      Drawing3D.prototype.transformm = function(pmatrix3d) {
        throw "p.transform is currently not supported in 3D mode";
      };
      Drawing2D.prototype.pushMatrix = function() {
        userMatrixStack.load(modelView);
        userReverseMatrixStack.load(modelViewInv);
        saveContext();
      };
      Drawing3D.prototype.pushMatrix = function() {
        userMatrixStack.load(modelView);
        userReverseMatrixStack.load(modelViewInv);
      };
      Drawing2D.prototype.popMatrix = function() {
        modelView.set(userMatrixStack.pop());
        modelViewInv.set(userReverseMatrixStack.pop());
        restoreContext();
      };
      Drawing3D.prototype.popMatrix = function() {
        modelView.set(userMatrixStack.pop());
        modelViewInv.set(userReverseMatrixStack.pop());
      };
      Drawing2D.prototype.resetMatrix = function() {
        modelView.reset();
        modelViewInv.reset();
        curContext.setTransform(1, 0, 0, 1, 0, 0);
      };
      Drawing3D.prototype.resetMatrix = function() {
        modelView.reset();
        modelViewInv.reset();
      };
      DrawingShared.prototype.applyMatrix = function() {
        var a = arguments;
        modelView.apply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
        modelViewInv.invApply(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
      };
      Drawing2D.prototype.applyMatrix = function() {
        var a = arguments;
        for (var cnt = a.length; cnt < 16; cnt++) {
          a[cnt] = 0;
        }
        a[10] = a[15] = 1;
        DrawingShared.prototype.applyMatrix.apply(this, a);
      };
      p.rotateX = function(angleInRadians) {
        modelView.rotateX(angleInRadians);
        modelViewInv.invRotateX(angleInRadians);
      };
      Drawing2D.prototype.rotateZ = function() {
        throw "rotateZ() is not supported in 2D mode. Use rotate(float) instead.";
      };
      Drawing3D.prototype.rotateZ = function(angleInRadians) {
        modelView.rotateZ(angleInRadians);
        modelViewInv.invRotateZ(angleInRadians);
      };
      p.rotateY = function(angleInRadians) {
        modelView.rotateY(angleInRadians);
        modelViewInv.invRotateY(angleInRadians);
      };
      Drawing2D.prototype.rotate = function(angleInRadians) {
        modelView.rotateZ(angleInRadians);
        modelViewInv.invRotateZ(angleInRadians);
        curContext.rotate(angleInRadians);
      };
      Drawing3D.prototype.rotate = function(angleInRadians) {
        if (arguments.length < 4) {
          p.rotateZ(angleInRadians);
        } else {
          modelView.rotate(angleInRadians, arguments[1], arguments[2], arguments[3]);
          modelViewInv.rotate(-angleInRadians, arguments[1], arguments[2], arguments[3]);
        }
      };
      Drawing2D.prototype.shearX = function(angleInRadians) {
        modelView.shearX(angleInRadians);
        curContext.transform(1, 0, angleInRadians, 1, 0, 0);
      };
      Drawing3D.prototype.shearX = function(angleInRadians) {
        modelView.shearX(angleInRadians);
      };
      Drawing2D.prototype.shearY = function(angleInRadians) {
        modelView.shearY(angleInRadians);
        curContext.transform(1, angleInRadians, 0, 1, 0, 0);
      };
      Drawing3D.prototype.shearY = function(angleInRadians) {
        modelView.shearY(angleInRadians);
      };
      p.pushStyle = function() {
        saveContext();
        p.pushMatrix();
        var newState = {
          "doFill": doFill,
          "currentFillColor": currentFillColor,
          "doStroke": doStroke,
          "currentStrokeColor": currentStrokeColor,
          "curTint": curTint,
          "curRectMode": curRectMode,
          "curColorMode": curColorMode,
          "colorModeX": colorModeX,
          "colorModeZ": colorModeZ,
          "colorModeY": colorModeY,
          "colorModeA": colorModeA,
          "curTextFont": curTextFont,
          "horizontalTextAlignment": horizontalTextAlignment,
          "verticalTextAlignment": verticalTextAlignment,
          "textMode": textMode,
          "curFontName": curFontName,
          "curTextSize": curTextSize,
          "curTextAscent": curTextAscent,
          "curTextDescent": curTextDescent,
          "curTextLeading": curTextLeading
        };
        styleArray.push(newState);
      };
      p.popStyle = function() {
        var oldState = styleArray.pop();
        if (oldState) {
          restoreContext();
          p.popMatrix();
          doFill = oldState.doFill;
          currentFillColor = oldState.currentFillColor;
          doStroke = oldState.doStroke;
          currentStrokeColor = oldState.currentStrokeColor;
          curTint = oldState.curTint;
          curRectMode = oldState.curRectMode;
          curColorMode = oldState.curColorMode;
          colorModeX = oldState.colorModeX;
          colorModeZ = oldState.colorModeZ;
          colorModeY = oldState.colorModeY;
          colorModeA = oldState.colorModeA;
          curTextFont = oldState.curTextFont;
          curFontName = oldState.curFontName;
          curTextSize = oldState.curTextSize;
          horizontalTextAlignment = oldState.horizontalTextAlignment;
          verticalTextAlignment = oldState.verticalTextAlignment;
          textMode = oldState.textMode;
          curTextAscent = oldState.curTextAscent;
          curTextDescent = oldState.curTextDescent;
          curTextLeading = oldState.curTextLeading;
        } else {
          throw "Too many popStyle() without enough pushStyle()";
        }
      };
      p.year = function() {
        return (/* @__PURE__ */ new Date()).getFullYear();
      };
      p.month = function() {
        return (/* @__PURE__ */ new Date()).getMonth() + 1;
      };
      p.day = function() {
        return (/* @__PURE__ */ new Date()).getDate();
      };
      p.hour = function() {
        return (/* @__PURE__ */ new Date()).getHours();
      };
      p.minute = function() {
        return (/* @__PURE__ */ new Date()).getMinutes();
      };
      p.second = function() {
        return (/* @__PURE__ */ new Date()).getSeconds();
      };
      p.millis = function() {
        return Date.now() - start;
      };
      function redrawHelper() {
        var sec = (Date.now() - timeSinceLastFPS) / 1e3;
        framesSinceLastFPS++;
        var fps = framesSinceLastFPS / sec;
        if (sec > 0.5) {
          timeSinceLastFPS = Date.now();
          framesSinceLastFPS = 0;
          p.__frameRate = fps;
        }
        p.frameCount++;
      }
      Drawing2D.prototype.redraw = function() {
        redrawHelper();
        curContext.lineWidth = lineWidth;
        var pmouseXLastEvent = p.pmouseX, pmouseYLastEvent = p.pmouseY;
        p.pmouseX = pmouseXLastFrame;
        p.pmouseY = pmouseYLastFrame;
        saveContext();
        p.draw();
        restoreContext();
        pmouseXLastFrame = p.mouseX;
        pmouseYLastFrame = p.mouseY;
        p.pmouseX = pmouseXLastEvent;
        p.pmouseY = pmouseYLastEvent;
      };
      Drawing3D.prototype.redraw = function() {
        redrawHelper();
        var pmouseXLastEvent = p.pmouseX, pmouseYLastEvent = p.pmouseY;
        p.pmouseX = pmouseXLastFrame;
        p.pmouseY = pmouseYLastFrame;
        curContext.clear(curContext.DEPTH_BUFFER_BIT);
        curContextCache = { attributes: {}, locations: {} };
        p.noLights();
        p.lightFalloff(1, 0, 0);
        p.shininess(1);
        p.ambient(255, 255, 255);
        p.specular(0, 0, 0);
        p.emissive(0, 0, 0);
        p.camera();
        p.draw();
        pmouseXLastFrame = p.mouseX;
        pmouseYLastFrame = p.mouseY;
        p.pmouseX = pmouseXLastEvent;
        p.pmouseY = pmouseYLastEvent;
      };
      p.noLoop = function() {
        doLoop = false;
        loopStarted = false;
        clearInterval(looping);
        curSketch.onPause();
      };
      p.loop = function() {
        if (loopStarted) {
          return;
        }
        timeSinceLastFPS = Date.now();
        framesSinceLastFPS = 0;
        looping = window2.setInterval(function() {
          try {
            curSketch.onFrameStart();
            p.redraw();
            curSketch.onFrameEnd();
          } catch (e_loop) {
            window2.clearInterval(looping);
            throw e_loop;
          }
        }, curMsPerFrame);
        doLoop = true;
        loopStarted = true;
        curSketch.onLoop();
      };
      p.frameRate = function(aRate) {
        curFrameRate = aRate;
        curMsPerFrame = 1e3 / curFrameRate;
        if (doLoop) {
          p.noLoop();
          p.loop();
        }
      };
      p.exit = function() {
        window2.clearInterval(looping);
        removeInstance(p.externals.canvas.id);
        delete curElement.onmousedown;
        for (var lib in Processing3.lib) {
          if (Processing3.lib.hasOwnProperty(lib)) {
            if (Processing3.lib[lib].hasOwnProperty("detach")) {
              Processing3.lib[lib].detach(p);
            }
          }
        }
        var i2 = eventHandlers.length;
        while (i2--) {
          detachEventHandler2(eventHandlers[i2]);
        }
        curSketch.onExit();
      };
      p.cursor = function() {
        if (arguments.length > 1 || arguments.length === 1 && arguments[0] instanceof p.PImage) {
          var image = arguments[0], x, y;
          if (arguments.length >= 3) {
            x = arguments[1];
            y = arguments[2];
            if (x < 0 || y < 0 || y >= image.height || x >= image.width) {
              throw "x and y must be non-negative and less than the dimensions of the image";
            }
          } else {
            x = image.width >>> 1;
            y = image.height >>> 1;
          }
          var imageDataURL = image.toDataURL();
          var style = 'url("' + imageDataURL + '") ' + x + " " + y + ", default";
          curCursor = curElement.style.cursor = style;
        } else if (arguments.length === 1) {
          var mode = arguments[0];
          curCursor = curElement.style.cursor = mode;
        } else {
          curCursor = curElement.style.cursor = oldCursor;
        }
      };
      p.noCursor = function() {
        curCursor = curElement.style.cursor = PConstants3.NOCURSOR;
      };
      p.link = function(href, target) {
        if (target !== undef) {
          window2.open(href, target);
        } else {
          window2.location = href;
        }
      };
      p.beginDraw = noop;
      p.endDraw = noop;
      Drawing2D.prototype.toImageData = function(x, y, w, h) {
        x = x !== undef ? x : 0;
        y = y !== undef ? y : 0;
        w = w !== undef ? w : p.width;
        h = h !== undef ? h : p.height;
        return curContext.getImageData(x, y, w, h);
      };
      Drawing3D.prototype.toImageData = function(x, y, w, h) {
        x = x !== undef ? x : 0;
        y = y !== undef ? y : 0;
        w = w !== undef ? w : p.width;
        h = h !== undef ? h : p.height;
        var c = document2.createElement("canvas"), ctx = c.getContext("2d"), obj = ctx.createImageData(w, h), uBuff = new Uint8Array2(w * h * 4);
        curContext.readPixels(x, y, w, h, curContext.RGBA, curContext.UNSIGNED_BYTE, uBuff);
        for (var i2 = 0, ul = uBuff.length, obj_data = obj.data; i2 < ul; i2++) {
          obj_data[i2] = uBuff[(h - 1 - Math.floor(i2 / 4 / w)) * w * 4 + i2 % (w * 4)];
        }
        return obj;
      };
      p.status = function(text) {
        window2.status = text;
      };
      p.binary = function(num, numBits) {
        var bit;
        if (numBits > 0) {
          bit = numBits;
        } else if (num instanceof Char2) {
          bit = 16;
          num |= 0;
        } else {
          bit = 32;
          while (bit > 1 && !(num >>> bit - 1 & 1)) {
            bit--;
          }
        }
        var result = "";
        while (bit > 0) {
          result += num >>> --bit & 1 ? "1" : "0";
        }
        return result;
      };
      p.unbinary = function(binaryString) {
        var i2 = binaryString.length - 1, mask = 1, result = 0;
        while (i2 >= 0) {
          var ch = binaryString[i2--];
          if (ch !== "0" && ch !== "1") {
            throw "the value passed into unbinary was not an 8 bit binary number";
          }
          if (ch === "1") {
            result += mask;
          }
          mask <<= 1;
        }
        return result;
      };
      var decimalToHex = function(d, padding) {
        padding = padding === undef || padding === null ? padding = 8 : padding;
        if (d < 0) {
          d = 4294967295 + d + 1;
        }
        var hex = Number(d).toString(16).toUpperCase();
        while (hex.length < padding) {
          hex = "0" + hex;
        }
        if (hex.length >= padding) {
          hex = hex.substring(hex.length - padding, hex.length);
        }
        return hex;
      };
      p.hex = function(value, len) {
        if (arguments.length === 1) {
          if (value instanceof Char2) {
            len = 4;
          } else {
            len = 8;
          }
        }
        return decimalToHex(value, len);
      };
      function unhexScalar(hex) {
        var value = parseInt("0x" + hex, 16);
        if (value > 2147483647) {
          value -= 4294967296;
        }
        return value;
      }
      p.unhex = function(hex) {
        if (hex instanceof Array) {
          var arr = [];
          for (var i2 = 0; i2 < hex.length; i2++) {
            arr.push(unhexScalar(hex[i2]));
          }
          return arr;
        }
        return unhexScalar(hex);
      };
      p.loadStrings = function(filename) {
        if (localStorage[filename]) {
          return localStorage[filename].split("\n");
        }
        var filecontent = ajax(filename);
        if (typeof filecontent !== "string" || filecontent === "") {
          return [];
        }
        filecontent = filecontent.replace(/(\r\n?)/g, "\n").replace(/\n$/, "");
        return filecontent.split("\n");
      };
      p.saveStrings = function(filename, strings) {
        localStorage[filename] = strings.join("\n");
      };
      p.loadBytes = function(url) {
        var string = ajax(url);
        var ret = [];
        for (var i2 = 0; i2 < string.length; i2++) {
          ret.push(string.charCodeAt(i2));
        }
        return ret;
      };
      p.matchAll = function(aString, aRegExp) {
        var results = [], latest;
        var regexp = new RegExp(aRegExp, "g");
        while ((latest = regexp.exec(aString)) !== null) {
          results.push(latest);
          if (latest[0].length === 0) {
            ++regexp.lastIndex;
          }
        }
        return results.length > 0 ? results : null;
      };
      p.match = function(str, regexp) {
        return str.match(regexp);
      };
      var logBuffer = [];
      p.println = function() {
        Processing3.logger.println.apply(Processing3.logger, arguments);
      };
      p.print = function() {
        Processing3.logger.print.apply(Processing3.logger, arguments);
      };
      p.str = function(val) {
        if (val instanceof Array) {
          var arr = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            arr.push(val[i2].toString() + "");
          }
          return arr;
        }
        return val.toString() + "";
      };
      function booleanScalar(val) {
        if (typeof val === "number") {
          return val !== 0;
        }
        if (typeof val === "boolean") {
          return val;
        }
        if (typeof val === "string") {
          return val.toLowerCase() === "true";
        }
        if (val instanceof Char2) {
          return val.code === 49 || val.code === 84 || val.code === 116;
        }
      }
      p.parseBoolean = function(val) {
        if (val instanceof Array) {
          var ret = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            ret.push(booleanScalar(val[i2]));
          }
          return ret;
        }
        return booleanScalar(val);
      };
      p.parseByte = function(what) {
        if (what instanceof Array) {
          var bytes = [];
          for (var i2 = 0; i2 < what.length; i2++) {
            bytes.push(0 - (what[i2] & 128) | what[i2] & 127);
          }
          return bytes;
        }
        return 0 - (what & 128) | what & 127;
      };
      p.parseChar = function(key) {
        if (typeof key === "number") {
          return new Char2(String.fromCharCode(key & 65535));
        }
        if (key instanceof Array) {
          var ret = [];
          for (var i2 = 0; i2 < key.length; i2++) {
            ret.push(new Char2(String.fromCharCode(key[i2] & 65535)));
          }
          return ret;
        }
        throw "char() may receive only one argument of type int, byte, int[], or byte[].";
      };
      function floatScalar(val) {
        if (typeof val === "number") {
          return val;
        }
        if (typeof val === "boolean") {
          return val ? 1 : 0;
        }
        if (typeof val === "string") {
          return parseFloat(val);
        }
        if (val instanceof Char2) {
          return val.code;
        }
      }
      p.parseFloat = function(val) {
        if (val instanceof Array) {
          var ret = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            ret.push(floatScalar(val[i2]));
          }
          return ret;
        }
        return floatScalar(val);
      };
      function intScalar(val, radix) {
        if (typeof val === "number") {
          return val & 4294967295;
        }
        if (typeof val === "boolean") {
          return val ? 1 : 0;
        }
        if (typeof val === "string") {
          var number = parseInt(val, radix || 10);
          return number & 4294967295;
        }
        if (val instanceof Char2) {
          return val.code;
        }
      }
      p.parseInt = function(val, radix) {
        if (val instanceof Array) {
          var ret = [];
          for (var i2 = 0; i2 < val.length; i2++) {
            if (typeof val[i2] === "string" && !/^\s*[+\-]?\d+\s*$/.test(val[i2])) {
              ret.push(0);
            } else {
              ret.push(intScalar(val[i2], radix));
            }
          }
          return ret;
        }
        return intScalar(val, radix);
      };
      p.__int_cast = function(val) {
        return 0 | val;
      };
      p.__instanceof = function(obj, type) {
        if (typeof type !== "function") {
          throw "Function is expected as type argument for instanceof operator";
        }
        if (typeof obj === "string") {
          return type === Object || type === String;
        }
        if (obj instanceof type) {
          return true;
        }
        if (typeof obj !== "object" || obj === null) {
          return false;
        }
        var objType = obj.constructor;
        if (type.$isInterface) {
          var interfaces = [];
          while (objType) {
            if (objType.$interfaces) {
              interfaces = interfaces.concat(objType.$interfaces);
            }
            objType = objType.$base;
          }
          while (interfaces.length > 0) {
            var i2 = interfaces.shift();
            if (i2 === type) {
              return true;
            }
            if (i2.$interfaces) {
              interfaces = interfaces.concat(i2.$interfaces);
            }
          }
          return false;
        }
        while (objType.hasOwnProperty("$base")) {
          objType = objType.$base;
          if (objType === type) {
            return true;
          }
        }
        return false;
      };
      DrawingShared.prototype.size = function(aWidth, aHeight, aMode) {
        if (doStroke) {
          p.stroke(0);
        }
        if (doFill) {
          p.fill(255);
        }
        var savedProperties = {
          fillStyle: curContext.fillStyle,
          strokeStyle: curContext.strokeStyle,
          lineCap: curContext.lineCap,
          lineJoin: curContext.lineJoin
        };
        if (curElement.style.length > 0) {
          curElement.style.removeProperty("width");
          curElement.style.removeProperty("height");
        }
        curElement.width = p.width = aWidth || 100;
        curElement.height = p.height = aHeight || 100;
        for (var prop in savedProperties) {
          if (savedProperties.hasOwnProperty(prop)) {
            curContext[prop] = savedProperties[prop];
          }
        }
        p.textFont(curTextFont);
        p.background();
        maxPixelsCached = Math.max(1e3, aWidth * aHeight * 0.05);
        p.externals.context = curContext;
        for (var i2 = 0; i2 < PConstants3.SINCOS_LENGTH; i2++) {
          sinLUT[i2] = p.sin(i2 * (PConstants3.PI / 180) * 0.5);
          cosLUT[i2] = p.cos(i2 * (PConstants3.PI / 180) * 0.5);
        }
      };
      Drawing2D.prototype.size = function(aWidth, aHeight, aMode) {
        if (curContext === undef) {
          curContext = curElement.getContext("2d");
          userMatrixStack = new PMatrixStack();
          userReverseMatrixStack = new PMatrixStack();
          modelView = new PMatrix2D2();
          modelViewInv = new PMatrix2D2();
        }
        DrawingShared.prototype.size.apply(this, arguments);
      };
      Drawing3D.prototype.size = /* @__PURE__ */ function() {
        var size3DCalled = false;
        return function size(aWidth, aHeight, aMode) {
          if (size3DCalled) {
            throw "Multiple calls to size() for 3D renders are not allowed.";
          }
          size3DCalled = true;
          function getGLContext(canvas) {
            var ctxNames = ["experimental-webgl", "webgl", "webkit-3d"], gl;
            for (var i2 = 0, l2 = ctxNames.length; i2 < l2; i2++) {
              gl = canvas.getContext(ctxNames[i2], { antialias: false, preserveDrawingBuffer: true });
              if (gl) {
                break;
              }
            }
            return gl;
          }
          try {
            curElement.width = p.width = aWidth || 100;
            curElement.height = p.height = aHeight || 100;
            curContext = getGLContext(curElement);
            canTex = curContext.createTexture();
            textTex = curContext.createTexture();
          } catch (e_size) {
            Processing3.debug(e_size);
          }
          if (!curContext) {
            throw "WebGL context is not supported on this browser.";
          }
          curContext.viewport(0, 0, curElement.width, curElement.height);
          curContext.enable(curContext.DEPTH_TEST);
          curContext.enable(curContext.BLEND);
          curContext.blendFunc(curContext.SRC_ALPHA, curContext.ONE_MINUS_SRC_ALPHA);
          programObject2D = createProgramObject(curContext, vertexShaderSrc2D, fragmentShaderSrc2D);
          programObjectUnlitShape = createProgramObject(curContext, vertexShaderSrcUnlitShape, fragmentShaderSrcUnlitShape);
          p.strokeWeight(1);
          programObject3D = createProgramObject(curContext, vertexShaderSrc3D, fragmentShaderSrc3D);
          curContext.useProgram(programObject3D);
          uniformi("usingTexture3d", programObject3D, "usingTexture", usingTexture);
          p.lightFalloff(1, 0, 0);
          p.shininess(1);
          p.ambient(255, 255, 255);
          p.specular(0, 0, 0);
          p.emissive(0, 0, 0);
          boxBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, boxBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, boxVerts, curContext.STATIC_DRAW);
          boxNormBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, boxNormBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, boxNorms, curContext.STATIC_DRAW);
          boxOutlineBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, boxOutlineBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, boxOutlineVerts, curContext.STATIC_DRAW);
          rectBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, rectBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, rectVerts, curContext.STATIC_DRAW);
          rectNormBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, rectNormBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, rectNorms, curContext.STATIC_DRAW);
          sphereBuffer = curContext.createBuffer();
          lineBuffer = curContext.createBuffer();
          fillBuffer = curContext.createBuffer();
          fillColorBuffer = curContext.createBuffer();
          strokeColorBuffer = curContext.createBuffer();
          shapeTexVBO = curContext.createBuffer();
          pointBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, pointBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2([0, 0, 0]), curContext.STATIC_DRAW);
          textBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, textBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0]), curContext.STATIC_DRAW);
          textureBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ARRAY_BUFFER, textureBuffer);
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2([0, 0, 1, 0, 1, 1, 0, 1]), curContext.STATIC_DRAW);
          indexBuffer = curContext.createBuffer();
          curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
          curContext.bufferData(curContext.ELEMENT_ARRAY_BUFFER, new Uint16Array2([0, 1, 2, 2, 3, 0]), curContext.STATIC_DRAW);
          cam = new PMatrix3D2();
          cameraInv = new PMatrix3D2();
          modelView = new PMatrix3D2();
          modelViewInv = new PMatrix3D2();
          projection = new PMatrix3D2();
          p.camera();
          p.perspective();
          userMatrixStack = new PMatrixStack();
          userReverseMatrixStack = new PMatrixStack();
          curveBasisMatrix = new PMatrix3D2();
          curveToBezierMatrix = new PMatrix3D2();
          curveDrawMatrix = new PMatrix3D2();
          bezierDrawMatrix = new PMatrix3D2();
          bezierBasisInverse = new PMatrix3D2();
          bezierBasisMatrix = new PMatrix3D2();
          bezierBasisMatrix.set(-1, 3, -3, 1, 3, -6, 3, 0, -3, 3, 0, 0, 1, 0, 0, 0);
          DrawingShared.prototype.size.apply(this, arguments);
        };
      }();
      Drawing2D.prototype.ambientLight = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.ambientLight = function(r, g, b, x, y, z) {
        if (lightCount === PConstants3.MAX_LIGHTS) {
          throw "can only create " + PConstants3.MAX_LIGHTS + " lights";
        }
        var pos = new PVector3(x, y, z);
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.mult(pos, pos);
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        curContext.useProgram(programObject3D);
        uniformf("uLights.color.3d." + lightCount, programObject3D, "uLights" + lightCount + ".color", normalizedCol);
        uniformf("uLights.position.3d." + lightCount, programObject3D, "uLights" + lightCount + ".position", pos.array());
        uniformi("uLights.type.3d." + lightCount, programObject3D, "uLights" + lightCount + ".type", 0);
        uniformi("uLightCount3d", programObject3D, "uLightCount", ++lightCount);
      };
      Drawing2D.prototype.directionalLight = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.directionalLight = function(r, g, b, nx, ny, nz) {
        if (lightCount === PConstants3.MAX_LIGHTS) {
          throw "can only create " + PConstants3.MAX_LIGHTS + " lights";
        }
        curContext.useProgram(programObject3D);
        var mvm = new PMatrix3D2();
        mvm.scale(1, -1, 1);
        mvm.apply(modelView.array());
        mvm = mvm.array();
        var dir = [
          mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,
          mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,
          mvm[2] * nx + mvm[6] * ny + mvm[10] * nz
        ];
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        uniformf("uLights.color.3d." + lightCount, programObject3D, "uLights" + lightCount + ".color", normalizedCol);
        uniformf("uLights.position.3d." + lightCount, programObject3D, "uLights" + lightCount + ".position", dir);
        uniformi("uLights.type.3d." + lightCount, programObject3D, "uLights" + lightCount + ".type", 1);
        uniformi("uLightCount3d", programObject3D, "uLightCount", ++lightCount);
      };
      Drawing2D.prototype.lightFalloff = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.lightFalloff = function(constant, linear, quadratic) {
        curContext.useProgram(programObject3D);
        uniformf("uFalloff3d", programObject3D, "uFalloff", [constant, linear, quadratic]);
      };
      Drawing2D.prototype.lightSpecular = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.lightSpecular = function(r, g, b) {
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        curContext.useProgram(programObject3D);
        uniformf("uSpecular3d", programObject3D, "uSpecular", normalizedCol);
      };
      p.lights = function() {
        p.ambientLight(128, 128, 128);
        p.directionalLight(128, 128, 128, 0, 0, -1);
        p.lightFalloff(1, 0, 0);
        p.lightSpecular(0, 0, 0);
      };
      Drawing2D.prototype.pointLight = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.pointLight = function(r, g, b, x, y, z) {
        if (lightCount === PConstants3.MAX_LIGHTS) {
          throw "can only create " + PConstants3.MAX_LIGHTS + " lights";
        }
        var pos = new PVector3(x, y, z);
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.mult(pos, pos);
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        curContext.useProgram(programObject3D);
        uniformf("uLights.color.3d." + lightCount, programObject3D, "uLights" + lightCount + ".color", normalizedCol);
        uniformf("uLights.position.3d." + lightCount, programObject3D, "uLights" + lightCount + ".position", pos.array());
        uniformi("uLights.type.3d." + lightCount, programObject3D, "uLights" + lightCount + ".type", 2);
        uniformi("uLightCount3d", programObject3D, "uLightCount", ++lightCount);
      };
      Drawing2D.prototype.noLights = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.noLights = function() {
        lightCount = 0;
        curContext.useProgram(programObject3D);
        uniformi("uLightCount3d", programObject3D, "uLightCount", lightCount);
      };
      Drawing2D.prototype.spotLight = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.spotLight = function(r, g, b, x, y, z, nx, ny, nz, angle, concentration) {
        if (lightCount === PConstants3.MAX_LIGHTS) {
          throw "can only create " + PConstants3.MAX_LIGHTS + " lights";
        }
        curContext.useProgram(programObject3D);
        var pos = new PVector3(x, y, z);
        var mvm = new PMatrix3D2();
        mvm.scale(1, -1, 1);
        mvm.apply(modelView.array());
        mvm.mult(pos, pos);
        mvm = mvm.array();
        var dir = [
          mvm[0] * nx + mvm[4] * ny + mvm[8] * nz,
          mvm[1] * nx + mvm[5] * ny + mvm[9] * nz,
          mvm[2] * nx + mvm[6] * ny + mvm[10] * nz
        ];
        var col = color$4(r, g, b, 0);
        var normalizedCol = [
          ((col & PConstants3.RED_MASK) >>> 16) / 255,
          ((col & PConstants3.GREEN_MASK) >>> 8) / 255,
          (col & PConstants3.BLUE_MASK) / 255
        ];
        uniformf("uLights.color.3d." + lightCount, programObject3D, "uLights" + lightCount + ".color", normalizedCol);
        uniformf("uLights.position.3d." + lightCount, programObject3D, "uLights" + lightCount + ".position", pos.array());
        uniformf("uLights.direction.3d." + lightCount, programObject3D, "uLights" + lightCount + ".direction", dir);
        uniformf("uLights.concentration.3d." + lightCount, programObject3D, "uLights" + lightCount + ".concentration", concentration);
        uniformf("uLights.angle.3d." + lightCount, programObject3D, "uLights" + lightCount + ".angle", angle);
        uniformi("uLights.type.3d." + lightCount, programObject3D, "uLights" + lightCount + ".type", 3);
        uniformi("uLightCount3d", programObject3D, "uLightCount", ++lightCount);
      };
      Drawing2D.prototype.beginCamera = function() {
        throw "beginCamera() is not available in 2D mode";
      };
      Drawing3D.prototype.beginCamera = function() {
        if (manipulatingCamera) {
          throw "You cannot call beginCamera() again before calling endCamera()";
        }
        manipulatingCamera = true;
        modelView = cameraInv;
        modelViewInv = cam;
      };
      Drawing2D.prototype.endCamera = function() {
        throw "endCamera() is not available in 2D mode";
      };
      Drawing3D.prototype.endCamera = function() {
        if (!manipulatingCamera) {
          throw "You cannot call endCamera() before calling beginCamera()";
        }
        modelView.set(cam);
        modelViewInv.set(cameraInv);
        manipulatingCamera = false;
      };
      p.camera = function(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
        if (eyeX === undef) {
          cameraX = p.width / 2;
          cameraY = p.height / 2;
          cameraZ = cameraY / Math.tan(cameraFOV / 2);
          eyeX = cameraX;
          eyeY = cameraY;
          eyeZ = cameraZ;
          centerX = cameraX;
          centerY = cameraY;
          centerZ = 0;
          upX = 0;
          upY = 1;
          upZ = 0;
        }
        var z = new PVector3(eyeX - centerX, eyeY - centerY, eyeZ - centerZ);
        var y = new PVector3(upX, upY, upZ);
        z.normalize();
        var x = PVector3.cross(y, z);
        y = PVector3.cross(z, x);
        x.normalize();
        y.normalize();
        var xX = x.x, xY = x.y, xZ = x.z;
        var yX = y.x, yY = y.y, yZ = y.z;
        var zX = z.x, zY = z.y, zZ = z.z;
        cam.set(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);
        cam.translate(-eyeX, -eyeY, -eyeZ);
        cameraInv.reset();
        cameraInv.invApply(xX, xY, xZ, 0, yX, yY, yZ, 0, zX, zY, zZ, 0, 0, 0, 0, 1);
        cameraInv.translate(eyeX, eyeY, eyeZ);
        modelView.set(cam);
        modelViewInv.set(cameraInv);
      };
      p.perspective = function(fov, aspect, near, far) {
        if (arguments.length === 0) {
          cameraY = curElement.height / 2;
          cameraZ = cameraY / Math.tan(cameraFOV / 2);
          cameraNear = cameraZ / 10;
          cameraFar = cameraZ * 10;
          cameraAspect = p.width / p.height;
          fov = cameraFOV;
          aspect = cameraAspect;
          near = cameraNear;
          far = cameraFar;
        }
        var yMax, yMin, xMax, xMin;
        yMax = near * Math.tan(fov / 2);
        yMin = -yMax;
        xMax = yMax * aspect;
        xMin = yMin * aspect;
        p.frustum(xMin, xMax, yMin, yMax, near, far);
      };
      Drawing2D.prototype.frustum = function() {
        throw "Processing.js: frustum() is not supported in 2D mode";
      };
      Drawing3D.prototype.frustum = function(left, right, bottom, top, near, far) {
        frustumMode = true;
        projection = new PMatrix3D2();
        projection.set(
          2 * near / (right - left),
          0,
          (right + left) / (right - left),
          0,
          0,
          2 * near / (top - bottom),
          (top + bottom) / (top - bottom),
          0,
          0,
          0,
          -(far + near) / (far - near),
          -(2 * far * near) / (far - near),
          0,
          0,
          -1,
          0
        );
        var proj = new PMatrix3D2();
        proj.set(projection);
        proj.transpose();
        curContext.useProgram(programObject2D);
        uniformMatrix("projection2d", programObject2D, "uProjection", false, proj.array());
        curContext.useProgram(programObject3D);
        uniformMatrix("projection3d", programObject3D, "uProjection", false, proj.array());
        curContext.useProgram(programObjectUnlitShape);
        uniformMatrix("uProjectionUS", programObjectUnlitShape, "uProjection", false, proj.array());
      };
      p.ortho = function(left, right, bottom, top, near, far) {
        if (arguments.length === 0) {
          left = 0;
          right = p.width;
          bottom = 0;
          top = p.height;
          near = -10;
          far = 10;
        }
        var x = 2 / (right - left);
        var y = 2 / (top - bottom);
        var z = -2 / (far - near);
        var tx = -(right + left) / (right - left);
        var ty = -(top + bottom) / (top - bottom);
        var tz = -(far + near) / (far - near);
        projection = new PMatrix3D2();
        projection.set(x, 0, 0, tx, 0, y, 0, ty, 0, 0, z, tz, 0, 0, 0, 1);
        var proj = new PMatrix3D2();
        proj.set(projection);
        proj.transpose();
        curContext.useProgram(programObject2D);
        uniformMatrix("projection2d", programObject2D, "uProjection", false, proj.array());
        curContext.useProgram(programObject3D);
        uniformMatrix("projection3d", programObject3D, "uProjection", false, proj.array());
        curContext.useProgram(programObjectUnlitShape);
        uniformMatrix("uProjectionUS", programObjectUnlitShape, "uProjection", false, proj.array());
        frustumMode = false;
      };
      p.printProjection = function() {
        projection.print();
      };
      p.printCamera = function() {
        cam.print();
      };
      Drawing2D.prototype.box = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.box = function(w, h, d) {
        if (!h || !d) {
          h = d = w;
        }
        var model = new PMatrix3D2();
        model.scale(w, h, d);
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        if (doFill) {
          curContext.useProgram(programObject3D);
          uniformMatrix("model3d", programObject3D, "uModel", false, model.array());
          uniformMatrix("view3d", programObject3D, "uView", false, view.array());
          curContext.enable(curContext.POLYGON_OFFSET_FILL);
          curContext.polygonOffset(1, 1);
          uniformf("color3d", programObject3D, "uColor", fillStyle);
          if (lightCount > 0) {
            var v = new PMatrix3D2();
            v.set(view);
            var m = new PMatrix3D2();
            m.set(model);
            v.mult(m);
            var normalMatrix = new PMatrix3D2();
            normalMatrix.set(v);
            normalMatrix.invert();
            normalMatrix.transpose();
            uniformMatrix("uNormalTransform3d", programObject3D, "uNormalTransform", false, normalMatrix.array());
            vertexAttribPointer("aNormal3d", programObject3D, "aNormal", 3, boxNormBuffer);
          } else {
            disableVertexAttribPointer("aNormal3d", programObject3D, "aNormal");
          }
          vertexAttribPointer("aVertex3d", programObject3D, "aVertex", 3, boxBuffer);
          disableVertexAttribPointer("aColor3d", programObject3D, "aColor");
          disableVertexAttribPointer("aTexture3d", programObject3D, "aTexture");
          curContext.drawArrays(curContext.TRIANGLES, 0, boxVerts.length / 3);
          curContext.disable(curContext.POLYGON_OFFSET_FILL);
        }
        if (lineWidth > 0 && doStroke) {
          curContext.useProgram(programObject2D);
          uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
          uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText2d", programObject2D, "uIsDrawingText", false);
          vertexAttribPointer("vertex2d", programObject2D, "aVertex", 3, boxOutlineBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          curContext.drawArrays(curContext.LINES, 0, boxOutlineVerts.length / 3);
        }
      };
      var initSphere = function() {
        var i2;
        sphereVerts = [];
        for (i2 = 0; i2 < sphereDetailU; i2++) {
          sphereVerts.push(0);
          sphereVerts.push(-1);
          sphereVerts.push(0);
          sphereVerts.push(sphereX[i2]);
          sphereVerts.push(sphereY[i2]);
          sphereVerts.push(sphereZ[i2]);
        }
        sphereVerts.push(0);
        sphereVerts.push(-1);
        sphereVerts.push(0);
        sphereVerts.push(sphereX[0]);
        sphereVerts.push(sphereY[0]);
        sphereVerts.push(sphereZ[0]);
        var v1, v11, v2;
        var voff = 0;
        for (i2 = 2; i2 < sphereDetailV; i2++) {
          v1 = v11 = voff;
          voff += sphereDetailU;
          v2 = voff;
          for (var j = 0; j < sphereDetailU; j++) {
            sphereVerts.push(sphereX[v1]);
            sphereVerts.push(sphereY[v1]);
            sphereVerts.push(sphereZ[v1++]);
            sphereVerts.push(sphereX[v2]);
            sphereVerts.push(sphereY[v2]);
            sphereVerts.push(sphereZ[v2++]);
          }
          v1 = v11;
          v2 = voff;
          sphereVerts.push(sphereX[v1]);
          sphereVerts.push(sphereY[v1]);
          sphereVerts.push(sphereZ[v1]);
          sphereVerts.push(sphereX[v2]);
          sphereVerts.push(sphereY[v2]);
          sphereVerts.push(sphereZ[v2]);
        }
        for (i2 = 0; i2 < sphereDetailU; i2++) {
          v2 = voff + i2;
          sphereVerts.push(sphereX[v2]);
          sphereVerts.push(sphereY[v2]);
          sphereVerts.push(sphereZ[v2]);
          sphereVerts.push(0);
          sphereVerts.push(1);
          sphereVerts.push(0);
        }
        sphereVerts.push(sphereX[voff]);
        sphereVerts.push(sphereY[voff]);
        sphereVerts.push(sphereZ[voff]);
        sphereVerts.push(0);
        sphereVerts.push(1);
        sphereVerts.push(0);
        curContext.bindBuffer(curContext.ARRAY_BUFFER, sphereBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(sphereVerts), curContext.STATIC_DRAW);
      };
      p.sphereDetail = function(ures, vres) {
        var i2;
        if (arguments.length === 1) {
          ures = vres = arguments[0];
        }
        if (ures < 3) {
          ures = 3;
        }
        if (vres < 2) {
          vres = 2;
        }
        if (ures === sphereDetailU && vres === sphereDetailV) {
          return;
        }
        var delta = PConstants3.SINCOS_LENGTH / ures;
        var cx = new Float32Array2(ures);
        var cz = new Float32Array2(ures);
        for (i2 = 0; i2 < ures; i2++) {
          cx[i2] = cosLUT[i2 * delta % PConstants3.SINCOS_LENGTH | 0];
          cz[i2] = sinLUT[i2 * delta % PConstants3.SINCOS_LENGTH | 0];
        }
        var vertCount = ures * (vres - 1) + 2;
        var currVert = 0;
        sphereX = new Float32Array2(vertCount);
        sphereY = new Float32Array2(vertCount);
        sphereZ = new Float32Array2(vertCount);
        var angle_step = PConstants3.SINCOS_LENGTH * 0.5 / vres;
        var angle = angle_step;
        for (i2 = 1; i2 < vres; i2++) {
          var curradius = sinLUT[angle % PConstants3.SINCOS_LENGTH | 0];
          var currY = -cosLUT[angle % PConstants3.SINCOS_LENGTH | 0];
          for (var j = 0; j < ures; j++) {
            sphereX[currVert] = cx[j] * curradius;
            sphereY[currVert] = currY;
            sphereZ[currVert++] = cz[j] * curradius;
          }
          angle += angle_step;
        }
        sphereDetailU = ures;
        sphereDetailV = vres;
        initSphere();
      };
      Drawing2D.prototype.sphere = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.sphere = function() {
        var sRad = arguments[0];
        if (sphereDetailU < 3 || sphereDetailV < 2) {
          p.sphereDetail(30);
        }
        var model = new PMatrix3D2();
        model.scale(sRad, sRad, sRad);
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        if (doFill) {
          if (lightCount > 0) {
            var v = new PMatrix3D2();
            v.set(view);
            var m = new PMatrix3D2();
            m.set(model);
            v.mult(m);
            var normalMatrix = new PMatrix3D2();
            normalMatrix.set(v);
            normalMatrix.invert();
            normalMatrix.transpose();
            uniformMatrix("uNormalTransform3d", programObject3D, "uNormalTransform", false, normalMatrix.array());
            vertexAttribPointer("aNormal3d", programObject3D, "aNormal", 3, sphereBuffer);
          } else {
            disableVertexAttribPointer("aNormal3d", programObject3D, "aNormal");
          }
          curContext.useProgram(programObject3D);
          disableVertexAttribPointer("aTexture3d", programObject3D, "aTexture");
          uniformMatrix("uModel3d", programObject3D, "uModel", false, model.array());
          uniformMatrix("uView3d", programObject3D, "uView", false, view.array());
          vertexAttribPointer("aVertex3d", programObject3D, "aVertex", 3, sphereBuffer);
          disableVertexAttribPointer("aColor3d", programObject3D, "aColor");
          curContext.enable(curContext.POLYGON_OFFSET_FILL);
          curContext.polygonOffset(1, 1);
          uniformf("uColor3d", programObject3D, "uColor", fillStyle);
          curContext.drawArrays(curContext.TRIANGLE_STRIP, 0, sphereVerts.length / 3);
          curContext.disable(curContext.POLYGON_OFFSET_FILL);
        }
        if (lineWidth > 0 && doStroke) {
          curContext.useProgram(programObject2D);
          uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
          uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
          vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, sphereBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText", programObject2D, "uIsDrawingText", false);
          curContext.drawArrays(curContext.LINE_STRIP, 0, sphereVerts.length / 3);
        }
      };
      p.modelX = function(x, y, z) {
        var mv = modelView.array();
        var ci = cameraInv.array();
        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
        var ox = ci[0] * ax + ci[1] * ay + ci[2] * az + ci[3] * aw;
        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;
        return ow !== 0 ? ox / ow : ox;
      };
      p.modelY = function(x, y, z) {
        var mv = modelView.array();
        var ci = cameraInv.array();
        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
        var oy = ci[4] * ax + ci[5] * ay + ci[6] * az + ci[7] * aw;
        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;
        return ow !== 0 ? oy / ow : oy;
      };
      p.modelZ = function(x, y, z) {
        var mv = modelView.array();
        var ci = cameraInv.array();
        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
        var oz = ci[8] * ax + ci[9] * ay + ci[10] * az + ci[11] * aw;
        var ow = ci[12] * ax + ci[13] * ay + ci[14] * az + ci[15] * aw;
        return ow !== 0 ? oz / ow : oz;
      };
      Drawing2D.prototype.ambient = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.ambient = function(v1, v2, v3) {
        curContext.useProgram(programObject3D);
        uniformi("uUsingMat3d", programObject3D, "uUsingMat", true);
        var col = p.color(v1, v2, v3);
        uniformf("uMaterialAmbient3d", programObject3D, "uMaterialAmbient", p.color.toGLArray(col).slice(0, 3));
      };
      Drawing2D.prototype.emissive = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.emissive = function(v1, v2, v3) {
        curContext.useProgram(programObject3D);
        uniformi("uUsingMat3d", programObject3D, "uUsingMat", true);
        var col = p.color(v1, v2, v3);
        uniformf("uMaterialEmissive3d", programObject3D, "uMaterialEmissive", p.color.toGLArray(col).slice(0, 3));
      };
      Drawing2D.prototype.shininess = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.shininess = function(shine) {
        curContext.useProgram(programObject3D);
        uniformi("uUsingMat3d", programObject3D, "uUsingMat", true);
        uniformf("uShininess3d", programObject3D, "uShininess", shine);
      };
      Drawing2D.prototype.specular = DrawingShared.prototype.a3DOnlyFunction;
      Drawing3D.prototype.specular = function(v1, v2, v3) {
        curContext.useProgram(programObject3D);
        uniformi("uUsingMat3d", programObject3D, "uUsingMat", true);
        var col = p.color(v1, v2, v3);
        uniformf("uMaterialSpecular3d", programObject3D, "uMaterialSpecular", p.color.toGLArray(col).slice(0, 3));
      };
      p.screenX = function(x, y, z) {
        var mv = modelView.array();
        if (mv.length === 16) {
          var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
          var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
          var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
          var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
          var pj = projection.array();
          var ox = pj[0] * ax + pj[1] * ay + pj[2] * az + pj[3] * aw;
          var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;
          if (ow !== 0) {
            ox /= ow;
          }
          return p.width * (1 + ox) / 2;
        }
        return modelView.multX(x, y);
      };
      p.screenY = function screenY(x, y, z) {
        var mv = modelView.array();
        if (mv.length === 16) {
          var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
          var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
          var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
          var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
          var pj = projection.array();
          var oy = pj[4] * ax + pj[5] * ay + pj[6] * az + pj[7] * aw;
          var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;
          if (ow !== 0) {
            oy /= ow;
          }
          return p.height * (1 + oy) / 2;
        }
        return modelView.multY(x, y);
      };
      p.screenZ = function screenZ(x, y, z) {
        var mv = modelView.array();
        if (mv.length !== 16) {
          return 0;
        }
        var pj = projection.array();
        var ax = mv[0] * x + mv[1] * y + mv[2] * z + mv[3];
        var ay = mv[4] * x + mv[5] * y + mv[6] * z + mv[7];
        var az = mv[8] * x + mv[9] * y + mv[10] * z + mv[11];
        var aw = mv[12] * x + mv[13] * y + mv[14] * z + mv[15];
        var oz = pj[8] * ax + pj[9] * ay + pj[10] * az + pj[11] * aw;
        var ow = pj[12] * ax + pj[13] * ay + pj[14] * az + pj[15] * aw;
        if (ow !== 0) {
          oz /= ow;
        }
        return (oz + 1) / 2;
      };
      DrawingShared.prototype.fill = function() {
        var color = p.color.apply(this, arguments);
        if (color === currentFillColor && doFill) {
          return;
        }
        doFill = true;
        currentFillColor = color;
      };
      Drawing2D.prototype.fill = function() {
        DrawingShared.prototype.fill.apply(this, arguments);
        isFillDirty = true;
      };
      Drawing3D.prototype.fill = function() {
        DrawingShared.prototype.fill.apply(this, arguments);
        fillStyle = p.color.toGLArray(currentFillColor);
      };
      function executeContextFill() {
        if (doFill) {
          if (isFillDirty) {
            curContext.fillStyle = p.color.toString(currentFillColor);
            isFillDirty = false;
          }
          curContext.fill();
        }
      }
      p.noFill = function() {
        doFill = false;
      };
      DrawingShared.prototype.stroke = function() {
        var color = p.color.apply(this, arguments);
        if (color === currentStrokeColor && doStroke) {
          return;
        }
        doStroke = true;
        currentStrokeColor = color;
      };
      Drawing2D.prototype.stroke = function() {
        DrawingShared.prototype.stroke.apply(this, arguments);
        isStrokeDirty = true;
      };
      Drawing3D.prototype.stroke = function() {
        DrawingShared.prototype.stroke.apply(this, arguments);
        strokeStyle = p.color.toGLArray(currentStrokeColor);
      };
      function executeContextStroke() {
        if (doStroke) {
          if (isStrokeDirty) {
            curContext.strokeStyle = p.color.toString(currentStrokeColor);
            isStrokeDirty = false;
          }
          curContext.stroke();
        }
      }
      p.noStroke = function() {
        doStroke = false;
      };
      DrawingShared.prototype.strokeWeight = function(w) {
        lineWidth = w;
      };
      Drawing2D.prototype.strokeWeight = function(w) {
        DrawingShared.prototype.strokeWeight.apply(this, arguments);
        curContext.lineWidth = w;
      };
      Drawing3D.prototype.strokeWeight = function(w) {
        DrawingShared.prototype.strokeWeight.apply(this, arguments);
        curContext.useProgram(programObject2D);
        uniformf("pointSize2d", programObject2D, "uPointSize", w);
        curContext.useProgram(programObjectUnlitShape);
        uniformf("pointSizeUnlitShape", programObjectUnlitShape, "uPointSize", w);
        curContext.lineWidth(w);
      };
      p.strokeCap = function(value) {
        drawing.$ensureContext().lineCap = value;
      };
      p.strokeJoin = function(value) {
        drawing.$ensureContext().lineJoin = value;
      };
      Drawing2D.prototype.smooth = function() {
        renderSmooth = true;
        var style = curElement.style;
        style.setProperty("image-rendering", "optimizeQuality", "important");
        style.setProperty("-ms-interpolation-mode", "bicubic", "important");
        if (curContext.hasOwnProperty("mozImageSmoothingEnabled")) {
          curContext.mozImageSmoothingEnabled = true;
        }
      };
      Drawing3D.prototype.smooth = function() {
        renderSmooth = true;
      };
      Drawing2D.prototype.noSmooth = function() {
        renderSmooth = false;
        var style = curElement.style;
        style.setProperty("image-rendering", "optimizeSpeed", "important");
        style.setProperty("image-rendering", "-moz-crisp-edges", "important");
        style.setProperty("image-rendering", "-webkit-optimize-contrast", "important");
        style.setProperty("image-rendering", "optimize-contrast", "important");
        style.setProperty("-ms-interpolation-mode", "nearest-neighbor", "important");
        if (curContext.hasOwnProperty("mozImageSmoothingEnabled")) {
          curContext.mozImageSmoothingEnabled = false;
        }
      };
      Drawing3D.prototype.noSmooth = function() {
        renderSmooth = false;
      };
      Drawing2D.prototype.point = function(x, y) {
        if (!doStroke) {
          return;
        }
        if (!renderSmooth) {
          x = Math.round(x);
          y = Math.round(y);
        }
        curContext.fillStyle = p.color.toString(currentStrokeColor);
        isFillDirty = true;
        if (lineWidth > 1) {
          curContext.beginPath();
          curContext.arc(x, y, lineWidth / 2, 0, PConstants3.TWO_PI, false);
          curContext.fill();
        } else {
          curContext.fillRect(x, y, 1, 1);
        }
      };
      Drawing3D.prototype.point = function(x, y, z) {
        var model = new PMatrix3D2();
        model.translate(x, y, z || 0);
        model.transpose();
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObject2D);
        uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
        uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
        if (lineWidth > 0 && doStroke) {
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText2d", programObject2D, "uIsDrawingText", false);
          uniformi("uSmooth2d", programObject2D, "uSmooth", renderSmooth);
          vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, pointBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          curContext.drawArrays(curContext.POINTS, 0, 1);
        }
      };
      p.beginShape = function(type) {
        curShape = type;
        curvePoints = [];
        vertArray2 = [];
      };
      Drawing2D.prototype.vertex = function(x, y, moveTo) {
        var vert = [];
        if (firstVert) {
          firstVert = false;
        }
        vert.isVert = true;
        vert[0] = x;
        vert[1] = y;
        vert[2] = 0;
        vert[3] = 0;
        vert[4] = 0;
        vert[5] = currentFillColor;
        vert[6] = currentStrokeColor;
        vertArray2.push(vert);
        if (moveTo) {
          vertArray2[vertArray2.length - 1].moveTo = moveTo;
        }
      };
      Drawing3D.prototype.vertex = function(x, y, z, u, v) {
        var vert = [];
        if (firstVert) {
          firstVert = false;
        }
        vert.isVert = true;
        if (v === undef && usingTexture) {
          v = u;
          u = z;
          z = 0;
        }
        if (u !== undef && v !== undef) {
          if (curTextureMode === PConstants3.IMAGE) {
            u /= curTexture.width;
            v /= curTexture.height;
          }
          u = u > 1 ? 1 : u;
          u = u < 0 ? 0 : u;
          v = v > 1 ? 1 : v;
          v = v < 0 ? 0 : v;
        }
        vert[0] = x;
        vert[1] = y;
        vert[2] = z || 0;
        vert[3] = u || 0;
        vert[4] = v || 0;
        vert[5] = fillStyle[0];
        vert[6] = fillStyle[1];
        vert[7] = fillStyle[2];
        vert[8] = fillStyle[3];
        vert[9] = strokeStyle[0];
        vert[10] = strokeStyle[1];
        vert[11] = strokeStyle[2];
        vert[12] = strokeStyle[3];
        vert[13] = normalX;
        vert[14] = normalY;
        vert[15] = normalZ;
        vertArray2.push(vert);
      };
      var point3D = function(vArray, cArray) {
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObjectUnlitShape);
        uniformMatrix("uViewUS", programObjectUnlitShape, "uView", false, view.array());
        uniformi("uSmoothUS", programObjectUnlitShape, "uSmooth", renderSmooth);
        vertexAttribPointer("aVertexUS", programObjectUnlitShape, "aVertex", 3, pointBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(vArray), curContext.STREAM_DRAW);
        vertexAttribPointer("aColorUS", programObjectUnlitShape, "aColor", 4, fillColorBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(cArray), curContext.STREAM_DRAW);
        curContext.drawArrays(curContext.POINTS, 0, vArray.length / 3);
      };
      var line3D = function(vArray, mode, cArray) {
        var ctxMode;
        if (mode === "LINES") {
          ctxMode = curContext.LINES;
        } else if (mode === "LINE_LOOP") {
          ctxMode = curContext.LINE_LOOP;
        } else {
          ctxMode = curContext.LINE_STRIP;
        }
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObjectUnlitShape);
        uniformMatrix("uViewUS", programObjectUnlitShape, "uView", false, view.array());
        vertexAttribPointer("aVertexUS", programObjectUnlitShape, "aVertex", 3, lineBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(vArray), curContext.STREAM_DRAW);
        vertexAttribPointer("aColorUS", programObjectUnlitShape, "aColor", 4, strokeColorBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(cArray), curContext.STREAM_DRAW);
        curContext.drawArrays(ctxMode, 0, vArray.length / 3);
      };
      var fill3D = function(vArray, mode, cArray, tArray) {
        var ctxMode;
        if (mode === "TRIANGLES") {
          ctxMode = curContext.TRIANGLES;
        } else if (mode === "TRIANGLE_FAN") {
          ctxMode = curContext.TRIANGLE_FAN;
        } else {
          ctxMode = curContext.TRIANGLE_STRIP;
        }
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObject3D);
        uniformMatrix("model3d", programObject3D, "uModel", false, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        uniformMatrix("view3d", programObject3D, "uView", false, view.array());
        curContext.enable(curContext.POLYGON_OFFSET_FILL);
        curContext.polygonOffset(1, 1);
        uniformf("color3d", programObject3D, "uColor", [-1, 0, 0, 0]);
        vertexAttribPointer("vertex3d", programObject3D, "aVertex", 3, fillBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(vArray), curContext.STREAM_DRAW);
        if (usingTexture && curTint !== null) {
          curTint3d(cArray);
        }
        vertexAttribPointer("aColor3d", programObject3D, "aColor", 4, fillColorBuffer);
        curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(cArray), curContext.STREAM_DRAW);
        disableVertexAttribPointer("aNormal3d", programObject3D, "aNormal");
        if (usingTexture) {
          uniformi("uUsingTexture3d", programObject3D, "uUsingTexture", usingTexture);
          vertexAttribPointer("aTexture3d", programObject3D, "aTexture", 2, shapeTexVBO);
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(tArray), curContext.STREAM_DRAW);
        }
        curContext.drawArrays(ctxMode, 0, vArray.length / 3);
        curContext.disable(curContext.POLYGON_OFFSET_FILL);
      };
      function fillStrokeClose() {
        executeContextFill();
        executeContextStroke();
        curContext.closePath();
      }
      Drawing2D.prototype.endShape = function(mode) {
        if (vertArray2.length === 0) {
          return;
        }
        var closeShape = mode === PConstants3.CLOSE;
        if (closeShape) {
          vertArray2.push(vertArray2[0]);
        }
        var lineVertArray = [];
        var fillVertArray = [];
        var colorVertArray = [];
        var strokeVertArray = [];
        var texVertArray = [];
        var cachedVertArray;
        firstVert = true;
        var i2, j, k;
        var vertArrayLength = vertArray2.length;
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 0; j < 3; j++) {
            fillVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 5; j < 9; j++) {
            colorVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 9; j < 13; j++) {
            strokeVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          texVertArray.push(cachedVertArray[3]);
          texVertArray.push(cachedVertArray[4]);
        }
        if (isCurve && (curShape === PConstants3.POLYGON || curShape === undef)) {
          if (vertArrayLength > 3) {
            var b = [], s = 1 - curTightness;
            curContext.beginPath();
            curContext.moveTo(vertArray2[1][0], vertArray2[1][1]);
            for (i2 = 1; i2 + 2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              b[0] = [cachedVertArray[0], cachedVertArray[1]];
              b[1] = [
                cachedVertArray[0] + (s * vertArray2[i2 + 1][0] - s * vertArray2[i2 - 1][0]) / 6,
                cachedVertArray[1] + (s * vertArray2[i2 + 1][1] - s * vertArray2[i2 - 1][1]) / 6
              ];
              b[2] = [
                vertArray2[i2 + 1][0] + (s * vertArray2[i2][0] - s * vertArray2[i2 + 2][0]) / 6,
                vertArray2[i2 + 1][1] + (s * vertArray2[i2][1] - s * vertArray2[i2 + 2][1]) / 6
              ];
              b[3] = [vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]];
              curContext.bezierCurveTo(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);
            }
            fillStrokeClose();
          }
        } else if (isBezier && (curShape === PConstants3.POLYGON || curShape === undef)) {
          curContext.beginPath();
          for (i2 = 0; i2 < vertArrayLength; i2++) {
            cachedVertArray = vertArray2[i2];
            if (vertArray2[i2].isVert) {
              if (vertArray2[i2].moveTo) {
                curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
              } else {
                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
              }
            } else {
              curContext.bezierCurveTo(vertArray2[i2][0], vertArray2[i2][1], vertArray2[i2][2], vertArray2[i2][3], vertArray2[i2][4], vertArray2[i2][5]);
            }
          }
          fillStrokeClose();
        } else {
          if (curShape === PConstants3.POINTS) {
            for (i2 = 0; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              if (doStroke) {
                p.stroke(cachedVertArray[6]);
              }
              p.point(cachedVertArray[0], cachedVertArray[1]);
            }
          } else if (curShape === PConstants3.LINES) {
            for (i2 = 0; i2 + 1 < vertArrayLength; i2 += 2) {
              cachedVertArray = vertArray2[i2];
              if (doStroke) {
                p.stroke(vertArray2[i2 + 1][6]);
              }
              p.line(cachedVertArray[0], cachedVertArray[1], vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
            }
          } else if (curShape === PConstants3.TRIANGLES) {
            for (i2 = 0; i2 + 2 < vertArrayLength; i2 += 3) {
              cachedVertArray = vertArray2[i2];
              curContext.beginPath();
              curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
              curContext.lineTo(vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
              curContext.lineTo(vertArray2[i2 + 2][0], vertArray2[i2 + 2][1]);
              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
              if (doFill) {
                p.fill(vertArray2[i2 + 2][5]);
                executeContextFill();
              }
              if (doStroke) {
                p.stroke(vertArray2[i2 + 2][6]);
                executeContextStroke();
              }
              curContext.closePath();
            }
          } else if (curShape === PConstants3.TRIANGLE_STRIP) {
            for (i2 = 0; i2 + 1 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              curContext.beginPath();
              curContext.moveTo(vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
              if (doStroke) {
                p.stroke(vertArray2[i2 + 1][6]);
              }
              if (doFill) {
                p.fill(vertArray2[i2 + 1][5]);
              }
              if (i2 + 2 < vertArrayLength) {
                curContext.lineTo(vertArray2[i2 + 2][0], vertArray2[i2 + 2][1]);
                if (doStroke) {
                  p.stroke(vertArray2[i2 + 2][6]);
                }
                if (doFill) {
                  p.fill(vertArray2[i2 + 2][5]);
                }
              }
              fillStrokeClose();
            }
          } else if (curShape === PConstants3.TRIANGLE_FAN) {
            if (vertArrayLength > 2) {
              curContext.beginPath();
              curContext.moveTo(vertArray2[0][0], vertArray2[0][1]);
              curContext.lineTo(vertArray2[1][0], vertArray2[1][1]);
              curContext.lineTo(vertArray2[2][0], vertArray2[2][1]);
              if (doFill) {
                p.fill(vertArray2[2][5]);
                executeContextFill();
              }
              if (doStroke) {
                p.stroke(vertArray2[2][6]);
                executeContextStroke();
              }
              curContext.closePath();
              for (i2 = 3; i2 < vertArrayLength; i2++) {
                cachedVertArray = vertArray2[i2];
                curContext.beginPath();
                curContext.moveTo(vertArray2[0][0], vertArray2[0][1]);
                curContext.lineTo(vertArray2[i2 - 1][0], vertArray2[i2 - 1][1]);
                curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
                if (doFill) {
                  p.fill(cachedVertArray[5]);
                  executeContextFill();
                }
                if (doStroke) {
                  p.stroke(cachedVertArray[6]);
                  executeContextStroke();
                }
                curContext.closePath();
              }
            }
          } else if (curShape === PConstants3.QUADS) {
            for (i2 = 0; i2 + 3 < vertArrayLength; i2 += 4) {
              cachedVertArray = vertArray2[i2];
              curContext.beginPath();
              curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
              for (j = 1; j < 4; j++) {
                curContext.lineTo(vertArray2[i2 + j][0], vertArray2[i2 + j][1]);
              }
              curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
              if (doFill) {
                p.fill(vertArray2[i2 + 3][5]);
                executeContextFill();
              }
              if (doStroke) {
                p.stroke(vertArray2[i2 + 3][6]);
                executeContextStroke();
              }
              curContext.closePath();
            }
          } else if (curShape === PConstants3.QUAD_STRIP) {
            if (vertArrayLength > 3) {
              for (i2 = 0; i2 + 1 < vertArrayLength; i2 += 2) {
                cachedVertArray = vertArray2[i2];
                curContext.beginPath();
                if (i2 + 3 < vertArrayLength) {
                  curContext.moveTo(vertArray2[i2 + 2][0], vertArray2[i2 + 2][1]);
                  curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
                  curContext.lineTo(vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
                  curContext.lineTo(vertArray2[i2 + 3][0], vertArray2[i2 + 3][1]);
                  if (doFill) {
                    p.fill(vertArray2[i2 + 3][5]);
                  }
                  if (doStroke) {
                    p.stroke(vertArray2[i2 + 3][6]);
                  }
                } else {
                  curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
                  curContext.lineTo(vertArray2[i2 + 1][0], vertArray2[i2 + 1][1]);
                }
                fillStrokeClose();
              }
            }
          } else {
            curContext.beginPath();
            curContext.moveTo(vertArray2[0][0], vertArray2[0][1]);
            for (i2 = 1; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              if (cachedVertArray.isVert) {
                if (cachedVertArray.moveTo) {
                  curContext.moveTo(cachedVertArray[0], cachedVertArray[1]);
                } else {
                  curContext.lineTo(cachedVertArray[0], cachedVertArray[1]);
                }
              }
            }
            fillStrokeClose();
          }
        }
        isCurve = false;
        isBezier = false;
        curveVertArray = [];
        curveVertCount = 0;
        if (closeShape) {
          vertArray2.pop();
        }
      };
      Drawing3D.prototype.endShape = function(mode) {
        if (vertArray2.length === 0) {
          return;
        }
        var closeShape = mode === PConstants3.CLOSE;
        var lineVertArray = [];
        var fillVertArray = [];
        var colorVertArray = [];
        var strokeVertArray = [];
        var texVertArray = [];
        var cachedVertArray;
        firstVert = true;
        var i2, j, k;
        var vertArrayLength = vertArray2.length;
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 0; j < 3; j++) {
            fillVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 5; j < 9; j++) {
            colorVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          for (j = 9; j < 13; j++) {
            strokeVertArray.push(cachedVertArray[j]);
          }
        }
        for (i2 = 0; i2 < vertArrayLength; i2++) {
          cachedVertArray = vertArray2[i2];
          texVertArray.push(cachedVertArray[3]);
          texVertArray.push(cachedVertArray[4]);
        }
        if (closeShape) {
          fillVertArray.push(vertArray2[0][0]);
          fillVertArray.push(vertArray2[0][1]);
          fillVertArray.push(vertArray2[0][2]);
          for (i2 = 5; i2 < 9; i2++) {
            colorVertArray.push(vertArray2[0][i2]);
          }
          for (i2 = 9; i2 < 13; i2++) {
            strokeVertArray.push(vertArray2[0][i2]);
          }
          texVertArray.push(vertArray2[0][3]);
          texVertArray.push(vertArray2[0][4]);
        }
        if (isCurve && (curShape === PConstants3.POLYGON || curShape === undef)) {
          lineVertArray = fillVertArray;
          if (doStroke) {
            line3D(lineVertArray, null, strokeVertArray);
          }
          if (doFill) {
            fill3D(fillVertArray, null, colorVertArray);
          }
        } else if (isBezier && (curShape === PConstants3.POLYGON || curShape === undef)) {
          lineVertArray = fillVertArray;
          lineVertArray.splice(lineVertArray.length - 3);
          strokeVertArray.splice(strokeVertArray.length - 4);
          if (doStroke) {
            line3D(lineVertArray, null, strokeVertArray);
          }
          if (doFill) {
            fill3D(fillVertArray, "TRIANGLES", colorVertArray);
          }
        } else {
          if (curShape === PConstants3.POINTS) {
            for (i2 = 0; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              for (j = 0; j < 3; j++) {
                lineVertArray.push(cachedVertArray[j]);
              }
            }
            point3D(lineVertArray, strokeVertArray);
          } else if (curShape === PConstants3.LINES) {
            for (i2 = 0; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              for (j = 0; j < 3; j++) {
                lineVertArray.push(cachedVertArray[j]);
              }
            }
            for (i2 = 0; i2 < vertArrayLength; i2++) {
              cachedVertArray = vertArray2[i2];
              for (j = 5; j < 9; j++) {
                colorVertArray.push(cachedVertArray[j]);
              }
            }
            line3D(lineVertArray, "LINES", strokeVertArray);
          } else if (curShape === PConstants3.TRIANGLES) {
            if (vertArrayLength > 2) {
              for (i2 = 0; i2 + 2 < vertArrayLength; i2 += 3) {
                fillVertArray = [];
                texVertArray = [];
                lineVertArray = [];
                colorVertArray = [];
                strokeVertArray = [];
                for (j = 0; j < 3; j++) {
                  for (k = 0; k < 3; k++) {
                    lineVertArray.push(vertArray2[i2 + j][k]);
                    fillVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 3; j++) {
                  for (k = 3; k < 5; k++) {
                    texVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 3; j++) {
                  for (k = 5; k < 9; k++) {
                    colorVertArray.push(vertArray2[i2 + j][k]);
                    strokeVertArray.push(vertArray2[i2 + j][k + 4]);
                  }
                }
                if (doStroke) {
                  line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
                }
                if (doFill || usingTexture) {
                  fill3D(fillVertArray, "TRIANGLES", colorVertArray, texVertArray);
                }
              }
            }
          } else if (curShape === PConstants3.TRIANGLE_STRIP) {
            if (vertArrayLength > 2) {
              for (i2 = 0; i2 + 2 < vertArrayLength; i2++) {
                lineVertArray = [];
                fillVertArray = [];
                strokeVertArray = [];
                colorVertArray = [];
                texVertArray = [];
                for (j = 0; j < 3; j++) {
                  for (k = 0; k < 3; k++) {
                    lineVertArray.push(vertArray2[i2 + j][k]);
                    fillVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 3; j++) {
                  for (k = 3; k < 5; k++) {
                    texVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 3; j++) {
                  for (k = 5; k < 9; k++) {
                    strokeVertArray.push(vertArray2[i2 + j][k + 4]);
                    colorVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                if (doFill || usingTexture) {
                  fill3D(fillVertArray, "TRIANGLE_STRIP", colorVertArray, texVertArray);
                }
                if (doStroke) {
                  line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
                }
              }
            }
          } else if (curShape === PConstants3.TRIANGLE_FAN) {
            if (vertArrayLength > 2) {
              for (i2 = 0; i2 < 3; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(cachedVertArray[j]);
                }
              }
              for (i2 = 0; i2 < 3; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(cachedVertArray[j]);
                }
              }
              if (doStroke) {
                line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
              }
              for (i2 = 2; i2 + 1 < vertArrayLength; i2++) {
                lineVertArray = [];
                strokeVertArray = [];
                lineVertArray.push(vertArray2[0][0]);
                lineVertArray.push(vertArray2[0][1]);
                lineVertArray.push(vertArray2[0][2]);
                strokeVertArray.push(vertArray2[0][9]);
                strokeVertArray.push(vertArray2[0][10]);
                strokeVertArray.push(vertArray2[0][11]);
                strokeVertArray.push(vertArray2[0][12]);
                for (j = 0; j < 2; j++) {
                  for (k = 0; k < 3; k++) {
                    lineVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                for (j = 0; j < 2; j++) {
                  for (k = 9; k < 13; k++) {
                    strokeVertArray.push(vertArray2[i2 + j][k]);
                  }
                }
                if (doStroke) {
                  line3D(lineVertArray, "LINE_STRIP", strokeVertArray);
                }
              }
              if (doFill || usingTexture) {
                fill3D(fillVertArray, "TRIANGLE_FAN", colorVertArray, texVertArray);
              }
            }
          } else if (curShape === PConstants3.QUADS) {
            for (i2 = 0; i2 + 3 < vertArrayLength; i2 += 4) {
              lineVertArray = [];
              for (j = 0; j < 4; j++) {
                cachedVertArray = vertArray2[i2 + j];
                for (k = 0; k < 3; k++) {
                  lineVertArray.push(cachedVertArray[k]);
                }
              }
              if (doStroke) {
                line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
              }
              if (doFill) {
                fillVertArray = [];
                colorVertArray = [];
                texVertArray = [];
                for (j = 0; j < 3; j++) {
                  fillVertArray.push(vertArray2[i2][j]);
                }
                for (j = 5; j < 9; j++) {
                  colorVertArray.push(vertArray2[i2][j]);
                }
                for (j = 0; j < 3; j++) {
                  fillVertArray.push(vertArray2[i2 + 1][j]);
                }
                for (j = 5; j < 9; j++) {
                  colorVertArray.push(vertArray2[i2 + 1][j]);
                }
                for (j = 0; j < 3; j++) {
                  fillVertArray.push(vertArray2[i2 + 3][j]);
                }
                for (j = 5; j < 9; j++) {
                  colorVertArray.push(vertArray2[i2 + 3][j]);
                }
                for (j = 0; j < 3; j++) {
                  fillVertArray.push(vertArray2[i2 + 2][j]);
                }
                for (j = 5; j < 9; j++) {
                  colorVertArray.push(vertArray2[i2 + 2][j]);
                }
                if (usingTexture) {
                  texVertArray.push(vertArray2[i2 + 0][3]);
                  texVertArray.push(vertArray2[i2 + 0][4]);
                  texVertArray.push(vertArray2[i2 + 1][3]);
                  texVertArray.push(vertArray2[i2 + 1][4]);
                  texVertArray.push(vertArray2[i2 + 3][3]);
                  texVertArray.push(vertArray2[i2 + 3][4]);
                  texVertArray.push(vertArray2[i2 + 2][3]);
                  texVertArray.push(vertArray2[i2 + 2][4]);
                }
                fill3D(fillVertArray, "TRIANGLE_STRIP", colorVertArray, texVertArray);
              }
            }
          } else if (curShape === PConstants3.QUAD_STRIP) {
            var tempArray = [];
            if (vertArrayLength > 3) {
              for (i2 = 0; i2 < 2; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(cachedVertArray[j]);
                }
              }
              for (i2 = 0; i2 < 2; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(cachedVertArray[j]);
                }
              }
              line3D(lineVertArray, "LINE_STRIP", strokeVertArray);
              if (vertArrayLength > 4 && vertArrayLength % 2 > 0) {
                tempArray = fillVertArray.splice(fillVertArray.length - 3);
                vertArray2.pop();
              }
              for (i2 = 0; i2 + 3 < vertArrayLength; i2 += 2) {
                lineVertArray = [];
                strokeVertArray = [];
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(vertArray2[i2 + 1][j]);
                }
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(vertArray2[i2 + 3][j]);
                }
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(vertArray2[i2 + 2][j]);
                }
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(vertArray2[i2 + 0][j]);
                }
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(vertArray2[i2 + 1][j]);
                }
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(vertArray2[i2 + 3][j]);
                }
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(vertArray2[i2 + 2][j]);
                }
                for (j = 9; j < 13; j++) {
                  strokeVertArray.push(vertArray2[i2 + 0][j]);
                }
                if (doStroke) {
                  line3D(lineVertArray, "LINE_STRIP", strokeVertArray);
                }
              }
              if (doFill || usingTexture) {
                fill3D(fillVertArray, "TRIANGLE_LIST", colorVertArray, texVertArray);
              }
            }
          } else {
            if (vertArrayLength === 1) {
              for (j = 0; j < 3; j++) {
                lineVertArray.push(vertArray2[0][j]);
              }
              for (j = 9; j < 13; j++) {
                strokeVertArray.push(vertArray2[0][j]);
              }
              point3D(lineVertArray, strokeVertArray);
            } else {
              for (i2 = 0; i2 < vertArrayLength; i2++) {
                cachedVertArray = vertArray2[i2];
                for (j = 0; j < 3; j++) {
                  lineVertArray.push(cachedVertArray[j]);
                }
                for (j = 5; j < 9; j++) {
                  strokeVertArray.push(cachedVertArray[j]);
                }
              }
              if (doStroke && closeShape) {
                line3D(lineVertArray, "LINE_LOOP", strokeVertArray);
              } else if (doStroke && !closeShape) {
                line3D(lineVertArray, "LINE_STRIP", strokeVertArray);
              }
              if (doFill || usingTexture) {
                fill3D(fillVertArray, "TRIANGLE_FAN", colorVertArray, texVertArray);
              }
            }
          }
          usingTexture = false;
          curContext.useProgram(programObject3D);
          uniformi("usingTexture3d", programObject3D, "uUsingTexture", usingTexture);
        }
        isCurve = false;
        isBezier = false;
        curveVertArray = [];
        curveVertCount = 0;
      };
      var splineForward = function(segments, matrix) {
        var f = 1 / segments;
        var ff = f * f;
        var fff = ff * f;
        matrix.set(0, 0, 0, 1, fff, ff, f, 0, 6 * fff, 2 * ff, 0, 0, 6 * fff, 0, 0, 0);
      };
      var curveInit = function() {
        if (!curveDrawMatrix) {
          curveBasisMatrix = new PMatrix3D2();
          curveDrawMatrix = new PMatrix3D2();
          curveInited = true;
        }
        var s = curTightness;
        curveBasisMatrix.set(
          (s - 1) / 2,
          (s + 3) / 2,
          (-3 - s) / 2,
          (1 - s) / 2,
          1 - s,
          (-5 - s) / 2,
          s + 2,
          (s - 1) / 2,
          (s - 1) / 2,
          0,
          (1 - s) / 2,
          0,
          0,
          1,
          0,
          0
        );
        splineForward(curveDet, curveDrawMatrix);
        if (!bezierBasisInverse) {
          curveToBezierMatrix = new PMatrix3D2();
        }
        curveToBezierMatrix.set(curveBasisMatrix);
        curveToBezierMatrix.preApply(bezierBasisInverse);
        curveDrawMatrix.apply(curveBasisMatrix);
      };
      Drawing2D.prototype.bezierVertex = function() {
        isBezier = true;
        var vert = [];
        if (firstVert) {
          throw "vertex() must be used at least once before calling bezierVertex()";
        }
        for (var i2 = 0; i2 < arguments.length; i2++) {
          vert[i2] = arguments[i2];
        }
        vertArray2.push(vert);
        vertArray2[vertArray2.length - 1].isVert = false;
      };
      Drawing3D.prototype.bezierVertex = function() {
        isBezier = true;
        var vert = [];
        if (firstVert) {
          throw "vertex() must be used at least once before calling bezierVertex()";
        }
        if (arguments.length === 9) {
          if (bezierDrawMatrix === undef) {
            bezierDrawMatrix = new PMatrix3D2();
          }
          var lastPoint = vertArray2.length - 1;
          splineForward(bezDetail, bezierDrawMatrix);
          bezierDrawMatrix.apply(bezierBasisMatrix);
          var draw = bezierDrawMatrix.array();
          var x1 = vertArray2[lastPoint][0], y1 = vertArray2[lastPoint][1], z1 = vertArray2[lastPoint][2];
          var xplot1 = draw[4] * x1 + draw[5] * arguments[0] + draw[6] * arguments[3] + draw[7] * arguments[6];
          var xplot2 = draw[8] * x1 + draw[9] * arguments[0] + draw[10] * arguments[3] + draw[11] * arguments[6];
          var xplot3 = draw[12] * x1 + draw[13] * arguments[0] + draw[14] * arguments[3] + draw[15] * arguments[6];
          var yplot1 = draw[4] * y1 + draw[5] * arguments[1] + draw[6] * arguments[4] + draw[7] * arguments[7];
          var yplot2 = draw[8] * y1 + draw[9] * arguments[1] + draw[10] * arguments[4] + draw[11] * arguments[7];
          var yplot3 = draw[12] * y1 + draw[13] * arguments[1] + draw[14] * arguments[4] + draw[15] * arguments[7];
          var zplot1 = draw[4] * z1 + draw[5] * arguments[2] + draw[6] * arguments[5] + draw[7] * arguments[8];
          var zplot2 = draw[8] * z1 + draw[9] * arguments[2] + draw[10] * arguments[5] + draw[11] * arguments[8];
          var zplot3 = draw[12] * z1 + draw[13] * arguments[2] + draw[14] * arguments[5] + draw[15] * arguments[8];
          for (var j = 0; j < bezDetail; j++) {
            x1 += xplot1;
            xplot1 += xplot2;
            xplot2 += xplot3;
            y1 += yplot1;
            yplot1 += yplot2;
            yplot2 += yplot3;
            z1 += zplot1;
            zplot1 += zplot2;
            zplot2 += zplot3;
            p.vertex(x1, y1, z1);
          }
          p.vertex(arguments[6], arguments[7], arguments[8]);
        }
      };
      p.texture = function(pimage) {
        var curContext2 = drawing.$ensureContext();
        if (pimage.__texture) {
          curContext2.bindTexture(curContext2.TEXTURE_2D, pimage.__texture);
        } else if (pimage.localName === "canvas") {
          curContext2.bindTexture(curContext2.TEXTURE_2D, canTex);
          curContext2.texImage2D(curContext2.TEXTURE_2D, 0, curContext2.RGBA, curContext2.RGBA, curContext2.UNSIGNED_BYTE, pimage);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_MAG_FILTER, curContext2.LINEAR);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_MIN_FILTER, curContext2.LINEAR);
          curContext2.generateMipmap(curContext2.TEXTURE_2D);
          curTexture.width = pimage.width;
          curTexture.height = pimage.height;
        } else {
          var texture = curContext2.createTexture(), cvs = document2.createElement("canvas"), cvsTextureCtx = cvs.getContext("2d"), pot;
          if (pimage.width & pimage.width - 1 === 0) {
            cvs.width = pimage.width;
          } else {
            pot = 1;
            while (pot < pimage.width) {
              pot *= 2;
            }
            cvs.width = pot;
          }
          if (pimage.height & pimage.height - 1 === 0) {
            cvs.height = pimage.height;
          } else {
            pot = 1;
            while (pot < pimage.height) {
              pot *= 2;
            }
            cvs.height = pot;
          }
          cvsTextureCtx.drawImage(pimage.sourceImg, 0, 0, pimage.width, pimage.height, 0, 0, cvs.width, cvs.height);
          curContext2.bindTexture(curContext2.TEXTURE_2D, texture);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_MIN_FILTER, curContext2.LINEAR_MIPMAP_LINEAR);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_MAG_FILTER, curContext2.LINEAR);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_WRAP_T, curContext2.CLAMP_TO_EDGE);
          curContext2.texParameteri(curContext2.TEXTURE_2D, curContext2.TEXTURE_WRAP_S, curContext2.CLAMP_TO_EDGE);
          curContext2.texImage2D(curContext2.TEXTURE_2D, 0, curContext2.RGBA, curContext2.RGBA, curContext2.UNSIGNED_BYTE, cvs);
          curContext2.generateMipmap(curContext2.TEXTURE_2D);
          pimage.__texture = texture;
          curTexture.width = pimage.width;
          curTexture.height = pimage.height;
        }
        usingTexture = true;
        curContext2.useProgram(programObject3D);
        uniformi("usingTexture3d", programObject3D, "uUsingTexture", usingTexture);
      };
      p.textureMode = function(mode) {
        curTextureMode = mode;
      };
      var curveVertexSegment = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
        var x0 = x2;
        var y0 = y2;
        var z0 = z2;
        var draw = curveDrawMatrix.array();
        var xplot1 = draw[4] * x1 + draw[5] * x2 + draw[6] * x3 + draw[7] * x4;
        var xplot2 = draw[8] * x1 + draw[9] * x2 + draw[10] * x3 + draw[11] * x4;
        var xplot3 = draw[12] * x1 + draw[13] * x2 + draw[14] * x3 + draw[15] * x4;
        var yplot1 = draw[4] * y1 + draw[5] * y2 + draw[6] * y3 + draw[7] * y4;
        var yplot2 = draw[8] * y1 + draw[9] * y2 + draw[10] * y3 + draw[11] * y4;
        var yplot3 = draw[12] * y1 + draw[13] * y2 + draw[14] * y3 + draw[15] * y4;
        var zplot1 = draw[4] * z1 + draw[5] * z2 + draw[6] * z3 + draw[7] * z4;
        var zplot2 = draw[8] * z1 + draw[9] * z2 + draw[10] * z3 + draw[11] * z4;
        var zplot3 = draw[12] * z1 + draw[13] * z2 + draw[14] * z3 + draw[15] * z4;
        p.vertex(x0, y0, z0);
        for (var j = 0; j < curveDet; j++) {
          x0 += xplot1;
          xplot1 += xplot2;
          xplot2 += xplot3;
          y0 += yplot1;
          yplot1 += yplot2;
          yplot2 += yplot3;
          z0 += zplot1;
          zplot1 += zplot2;
          zplot2 += zplot3;
          p.vertex(x0, y0, z0);
        }
      };
      Drawing2D.prototype.curveVertex = function(x, y) {
        isCurve = true;
        p.vertex(x, y);
      };
      Drawing3D.prototype.curveVertex = function(x, y, z) {
        isCurve = true;
        if (!curveInited) {
          curveInit();
        }
        var vert = [];
        vert[0] = x;
        vert[1] = y;
        vert[2] = z;
        curveVertArray.push(vert);
        curveVertCount++;
        if (curveVertCount > 3) {
          curveVertexSegment(
            curveVertArray[curveVertCount - 4][0],
            curveVertArray[curveVertCount - 4][1],
            curveVertArray[curveVertCount - 4][2],
            curveVertArray[curveVertCount - 3][0],
            curveVertArray[curveVertCount - 3][1],
            curveVertArray[curveVertCount - 3][2],
            curveVertArray[curveVertCount - 2][0],
            curveVertArray[curveVertCount - 2][1],
            curveVertArray[curveVertCount - 2][2],
            curveVertArray[curveVertCount - 1][0],
            curveVertArray[curveVertCount - 1][1],
            curveVertArray[curveVertCount - 1][2]
          );
        }
      };
      Drawing2D.prototype.curve = function(x1, y1, x2, y2, x3, y3, x4, y4) {
        p.beginShape();
        p.curveVertex(x1, y1);
        p.curveVertex(x2, y2);
        p.curveVertex(x3, y3);
        p.curveVertex(x4, y4);
        p.endShape();
      };
      Drawing3D.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
        if (z4 !== undef) {
          p.beginShape();
          p.curveVertex(x1, y1, z1);
          p.curveVertex(x2, y2, z2);
          p.curveVertex(x3, y3, z3);
          p.curveVertex(x4, y4, z4);
          p.endShape();
          return;
        }
        p.beginShape();
        p.curveVertex(x1, y1);
        p.curveVertex(z1, x2);
        p.curveVertex(y2, z2);
        p.curveVertex(x3, y3);
        p.endShape();
      };
      p.curveTightness = function(tightness) {
        curTightness = tightness;
      };
      p.curveDetail = function(detail) {
        curveDet = detail;
        curveInit();
      };
      p.rectMode = function(aRectMode) {
        curRectMode = aRectMode;
      };
      p.imageMode = function(mode) {
        switch (mode) {
          case PConstants3.CORNER:
            imageModeConvert2 = imageModeCorner;
            break;
          case PConstants3.CORNERS:
            imageModeConvert2 = imageModeCorners;
            break;
          case PConstants3.CENTER:
            imageModeConvert2 = imageModeCenter;
            break;
          default:
            throw "Invalid imageMode";
        }
      };
      p.ellipseMode = function(aEllipseMode) {
        curEllipseMode2 = aEllipseMode;
      };
      p.arc = function(x, y, width, height, start2, stop, mode) {
        if (width <= 0 || stop < start2) {
          return;
        }
        if (curEllipseMode2 === PConstants3.CORNERS) {
          width = width - x;
          height = height - y;
        } else if (curEllipseMode2 === PConstants3.RADIUS) {
          x = x - width;
          y = y - height;
          width = width * 2;
          height = height * 2;
        } else if (curEllipseMode2 === PConstants3.CENTER) {
          x = x - width / 2;
          y = y - height / 2;
        }
        while (start2 < 0) {
          start2 += PConstants3.TWO_PI;
          stop += PConstants3.TWO_PI;
        }
        if (stop - start2 > PConstants3.TWO_PI) {
          stop = start2 + PConstants3.TWO_PI;
        }
        var hr = width / 2, vr = height / 2, centerX = x + hr, centerY = y + vr, step = 1 / (hr + vr);
        var drawSlice = /* @__PURE__ */ function(x2, y2, start3, step2, stop2) {
          return function(p2, closed, i2, a, e) {
            i2 = 0;
            a = start3;
            e = stop2 + step2;
            p2.beginShape();
            if (closed) {
              p2.vertex(x2 - 0.5, y2 - 0.5);
            }
            for (; a < e; i2++, a = i2 * step2 + start3) {
              p2.vertex(
                x2 + Math.cos(a) * hr | 0,
                y2 + Math.sin(a) * vr | 0
              );
            }
            if (mode === PConstants3.OPEN && doFill) {
              p2.vertex(centerX + Math.cos(start3) * hr, centerY + Math.sin(start3) * vr);
            } else if (mode === PConstants3.CHORD) {
              p2.vertex(centerX + Math.cos(start3) * hr, centerY + Math.sin(start3) * vr);
            } else if (mode === PConstants3.PIE) {
              p2.line(centerX + Math.cos(start3) * hr, centerY + Math.sin(start3) * vr, centerX, centerY);
              p2.line(centerX, centerY, centerX + Math.cos(stop2) * hr, centerY + Math.sin(stop2) * vr);
            }
            p2.endShape(closed ? PConstants3.CLOSE : void 0);
          };
        }(centerX + 0.5, centerY + 0.5, start2, step, stop);
        if (doFill) {
          var savedStroke = doStroke;
          doStroke = false;
          drawSlice(p, true);
          doStroke = savedStroke;
        }
        if (doStroke) {
          var savedFill = doFill;
          doFill = false;
          drawSlice(p);
          doFill = savedFill;
        }
      };
      Drawing2D.prototype.line = function(x1, y1, x2, y2) {
        if (!doStroke) {
          return;
        }
        if (!renderSmooth) {
          x1 = Math.round(x1);
          x2 = Math.round(x2);
          y1 = Math.round(y1);
          y2 = Math.round(y2);
        }
        if (x1 === x2 && y1 === y2) {
          p.point(x1, y1);
          return;
        }
        var swap = undef, lineCap = undef, drawCrisp = true, currentModelView = modelView.array(), identityMatrix = [1, 0, 0, 0, 1, 0];
        for (var i2 = 0; i2 < 6 && drawCrisp; i2++) {
          drawCrisp = currentModelView[i2] === identityMatrix[i2];
        }
        if (drawCrisp) {
          if (x1 === x2) {
            if (y1 > y2) {
              swap = y1;
              y1 = y2;
              y2 = swap;
            }
            y2++;
            if (lineWidth % 2 === 1) {
              curContext.translate(0.5, 0);
            }
          } else if (y1 === y2) {
            if (x1 > x2) {
              swap = x1;
              x1 = x2;
              x2 = swap;
            }
            x2++;
            if (lineWidth % 2 === 1) {
              curContext.translate(0, 0.5);
            }
          }
          if (lineWidth === 1) {
            lineCap = curContext.lineCap;
            curContext.lineCap = "butt";
          }
        }
        curContext.beginPath();
        curContext.moveTo(x1 || 0, y1 || 0);
        curContext.lineTo(x2 || 0, y2 || 0);
        executeContextStroke();
        if (drawCrisp) {
          if (x1 === x2 && lineWidth % 2 === 1) {
            curContext.translate(-0.5, 0);
          } else if (y1 === y2 && lineWidth % 2 === 1) {
            curContext.translate(0, -0.5);
          }
          if (lineWidth === 1) {
            curContext.lineCap = lineCap;
          }
        }
      };
      Drawing3D.prototype.line = function(x1, y1, z1, x2, y2, z2) {
        if (y2 === undef || z2 === undef) {
          z2 = 0;
          y2 = x2;
          x2 = z1;
          z1 = 0;
        }
        if (x1 === x2 && y1 === y2 && z1 === z2) {
          p.point(x1, y1, z1);
          return;
        }
        var lineVerts = [x1, y1, z1, x2, y2, z2];
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        if (lineWidth > 0 && doStroke) {
          curContext.useProgram(programObject2D);
          uniformMatrix("uModel2d", programObject2D, "uModel", false, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
          uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText", programObject2D, "uIsDrawingText", false);
          vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, lineBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          curContext.bufferData(curContext.ARRAY_BUFFER, new Float32Array2(lineVerts), curContext.STREAM_DRAW);
          curContext.drawArrays(curContext.LINES, 0, 2);
        }
      };
      Drawing2D.prototype.bezier = function() {
        if (arguments.length !== 8) {
          throw "You must use 8 parameters for bezier() in 2D mode";
        }
        p.beginShape();
        p.vertex(arguments[0], arguments[1]);
        p.bezierVertex(
          arguments[2],
          arguments[3],
          arguments[4],
          arguments[5],
          arguments[6],
          arguments[7]
        );
        p.endShape();
      };
      Drawing3D.prototype.bezier = function() {
        if (arguments.length !== 12) {
          throw "You must use 12 parameters for bezier() in 3D mode";
        }
        p.beginShape();
        p.vertex(arguments[0], arguments[1], arguments[2]);
        p.bezierVertex(
          arguments[3],
          arguments[4],
          arguments[5],
          arguments[6],
          arguments[7],
          arguments[8],
          arguments[9],
          arguments[10],
          arguments[11]
        );
        p.endShape();
      };
      p.bezierDetail = function(detail) {
        bezDetail = detail;
      };
      p.bezierPoint = function(a, b, c, d, t2) {
        return (1 - t2) * (1 - t2) * (1 - t2) * a + 3 * (1 - t2) * (1 - t2) * t2 * b + 3 * (1 - t2) * t2 * t2 * c + t2 * t2 * t2 * d;
      };
      p.bezierTangent = function(a, b, c, d, t2) {
        return 3 * t2 * t2 * (-a + 3 * b - 3 * c + d) + 6 * t2 * (a - 2 * b + c) + 3 * (-a + b);
      };
      p.curvePoint = function(a, b, c, d, t2) {
        return 0.5 * (2 * b + (-a + c) * t2 + (2 * a - 5 * b + 4 * c - d) * t2 * t2 + (-a + 3 * b - 3 * c + d) * t2 * t2 * t2);
      };
      p.curveTangent = function(a, b, c, d, t2) {
        return 0.5 * (-a + c + 2 * (2 * a - 5 * b + 4 * c - d) * t2 + 3 * (-a + 3 * b - 3 * c + d) * t2 * t2);
      };
      p.triangle = function(x1, y1, x2, y2, x3, y3) {
        p.beginShape(PConstants3.TRIANGLES);
        p.vertex(x1, y1, 0);
        p.vertex(x2, y2, 0);
        p.vertex(x3, y3, 0);
        p.endShape();
      };
      p.quad = function(x1, y1, x2, y2, x3, y3, x4, y4) {
        p.beginShape(PConstants3.QUADS);
        p.vertex(x1, y1, 0);
        p.vertex(x2, y2, 0);
        p.vertex(x3, y3, 0);
        p.vertex(x4, y4, 0);
        p.endShape();
      };
      var roundedRect$2d = function(x, y, width, height, tl, tr, br, bl) {
        if (bl === undef) {
          tr = tl;
          br = tl;
          bl = tl;
        }
        var halfWidth = width / 2, halfHeight = height / 2;
        if (tl > halfWidth || tl > halfHeight) {
          tl = Math.min(halfWidth, halfHeight);
        }
        if (tr > halfWidth || tr > halfHeight) {
          tr = Math.min(halfWidth, halfHeight);
        }
        if (br > halfWidth || br > halfHeight) {
          br = Math.min(halfWidth, halfHeight);
        }
        if (bl > halfWidth || bl > halfHeight) {
          bl = Math.min(halfWidth, halfHeight);
        }
        if (!doFill || doStroke) {
          curContext.translate(0.5, 0.5);
        }
        curContext.beginPath();
        curContext.moveTo(x + tl, y);
        curContext.lineTo(x + width - tr, y);
        curContext.quadraticCurveTo(x + width, y, x + width, y + tr);
        curContext.lineTo(x + width, y + height - br);
        curContext.quadraticCurveTo(x + width, y + height, x + width - br, y + height);
        curContext.lineTo(x + bl, y + height);
        curContext.quadraticCurveTo(x, y + height, x, y + height - bl);
        curContext.lineTo(x, y + tl);
        curContext.quadraticCurveTo(x, y, x + tl, y);
        if (!doFill || doStroke) {
          curContext.translate(-0.5, -0.5);
        }
        executeContextFill();
        executeContextStroke();
      };
      Drawing2D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {
        if (width != "" + width && height != "" + height) {
          return;
        }
        if (curRectMode === PConstants3.CORNERS) {
          width -= x;
          height -= y;
        } else if (curRectMode === PConstants3.RADIUS) {
          width *= 2;
          height *= 2;
          x -= width / 2;
          y -= height / 2;
        } else if (curRectMode === PConstants3.CENTER) {
          x -= width / 2;
          y -= height / 2;
        }
        if (!renderSmooth) {
          x = Math.round(x);
          y = Math.round(y);
          width = Math.round(width);
          height = Math.round(height);
        }
        if (tl !== undef) {
          roundedRect$2d(x, y, width, height, tl, tr, br, bl);
          return;
        }
        if (doStroke && lineWidth % 2 === 1) {
          curContext.translate(0.5, 0.5);
        }
        curContext.beginPath();
        curContext.rect(x, y, width, height);
        executeContextFill();
        executeContextStroke();
        if (doStroke && lineWidth % 2 === 1) {
          curContext.translate(-0.5, -0.5);
        }
      };
      Drawing3D.prototype.rect = function(x, y, width, height, tl, tr, br, bl) {
        if (tl !== undef) {
          throw "rect() with rounded corners is not supported in 3D mode";
        }
        if (curRectMode === PConstants3.CORNERS) {
          width -= x;
          height -= y;
        } else if (curRectMode === PConstants3.RADIUS) {
          width *= 2;
          height *= 2;
          x -= width / 2;
          y -= height / 2;
        } else if (curRectMode === PConstants3.CENTER) {
          x -= width / 2;
          y -= height / 2;
        }
        var model = new PMatrix3D2();
        model.translate(x, y, 0);
        model.scale(width, height, 1);
        model.transpose();
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        if (lineWidth > 0 && doStroke) {
          curContext.useProgram(programObject2D);
          uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
          uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
          uniformf("uColor2d", programObject2D, "uColor", strokeStyle);
          uniformi("uIsDrawingText2d", programObject2D, "uIsDrawingText", false);
          vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, rectBuffer);
          disableVertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord");
          curContext.drawArrays(curContext.LINE_LOOP, 0, rectVerts.length / 3);
        }
        if (doFill) {
          curContext.useProgram(programObject3D);
          uniformMatrix("uModel3d", programObject3D, "uModel", false, model.array());
          uniformMatrix("uView3d", programObject3D, "uView", false, view.array());
          curContext.enable(curContext.POLYGON_OFFSET_FILL);
          curContext.polygonOffset(1, 1);
          uniformf("color3d", programObject3D, "uColor", fillStyle);
          if (lightCount > 0) {
            var v = new PMatrix3D2();
            v.set(view);
            var m = new PMatrix3D2();
            m.set(model);
            v.mult(m);
            var normalMatrix = new PMatrix3D2();
            normalMatrix.set(v);
            normalMatrix.invert();
            normalMatrix.transpose();
            uniformMatrix("uNormalTransform3d", programObject3D, "uNormalTransform", false, normalMatrix.array());
            vertexAttribPointer("aNormal3d", programObject3D, "aNormal", 3, rectNormBuffer);
          } else {
            disableVertexAttribPointer("normal3d", programObject3D, "aNormal");
          }
          vertexAttribPointer("vertex3d", programObject3D, "aVertex", 3, rectBuffer);
          curContext.drawArrays(curContext.TRIANGLE_FAN, 0, rectVerts.length / 3);
          curContext.disable(curContext.POLYGON_OFFSET_FILL);
        }
      };
      Drawing2D.prototype.ellipse = function(x, y, width, height) {
        x = x || 0;
        y = y || 0;
        if (width <= 0 && height <= 0) {
          return;
        }
        if (curEllipseMode2 === PConstants3.RADIUS) {
          width *= 2;
          height *= 2;
        } else if (curEllipseMode2 === PConstants3.CORNERS) {
          width = width - x;
          height = height - y;
          x += width / 2;
          y += height / 2;
        } else if (curEllipseMode2 === PConstants3.CORNER) {
          x += width / 2;
          y += height / 2;
        }
        if (width === height) {
          curContext.beginPath();
          curContext.arc(x, y, width / 2, 0, PConstants3.TWO_PI, false);
          executeContextFill();
          executeContextStroke();
        } else {
          var w = width / 2, h = height / 2, C = 0.5522847498307933, c_x = C * w, c_y = C * h;
          p.beginShape();
          p.vertex(x + w, y);
          p.bezierVertex(x + w, y - c_y, x + c_x, y - h, x, y - h);
          p.bezierVertex(x - c_x, y - h, x - w, y - c_y, x - w, y);
          p.bezierVertex(x - w, y + c_y, x - c_x, y + h, x, y + h);
          p.bezierVertex(x + c_x, y + h, x + w, y + c_y, x + w, y);
          p.endShape();
        }
      };
      Drawing3D.prototype.ellipse = function(x, y, width, height) {
        x = x || 0;
        y = y || 0;
        if (width <= 0 && height <= 0) {
          return;
        }
        if (curEllipseMode2 === PConstants3.RADIUS) {
          width *= 2;
          height *= 2;
        } else if (curEllipseMode2 === PConstants3.CORNERS) {
          width = width - x;
          height = height - y;
          x += width / 2;
          y += height / 2;
        } else if (curEllipseMode2 === PConstants3.CORNER) {
          x += width / 2;
          y += height / 2;
        }
        var w = width / 2, h = height / 2, C = 0.5522847498307933, c_x = C * w, c_y = C * h;
        p.beginShape();
        p.vertex(x + w, y);
        p.bezierVertex(x + w, y - c_y, 0, x + c_x, y - h, 0, x, y - h, 0);
        p.bezierVertex(x - c_x, y - h, 0, x - w, y - c_y, 0, x - w, y, 0);
        p.bezierVertex(x - w, y + c_y, 0, x - c_x, y + h, 0, x, y + h, 0);
        p.bezierVertex(x + c_x, y + h, 0, x + w, y + c_y, 0, x + w, y, 0);
        p.endShape();
        if (doFill) {
          var xAv = 0, yAv = 0, i2, j;
          for (i2 = 0; i2 < vertArray2.length; i2++) {
            xAv += vertArray2[i2][0];
            yAv += vertArray2[i2][1];
          }
          xAv /= vertArray2.length;
          yAv /= vertArray2.length;
          var vert = [], fillVertArray = [], colorVertArray = [];
          vert[0] = xAv;
          vert[1] = yAv;
          vert[2] = 0;
          vert[3] = 0;
          vert[4] = 0;
          vert[5] = fillStyle[0];
          vert[6] = fillStyle[1];
          vert[7] = fillStyle[2];
          vert[8] = fillStyle[3];
          vert[9] = strokeStyle[0];
          vert[10] = strokeStyle[1];
          vert[11] = strokeStyle[2];
          vert[12] = strokeStyle[3];
          vert[13] = normalX;
          vert[14] = normalY;
          vert[15] = normalZ;
          vertArray2.unshift(vert);
          for (i2 = 0; i2 < vertArray2.length; i2++) {
            for (j = 0; j < 3; j++) {
              fillVertArray.push(vertArray2[i2][j]);
            }
            for (j = 5; j < 9; j++) {
              colorVertArray.push(vertArray2[i2][j]);
            }
          }
          fill3D(fillVertArray, "TRIANGLE_FAN", colorVertArray);
        }
      };
      p.normal = function(nx, ny, nz) {
        if (arguments.length !== 3 || !(typeof nx === "number" && typeof ny === "number" && typeof nz === "number")) {
          throw "normal() requires three numeric arguments.";
        }
        normalX = nx;
        normalY = ny;
        normalZ = nz;
        if (curShape !== 0) {
          if (normalMode === PConstants3.NORMAL_MODE_AUTO) {
            normalMode = PConstants3.NORMAL_MODE_SHAPE;
          } else if (normalMode === PConstants3.NORMAL_MODE_SHAPE) {
            normalMode = PConstants3.NORMAL_MODE_VERTEX;
          }
        }
      };
      p.save = function(file, img) {
        if (img !== undef) {
          return window2.open(img.toDataURL(), "_blank");
        }
        return window2.open(p.externals.canvas.toDataURL(), "_blank");
      };
      var saveNumber = 0;
      p.saveFrame = function(file) {
        if (file === undef) {
          file = "screen-####.png";
        }
        var frameFilename = file.replace(/#+/, function(all) {
          var s = "" + saveNumber++;
          while (s.length < all.length) {
            s = "0" + s;
          }
          return s;
        });
        p.save(frameFilename);
      };
      var utilityContext2d = document2.createElement("canvas").getContext("2d");
      var canvasDataCache = [undef, undef, undef];
      function getCanvasData(obj, w, h) {
        var canvasData = canvasDataCache.shift();
        if (canvasData === undef) {
          canvasData = {};
          canvasData.canvas = document2.createElement("canvas");
          canvasData.context = canvasData.canvas.getContext("2d");
        }
        canvasDataCache.push(canvasData);
        var canvas = canvasData.canvas, context = canvasData.context, width = w || obj.width, height = h || obj.height;
        canvas.width = width;
        canvas.height = height;
        if (!obj) {
          context.clearRect(0, 0, width, height);
        } else if ("data" in obj) {
          context.putImageData(obj, 0, 0);
        } else {
          context.clearRect(0, 0, width, height);
          context.drawImage(obj, 0, 0, width, height);
        }
        return canvasData;
      }
      function buildPixelsObject(pImage) {
        return {
          getLength: /* @__PURE__ */ function(aImg) {
            return function() {
              if (aImg.isRemote) {
                throw "Image is loaded remotely. Cannot get length.";
              } else {
                return aImg.imageData.data.length ? aImg.imageData.data.length / 4 : 0;
              }
            };
          }(pImage),
          getPixel: /* @__PURE__ */ function(aImg) {
            return function(i2) {
              var offset = i2 * 4, data = aImg.imageData.data;
              if (aImg.isRemote) {
                throw "Image is loaded remotely. Cannot get pixels.";
              }
              return data[offset + 3] << 24 & PConstants3.ALPHA_MASK | data[offset] << 16 & PConstants3.RED_MASK | data[offset + 1] << 8 & PConstants3.GREEN_MASK | data[offset + 2] & PConstants3.BLUE_MASK;
            };
          }(pImage),
          setPixel: /* @__PURE__ */ function(aImg) {
            return function(i2, c) {
              var offset = i2 * 4, data = aImg.imageData.data;
              if (aImg.isRemote) {
                throw "Image is loaded remotely. Cannot set pixel.";
              }
              data[offset + 0] = (c & PConstants3.RED_MASK) >>> 16;
              data[offset + 1] = (c & PConstants3.GREEN_MASK) >>> 8;
              data[offset + 2] = c & PConstants3.BLUE_MASK;
              data[offset + 3] = (c & PConstants3.ALPHA_MASK) >>> 24;
              aImg.__isDirty = true;
            };
          }(pImage),
          toArray: /* @__PURE__ */ function(aImg) {
            return function() {
              var arr = [], data = aImg.imageData.data, length = aImg.width * aImg.height;
              if (aImg.isRemote) {
                throw "Image is loaded remotely. Cannot get pixels.";
              }
              for (var i2 = 0, offset = 0; i2 < length; i2++, offset += 4) {
                arr.push(data[offset + 3] << 24 & PConstants3.ALPHA_MASK | data[offset] << 16 & PConstants3.RED_MASK | data[offset + 1] << 8 & PConstants3.GREEN_MASK | data[offset + 2] & PConstants3.BLUE_MASK);
              }
              return arr;
            };
          }(pImage),
          set: /* @__PURE__ */ function(aImg) {
            return function(arr) {
              var offset, data, c;
              if (this.isRemote) {
                throw "Image is loaded remotely. Cannot set pixels.";
              }
              data = aImg.imageData.data;
              for (var i2 = 0, aL = arr.length; i2 < aL; i2++) {
                c = arr[i2];
                offset = i2 * 4;
                data[offset + 0] = (c & PConstants3.RED_MASK) >>> 16;
                data[offset + 1] = (c & PConstants3.GREEN_MASK) >>> 8;
                data[offset + 2] = c & PConstants3.BLUE_MASK;
                data[offset + 3] = (c & PConstants3.ALPHA_MASK) >>> 24;
              }
              aImg.__isDirty = true;
            };
          }(pImage)
        };
      }
      var PImage = function(aWidth, aHeight, aFormat) {
        this.__isDirty = false;
        if (aWidth instanceof HTMLImageElement) {
          this.fromHTMLImageData(aWidth);
        } else if (aHeight || aFormat) {
          this.width = aWidth || 1;
          this.height = aHeight || 1;
          var canvas = this.sourceImg = document2.createElement("canvas");
          canvas.width = this.width;
          canvas.height = this.height;
          var imageData = this.imageData = canvas.getContext("2d").createImageData(this.width, this.height);
          this.format = aFormat === PConstants3.ARGB || aFormat === PConstants3.ALPHA ? aFormat : PConstants3.RGB;
          if (this.format === PConstants3.RGB) {
            for (var i2 = 3, data = this.imageData.data, len = data.length; i2 < len; i2 += 4) {
              data[i2] = 255;
            }
          }
          this.__isDirty = true;
          this.updatePixels();
        } else {
          this.width = 0;
          this.height = 0;
          this.imageData = utilityContext2d.createImageData(1, 1);
          this.format = PConstants3.ARGB;
        }
        this.pixels = buildPixelsObject(this);
      };
      PImage.prototype = {
        /**
         * Temporary hack to deal with cross-Processing-instance created PImage.  See
         * tickets #1623 and #1644.
         */
        __isPImage: true,
        /**
        * @member PImage
        * Updates the image with the data in its pixels[] array. Use in conjunction with loadPixels(). If
        * you're only reading pixels from the array, there's no need to call updatePixels().
        * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule
        * is that any time you want to manipulate the pixels[] array, you must first call loadPixels(), and
        * after changes have been made, call updatePixels(). Even if the renderer may not seem to use this
        * function in the current Processing release, this will always be subject to change.
        * Currently, none of the renderers use the additional parameters to updatePixels().
        */
        updatePixels: function() {
          var canvas = this.sourceImg;
          if (canvas && canvas instanceof HTMLCanvasElement && this.__isDirty) {
            canvas.getContext("2d").putImageData(this.imageData, 0, 0);
          }
          this.__isDirty = false;
        },
        fromHTMLImageData: function(htmlImg) {
          var canvasData = getCanvasData(htmlImg);
          try {
            var imageData = canvasData.context.getImageData(0, 0, htmlImg.width, htmlImg.height);
            this.fromImageData(imageData);
          } catch (e) {
            if (htmlImg.width && htmlImg.height) {
              this.isRemote = true;
              this.width = htmlImg.width;
              this.height = htmlImg.height;
            }
          }
          this.sourceImg = htmlImg;
        },
        "get": function(x, y, w, h) {
          if (!arguments.length) {
            return p.get(this);
          }
          if (arguments.length === 2) {
            return p.get(x, y, this);
          }
          if (arguments.length === 4) {
            return p.get(x, y, w, h, this);
          }
        },
        /**
        * @member PImage
        * Changes the color of any pixel or writes an image directly into the image. The x and y parameter
        * specify the pixel or the upper-left corner of the image. The color parameter specifies the color value.
        * Setting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data
        * directly into pixels[]. The equivalent statement to "set(x, y, #000000)" using pixels[] is
        * "pixels[y*width+x] = #000000". Processing requires calling loadPixels() to load the display window
        * data into the pixels[] array before getting the values and calling updatePixels() to update the window.
        *
        * @param {int} x        x-coordinate of the pixel or upper-left corner of the image
        * @param {int} y        y-coordinate of the pixel or upper-left corner of the image
        * @param {color} color  any value of the color datatype
        *
        * @see get
        * @see pixels[]
        * @see copy
        */
        "set": function(x, y, c) {
          p.set(x, y, c, this);
          this.__isDirty = true;
        },
        /**
        * @member PImage
        * Blends a region of pixels into the image specified by the img parameter. These copies utilize full
        * alpha channel support and a choice of the following modes to blend the colors of source pixels (A)
        * with the ones of pixels in the destination image (B):
        * BLEND - linear interpolation of colours: C = A*factor + B
        * ADD - additive blending with white clip: C = min(A*factor + B, 255)
        * SUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)
        * DARKEST - only the darkest colour succeeds: C = min(A*factor, B)
        * LIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)
        * DIFFERENCE - subtract colors from underlying image.
        * EXCLUSION - similar to DIFFERENCE, but less extreme.
        * MULTIPLY - Multiply the colors, result will always be darker.
        * SCREEN - Opposite multiply, uses inverse values of the colors.
        * OVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values, and screens light values.
        * HARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.
        * SOFT_LIGHT - Mix of DARKEST and LIGHTEST. Works like OVERLAY, but not as harsh.
        * DODGE - Lightens light tones and increases contrast, ignores darks. Called "Color Dodge" in Illustrator and Photoshop.
        * BURN - Darker areas are applied, increasing contrast, ignores lights. Called "Color Burn" in Illustrator and Photoshop.
        * All modes use the alpha information (highest byte) of source image pixels as the blending factor.
        * If the source and destination regions are different sizes, the image will be automatically resized to
        * match the destination size. If the srcImg parameter is not used, the display window is used as the source image.
        * This function ignores imageMode().
        *
        * @param {int} x              X coordinate of the source's upper left corner
        * @param {int} y              Y coordinate of the source's upper left corner
        * @param {int} width          source image width
        * @param {int} height         source image height
        * @param {int} dx             X coordinate of the destinations's upper left corner
        * @param {int} dy             Y coordinate of the destinations's upper left corner
        * @param {int} dwidth         destination image width
        * @param {int} dheight        destination image height
        * @param {PImage} srcImg      an image variable referring to the source image
        * @param {MODE} MODE          Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION,
        * MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN
        *
        * @see alpha
        * @see copy
        */
        blend: function(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE) {
          if (arguments.length === 9) {
            p.blend(this, srcImg, x, y, width, height, dx, dy, dwidth, dheight, this);
          } else if (arguments.length === 10) {
            p.blend(srcImg, x, y, width, height, dx, dy, dwidth, dheight, MODE, this);
          }
          delete this.sourceImg;
        },
        /**
        * @member PImage
        * Copies a region of pixels from one image into another. If the source and destination regions
        * aren't the same size, it will automatically resize source pixels to fit the specified target region.
        * No alpha information is used in the process, however if the source image has an alpha channel set,
        * it will be copied as well. This function ignores imageMode().
        *
        * @param {int} sx             X coordinate of the source's upper left corner
        * @param {int} sy             Y coordinate of the source's upper left corner
        * @param {int} swidth         source image width
        * @param {int} sheight        source image height
        * @param {int} dx             X coordinate of the destinations's upper left corner
        * @param {int} dy             Y coordinate of the destinations's upper left corner
        * @param {int} dwidth         destination image width
        * @param {int} dheight        destination image height
        * @param {PImage} srcImg      an image variable referring to the source image
        *
        * @see alpha
        * @see blend
        */
        copy: function(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
          if (arguments.length === 8) {
            p.blend(this, srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, PConstants3.REPLACE, this);
          } else if (arguments.length === 9) {
            p.blend(srcImg, sx, sy, swidth, sheight, dx, dy, dwidth, dheight, PConstants3.REPLACE, this);
          }
          delete this.sourceImg;
        },
        /**
        * @member PImage
        * Filters an image as defined by one of the following modes:
        * THRESHOLD - converts the image to black and white pixels depending if they are above or below
        * the threshold defined by the level parameter. The level must be between 0.0 (black) and 1.0(white).
        * If no level is specified, 0.5 is used.
        * GRAY - converts any colors in the image to grayscale equivalents
        * INVERT - sets each pixel to its inverse value
        * POSTERIZE - limits each channel of the image to the number of colors specified as the level parameter
        * BLUR - executes a Guassian blur with the level parameter specifying the extent of the blurring.
        * If no level parameter is used, the blur is equivalent to Guassian blur of radius 1.
        * OPAQUE - sets the alpha channel to entirely opaque.
        * ERODE - reduces the light areas with the amount defined by the level parameter.
        * DILATE - increases the light areas with the amount defined by the level parameter
        *
        * @param {MODE} MODE        Either THRESHOLD, GRAY, INVERT, POSTERIZE, BLUR, OPAQUE, ERODE, or DILATE
        * @param {int|float} param  in the range from 0 to 1
        */
        filter: function(mode, param) {
          if (arguments.length === 2) {
            p.filter(mode, param, this);
          } else if (arguments.length === 1) {
            p.filter(mode, null, this);
          }
          delete this.sourceImg;
        },
        /**
        * @member PImage
        * Saves the image into a file. Images are saved in TIFF, TARGA, JPEG, and PNG format depending on
        * the extension within the filename  parameter. For example, "image.tif" will have a TIFF image and
        * "image.png" will save a PNG image. If no extension is included in the filename, the image will save
        * in TIFF format and .tif will be added to the name. These files are saved to the sketch's folder,
        * which may be opened by selecting "Show sketch folder" from the "Sketch" menu. It is not possible to
        * use save() while running the program in a web browser.
        * To save an image created within the code, rather than through loading, it's necessary to make the
        * image with the createImage() function so it is aware of the location of the program and can therefore
        * save the file to the right place. See the createImage() reference for more information.
        *
        * @param {String} filename        a sequence of letters and numbers
        */
        save: function(file) {
          p.save(file, this);
        },
        /**
        * @member PImage
        * Resize the image to a new width and height. To make the image scale proportionally, use 0 as the
        * value for the wide or high parameter.
        *
        * @param {int} wide         the resized image width
        * @param {int} high         the resized image height
        *
        * @see get
        */
        resize: function(w, h) {
          if (this.isRemote) {
            throw "Image is loaded remotely. Cannot resize.";
          }
          if (this.width !== 0 || this.height !== 0) {
            if (w === 0 && h !== 0) {
              w = Math.floor(this.width / this.height * h);
            } else if (h === 0 && w !== 0) {
              h = Math.floor(this.height / this.width * w);
            }
            var canvas = getCanvasData(this.imageData).canvas;
            var imageData = getCanvasData(canvas, w, h).context.getImageData(0, 0, w, h);
            this.fromImageData(imageData);
          }
        },
        /**
        * @member PImage
        * Masks part of an image from displaying by loading another image and using it as an alpha channel.
        * This mask image should only contain grayscale data, but only the blue color channel is used. The
        * mask image needs to be the same size as the image to which it is applied.
        * In addition to using a mask image, an integer array containing the alpha channel data can be
        * specified directly. This method is useful for creating dynamically generated alpha masks. This
        * array must be of the same length as the target image's pixels array and should contain only grayscale
        * data of values between 0-255.
        *
        * @param {PImage} maskImg         any PImage object used as the alpha channel for "img", needs to be same
        *                                 size as "img"
        * @param {int[]} maskArray        any array of Integer numbers used as the alpha channel, needs to be same
        *                                 length as the image's pixel array
        */
        mask: function(mask) {
          var obj = this.toImageData(), i2, size;
          if (mask instanceof PImage || mask.__isPImage) {
            if (mask.width === this.width && mask.height === this.height) {
              mask = mask.toImageData();
              for (i2 = 2, size = this.width * this.height * 4; i2 < size; i2 += 4) {
                obj.data[i2 + 1] = mask.data[i2];
              }
            } else {
              throw "mask must have the same dimensions as PImage.";
            }
          } else if (mask instanceof Array) {
            if (this.width * this.height === mask.length) {
              for (i2 = 0, size = mask.length; i2 < size; ++i2) {
                obj.data[i2 * 4 + 3] = mask[i2];
              }
            } else {
              throw "mask array must be the same length as PImage pixels array.";
            }
          }
          this.fromImageData(obj);
        },
        // These are intentionally left blank for PImages, we work live with pixels and draw as necessary
        /**
        * @member PImage
        * Loads the pixel data for the image into its pixels[] array. This function must always be called
        * before reading from or writing to pixels[].
        * Certain renderers may or may not seem to require loadPixels() or updatePixels(). However, the
        * rule is that any time you want to manipulate the pixels[] array, you must first call loadPixels(),
        * and after changes have been made, call updatePixels(). Even if the renderer may not seem to use
        * this function in the current Processing release, this will always be subject to change.
        */
        loadPixels: noop,
        toImageData: function() {
          if (this.isRemote) {
            return this.sourceImg;
          }
          if (!this.__isDirty) {
            return this.imageData;
          }
          var canvasData = getCanvasData(this.sourceImg);
          return canvasData.context.getImageData(0, 0, this.width, this.height);
        },
        toDataURL: function() {
          if (this.isRemote) {
            throw "Image is loaded remotely. Cannot create dataURI.";
          }
          var canvasData = getCanvasData(this.imageData);
          return canvasData.canvas.toDataURL();
        },
        fromImageData: function(canvasImg) {
          var w = canvasImg.width, h = canvasImg.height, canvas = document2.createElement("canvas"), ctx = canvas.getContext("2d");
          this.width = canvas.width = w;
          this.height = canvas.height = h;
          ctx.putImageData(canvasImg, 0, 0);
          this.format = PConstants3.ARGB;
          this.imageData = canvasImg;
          this.sourceImg = canvas;
        }
      };
      p.PImage = PImage;
      p.createImage = function(w, h, mode) {
        return new PImage(w, h, mode);
      };
      p.loadImage = function(file, type, callback) {
        var pimg;
        if (curSketch.imageCache.images[file]) {
          pimg = new PImage(curSketch.imageCache.images[file]);
          pimg.loaded = true;
          return pimg;
        }
        pimg = new PImage();
        var img = document2.createElement("img");
        pimg.sourceImg = img;
        img.onload = /* @__PURE__ */ function(aImage, aPImage, aCallback) {
          var image = aImage;
          var pimg2 = aPImage;
          var callback2 = aCallback;
          return function() {
            pimg2.fromHTMLImageData(image);
            pimg2.loaded = true;
            if (callback2) {
              callback2();
            }
          };
        }(img, pimg, callback);
        img.src = file;
        return pimg;
      };
      p.requestImage = p.loadImage;
      function get$2(x, y) {
        var data;
        if (x >= p.width || x < 0 || y < 0 || y >= p.height) {
          return 0;
        }
        if (isContextReplaced) {
          var offset = ((0 | x) + p.width * (0 | y)) * 4;
          data = p.imageData.data;
          return data[offset + 3] << 24 & PConstants3.ALPHA_MASK | data[offset] << 16 & PConstants3.RED_MASK | data[offset + 1] << 8 & PConstants3.GREEN_MASK | data[offset + 2] & PConstants3.BLUE_MASK;
        }
        data = p.toImageData(0 | x, 0 | y, 1, 1).data;
        return data[3] << 24 & PConstants3.ALPHA_MASK | data[0] << 16 & PConstants3.RED_MASK | data[1] << 8 & PConstants3.GREEN_MASK | data[2] & PConstants3.BLUE_MASK;
      }
      function get$3(x, y, img) {
        if (img.isRemote) {
          throw "Image is loaded remotely. Cannot get x,y.";
        }
        var offset = y * img.width * 4 + x * 4, data = img.imageData.data;
        return data[offset + 3] << 24 & PConstants3.ALPHA_MASK | data[offset] << 16 & PConstants3.RED_MASK | data[offset + 1] << 8 & PConstants3.GREEN_MASK | data[offset + 2] & PConstants3.BLUE_MASK;
      }
      function get$4(x, y, w, h) {
        var c = new PImage(w, h, PConstants3.ARGB);
        c.fromImageData(p.toImageData(x, y, w, h));
        return c;
      }
      function get$5(x, y, w, h, img) {
        if (img.isRemote) {
          throw "Image is loaded remotely. Cannot get x,y,w,h.";
        }
        var c = new PImage(w, h, PConstants3.ARGB), cData = c.imageData.data, imgWidth = img.width, imgHeight = img.height, imgData = img.imageData.data;
        var startRow = Math.max(0, -y), startColumn = Math.max(0, -x), stopRow = Math.min(h, imgHeight - y), stopColumn = Math.min(w, imgWidth - x);
        for (var i2 = startRow; i2 < stopRow; ++i2) {
          var sourceOffset = ((y + i2) * imgWidth + (x + startColumn)) * 4;
          var targetOffset = (i2 * w + startColumn) * 4;
          for (var j = startColumn; j < stopColumn; ++j) {
            cData[targetOffset++] = imgData[sourceOffset++];
            cData[targetOffset++] = imgData[sourceOffset++];
            cData[targetOffset++] = imgData[sourceOffset++];
            cData[targetOffset++] = imgData[sourceOffset++];
          }
        }
        c.__isDirty = true;
        return c;
      }
      p.get = function(x, y, w, h, img) {
        if (img !== void 0) {
          return get$5(x, y, w, h, img);
        }
        if (h !== void 0) {
          return get$4(x, y, w, h);
        }
        if (w !== void 0) {
          return get$3(x, y, w);
        }
        if (y !== void 0) {
          return get$2(x, y);
        }
        if (x !== void 0) {
          return get$5(0, 0, x.width, x.height, x);
        }
        return get$4(0, 0, p.width, p.height);
      };
      p.createGraphics = function(w, h, render) {
        var pg = new Processing3();
        pg.size(w, h, render);
        pg.background(0, 0);
        return pg;
      };
      function resetContext() {
        if (isContextReplaced) {
          curContext = originalContext;
          isContextReplaced = false;
          p.updatePixels();
        }
      }
      function SetPixelContextWrapper() {
        function wrapFunction(newContext, name) {
          function wrapper() {
            resetContext();
            curContext[name].apply(curContext, arguments);
          }
          newContext[name] = wrapper;
        }
        function wrapProperty(newContext, name) {
          function getter() {
            resetContext();
            return curContext[name];
          }
          function setter(value) {
            resetContext();
            curContext[name] = value;
          }
          p.defineProperty(newContext, name, { get: getter, set: setter });
        }
        for (var n in curContext) {
          if (typeof curContext[n] === "function") {
            wrapFunction(this, n);
          } else {
            wrapProperty(this, n);
          }
        }
      }
      function replaceContext() {
        if (isContextReplaced) {
          return;
        }
        p.loadPixels();
        if (proxyContext === null) {
          originalContext = curContext;
          proxyContext = new SetPixelContextWrapper();
        }
        isContextReplaced = true;
        curContext = proxyContext;
        setPixelsCached = 0;
      }
      function set$3(x, y, c) {
        if (x < p.width && x >= 0 && y >= 0 && y < p.height) {
          replaceContext();
          p.pixels.setPixel((0 | x) + p.width * (0 | y), c);
          if (++setPixelsCached > maxPixelsCached) {
            resetContext();
          }
        }
      }
      function set$4(x, y, obj, img) {
        if (img.isRemote) {
          throw "Image is loaded remotely. Cannot set x,y.";
        }
        var c = p.color.toArray(obj);
        var offset = y * img.width * 4 + x * 4;
        var data = img.imageData.data;
        data[offset] = c[0];
        data[offset + 1] = c[1];
        data[offset + 2] = c[2];
        data[offset + 3] = c[3];
      }
      p.set = function(x, y, obj, img) {
        var color, oldFill;
        if (arguments.length === 3) {
          if (typeof obj === "number") {
            set$3(x, y, obj);
          } else if (obj instanceof PImage || obj.__isPImage) {
            p.image(obj, x, y);
          }
        } else if (arguments.length === 4) {
          set$4(x, y, obj, img);
        }
      };
      p.imageData = {};
      p.pixels = {
        getLength: function() {
          return p.imageData.data.length ? p.imageData.data.length / 4 : 0;
        },
        getPixel: function(i2) {
          var offset = i2 * 4, data = p.imageData.data;
          return data[offset + 3] << 24 & 4278190080 | data[offset + 0] << 16 & 16711680 | data[offset + 1] << 8 & 65280 | data[offset + 2] & 255;
        },
        setPixel: function(i2, c) {
          var offset = i2 * 4, data = p.imageData.data;
          data[offset + 0] = (c & 16711680) >>> 16;
          data[offset + 1] = (c & 65280) >>> 8;
          data[offset + 2] = c & 255;
          data[offset + 3] = (c & 4278190080) >>> 24;
        },
        toArray: function() {
          var arr = [], length = p.imageData.width * p.imageData.height, data = p.imageData.data;
          for (var i2 = 0, offset = 0; i2 < length; i2++, offset += 4) {
            arr.push(data[offset + 3] << 24 & 4278190080 | data[offset + 0] << 16 & 16711680 | data[offset + 1] << 8 & 65280 | data[offset + 2] & 255);
          }
          return arr;
        },
        set: function(arr) {
          for (var i2 = 0, aL = arr.length; i2 < aL; i2++) {
            this.setPixel(i2, arr[i2]);
          }
        }
      };
      p.loadPixels = function() {
        p.imageData = drawing.$ensureContext().getImageData(0, 0, p.width, p.height);
      };
      p.updatePixels = function() {
        if (p.imageData) {
          drawing.$ensureContext().putImageData(p.imageData, 0, 0);
        }
      };
      p.hint = function(which) {
        var curContext2 = drawing.$ensureContext();
        if (which === PConstants3.DISABLE_DEPTH_TEST) {
          curContext2.disable(curContext2.DEPTH_TEST);
          curContext2.depthMask(false);
          curContext2.clear(curContext2.DEPTH_BUFFER_BIT);
        } else if (which === PConstants3.ENABLE_DEPTH_TEST) {
          curContext2.enable(curContext2.DEPTH_TEST);
          curContext2.depthMask(true);
        } else if (which === PConstants3.ENABLE_OPENGL_2X_SMOOTH || which === PConstants3.ENABLE_OPENGL_4X_SMOOTH) {
          renderSmooth = true;
        } else if (which === PConstants3.DISABLE_OPENGL_2X_SMOOTH) {
          renderSmooth = false;
        }
      };
      var backgroundHelper = function(arg1, arg2, arg3, arg4) {
        var obj;
        if (arg1 instanceof PImage || arg1.__isPImage) {
          obj = arg1;
          if (!obj.loaded) {
            throw "Error using image in background(): PImage not loaded.";
          }
          if (obj.width !== p.width || obj.height !== p.height) {
            throw "Background image must be the same dimensions as the canvas.";
          }
        } else {
          obj = p.color(arg1, arg2, arg3, arg4);
        }
        backgroundObj = obj;
      };
      Drawing2D.prototype.background = function(arg1, arg2, arg3, arg4) {
        if (arg1 !== undef) {
          backgroundHelper(arg1, arg2, arg3, arg4);
        }
        if (backgroundObj instanceof PImage || backgroundObj.__isPImage) {
          saveContext();
          curContext.setTransform(1, 0, 0, 1, 0, 0);
          p.image(backgroundObj, 0, 0);
          restoreContext();
        } else {
          saveContext();
          curContext.setTransform(1, 0, 0, 1, 0, 0);
          if (p.alpha(backgroundObj) !== colorModeA) {
            curContext.clearRect(0, 0, p.width, p.height);
          }
          curContext.fillStyle = p.color.toString(backgroundObj);
          curContext.fillRect(0, 0, p.width, p.height);
          isFillDirty = true;
          restoreContext();
        }
      };
      Drawing3D.prototype.background = function(arg1, arg2, arg3, arg4) {
        if (arguments.length > 0) {
          backgroundHelper(arg1, arg2, arg3, arg4);
        }
        var c = p.color.toGLArray(backgroundObj);
        curContext.clearColor(c[0], c[1], c[2], c[3]);
        curContext.clear(curContext.COLOR_BUFFER_BIT | curContext.DEPTH_BUFFER_BIT);
      };
      Drawing2D.prototype.image = function(img, x, y, w, h) {
        x = Math.round(x);
        y = Math.round(y);
        if (img.width > 0) {
          var wid = w || img.width;
          var hgt = h || img.height;
          var bounds = imageModeConvert2(x || 0, y || 0, w || img.width, h || img.height, arguments.length < 4);
          var fastImage = !!img.sourceImg && curTint === null;
          if (fastImage) {
            var htmlElement = img.sourceImg;
            if (img.__isDirty) {
              img.updatePixels();
            }
            curContext.drawImage(
              htmlElement,
              0,
              0,
              htmlElement.width,
              htmlElement.height,
              bounds.x,
              bounds.y,
              bounds.w,
              bounds.h
            );
          } else {
            var obj = img.toImageData();
            if (curTint !== null) {
              curTint(obj);
              img.__isDirty = true;
            }
            curContext.drawImage(
              getCanvasData(obj).canvas,
              0,
              0,
              img.width,
              img.height,
              bounds.x,
              bounds.y,
              bounds.w,
              bounds.h
            );
          }
        }
      };
      Drawing3D.prototype.image = function(img, x, y, w, h) {
        if (img.width > 0) {
          x = Math.round(x);
          y = Math.round(y);
          w = w || img.width;
          h = h || img.height;
          p.beginShape(p.QUADS);
          p.texture(img);
          p.vertex(x, y, 0, 0, 0);
          p.vertex(x, y + h, 0, 0, h);
          p.vertex(x + w, y + h, 0, w, h);
          p.vertex(x + w, y, 0, w, 0);
          p.endShape();
        }
      };
      p.tint = function(a1, a2, a3, a4) {
        var tintColor = p.color(a1, a2, a3, a4);
        var r = p.red(tintColor) / colorModeX;
        var g = p.green(tintColor) / colorModeY;
        var b = p.blue(tintColor) / colorModeZ;
        var a = p.alpha(tintColor) / colorModeA;
        curTint = function(obj) {
          var data = obj.data, length = 4 * obj.width * obj.height;
          for (var i2 = 0; i2 < length; ) {
            data[i2++] *= r;
            data[i2++] *= g;
            data[i2++] *= b;
            data[i2++] *= a;
          }
        };
        curTint3d = function(data) {
          for (var i2 = 0; i2 < data.length; ) {
            data[i2++] = r;
            data[i2++] = g;
            data[i2++] = b;
            data[i2++] = a;
          }
        };
      };
      p.noTint = function() {
        curTint = null;
        curTint3d = null;
      };
      p.copy = function(src, sx, sy, sw, sh, dx, dy, dw, dh) {
        if (dh === undef) {
          dh = dw;
          dw = dy;
          dy = dx;
          dx = sh;
          sh = sw;
          sw = sy;
          sy = sx;
          sx = src;
          src = p;
        }
        p.blend(src, sx, sy, sw, sh, dx, dy, dw, dh, PConstants3.REPLACE);
      };
      p.blend = function(src, sx, sy, sw, sh, dx, dy, dw, dh, mode, pimgdest) {
        if (src.isRemote) {
          throw "Image is loaded remotely. Cannot blend image.";
        }
        if (mode === undef) {
          mode = dh;
          dh = dw;
          dw = dy;
          dy = dx;
          dx = sh;
          sh = sw;
          sw = sy;
          sy = sx;
          sx = src;
          src = p;
        }
        var sx2 = sx + sw, sy2 = sy + sh, dx2 = dx + dw, dy2 = dy + dh, dest = pimgdest || p;
        if (pimgdest === undef || mode === undef) {
          p.loadPixels();
        }
        src.loadPixels();
        if (src === p && p.intersect(sx, sy, sx2, sy2, dx, dy, dx2, dy2)) {
          p.blit_resize(
            p.get(sx, sy, sx2 - sx, sy2 - sy),
            0,
            0,
            sx2 - sx - 1,
            sy2 - sy - 1,
            dest.imageData.data,
            dest.width,
            dest.height,
            dx,
            dy,
            dx2,
            dy2,
            mode
          );
        } else {
          p.blit_resize(src, sx, sy, sx2, sy2, dest.imageData.data, dest.width, dest.height, dx, dy, dx2, dy2, mode);
        }
        if (pimgdest === undef) {
          p.updatePixels();
        }
      };
      var buildBlurKernel = function(r) {
        var radius = p.floor(r * 3.5), i2;
        radius = radius < 1 ? 1 : radius < 248 ? radius : 248;
        if (p.shared.blurRadius !== radius) {
          p.shared.blurRadius = radius;
          p.shared.blurKernelSize = 1 + (p.shared.blurRadius << 1);
          p.shared.blurKernel = new Float32Array2(p.shared.blurKernelSize);
          var sharedBlurKernal = p.shared.blurKernel;
          var sharedBlurKernelSize = p.shared.blurKernelSize;
          var sharedBlurRadius = p.shared.blurRadius;
          for (i2 = 0; i2 < sharedBlurKernelSize; i2++) {
            sharedBlurKernal[i2] = 0;
          }
          var radiusiSquared = (radius - 1) * (radius - 1);
          for (i2 = 1; i2 < radius; i2++) {
            sharedBlurKernal[radius + i2] = sharedBlurKernal[radius - i2] = radiusiSquared;
          }
          sharedBlurKernal[radius] = radius * radius;
        }
      };
      var blurARGB = function(r, aImg) {
        var sum, cr, cg, cb, ca, c, m;
        var read2, ri, ym, ymi, bk0;
        var wh = aImg.pixels.getLength();
        var r2 = new Float32Array2(wh);
        var g2 = new Float32Array2(wh);
        var b2 = new Float32Array2(wh);
        var a2 = new Float32Array2(wh);
        var yi = 0;
        var x, y, i2, offset;
        buildBlurKernel(r);
        var aImgHeight = aImg.height;
        var aImgWidth = aImg.width;
        var sharedBlurKernelSize = p.shared.blurKernelSize;
        var sharedBlurRadius = p.shared.blurRadius;
        var sharedBlurKernal = p.shared.blurKernel;
        var pix = aImg.imageData.data;
        for (y = 0; y < aImgHeight; y++) {
          for (x = 0; x < aImgWidth; x++) {
            cb = cg = cr = ca = sum = 0;
            read2 = x - sharedBlurRadius;
            if (read2 < 0) {
              bk0 = -read2;
              read2 = 0;
            } else {
              if (read2 >= aImgWidth) {
                break;
              }
              bk0 = 0;
            }
            for (i2 = bk0; i2 < sharedBlurKernelSize; i2++) {
              if (read2 >= aImgWidth) {
                break;
              }
              offset = (read2 + yi) * 4;
              m = sharedBlurKernal[i2];
              ca += m * pix[offset + 3];
              cr += m * pix[offset];
              cg += m * pix[offset + 1];
              cb += m * pix[offset + 2];
              sum += m;
              read2++;
            }
            ri = yi + x;
            a2[ri] = ca / sum;
            r2[ri] = cr / sum;
            g2[ri] = cg / sum;
            b2[ri] = cb / sum;
          }
          yi += aImgWidth;
        }
        yi = 0;
        ym = -sharedBlurRadius;
        ymi = ym * aImgWidth;
        for (y = 0; y < aImgHeight; y++) {
          for (x = 0; x < aImgWidth; x++) {
            cb = cg = cr = ca = sum = 0;
            if (ym < 0) {
              bk0 = ri = -ym;
              read2 = x;
            } else {
              if (ym >= aImgHeight) {
                break;
              }
              bk0 = 0;
              ri = ym;
              read2 = x + ymi;
            }
            for (i2 = bk0; i2 < sharedBlurKernelSize; i2++) {
              if (ri >= aImgHeight) {
                break;
              }
              m = sharedBlurKernal[i2];
              ca += m * a2[read2];
              cr += m * r2[read2];
              cg += m * g2[read2];
              cb += m * b2[read2];
              sum += m;
              ri++;
              read2 += aImgWidth;
            }
            offset = (x + yi) * 4;
            pix[offset] = cr / sum;
            pix[offset + 1] = cg / sum;
            pix[offset + 2] = cb / sum;
            pix[offset + 3] = ca / sum;
          }
          yi += aImgWidth;
          ymi += aImgWidth;
          ym++;
        }
      };
      var dilate = function(isInverted, aImg) {
        var currIdx = 0;
        var maxIdx = aImg.pixels.getLength();
        var out = new Int32Array2(maxIdx);
        var currRowIdx, maxRowIdx, colOrig, colOut, currLum;
        var idxRight, idxLeft, idxUp, idxDown, colRight, colLeft, colUp, colDown, lumRight, lumLeft, lumUp, lumDown;
        if (!isInverted) {
          while (currIdx < maxIdx) {
            currRowIdx = currIdx;
            maxRowIdx = currIdx + aImg.width;
            while (currIdx < maxRowIdx) {
              colOrig = colOut = aImg.pixels.getPixel(currIdx);
              idxLeft = currIdx - 1;
              idxRight = currIdx + 1;
              idxUp = currIdx - aImg.width;
              idxDown = currIdx + aImg.width;
              if (idxLeft < currRowIdx) {
                idxLeft = currIdx;
              }
              if (idxRight >= maxRowIdx) {
                idxRight = currIdx;
              }
              if (idxUp < 0) {
                idxUp = 0;
              }
              if (idxDown >= maxIdx) {
                idxDown = currIdx;
              }
              colUp = aImg.pixels.getPixel(idxUp);
              colLeft = aImg.pixels.getPixel(idxLeft);
              colDown = aImg.pixels.getPixel(idxDown);
              colRight = aImg.pixels.getPixel(idxRight);
              currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
              lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
              lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
              lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
              lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
              if (lumLeft > currLum) {
                colOut = colLeft;
                currLum = lumLeft;
              }
              if (lumRight > currLum) {
                colOut = colRight;
                currLum = lumRight;
              }
              if (lumUp > currLum) {
                colOut = colUp;
                currLum = lumUp;
              }
              if (lumDown > currLum) {
                colOut = colDown;
                currLum = lumDown;
              }
              out[currIdx++] = colOut;
            }
          }
        } else {
          while (currIdx < maxIdx) {
            currRowIdx = currIdx;
            maxRowIdx = currIdx + aImg.width;
            while (currIdx < maxRowIdx) {
              colOrig = colOut = aImg.pixels.getPixel(currIdx);
              idxLeft = currIdx - 1;
              idxRight = currIdx + 1;
              idxUp = currIdx - aImg.width;
              idxDown = currIdx + aImg.width;
              if (idxLeft < currRowIdx) {
                idxLeft = currIdx;
              }
              if (idxRight >= maxRowIdx) {
                idxRight = currIdx;
              }
              if (idxUp < 0) {
                idxUp = 0;
              }
              if (idxDown >= maxIdx) {
                idxDown = currIdx;
              }
              colUp = aImg.pixels.getPixel(idxUp);
              colLeft = aImg.pixels.getPixel(idxLeft);
              colDown = aImg.pixels.getPixel(idxDown);
              colRight = aImg.pixels.getPixel(idxRight);
              currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
              lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
              lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
              lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
              lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
              if (lumLeft < currLum) {
                colOut = colLeft;
                currLum = lumLeft;
              }
              if (lumRight < currLum) {
                colOut = colRight;
                currLum = lumRight;
              }
              if (lumUp < currLum) {
                colOut = colUp;
                currLum = lumUp;
              }
              if (lumDown < currLum) {
                colOut = colDown;
                currLum = lumDown;
              }
              out[currIdx++] = colOut;
            }
          }
        }
        aImg.pixels.set(out);
      };
      p.filter = function(kind, param, aImg) {
        var img, col, lum, i2;
        if (arguments.length === 3) {
          aImg.loadPixels();
          img = aImg;
        } else {
          p.loadPixels();
          img = p;
        }
        if (param === undef) {
          param = null;
        }
        if (img.isRemote) {
          throw "Image is loaded remotely. Cannot filter image.";
        }
        var imglen = img.pixels.getLength();
        switch (kind) {
          case PConstants3.BLUR:
            var radius = param || 1;
            blurARGB(radius, img);
            break;
          case PConstants3.GRAY:
            if (img.format === PConstants3.ALPHA) {
              for (i2 = 0; i2 < imglen; i2++) {
                col = 255 - img.pixels.getPixel(i2);
                img.pixels.setPixel(i2, 4278190080 | col << 16 | col << 8 | col);
              }
              img.format = PConstants3.RGB;
            } else {
              for (i2 = 0; i2 < imglen; i2++) {
                col = img.pixels.getPixel(i2);
                lum = 77 * (col >> 16 & 255) + 151 * (col >> 8 & 255) + 28 * (col & 255) >> 8;
                img.pixels.setPixel(i2, col & PConstants3.ALPHA_MASK | lum << 16 | lum << 8 | lum);
              }
            }
            break;
          case PConstants3.INVERT:
            for (i2 = 0; i2 < imglen; i2++) {
              img.pixels.setPixel(i2, img.pixels.getPixel(i2) ^ 16777215);
            }
            break;
          case PConstants3.POSTERIZE:
            if (param === null) {
              throw "Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)";
            }
            var levels = p.floor(param);
            if (levels < 2 || levels > 255) {
              throw "Levels must be between 2 and 255 for filter(POSTERIZE, levels)";
            }
            var levels1 = levels - 1;
            for (i2 = 0; i2 < imglen; i2++) {
              var rlevel = img.pixels.getPixel(i2) >> 16 & 255;
              var glevel = img.pixels.getPixel(i2) >> 8 & 255;
              var blevel = img.pixels.getPixel(i2) & 255;
              rlevel = (rlevel * levels >> 8) * 255 / levels1;
              glevel = (glevel * levels >> 8) * 255 / levels1;
              blevel = (blevel * levels >> 8) * 255 / levels1;
              img.pixels.setPixel(i2, 4278190080 & img.pixels.getPixel(i2) | rlevel << 16 | glevel << 8 | blevel);
            }
            break;
          case PConstants3.OPAQUE:
            for (i2 = 0; i2 < imglen; i2++) {
              img.pixels.setPixel(i2, img.pixels.getPixel(i2) | 4278190080);
            }
            img.format = PConstants3.RGB;
            break;
          case PConstants3.THRESHOLD:
            if (param === null) {
              param = 0.5;
            }
            if (param < 0 || param > 1) {
              throw "Level must be between 0 and 1 for filter(THRESHOLD, level)";
            }
            var thresh = p.floor(param * 255);
            for (i2 = 0; i2 < imglen; i2++) {
              var max = p.max((img.pixels.getPixel(i2) & PConstants3.RED_MASK) >> 16, p.max((img.pixels.getPixel(i2) & PConstants3.GREEN_MASK) >> 8, img.pixels.getPixel(i2) & PConstants3.BLUE_MASK));
              img.pixels.setPixel(i2, img.pixels.getPixel(i2) & PConstants3.ALPHA_MASK | (max < thresh ? 0 : 16777215));
            }
            break;
          case PConstants3.ERODE:
            dilate(true, img);
            break;
          case PConstants3.DILATE:
            dilate(false, img);
            break;
        }
        img.updatePixels();
      };
      p.shared = {
        fracU: 0,
        ifU: 0,
        fracV: 0,
        ifV: 0,
        u1: 0,
        u2: 0,
        v1: 0,
        v2: 0,
        sX: 0,
        sY: 0,
        iw: 0,
        iw1: 0,
        ih1: 0,
        ul: 0,
        ll: 0,
        ur: 0,
        lr: 0,
        cUL: 0,
        cLL: 0,
        cUR: 0,
        cLR: 0,
        srcXOffset: 0,
        srcYOffset: 0,
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        srcBuffer: null,
        blurRadius: 0,
        blurKernelSize: 0,
        blurKernel: null
      };
      p.intersect = function(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2) {
        var sw = sx2 - sx1 + 1;
        var sh = sy2 - sy1 + 1;
        var dw = dx2 - dx1 + 1;
        var dh = dy2 - dy1 + 1;
        if (dx1 < sx1) {
          dw += dx1 - sx1;
          if (dw > sw) {
            dw = sw;
          }
        } else {
          var w = sw + sx1 - dx1;
          if (dw > w) {
            dw = w;
          }
        }
        if (dy1 < sy1) {
          dh += dy1 - sy1;
          if (dh > sh) {
            dh = sh;
          }
        } else {
          var h = sh + sy1 - dy1;
          if (dh > h) {
            dh = h;
          }
        }
        return !(dw <= 0 || dh <= 0);
      };
      var blendFuncs = {};
      blendFuncs[PConstants3.BLEND] = p.modes.blend;
      blendFuncs[PConstants3.ADD] = p.modes.add;
      blendFuncs[PConstants3.SUBTRACT] = p.modes.subtract;
      blendFuncs[PConstants3.LIGHTEST] = p.modes.lightest;
      blendFuncs[PConstants3.DARKEST] = p.modes.darkest;
      blendFuncs[PConstants3.REPLACE] = p.modes.replace;
      blendFuncs[PConstants3.DIFFERENCE] = p.modes.difference;
      blendFuncs[PConstants3.EXCLUSION] = p.modes.exclusion;
      blendFuncs[PConstants3.MULTIPLY] = p.modes.multiply;
      blendFuncs[PConstants3.SCREEN] = p.modes.screen;
      blendFuncs[PConstants3.OVERLAY] = p.modes.overlay;
      blendFuncs[PConstants3.HARD_LIGHT] = p.modes.hard_light;
      blendFuncs[PConstants3.SOFT_LIGHT] = p.modes.soft_light;
      blendFuncs[PConstants3.DODGE] = p.modes.dodge;
      blendFuncs[PConstants3.BURN] = p.modes.burn;
      p.blit_resize = function(img, srcX1, srcY1, srcX2, srcY2, destPixels, screenW, screenH, destX1, destY1, destX2, destY2, mode) {
        var x, y;
        if (srcX1 < 0) {
          srcX1 = 0;
        }
        if (srcY1 < 0) {
          srcY1 = 0;
        }
        if (srcX2 >= img.width) {
          srcX2 = img.width - 1;
        }
        if (srcY2 >= img.height) {
          srcY2 = img.height - 1;
        }
        var srcW = srcX2 - srcX1;
        var srcH = srcY2 - srcY1;
        var destW = destX2 - destX1;
        var destH = destY2 - destY1;
        if (destW <= 0 || destH <= 0 || srcW <= 0 || srcH <= 0 || destX1 >= screenW || destY1 >= screenH || srcX1 >= img.width || srcY1 >= img.height) {
          return;
        }
        var dx = Math.floor(srcW / destW * PConstants3.PRECISIONF);
        var dy = Math.floor(srcH / destH * PConstants3.PRECISIONF);
        var pshared = p.shared;
        pshared.srcXOffset = Math.floor(destX1 < 0 ? -destX1 * dx : srcX1 * PConstants3.PRECISIONF);
        pshared.srcYOffset = Math.floor(destY1 < 0 ? -destY1 * dy : srcY1 * PConstants3.PRECISIONF);
        if (destX1 < 0) {
          destW += destX1;
          destX1 = 0;
        }
        if (destY1 < 0) {
          destH += destY1;
          destY1 = 0;
        }
        destW = Math.min(destW, screenW - destX1);
        destH = Math.min(destH, screenH - destY1);
        var destOffset = destY1 * screenW + destX1;
        var destColor;
        pshared.srcBuffer = img.imageData.data;
        pshared.iw = img.width;
        pshared.iw1 = img.width - 1;
        pshared.ih1 = img.height - 1;
        var filterBilinear = p.filter_bilinear, filterNewScanline = p.filter_new_scanline, blendFunc = blendFuncs[mode], blendedColor, idx, cULoffset, cURoffset, cLLoffset, cLRoffset, ALPHA_MASK = PConstants3.ALPHA_MASK, RED_MASK = PConstants3.RED_MASK, GREEN_MASK = PConstants3.GREEN_MASK, BLUE_MASK = PConstants3.BLUE_MASK, PREC_MAXVAL = PConstants3.PREC_MAXVAL, PRECISIONB = PConstants3.PRECISIONB, PREC_RED_SHIFT = PConstants3.PREC_RED_SHIFT, PREC_ALPHA_SHIFT = PConstants3.PREC_ALPHA_SHIFT, srcBuffer = pshared.srcBuffer, min = Math.min;
        for (y = 0; y < destH; y++) {
          pshared.sX = pshared.srcXOffset;
          pshared.fracV = pshared.srcYOffset & PREC_MAXVAL;
          pshared.ifV = PREC_MAXVAL - pshared.fracV;
          pshared.v1 = (pshared.srcYOffset >> PRECISIONB) * pshared.iw;
          pshared.v2 = min((pshared.srcYOffset >> PRECISIONB) + 1, pshared.ih1) * pshared.iw;
          for (x = 0; x < destW; x++) {
            idx = (destOffset + x) * 4;
            destColor = destPixels[idx + 3] << 24 & ALPHA_MASK | destPixels[idx] << 16 & RED_MASK | destPixels[idx + 1] << 8 & GREEN_MASK | destPixels[idx + 2] & BLUE_MASK;
            pshared.fracU = pshared.sX & PREC_MAXVAL;
            pshared.ifU = PREC_MAXVAL - pshared.fracU;
            pshared.ul = pshared.ifU * pshared.ifV >> PRECISIONB;
            pshared.ll = pshared.ifU * pshared.fracV >> PRECISIONB;
            pshared.ur = pshared.fracU * pshared.ifV >> PRECISIONB;
            pshared.lr = pshared.fracU * pshared.fracV >> PRECISIONB;
            pshared.u1 = pshared.sX >> PRECISIONB;
            pshared.u2 = min(pshared.u1 + 1, pshared.iw1);
            cULoffset = (pshared.v1 + pshared.u1) * 4;
            cURoffset = (pshared.v1 + pshared.u2) * 4;
            cLLoffset = (pshared.v2 + pshared.u1) * 4;
            cLRoffset = (pshared.v2 + pshared.u2) * 4;
            pshared.cUL = srcBuffer[cULoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cULoffset] << 16 & RED_MASK | srcBuffer[cULoffset + 1] << 8 & GREEN_MASK | srcBuffer[cULoffset + 2] & BLUE_MASK;
            pshared.cUR = srcBuffer[cURoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cURoffset] << 16 & RED_MASK | srcBuffer[cURoffset + 1] << 8 & GREEN_MASK | srcBuffer[cURoffset + 2] & BLUE_MASK;
            pshared.cLL = srcBuffer[cLLoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cLLoffset] << 16 & RED_MASK | srcBuffer[cLLoffset + 1] << 8 & GREEN_MASK | srcBuffer[cLLoffset + 2] & BLUE_MASK;
            pshared.cLR = srcBuffer[cLRoffset + 3] << 24 & ALPHA_MASK | srcBuffer[cLRoffset] << 16 & RED_MASK | srcBuffer[cLRoffset + 1] << 8 & GREEN_MASK | srcBuffer[cLRoffset + 2] & BLUE_MASK;
            pshared.r = pshared.ul * ((pshared.cUL & RED_MASK) >> 16) + pshared.ll * ((pshared.cLL & RED_MASK) >> 16) + pshared.ur * ((pshared.cUR & RED_MASK) >> 16) + pshared.lr * ((pshared.cLR & RED_MASK) >> 16) << PREC_RED_SHIFT & RED_MASK;
            pshared.g = pshared.ul * (pshared.cUL & GREEN_MASK) + pshared.ll * (pshared.cLL & GREEN_MASK) + pshared.ur * (pshared.cUR & GREEN_MASK) + pshared.lr * (pshared.cLR & GREEN_MASK) >>> PRECISIONB & GREEN_MASK;
            pshared.b = pshared.ul * (pshared.cUL & BLUE_MASK) + pshared.ll * (pshared.cLL & BLUE_MASK) + pshared.ur * (pshared.cUR & BLUE_MASK) + pshared.lr * (pshared.cLR & BLUE_MASK) >>> PRECISIONB;
            pshared.a = pshared.ul * ((pshared.cUL & ALPHA_MASK) >>> 24) + pshared.ll * ((pshared.cLL & ALPHA_MASK) >>> 24) + pshared.ur * ((pshared.cUR & ALPHA_MASK) >>> 24) + pshared.lr * ((pshared.cLR & ALPHA_MASK) >>> 24) << PREC_ALPHA_SHIFT & ALPHA_MASK;
            blendedColor = blendFunc(destColor, pshared.a | pshared.r | pshared.g | pshared.b);
            destPixels[idx] = (blendedColor & RED_MASK) >>> 16;
            destPixels[idx + 1] = (blendedColor & GREEN_MASK) >>> 8;
            destPixels[idx + 2] = blendedColor & BLUE_MASK;
            destPixels[idx + 3] = (blendedColor & ALPHA_MASK) >>> 24;
            pshared.sX += dx;
          }
          destOffset += screenW;
          pshared.srcYOffset += dy;
        }
      };
      p.loadFont = function(name, size) {
        if (name === undef) {
          throw "font name required in loadFont.";
        }
        if (name.indexOf(".svg") === -1) {
          if (size === undef) {
            size = curTextFont.size;
          }
          return PFont3.get(name, size);
        }
        var font = p.loadGlyphs(name);
        return {
          name,
          css: "12px sans-serif",
          glyph: true,
          units_per_em: font.units_per_em,
          horiz_adv_x: 1 / font.units_per_em * font.horiz_adv_x,
          ascent: font.ascent,
          descent: font.descent,
          width: function(str) {
            var width = 0;
            var len = str.length;
            for (var i2 = 0; i2 < len; i2++) {
              try {
                width += parseFloat(p.glyphLook(p.glyphTable[name], str[i2]).horiz_adv_x);
              } catch (e) {
                Processing3.debug(e);
              }
            }
            return width / p.glyphTable[name].units_per_em;
          }
        };
      };
      p.createFont = function(name, size) {
        return p.loadFont(name, size);
      };
      p.textFont = function(pfont, size) {
        if (size !== undef) {
          if (!pfont.glyph) {
            pfont = PFont3.get(pfont.name, size);
          }
          curTextSize = size;
        }
        curTextFont = pfont;
        curFontName = curTextFont.name;
        curTextAscent = curTextFont.ascent;
        curTextDescent = curTextFont.descent;
        curTextLeading = curTextFont.leading;
        var curContext2 = drawing.$ensureContext();
        curContext2.font = curTextFont.css;
      };
      p.textSize = function(size) {
        curTextFont = PFont3.get(curFontName, size);
        curTextSize = size;
        curTextAscent = curTextFont.ascent;
        curTextDescent = curTextFont.descent;
        curTextLeading = curTextFont.leading;
        var curContext2 = drawing.$ensureContext();
        curContext2.font = curTextFont.css;
      };
      p.textAscent = function() {
        return curTextAscent;
      };
      p.textDescent = function() {
        return curTextDescent;
      };
      p.textLeading = function(leading) {
        curTextLeading = leading;
      };
      p.textAlign = function(xalign, yalign) {
        horizontalTextAlignment = xalign;
        verticalTextAlignment = yalign || PConstants3.BASELINE;
      };
      function toP5String(obj) {
        if (obj instanceof String) {
          return obj;
        }
        if (typeof obj === "number") {
          if (obj === (0 | obj)) {
            return obj.toString();
          }
          return p.nf(obj, 0, 3);
        }
        if (obj === null || obj === undef) {
          return "";
        }
        return obj.toString();
      }
      Drawing2D.prototype.textWidth = function(str) {
        var lines = toP5String(str).split(/\r?\n/g), width = 0;
        var i2, linesCount = lines.length;
        curContext.font = curTextFont.css;
        for (i2 = 0; i2 < linesCount; ++i2) {
          width = Math.max(width, curTextFont.measureTextWidth(lines[i2]));
        }
        return width | 0;
      };
      Drawing3D.prototype.textWidth = function(str) {
        var lines = toP5String(str).split(/\r?\n/g), width = 0;
        var i2, linesCount = lines.length;
        if (textcanvas === undef) {
          textcanvas = document2.createElement("canvas");
        }
        var textContext = textcanvas.getContext("2d");
        textContext.font = curTextFont.css;
        for (i2 = 0; i2 < linesCount; ++i2) {
          width = Math.max(width, textContext.measureText(lines[i2]).width);
        }
        return width | 0;
      };
      p.glyphLook = function(font, chr) {
        try {
          switch (chr) {
            case "1":
              return font.one;
            case "2":
              return font.two;
            case "3":
              return font.three;
            case "4":
              return font.four;
            case "5":
              return font.five;
            case "6":
              return font.six;
            case "7":
              return font.seven;
            case "8":
              return font.eight;
            case "9":
              return font.nine;
            case "0":
              return font.zero;
            case " ":
              return font.space;
            case "$":
              return font.dollar;
            case "!":
              return font.exclam;
            case '"':
              return font.quotedbl;
            case "#":
              return font.numbersign;
            case "%":
              return font.percent;
            case "&":
              return font.ampersand;
            case "'":
              return font.quotesingle;
            case "(":
              return font.parenleft;
            case ")":
              return font.parenright;
            case "*":
              return font.asterisk;
            case "+":
              return font.plus;
            case ",":
              return font.comma;
            case "-":
              return font.hyphen;
            case ".":
              return font.period;
            case "/":
              return font.slash;
            case "_":
              return font.underscore;
            case ":":
              return font.colon;
            case ";":
              return font.semicolon;
            case "<":
              return font.less;
            case "=":
              return font.equal;
            case ">":
              return font.greater;
            case "?":
              return font.question;
            case "@":
              return font.at;
            case "[":
              return font.bracketleft;
            case "\\":
              return font.backslash;
            case "]":
              return font.bracketright;
            case "^":
              return font.asciicircum;
            case "`":
              return font.grave;
            case "{":
              return font.braceleft;
            case "|":
              return font.bar;
            case "}":
              return font.braceright;
            case "~":
              return font.asciitilde;
            // If the character is not 'special', access it by object reference
            default:
              return font[chr];
          }
        } catch (e) {
          Processing3.debug(e);
        }
      };
      Drawing2D.prototype.text$line = function(str, x, y, z, align) {
        var textWidth = 0, xOffset = 0;
        if (!curTextFont.glyph) {
          if (str && "fillText" in curContext) {
            if (isFillDirty) {
              curContext.fillStyle = p.color.toString(currentFillColor);
              isFillDirty = false;
            }
            if (align === PConstants3.RIGHT || align === PConstants3.CENTER) {
              textWidth = curTextFont.measureTextWidth(str);
              if (align === PConstants3.RIGHT) {
                xOffset = -textWidth;
              } else {
                xOffset = -textWidth / 2;
              }
            }
            curContext.fillText(str, x + xOffset, y);
          }
        } else {
          var font = p.glyphTable[curFontName];
          saveContext();
          curContext.translate(x, y + curTextSize);
          if (align === PConstants3.RIGHT || align === PConstants3.CENTER) {
            textWidth = font.width(str);
            if (align === PConstants3.RIGHT) {
              xOffset = -textWidth;
            } else {
              xOffset = -textWidth / 2;
            }
          }
          var upem = font.units_per_em, newScale = 1 / upem * curTextSize;
          curContext.scale(newScale, newScale);
          for (var i2 = 0, len = str.length; i2 < len; i2++) {
            try {
              p.glyphLook(font, str[i2]).draw();
            } catch (e) {
              Processing3.debug(e);
            }
          }
          restoreContext();
        }
      };
      Drawing3D.prototype.text$line = function(str, x, y, z, align) {
        if (textcanvas === undef) {
          textcanvas = document2.createElement("canvas");
        }
        var oldContext = curContext;
        curContext = textcanvas.getContext("2d");
        curContext.font = curTextFont.css;
        var textWidth = curTextFont.measureTextWidth(str);
        textcanvas.width = textWidth;
        textcanvas.height = curTextSize;
        curContext = textcanvas.getContext("2d");
        curContext.font = curTextFont.css;
        curContext.textBaseline = "top";
        Drawing2D.prototype.text$line(str, 0, 0, 0, PConstants3.LEFT);
        var aspect = textcanvas.width / textcanvas.height;
        curContext = oldContext;
        curContext.bindTexture(curContext.TEXTURE_2D, textTex);
        curContext.texImage2D(curContext.TEXTURE_2D, 0, curContext.RGBA, curContext.RGBA, curContext.UNSIGNED_BYTE, textcanvas);
        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MAG_FILTER, curContext.LINEAR);
        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_MIN_FILTER, curContext.LINEAR);
        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_T, curContext.CLAMP_TO_EDGE);
        curContext.texParameteri(curContext.TEXTURE_2D, curContext.TEXTURE_WRAP_S, curContext.CLAMP_TO_EDGE);
        var xOffset = 0;
        if (align === PConstants3.RIGHT) {
          xOffset = -textWidth;
        } else if (align === PConstants3.CENTER) {
          xOffset = -textWidth / 2;
        }
        var model = new PMatrix3D2();
        var scalefactor = curTextSize * 0.5;
        model.translate(x + xOffset - scalefactor / 2, y - scalefactor, z);
        model.scale(-aspect * scalefactor, -scalefactor, scalefactor);
        model.translate(-1, -1, -1);
        model.transpose();
        var view = new PMatrix3D2();
        view.scale(1, -1, 1);
        view.apply(modelView.array());
        view.transpose();
        curContext.useProgram(programObject2D);
        vertexAttribPointer("aVertex2d", programObject2D, "aVertex", 3, textBuffer);
        vertexAttribPointer("aTextureCoord2d", programObject2D, "aTextureCoord", 2, textureBuffer);
        uniformi("uSampler2d", programObject2D, "uSampler", [0]);
        uniformi("uIsDrawingText2d", programObject2D, "uIsDrawingText", true);
        uniformMatrix("uModel2d", programObject2D, "uModel", false, model.array());
        uniformMatrix("uView2d", programObject2D, "uView", false, view.array());
        uniformf("uColor2d", programObject2D, "uColor", fillStyle);
        curContext.bindBuffer(curContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
        curContext.drawElements(curContext.TRIANGLES, 6, curContext.UNSIGNED_SHORT, 0);
      };
      function text$4(str, x, y, z) {
        var lines, linesCount;
        if (str.indexOf("\n") < 0) {
          lines = [str];
          linesCount = 1;
        } else {
          lines = str.split(/\r?\n/g);
          linesCount = lines.length;
        }
        var yOffset = 0;
        if (verticalTextAlignment === PConstants3.TOP) {
          yOffset = curTextAscent + curTextDescent;
        } else if (verticalTextAlignment === PConstants3.CENTER) {
          yOffset = curTextAscent / 2 - (linesCount - 1) * curTextLeading / 2;
        } else if (verticalTextAlignment === PConstants3.BOTTOM) {
          yOffset = -(curTextDescent + (linesCount - 1) * curTextLeading);
        }
        for (var i2 = 0; i2 < linesCount; ++i2) {
          var line = lines[i2];
          drawing.text$line(line, x, y + yOffset, z, horizontalTextAlignment);
          yOffset += curTextLeading;
        }
      }
      function text$6(str, x, y, width, height, z) {
        if (str.length === 0 || width === 0 || height === 0) {
          return;
        }
        if (curTextSize > height) {
          return;
        }
        var spaceMark = -1;
        var start2 = 0;
        var lineWidth2 = 0;
        var drawCommands = [];
        for (var charPos = 0, len = str.length; charPos < len; charPos++) {
          var currentChar = str[charPos];
          var spaceChar = currentChar === " ";
          var letterWidth = curTextFont.measureTextWidth(currentChar);
          if (currentChar !== "\n" && lineWidth2 + letterWidth <= width) {
            if (spaceChar) {
              spaceMark = charPos;
            }
            lineWidth2 += letterWidth;
          } else {
            if (spaceMark + 1 === start2) {
              if (charPos > 0) {
                spaceMark = charPos;
              } else {
                return;
              }
            }
            if (currentChar === "\n") {
              drawCommands.push({ text: str.substring(start2, charPos), width: lineWidth2 });
              start2 = charPos + 1;
            } else {
              drawCommands.push({ text: str.substring(start2, spaceMark + 1), width: lineWidth2 });
              start2 = spaceMark + 1;
            }
            lineWidth2 = 0;
            charPos = start2 - 1;
          }
        }
        if (start2 < len) {
          drawCommands.push({ text: str.substring(start2), width: lineWidth2 });
        }
        var xOffset = 1, yOffset = curTextAscent;
        if (horizontalTextAlignment === PConstants3.CENTER) {
          xOffset = width / 2;
        } else if (horizontalTextAlignment === PConstants3.RIGHT) {
          xOffset = width;
        }
        var linesCount = drawCommands.length, visibleLines = Math.min(linesCount, Math.floor(height / curTextLeading));
        if (verticalTextAlignment === PConstants3.TOP) {
          yOffset = curTextAscent + curTextDescent;
        } else if (verticalTextAlignment === PConstants3.CENTER) {
          yOffset = height / 2 - curTextLeading * (visibleLines / 2 - 1);
        } else if (verticalTextAlignment === PConstants3.BOTTOM) {
          yOffset = curTextDescent + curTextLeading;
        }
        var command, drawCommand, leading;
        for (command = 0; command < linesCount; command++) {
          leading = command * curTextLeading;
          if (yOffset + leading > height - curTextDescent) {
            break;
          }
          drawCommand = drawCommands[command];
          drawing.text$line(drawCommand.text, x + xOffset, y + yOffset + leading, z, horizontalTextAlignment);
        }
      }
      p.text = function() {
        if (textMode === PConstants3.SHAPE) {
          return;
        }
        if (arguments.length === 3) {
          text$4(toP5String(arguments[0]), arguments[1], arguments[2], 0);
        } else if (arguments.length === 4) {
          text$4(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3]);
        } else if (arguments.length === 5) {
          text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], 0);
        } else if (arguments.length === 6) {
          text$6(toP5String(arguments[0]), arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
      };
      p.textMode = function(mode) {
        textMode = mode;
      };
      p.loadGlyphs = function(url) {
        var x, y, cx, cy, nx, ny, d, a, lastCom, lenC, horiz_adv_x, getXY = "[0-9\\-]+", path;
        var regex = function(needle, hay) {
          var i2 = 0, results = [], latest, regexp = new RegExp(needle, "g");
          latest = results[i2] = regexp.exec(hay);
          while (latest) {
            i2++;
            latest = results[i2] = regexp.exec(hay);
          }
          return results;
        };
        var buildPath = function(d2) {
          var c = regex("[A-Za-z][0-9\\- ]+|Z", d2);
          var beforePathDraw = function() {
            saveContext();
            return drawing.$ensureContext();
          };
          var afterPathDraw = function() {
            executeContextFill();
            executeContextStroke();
            restoreContext();
          };
          path = "return {draw:function(){var curContext=beforePathDraw();curContext.beginPath();";
          x = 0;
          y = 0;
          cx = 0;
          cy = 0;
          nx = 0;
          ny = 0;
          d2 = 0;
          a = 0;
          lastCom = "";
          lenC = c.length - 1;
          for (var j = 0; j < lenC; j++) {
            var com = c[j][0], xy = regex(getXY, com);
            switch (com[0]) {
              case "M":
                x = parseFloat(xy[0][0]);
                y = parseFloat(xy[1][0]);
                path += "curContext.moveTo(" + x + "," + -y + ");";
                break;
              case "L":
                x = parseFloat(xy[0][0]);
                y = parseFloat(xy[1][0]);
                path += "curContext.lineTo(" + x + "," + -y + ");";
                break;
              case "H":
                x = parseFloat(xy[0][0]);
                path += "curContext.lineTo(" + x + "," + -y + ");";
                break;
              case "V":
                y = parseFloat(xy[0][0]);
                path += "curContext.lineTo(" + x + "," + -y + ");";
                break;
              case "T":
                nx = parseFloat(xy[0][0]);
                ny = parseFloat(xy[1][0]);
                if (lastCom === "Q" || lastCom === "T") {
                  d2 = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(cy - y, 2));
                  a = Math.PI + Math.atan2(cx - x, cy - y);
                  cx = x + Math.sin(a) * d2;
                  cy = y + Math.cos(a) * d2;
                } else {
                  cx = x;
                  cy = y;
                }
                path += "curContext.quadraticCurveTo(" + cx + "," + -cy + "," + nx + "," + -ny + ");";
                x = nx;
                y = ny;
                break;
              case "Q":
                cx = parseFloat(xy[0][0]);
                cy = parseFloat(xy[1][0]);
                nx = parseFloat(xy[2][0]);
                ny = parseFloat(xy[3][0]);
                path += "curContext.quadraticCurveTo(" + cx + "," + -cy + "," + nx + "," + -ny + ");";
                x = nx;
                y = ny;
                break;
              case "Z":
                path += "curContext.closePath();";
                break;
            }
            lastCom = com[0];
          }
          path += "afterPathDraw();";
          path += "curContext.translate(" + horiz_adv_x + ",0);";
          path += "}}";
          return new Function("beforePathDraw", "afterPathDraw", path)(beforePathDraw, afterPathDraw);
        };
        var parseSVGFont = function(svg) {
          var font = svg.getElementsByTagName("font");
          p.glyphTable[url].horiz_adv_x = font[0].getAttribute("horiz-adv-x");
          var font_face = svg.getElementsByTagName("font-face")[0];
          p.glyphTable[url].units_per_em = parseFloat(font_face.getAttribute("units-per-em"));
          p.glyphTable[url].ascent = parseFloat(font_face.getAttribute("ascent"));
          p.glyphTable[url].descent = parseFloat(font_face.getAttribute("descent"));
          var glyph = svg.getElementsByTagName("glyph"), len = glyph.length;
          for (var i2 = 0; i2 < len; i2++) {
            var unicode = glyph[i2].getAttribute("unicode");
            var name = glyph[i2].getAttribute("glyph-name");
            horiz_adv_x = glyph[i2].getAttribute("horiz-adv-x");
            if (horiz_adv_x === null) {
              horiz_adv_x = p.glyphTable[url].horiz_adv_x;
            }
            d = glyph[i2].getAttribute("d");
            if (d !== undef) {
              path = buildPath(d);
              p.glyphTable[url][name] = {
                name,
                unicode,
                horiz_adv_x,
                draw: path.draw
              };
            }
          }
        };
        var loadXML = function() {
          var xmlDoc;
          try {
            xmlDoc = document2.implementation.createDocument("", "", null);
          } catch (e_fx_op) {
            Processing3.debug(e_fx_op.message);
            return;
          }
          try {
            xmlDoc.async = false;
            xmlDoc.load(url);
            parseSVGFont(xmlDoc.getElementsByTagName("svg")[0]);
          } catch (e_sf_ch) {
            Processing3.debug(e_sf_ch);
            try {
              var xmlhttp = new window2.XMLHttpRequest();
              xmlhttp.open("GET", url, false);
              xmlhttp.send(null);
              parseSVGFont(xmlhttp.responseXML.documentElement);
            } catch (e) {
              Processing3.debug(e_sf_ch);
            }
          }
        };
        p.glyphTable[url] = {};
        loadXML(url);
        return p.glyphTable[url];
      };
      p.param = function(name) {
        var attributeName = "data-processing-" + name;
        if (curElement.hasAttribute(attributeName)) {
          return curElement.getAttribute(attributeName);
        }
        for (var i2 = 0, len = curElement.childNodes.length; i2 < len; ++i2) {
          var item = curElement.childNodes.item(i2);
          if (item.nodeType !== 1 || item.tagName.toLowerCase() !== "param") {
            continue;
          }
          if (item.getAttribute("name") === name) {
            return item.getAttribute("value");
          }
        }
        if (curSketch.params.hasOwnProperty(name)) {
          return curSketch.params[name];
        }
        return null;
      };
      function wireDimensionalFunctions(mode) {
        if (mode === "3D") {
          drawing = new Drawing3D();
        } else if (mode === "2D") {
          drawing = new Drawing2D();
        } else {
          drawing = new DrawingPre();
        }
        for (var i2 in DrawingPre.prototype) {
          if (DrawingPre.prototype.hasOwnProperty(i2) && i2.indexOf("$") < 0) {
            p[i2] = drawing[i2];
          }
        }
        drawing.$init();
      }
      function createDrawingPreFunction(name) {
        return function() {
          wireDimensionalFunctions("2D");
          return drawing[name].apply(this, arguments);
        };
      }
      DrawingPre.prototype.translate = createDrawingPreFunction("translate");
      DrawingPre.prototype.transform = createDrawingPreFunction("transform");
      DrawingPre.prototype.scale = createDrawingPreFunction("scale");
      DrawingPre.prototype.pushMatrix = createDrawingPreFunction("pushMatrix");
      DrawingPre.prototype.popMatrix = createDrawingPreFunction("popMatrix");
      DrawingPre.prototype.resetMatrix = createDrawingPreFunction("resetMatrix");
      DrawingPre.prototype.applyMatrix = createDrawingPreFunction("applyMatrix");
      DrawingPre.prototype.rotate = createDrawingPreFunction("rotate");
      DrawingPre.prototype.rotateZ = createDrawingPreFunction("rotateZ");
      DrawingPre.prototype.shearX = createDrawingPreFunction("shearX");
      DrawingPre.prototype.shearY = createDrawingPreFunction("shearY");
      DrawingPre.prototype.redraw = createDrawingPreFunction("redraw");
      DrawingPre.prototype.toImageData = createDrawingPreFunction("toImageData");
      DrawingPre.prototype.ambientLight = createDrawingPreFunction("ambientLight");
      DrawingPre.prototype.directionalLight = createDrawingPreFunction("directionalLight");
      DrawingPre.prototype.lightFalloff = createDrawingPreFunction("lightFalloff");
      DrawingPre.prototype.lightSpecular = createDrawingPreFunction("lightSpecular");
      DrawingPre.prototype.pointLight = createDrawingPreFunction("pointLight");
      DrawingPre.prototype.noLights = createDrawingPreFunction("noLights");
      DrawingPre.prototype.spotLight = createDrawingPreFunction("spotLight");
      DrawingPre.prototype.beginCamera = createDrawingPreFunction("beginCamera");
      DrawingPre.prototype.endCamera = createDrawingPreFunction("endCamera");
      DrawingPre.prototype.frustum = createDrawingPreFunction("frustum");
      DrawingPre.prototype.box = createDrawingPreFunction("box");
      DrawingPre.prototype.sphere = createDrawingPreFunction("sphere");
      DrawingPre.prototype.ambient = createDrawingPreFunction("ambient");
      DrawingPre.prototype.emissive = createDrawingPreFunction("emissive");
      DrawingPre.prototype.shininess = createDrawingPreFunction("shininess");
      DrawingPre.prototype.specular = createDrawingPreFunction("specular");
      DrawingPre.prototype.fill = createDrawingPreFunction("fill");
      DrawingPre.prototype.stroke = createDrawingPreFunction("stroke");
      DrawingPre.prototype.strokeWeight = createDrawingPreFunction("strokeWeight");
      DrawingPre.prototype.smooth = createDrawingPreFunction("smooth");
      DrawingPre.prototype.noSmooth = createDrawingPreFunction("noSmooth");
      DrawingPre.prototype.point = createDrawingPreFunction("point");
      DrawingPre.prototype.vertex = createDrawingPreFunction("vertex");
      DrawingPre.prototype.endShape = createDrawingPreFunction("endShape");
      DrawingPre.prototype.bezierVertex = createDrawingPreFunction("bezierVertex");
      DrawingPre.prototype.curveVertex = createDrawingPreFunction("curveVertex");
      DrawingPre.prototype.curve = createDrawingPreFunction("curve");
      DrawingPre.prototype.line = createDrawingPreFunction("line");
      DrawingPre.prototype.bezier = createDrawingPreFunction("bezier");
      DrawingPre.prototype.rect = createDrawingPreFunction("rect");
      DrawingPre.prototype.ellipse = createDrawingPreFunction("ellipse");
      DrawingPre.prototype.background = createDrawingPreFunction("background");
      DrawingPre.prototype.image = createDrawingPreFunction("image");
      DrawingPre.prototype.textWidth = createDrawingPreFunction("textWidth");
      DrawingPre.prototype.text$line = createDrawingPreFunction("text$line");
      DrawingPre.prototype.$ensureContext = createDrawingPreFunction("$ensureContext");
      DrawingPre.prototype.$newPMatrix = createDrawingPreFunction("$newPMatrix");
      DrawingPre.prototype.size = function(aWidth, aHeight, aMode) {
        wireDimensionalFunctions(aMode === PConstants3.WEBGL ? "3D" : "2D");
        p.size(aWidth, aHeight, aMode);
      };
      DrawingPre.prototype.$init = noop;
      Drawing2D.prototype.$init = function() {
        p.size(p.width, p.height);
        curContext.lineCap = "round";
        p.noSmooth();
        p.disableContextMenu();
      };
      Drawing3D.prototype.$init = function() {
        p.use3DContext = true;
        p.disableContextMenu();
      };
      DrawingShared.prototype.$ensureContext = function() {
        return curContext;
      };
      if (!curElement.getAttribute("tabindex")) {
        curElement.setAttribute("tabindex", 0);
      }
      function getKeyCode(e) {
        var code = e.which || e.keyCode;
        switch (code) {
          case 13:
            return 10;
          case 91:
          // META L (Saf/Mac)
          case 93:
          // META R (Saf/Mac)
          case 224:
            return 157;
          case 57392:
            return 17;
          case 46:
            return 127;
          case 45:
            return 155;
        }
        return code;
      }
      function getKeyChar(e) {
        var c = e.which || e.keyCode;
        var anyShiftPressed = e.shiftKey || e.ctrlKey || e.altKey || e.metaKey;
        switch (c) {
          case 13:
            c = anyShiftPressed ? 13 : 10;
            break;
          case 8:
            c = anyShiftPressed ? 127 : 8;
            break;
        }
        return new Char2(c);
      }
      function suppressKeyEvent(e) {
        if (typeof e.preventDefault === "function") {
          e.preventDefault();
        } else if (typeof e.stopPropagation === "function") {
          e.stopPropagation();
        }
        return false;
      }
      function updateKeyPressed() {
        var ch;
        for (ch in pressedKeysMap) {
          if (pressedKeysMap.hasOwnProperty(ch)) {
            p.__keyPressed = true;
            return;
          }
        }
        p.__keyPressed = false;
      }
      function resetKeyPressed() {
        p.__keyPressed = false;
        pressedKeysMap = [];
        lastPressedKeyCode = null;
      }
      function simulateKeyTyped(code, c) {
        pressedKeysMap[code] = c;
        lastPressedKeyCode = null;
        p.key = c;
        p.keyCode = code;
        p.keyPressed();
        p.keyCode = 0;
        p.keyTyped();
        updateKeyPressed();
      }
      function handleKeydown(e) {
        var code = getKeyCode(e);
        if (code === PConstants3.DELETE) {
          simulateKeyTyped(code, new Char2(127));
          return;
        }
        if (codedKeys.indexOf(code) < 0) {
          lastPressedKeyCode = code;
          return;
        }
        var c = new Char2(PConstants3.CODED);
        p.key = c;
        p.keyCode = code;
        pressedKeysMap[code] = c;
        p.keyPressed();
        lastPressedKeyCode = null;
        updateKeyPressed();
        return suppressKeyEvent(e);
      }
      function handleKeypress(e) {
        if (lastPressedKeyCode === null) {
          return;
        }
        var code = lastPressedKeyCode, c = getKeyChar(e);
        simulateKeyTyped(code, c);
        return suppressKeyEvent(e);
      }
      function handleKeyup(e) {
        var code = getKeyCode(e), c = pressedKeysMap[code];
        if (c === undef) {
          return;
        }
        p.key = c;
        p.keyCode = code;
        p.keyReleased();
        delete pressedKeysMap[code];
        updateKeyPressed();
      }
      if (!pgraphicsMode) {
        if (aCode instanceof Processing3.Sketch) {
          curSketch = aCode;
        } else if (typeof aCode === "function") {
          curSketch = new Processing3.Sketch(aCode);
        } else if (!aCode) {
          curSketch = new Processing3.Sketch(function() {
          });
        } else {
          curSketch = Processing3.compile(aCode);
        }
        p.externals.sketch = curSketch;
        wireDimensionalFunctions();
        p.setupLive2D = function() {
          console.log("setting up l2d!");
          var l2d = defaultScope2.Live2D.getInstance();
          l2d.pjsToModern(p);
          return l2d;
        };
        curElement.onfocus = function() {
          p.focused = true;
        };
        curElement.onblur = function() {
          p.focused = false;
          if (!curSketch.options.globalKeyEvents) {
            resetKeyPressed();
          }
        };
        if (curSketch.options.pauseOnBlur) {
          attachEventHandler(window2, "focus", function() {
            if (doLoop) {
              p.loop();
            }
          });
          attachEventHandler(window2, "blur", function() {
            if (doLoop && loopStarted) {
              p.noLoop();
              doLoop = true;
            }
            resetKeyPressed();
          });
        }
        var keyTrigger = curSketch.options.globalKeyEvents ? window2 : curElement;
        attachEventHandler(keyTrigger, "keydown", handleKeydown);
        attachEventHandler(keyTrigger, "keypress", handleKeypress);
        attachEventHandler(keyTrigger, "keyup", handleKeyup);
        for (var i in Processing3.lib) {
          if (Processing3.lib.hasOwnProperty(i)) {
            if (Processing3.lib[i].hasOwnProperty("attach")) {
              Processing3.lib[i].attach(p);
            } else if (Processing3.lib[i] instanceof Function) {
              Processing3.lib[i].call(this);
            }
          }
        }
        var retryInterval = 100;
        var executeSketch = function(processing) {
          if (!(curSketch.imageCache.pending || PFont3.preloading.pending(retryInterval))) {
            if (window2.opera) {
              var link, element, operaCache = curSketch.imageCache.operaCache;
              for (link in operaCache) {
                if (operaCache.hasOwnProperty(link)) {
                  element = operaCache[link];
                  if (element !== null) {
                    document2.body.removeChild(element);
                  }
                  delete operaCache[link];
                }
              }
            }
            curSketch.attach(processing, defaultScope2);
            curSketch.onLoad(processing);
            if (processing.setup) {
              processing.setup();
              processing.resetMatrix();
              curSketch.onSetup();
            }
            resetContext();
            if (processing.draw) {
              if (!doLoop) {
                processing.redraw();
              } else {
                processing.loop();
              }
            }
          } else {
            window2.setTimeout(function() {
              executeSketch(processing);
            }, retryInterval);
          }
        };
        addInstance(this);
        executeSketch(p);
      } else {
        curSketch = new Processing3.Sketch();
        wireDimensionalFunctions();
        p.size = function(w, h, render) {
          if (render && render === PConstants3.WEBGL) {
            wireDimensionalFunctions("3D");
          } else {
            wireDimensionalFunctions("2D");
          }
          p.size(w, h, render);
        };
      }
    };
    Processing3.debug = function() {
      if ("console" in window2) {
        return function(msg) {
          window2.console.log("Processing.js: " + msg);
        };
      }
      return noop;
    }();
    Processing3.prototype = defaultScope2;
    Processing3.instances = processingInstances;
    Processing3.getInstanceById = function(name) {
      return processingInstances[processingInstanceIds[name]];
    };
    (function(Processing4) {
      var unsupportedP5 = "open() createOutput() createInput() BufferedReader selectFolder() dataPath() createWriter() selectOutput() beginRecord() saveStream() endRecord() selectInput() saveBytes() createReader() beginRaw() endRaw() PrintWriter delay()".split(" "), count = unsupportedP5.length, prettyName, p5Name;
      function createUnsupportedFunc(n) {
        return function() {
          throw "Processing.js does not support " + n + ".";
        };
      }
      while (count--) {
        prettyName = unsupportedP5[count];
        p5Name = prettyName.replace("()", "");
        Processing4[p5Name] = createUnsupportedFunc(prettyName);
      }
    })(defaultScope2);
    return Processing3;
  }
  var Processing_default = Processing2;

  // src/Helpers/PjsConsole.js
  function PjsConsole(document2) {
    var e = { BufferMax: 200 }, style = document2.createElement("style"), added = false;
    style.textContent = [
      ".pjsconsole.hidden {",
      "  display: none!important;",
      "}"
    ].join("\n");
    e.wrapper = document2.createElement("div");
    style.textContent += [
      "",
      ".pjsconsole {",
      "  opacity: .75;",
      "  display: block;",
      "  position: fixed;",
      "  bottom: 0px;",
      "  left: 0px;",
      "  right: 0px;",
      "  height: 50px;",
      "  background-color: #aaa;",
      "}"
    ].join("\n");
    e.wrapper.classList.add("pjsconsole");
    e.dragger = document2.createElement("div");
    style.textContent += [
      "",
      ".pjsconsole .dragger {",
      "  display: block;",
      "  border: 3px black raised;",
      "  cursor: n-resize;",
      "  position: absolute;",
      "  top: 0px;",
      "  left: 0px;",
      "  right: 0px;",
      "  height: 5px;",
      "  background-color: #333;",
      "}"
    ].join("\n");
    e.dragger.classList.add("dragger");
    e.closer = document2.createElement("div");
    style.textContent += [
      "",
      ".pjsconsole .closer {",
      "  opacity: .5;",
      "  display: block;",
      "  border: 3px black raised;",
      "  position: absolute;",
      "  top: 10px;",
      "  right: 30px;",
      "  height: 20px;",
      "  width: 20px;",
      "  background-color: #ddd;",
      "  color: #000;",
      "  line-height: 20px;",
      "  text-align: center;",
      "  cursor: pointer",
      "}"
    ].join("\n");
    e.closer.classList.add("closer");
    e.closer.innerHTML = "&#10006;";
    e.javaconsole = document2.createElement("div");
    style.textContent += [
      "",
      ".pjsconsole .console {",
      "  overflow-x: auto;",
      "  display: block;",
      "  position: absolute;",
      "  left: 10px;",
      "  right: 0px;",
      "  bottom: 5px;",
      "  top: 10px;",
      "  overflow-y: scroll;",
      "  height: 40px;",
      "}"
    ].join("\n");
    e.javaconsole.setAttribute("class", "console");
    e.wrapper.appendChild(e.dragger);
    e.wrapper.appendChild(e.javaconsole);
    e.wrapper.appendChild(e.closer);
    e.dragger.onmousedown = function(t2) {
      e.divheight = e.wrapper.style.height;
      if (document2.selection) document2.selection.empty();
      else window.getSelection().removeAllRanges();
      var n = t2.screenY;
      window.onmousemove = function(t3) {
        e.wrapper.style.height = parseFloat(e.divheight) + (n - t3.screenY) + "px";
        e.javaconsole.style.height = parseFloat(e.divheight) + (n - t3.screenY) - 10 + "px";
      };
      window.onmouseup = function(t3) {
        if (document2.selection) document2.selection.empty();
        else window.getSelection().removeAllRanges();
        e.wrapper.style.height = parseFloat(e.divheight) + (n - t3.screenY) + "px";
        e.javaconsole.style.height = parseFloat(e.divheight) + (n - t3.screenY) - 10 + "px";
        window.onmousemove = null;
        window.onmouseup = null;
      };
    };
    e.BufferArray = [];
    e.print = e.log = function() {
      if (!added) {
        document2.body.appendChild(style);
        document2.body.appendChild(e.wrapper);
        added = true;
      }
      var args = Array.prototype.slice.call(arguments);
      t = args.map(function(t2, idx) {
        return t2 + (idx + 1 === args.length ? "" : " ");
      }).join("");
      if (e.BufferArray[e.BufferArray.length - 1]) e.BufferArray[e.BufferArray.length - 1] += t + "";
      else e.BufferArray.push(t);
      e.javaconsole.innerHTML = e.BufferArray.join("");
      e.showconsole();
    };
    e.println = function() {
      var args = Array.prototype.slice.call(arguments);
      args.push("<br>");
      e.print.apply(e, args);
      if (e.BufferArray.length > e.BufferMax) {
        e.BufferArray.splice(0, 1);
      } else {
        e.javaconsole.scrollTop = e.javaconsole.scrollHeight;
      }
    };
    e.showconsole = function() {
      e.wrapper.classList.remove("hidden");
    };
    e.hideconsole = function() {
      e.wrapper.classList.add("hidden");
    };
    e.closer.onclick = function() {
      e.hideconsole();
    };
    e.hideconsole();
    return e;
  }

  // src/Parser/Parser.js
  function setupParser(Processing3, options) {
    var defaultScope2 = options.defaultScope, PConstants3 = defaultScope2.PConstants, aFunctions = options.aFunctions, Browser2 = options.Browser, document2 = Browser2.document, undef;
    function getGlobalMembers() {
      var names = [
        /* this code is generated by jsglobals.js */
        "abs",
        "acos",
        "alpha",
        "ambient",
        "ambientLight",
        "append",
        "applyMatrix",
        "arc",
        "arrayCopy",
        "asin",
        "atan",
        "atan2",
        "background",
        "beginCamera",
        "beginDraw",
        "beginShape",
        "bezier",
        "bezierDetail",
        "bezierPoint",
        "bezierTangent",
        "bezierVertex",
        "binary",
        "blend",
        "blendColor",
        "blit_resize",
        "blue",
        "box",
        "breakShape",
        "brightness",
        "camera",
        "ceil",
        "Character",
        "color",
        "colorMode",
        "concat",
        "constrain",
        "copy",
        "cos",
        "createFont",
        "createGraphics",
        "createImage",
        "cursor",
        "curve",
        "curveDetail",
        "curvePoint",
        "curveTangent",
        "curveTightness",
        "curveVertex",
        "day",
        "degrees",
        "directionalLight",
        "disableContextMenu",
        "dist",
        "draw",
        "ellipse",
        "ellipseMode",
        "emissive",
        "enableContextMenu",
        "endCamera",
        "endDraw",
        "endShape",
        "exit",
        "exp",
        "expand",
        "externals",
        "fill",
        "filter",
        "floor",
        "focused",
        "frameCount",
        "frameRate",
        "frustum",
        "get",
        "glyphLook",
        "glyphTable",
        "green",
        "height",
        "hex",
        "hint",
        "hour",
        "hue",
        "image",
        "imageMode",
        "intersect",
        "join",
        "key",
        "keyCode",
        "keyPressed",
        "keyReleased",
        "keyTyped",
        "lerp",
        "lerpColor",
        "lightFalloff",
        "lights",
        "lightSpecular",
        "line",
        "link",
        "loadBytes",
        "loadFont",
        "loadGlyphs",
        "loadImage",
        "loadPixels",
        "loadShape",
        "loadXML",
        "loadStrings",
        "log",
        "loop",
        "mag",
        "map",
        "match",
        "matchAll",
        "max",
        "millis",
        "min",
        "minute",
        "mix",
        "modelX",
        "modelY",
        "modelZ",
        "modes",
        "month",
        "mouseButton",
        "mouseClicked",
        "mouseDragged",
        "mouseMoved",
        "mouseOut",
        "mouseOver",
        "mousePressed",
        "mouseReleased",
        "mouseScroll",
        "mouseScrolled",
        "mouseX",
        "mouseY",
        "name",
        "nf",
        "nfc",
        "nfp",
        "nfs",
        "noCursor",
        "noFill",
        "noise",
        "noiseDetail",
        "noiseSeed",
        "noLights",
        "noLoop",
        "norm",
        "normal",
        "noSmooth",
        "noStroke",
        "noTint",
        "ortho",
        "param",
        "parseBoolean",
        "parseByte",
        "parseChar",
        "parseFloat",
        "parseInt",
        "parseXML",
        "peg",
        "perspective",
        "PImage",
        "pixels",
        "PMatrix2D",
        "PMatrix3D",
        "PMatrixStack",
        "pmouseX",
        "pmouseY",
        "point",
        "pointLight",
        "popMatrix",
        "popStyle",
        "pow",
        "print",
        "printCamera",
        "println",
        "printMatrix",
        "printProjection",
        "PShape",
        "PShapeSVG",
        "pushMatrix",
        "pushStyle",
        "quad",
        "radians",
        "random",
        "randomGaussian",
        "randomSeed",
        "rect",
        "rectMode",
        "red",
        "redraw",
        "requestImage",
        "resetMatrix",
        "reverse",
        "rotate",
        "rotateX",
        "rotateY",
        "rotateZ",
        "round",
        "saturation",
        "save",
        "saveFrame",
        "saveStrings",
        "scale",
        "screenX",
        "screenY",
        "screenZ",
        "second",
        "set",
        "setup",
        "shape",
        "shapeMode",
        "shared",
        "shearX",
        "shearY",
        "shininess",
        "shorten",
        "sin",
        "size",
        "smooth",
        "sort",
        "specular",
        "sphere",
        "sphereDetail",
        "splice",
        "split",
        "splitTokens",
        "spotLight",
        "sq",
        "sqrt",
        "status",
        "str",
        "stroke",
        "strokeCap",
        "strokeJoin",
        "strokeWeight",
        "subset",
        "tan",
        "text",
        "textAlign",
        "textAscent",
        "textDescent",
        "textFont",
        "textLeading",
        "textMode",
        "textSize",
        "texture",
        "textureMode",
        "textWidth",
        "tint",
        "toImageData",
        "touchCancel",
        "touchEnd",
        "touchMove",
        "touchStart",
        "translate",
        "transform",
        "triangle",
        "trim",
        "unbinary",
        "unhex",
        "updatePixels",
        "use3DContext",
        "vertex",
        "width",
        "XMLElement",
        "XML",
        "year",
        "__contains",
        "__equals",
        "__equalsIgnoreCase",
        "__frameRate",
        "__hashCode",
        "__int_cast",
        "__instanceof",
        "__keyPressed",
        "__mousePressed",
        "__printStackTrace",
        "__replace",
        "__replaceAll",
        "__replaceFirst",
        "__toCharArray",
        "__split",
        "__codePointAt",
        "__startsWith",
        "__endsWith",
        "__matches",
        "setupLive2D"
      ];
      if (aFunctions) {
        Object.keys(aFunctions).forEach(function(name) {
          names.push(name);
        });
      }
      var members = {};
      var i, l2;
      for (i = 0, l2 = names.length; i < l2; ++i) {
        members[names[i]] = null;
      }
      for (var lib in Processing3.lib) {
        if (Processing3.lib.hasOwnProperty(lib)) {
          if (Processing3.lib[lib].exports) {
            var exportedNames = Processing3.lib[lib].exports;
            for (i = 0, l2 = exportedNames.length; i < l2; ++i) {
              members[exportedNames[i]] = null;
            }
          }
        }
      }
      members["test"] = null;
      return members;
    }
    function parseProcessing(code) {
      var globalMembers = getGlobalMembers();
      function splitToAtoms(code2) {
        var atoms2 = [];
        var items = code2.split(/([\{\[\(\)\]\}])/);
        var result = items[0];
        var stack = [];
        for (var i = 1; i < items.length; i += 2) {
          var item = items[i];
          if (item === "[" || item === "{" || item === "(") {
            stack.push(result);
            result = item;
          } else if (item === "]" || item === "}" || item === ")") {
            var kind = item === "}" ? "A" : item === ")" ? "B" : "C";
            var index = atoms2.length;
            atoms2.push(result + item);
            result = stack.pop() + '"' + kind + (index + 1) + '"';
          }
          result += items[i + 1];
        }
        atoms2.unshift(result);
        return atoms2;
      }
      function injectStrings(code2, strings2) {
        return code2.replace(/'(\d+)'/g, function(all, index) {
          var val = strings2[index];
          if (val.charAt(0) === "/") {
            return val;
          }
          return /^'((?:[^'\\\n])|(?:\\.[0-9A-Fa-f]*))'$/.test(val) ? "(new $p.Character(" + val + "))" : val;
        });
      }
      function trimSpaces(string) {
        var m1 = /^\s*/.exec(string), result;
        if (m1[0].length === string.length) {
          result = { left: m1[0], middle: "", right: "" };
        } else {
          var m2 = /\s*$/.exec(string);
          result = { left: m1[0], middle: string.substring(m1[0].length, m2.index), right: m2[0] };
        }
        result.untrim = function(t2) {
          return this.left + t2 + this.right;
        };
        return result;
      }
      function trim(string) {
        return string.replace(/^\s+/, "").replace(/\s+$/, "");
      }
      function appendToLookupTable(table, array) {
        for (var i = 0, l2 = array.length; i < l2; ++i) {
          table[array[i]] = null;
        }
        return table;
      }
      function isLookupTableEmpty(table) {
        for (var i in table) {
          if (table.hasOwnProperty(i)) {
            return false;
          }
        }
        return true;
      }
      function getAtomIndex(templ) {
        return templ.substring(2, templ.length - 1);
      }
      var codeWoExtraCr = code.replace(/\r\n?|\n\r/g, "\n");
      var strings = [];
      var codeWoStrings = codeWoExtraCr.replace(
        /("(?:[^"\\\n]|\\.)*")|('(?:[^'\\\n]|\\.)*')|(([\[\(=|&!\^:?]\s*)(\/(?![*\/])(?:[^\/\\\n]|\\.)*\/[gim]*)\b)|(\/\/[^\n]*\n)|(\/\*(?:(?!\*\/)(?:.|\n))*\*\/)/g,
        function(all, quoted, aposed, regexCtx, prefix, regex, singleComment, comment) {
          var index;
          if (quoted || aposed) {
            index = strings.length;
            strings.push(all);
            return "'" + index + "'";
          }
          if (regexCtx) {
            index = strings.length;
            strings.push(regex);
            return prefix + "'" + index + "'";
          }
          return comment !== "" ? " " : "\n";
        }
      );
      codeWoStrings = codeWoStrings.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {
        return "__x005F_x" + hexCode;
      });
      codeWoStrings = codeWoStrings.replace(/\$/g, "__x0024");
      codeWoStrings = codeWoStrings.replace(/return\s*[\n\r]+/g, "return ");
      var genericsWereRemoved;
      var codeWoGenerics = codeWoStrings;
      var replaceFunc = function(all, before, types, after) {
        if (!!before || !!after) {
          return all;
        }
        genericsWereRemoved = true;
        return "";
      };
      do {
        genericsWereRemoved = false;
        codeWoGenerics = codeWoGenerics.replace(/([<]?)<\s*((?:\?|[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)(?:\[\])*(?:\s+(?:extends|super)\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)?(?:\s*,\s*(?:\?|[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)(?:\[\])*(?:\s+(?:extends|super)\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)?)*)\s*>([=]?)/g, replaceFunc);
      } while (genericsWereRemoved);
      var atoms = splitToAtoms(codeWoGenerics);
      var replaceContext;
      var declaredClasses = {}, currentClassId, classIdSeed = 0;
      function addAtom(text, type) {
        var lastIndex = atoms.length;
        atoms.push(text);
        return '"' + type + lastIndex + '"';
      }
      function generateClassId() {
        return "class" + ++classIdSeed;
      }
      function appendClass(class_, classId, scopeId) {
        class_.classId = classId;
        class_.scopeId = scopeId;
        declaredClasses[classId] = class_;
      }
      var transformClassBody, transformInterfaceBody, transformStatementsBlock, transformStatements, transformMain, transformExpression;
      var classesRegex = /\b((?:(?:public|private|final|protected|static|abstract)\s+)*)(class|interface)\s+([A-Za-z_$][\w$]*\b)(\s+extends\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*,\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*\b)*)?(\s+implements\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*,\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*\b)*)?\s*("A\d+")/g;
      var methodsRegex = /\b((?:(?:public|private|final|protected|static|abstract|synchronized)\s+)*)((?!(?:else|new|return|throw|function|public|private|protected)\b)[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*"C\d+")*)\s*([A-Za-z_$][\w$]*\b)\s*("B\d+")(\s*throws\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*,\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)*)?\s*("A\d+"|;)/g;
      var fieldTest = /^((?:(?:public|private|final|protected|static)\s+)*)((?!(?:else|new|return|throw)\b)[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*"C\d+")*)\s*([A-Za-z_$][\w$]*\b)\s*(?:"C\d+"\s*)*([=,]|$)/;
      var cstrsRegex = /\b((?:(?:public|private|final|protected|static|abstract)\s+)*)((?!(?:new|return|throw)\b)[A-Za-z_$][\w$]*\b)\s*("B\d+")(\s*throws\s+[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*,\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)*)?\s*("A\d+")/g;
      var attrAndTypeRegex = /^((?:(?:public|private|final|protected|static)\s+)*)((?!(?:new|return|throw)\b)[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*(?:\s*"C\d+")*)\s*/;
      var functionsRegex = /\bfunction(?:\s+([A-Za-z_$][\w$]*))?\s*("B\d+")\s*("A\d+")/g;
      function extractClassesAndMethods(code2) {
        var s = code2;
        s = s.replace(classesRegex, function(all) {
          return addAtom(all, "E");
        });
        s = s.replace(methodsRegex, function(all) {
          return addAtom(all, "D");
        });
        s = s.replace(functionsRegex, function(all) {
          return addAtom(all, "H");
        });
        return s;
      }
      function extractConstructors(code2, className) {
        var result = code2.replace(cstrsRegex, function(all, attr, name, params, throws_, body) {
          if (name !== className) {
            return all;
          }
          return addAtom(all, "G");
        });
        return result;
      }
      function AstParam(name) {
        this.name = name;
      }
      AstParam.prototype.toString = function() {
        return this.name;
      };
      function AstParams(params, methodArgsParam) {
        this.params = params;
        this.methodArgsParam = methodArgsParam;
      }
      AstParams.prototype.getNames = function() {
        var names = [];
        for (var i = 0, l2 = this.params.length; i < l2; ++i) {
          names.push(this.params[i].name);
        }
        return names;
      };
      AstParams.prototype.prependMethodArgs = function(body) {
        if (!this.methodArgsParam) {
          return body;
        }
        return "{\nvar " + this.methodArgsParam.name + " = Array.prototype.slice.call(arguments, " + this.params.length + ");\n" + body.substring(1);
      };
      AstParams.prototype.toString = function() {
        if (this.params.length === 0) {
          return "()";
        }
        var result = "(";
        for (var i = 0, l2 = this.params.length; i < l2; ++i) {
          result += this.params[i] + ", ";
        }
        return result.substring(0, result.length - 2) + ")";
      };
      function transformParams(params) {
        var paramsWoPars = trim(params.substring(1, params.length - 1));
        var result = [], methodArgsParam = null;
        if (paramsWoPars !== "") {
          var paramList = paramsWoPars.split(",");
          for (var i = 0; i < paramList.length; ++i) {
            var param = /\b([A-Za-z_$][\w$]*\b)(\s*"[ABC][\d]*")*\s*$/.exec(paramList[i]);
            if (i === paramList.length - 1 && paramList[i].indexOf("...") >= 0) {
              methodArgsParam = new AstParam(param[1]);
              break;
            }
            result.push(new AstParam(param[1]));
          }
        }
        return new AstParams(result, methodArgsParam);
      }
      function preExpressionTransform(expr) {
        var s = expr;
        s = s.replace(/\bnew\s+([A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)(?:\s*"C\d+")+\s*("A\d+")/g, function(all, type, init) {
          return init;
        });
        s = s.replace(/\bnew\s+([A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)(?:\s*"B\d+")\s*("A\d+")/g, function(all, type, init) {
          return addAtom(all, "F");
        });
        s = s.replace(functionsRegex, function(all) {
          return addAtom(all, "H");
        });
        s = s.replace(/\bnew\s+([A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)\s*("C\d+"(?:\s*"C\d+")*)/g, function(all, type, index) {
          var args = index.replace(/"C(\d+)"/g, function(all2, j) {
            return atoms[j];
          }).replace(/\[\s*\]/g, "[null]").replace(/\s*\]\s*\[\s*/g, ", ");
          var arrayInitializer = "{" + args.substring(1, args.length - 1) + "}";
          var createArrayArgs = "('" + type + "', " + addAtom(arrayInitializer, "A") + ")";
          return "$p.createJavaArray" + addAtom(createArrayArgs, "B");
        });
        s = s.replace(/(\.\s*length)\s*"B\d+"/g, "$1");
        s = s.replace(/#([0-9A-Fa-f]{6})\b/g, function(all, digits) {
          return "0xFF" + digits;
        });
        s = s.replace(/"B(\d+)"(\s*(?:[\w$']|"B))/g, function(all, index, next) {
          var atom = atoms[index];
          if (!/^\(\s*[A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*\s*(?:"C\d+"\s*)*\)$/.test(atom)) {
            return all;
          }
          if (/^\(\s*int\s*\)$/.test(atom)) {
            return "(int)" + next;
          }
          var indexParts = atom.split(/"C(\d+)"/g);
          if (indexParts.length > 1) {
            if (!/^\[\s*\]$/.test(atoms[indexParts[1]])) {
              return all;
            }
          }
          return "" + next;
        });
        s = s.replace(/\(int\)([^,\]\)\}\?\:\*\+\-\/\^\|\%\&\~<\>\=]+)/g, function(all, arg) {
          var trimmed = trimSpaces(arg);
          return trimmed.untrim("__int_cast(" + trimmed.middle + ")");
        });
        s = s.replace(/\bsuper(\s*"B\d+")/g, "$$superCstr$1").replace(/\bsuper(\s*\.)/g, "$$super$1");
        s = s.replace(/\b0+((\d*)(?:\.[\d*])?(?:[eE][\-\+]?\d+)?[fF]?)\b/, function(all, numberWo0, intPart) {
          if (numberWo0 === intPart) {
            return all;
          }
          return intPart === "" ? "0" + numberWo0 : numberWo0;
        });
        s = s.replace(/\b(\.?\d+\.?)[fF]\b/g, "$1");
        s = s.replace(/([^\s])%([^=\s])/g, "$1 % $2");
        s = s.replace(/\b(frameRate|keyPressed|mousePressed)\b(?!\s*"B)/g, "__$1");
        s = s.replace(/\b(boolean|byte|char|float|int)\s*"B/g, function(all, name) {
          return "parse" + name.substring(0, 1).toUpperCase() + name.substring(1) + '"B';
        });
        s = s.replace(
          /\bpixels\b\s*(("C(\d+)")|\.length)?(\s*=(?!=)([^,\]\)\}]+))?/g,
          function(all, indexOrLength, index, atomIndex, equalsPart, rightSide) {
            if (index) {
              var atom = atoms[atomIndex];
              if (equalsPart) {
                return "pixels.setPixel" + addAtom("(" + atom.substring(1, atom.length - 1) + "," + rightSide + ")", "B");
              }
              return "pixels.getPixel" + addAtom("(" + atom.substring(1, atom.length - 1) + ")", "B");
            }
            if (indexOrLength) {
              return "pixels.getLength" + addAtom("()", "B");
            }
            if (equalsPart) {
              return "pixels.set" + addAtom("(" + rightSide + ")", "B");
            }
            return "pixels.toArray" + addAtom("()", "B");
          }
        );
        var repeatJavaReplacement;
        function replacePrototypeMethods(all, subject, method, atomIndex) {
          var atom = atoms[atomIndex];
          repeatJavaReplacement = true;
          var trimmed = trimSpaces(atom.substring(1, atom.length - 1));
          return "__" + method + (trimmed.middle === "" ? addAtom("(" + subject.replace(/\.\s*$/, "") + ")", "B") : addAtom("(" + subject.replace(/\.\s*$/, "") + "," + trimmed.middle + ")", "B"));
        }
        do {
          repeatJavaReplacement = false;
          s = s.replace(
            /((?:'\d+'|\b[A-Za-z_$][\w$]*\s*(?:"[BC]\d+")*)\s*\.\s*(?:[A-Za-z_$][\w$]*\s*(?:"[BC]\d+"\s*)*\.\s*)*)(replace|replaceAll|replaceFirst|contains|equals|equalsIgnoreCase|hashCode|toCharArray|printStackTrace|split|startsWith|endsWith|codePointAt|matches)\s*"B(\d+)"/g,
            replacePrototypeMethods
          );
        } while (repeatJavaReplacement);
        function replaceInstanceof(all, subject, type) {
          repeatJavaReplacement = true;
          return "__instanceof" + addAtom("(" + subject + ", " + type + ")", "B");
        }
        do {
          repeatJavaReplacement = false;
          s = s.replace(
            /((?:'\d+'|\b[A-Za-z_$][\w$]*\s*(?:"[BC]\d+")*)\s*(?:\.\s*[A-Za-z_$][\w$]*\s*(?:"[BC]\d+"\s*)*)*)instanceof\s+([A-Za-z_$][\w$]*\s*(?:\.\s*[A-Za-z_$][\w$]*)*)/g,
            replaceInstanceof
          );
        } while (repeatJavaReplacement);
        s = s.replace(/\bthis(\s*"B\d+")/g, "$$constr$1");
        return s;
      }
      function AstInlineClass(baseInterfaceName, body) {
        this.baseInterfaceName = baseInterfaceName;
        this.body = body;
        body.owner = this;
      }
      AstInlineClass.prototype.toString = function() {
        return "new (" + this.body + ")";
      };
      function transformInlineClass(class_) {
        var m = new RegExp(/\bnew\s*([A-Za-z_$][\w$]*\s*(?:\.\s*[A-Za-z_$][\w$]*)*)\s*"B\d+"\s*"A(\d+)"/).exec(class_);
        var oldClassId = currentClassId, newClassId = generateClassId();
        currentClassId = newClassId;
        var uniqueClassName = m[1] + "$" + newClassId;
        var inlineClass = new AstInlineClass(
          uniqueClassName,
          transformClassBody(atoms[m[2]], uniqueClassName, "", "implements " + m[1])
        );
        appendClass(inlineClass, newClassId, oldClassId);
        currentClassId = oldClassId;
        return inlineClass;
      }
      function AstFunction(name, params, body) {
        this.name = name;
        this.params = params;
        this.body = body;
      }
      AstFunction.prototype.toString = function() {
        var oldContext = replaceContext;
        var names = appendToLookupTable({ "this": null }, this.params.getNames());
        replaceContext = function(subject) {
          return names.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
        };
        var result = "function";
        if (this.name) {
          result += " " + this.name;
        }
        var body = this.params.prependMethodArgs(this.body.toString());
        result += this.params + " " + body;
        replaceContext = oldContext;
        return result;
      };
      function transformFunction(class_) {
        var m = new RegExp(/\b([A-Za-z_$][\w$]*)\s*"B(\d+)"\s*"A(\d+)"/).exec(class_);
        return new AstFunction(
          m[1] !== "function" ? m[1] : null,
          transformParams(atoms[m[2]]),
          transformStatementsBlock(atoms[m[3]])
        );
      }
      function AstInlineObject(members) {
        this.members = members;
      }
      AstInlineObject.prototype.toString = function() {
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          return subject.name === "this" ? "this" : oldContext(subject);
        };
        var result = "";
        for (var i = 0, l2 = this.members.length; i < l2; ++i) {
          if (this.members[i].label) {
            result += this.members[i].label + ": ";
          }
          result += this.members[i].value.toString() + ", ";
        }
        replaceContext = oldContext;
        return result.substring(0, result.length - 2);
      };
      function transformInlineObject(obj) {
        var members = obj.split(",");
        for (var i = 0; i < members.length; ++i) {
          var label = members[i].indexOf(":");
          if (label < 0) {
            members[i] = { value: transformExpression(members[i]) };
          } else {
            members[i] = {
              label: trim(members[i].substring(0, label)),
              value: transformExpression(trim(members[i].substring(label + 1)))
            };
          }
        }
        return new AstInlineObject(members);
      }
      function expandExpression(expr) {
        if (expr.charAt(0) === "(" || expr.charAt(0) === "[") {
          return expr.charAt(0) + expandExpression(expr.substring(1, expr.length - 1)) + expr.charAt(expr.length - 1);
        }
        if (expr.charAt(0) === "{") {
          if (/^\{\s*(?:[A-Za-z_$][\w$]*|'\d+')\s*:/.test(expr)) {
            return "{" + addAtom(expr.substring(1, expr.length - 1), "I") + "}";
          }
          return "[" + expandExpression(expr.substring(1, expr.length - 1)) + "]";
        }
        var trimmed = trimSpaces(expr);
        var result = preExpressionTransform(trimmed.middle);
        result = result.replace(/"[ABC](\d+)"/g, function(all, index) {
          return expandExpression(atoms[index]);
        });
        return trimmed.untrim(result);
      }
      function replaceContextInVars(expr) {
        return expr.replace(
          /(\.\s*)?((?:\b[A-Za-z_]|\$)[\w$]*)(\s*\.\s*([A-Za-z_$][\w$]*)(\s*\()?)?/g,
          function(all, memberAccessSign, identifier, suffix, subMember, callSign) {
            if (memberAccessSign) {
              return all;
            }
            var subject = { name: identifier, member: subMember, callSign: !!callSign };
            return replaceContext(subject) + (suffix === undef ? "" : suffix);
          }
        );
      }
      function AstExpression(expr, transforms) {
        this.expr = expr;
        this.transforms = transforms;
      }
      AstExpression.prototype.toString = function() {
        var transforms = this.transforms;
        var expr = replaceContextInVars(this.expr);
        return expr.replace(/"!(\d+)"/g, function(all, index) {
          return transforms[index].toString();
        });
      };
      transformExpression = function(expr) {
        var transforms = [];
        var s = expandExpression(expr);
        s = s.replace(/"H(\d+)"/g, function(all, index) {
          transforms.push(transformFunction(atoms[index]));
          return '"!' + (transforms.length - 1) + '"';
        });
        s = s.replace(/"F(\d+)"/g, function(all, index) {
          transforms.push(transformInlineClass(atoms[index]));
          return '"!' + (transforms.length - 1) + '"';
        });
        s = s.replace(/"I(\d+)"/g, function(all, index) {
          transforms.push(transformInlineObject(atoms[index]));
          return '"!' + (transforms.length - 1) + '"';
        });
        return new AstExpression(s, transforms);
      };
      function AstVarDefinition(name, value, isDefault) {
        this.name = name;
        this.value = value;
        this.isDefault = isDefault;
      }
      AstVarDefinition.prototype.toString = function() {
        return this.name + " = " + this.value;
      };
      function transformVarDefinition(def, defaultTypeValue) {
        var eqIndex = def.indexOf("=");
        var name, value, isDefault;
        if (eqIndex < 0) {
          name = def;
          value = defaultTypeValue;
          isDefault = true;
        } else {
          name = def.substring(0, eqIndex);
          value = transformExpression(def.substring(eqIndex + 1));
          isDefault = false;
        }
        return new AstVarDefinition(
          trim(name.replace(/(\s*"C\d+")+/g, "")),
          value,
          isDefault
        );
      }
      function getDefaultValueForType(type) {
        if (type === "int" || type === "float") {
          return "0";
        }
        if (type === "boolean") {
          return "false";
        }
        if (type === "color") {
          return "0x00000000";
        }
        return "null";
      }
      function AstVar(definitions, varType) {
        this.definitions = definitions;
        this.varType = varType;
      }
      AstVar.prototype.getNames = function() {
        var names = [];
        for (var i = 0, l2 = this.definitions.length; i < l2; ++i) {
          names.push(this.definitions[i].name);
        }
        return names;
      };
      AstVar.prototype.toString = function() {
        return "var " + this.definitions.join(",");
      };
      function AstStatement(expression) {
        this.expression = expression;
      }
      AstStatement.prototype.toString = function() {
        return this.expression.toString();
      };
      function transformStatement(statement) {
        if (fieldTest.test(statement)) {
          var attrAndType = attrAndTypeRegex.exec(statement);
          var definitions = statement.substring(attrAndType[0].length).split(",");
          var defaultTypeValue = getDefaultValueForType(attrAndType[2]);
          for (var i = 0; i < definitions.length; ++i) {
            definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);
          }
          return new AstVar(definitions, attrAndType[2]);
        }
        return new AstStatement(transformExpression(statement));
      }
      function AstForExpression(initStatement, condition, step) {
        this.initStatement = initStatement;
        this.condition = condition;
        this.step = step;
      }
      AstForExpression.prototype.toString = function() {
        return "(" + this.initStatement + "; " + this.condition + "; " + this.step + ")";
      };
      function AstForInExpression(initStatement, container) {
        this.initStatement = initStatement;
        this.container = container;
      }
      AstForInExpression.prototype.toString = function() {
        var init = this.initStatement.toString();
        if (init.indexOf("=") >= 0) {
          init = init.substring(0, init.indexOf("="));
        }
        return "(" + init + " in " + this.container + ")";
      };
      function AstForEachExpression(initStatement, container) {
        this.initStatement = initStatement;
        this.container = container;
      }
      AstForEachExpression.iteratorId = 0;
      AstForEachExpression.prototype.toString = function() {
        var init = this.initStatement.toString();
        var iterator3 = "$it" + AstForEachExpression.iteratorId++;
        var variableName = init.replace(/^\s*var\s*/, "").split("=")[0];
        var initIteratorAndVariable = "var " + iterator3 + " = new $p.ObjectIterator(" + this.container + "), " + variableName + " = void(0)";
        var nextIterationCondition = iterator3 + ".hasNext() && ((" + variableName + " = " + iterator3 + ".next()) || true)";
        return "(" + initIteratorAndVariable + "; " + nextIterationCondition + ";)";
      };
      function transformForExpression(expr) {
        var content;
        if (/\bin\b/.test(expr)) {
          content = expr.substring(1, expr.length - 1).split(/\bin\b/g);
          return new AstForInExpression(
            transformStatement(trim(content[0])),
            transformExpression(content[1])
          );
        }
        if (expr.indexOf(":") >= 0 && expr.indexOf(";") < 0) {
          content = expr.substring(1, expr.length - 1).split(":");
          return new AstForEachExpression(
            transformStatement(trim(content[0])),
            transformExpression(content[1])
          );
        }
        content = expr.substring(1, expr.length - 1).split(";");
        return new AstForExpression(
          transformStatement(trim(content[0])),
          transformExpression(content[1]),
          transformExpression(content[2])
        );
      }
      function sortByWeight(array) {
        array.sort(function(a, b) {
          return b.weight - a.weight;
        });
      }
      function AstInnerInterface(name, body, isStatic) {
        this.name = name;
        this.body = body;
        this.isStatic = isStatic;
        body.owner = this;
      }
      AstInnerInterface.prototype.toString = function() {
        return "" + this.body;
      };
      function AstInnerClass(name, body, isStatic) {
        this.name = name;
        this.body = body;
        this.isStatic = isStatic;
        body.owner = this;
      }
      AstInnerClass.prototype.toString = function() {
        return "" + this.body;
      };
      function transformInnerClass(class_) {
        var m = classesRegex.exec(class_);
        classesRegex.lastIndex = 0;
        var isStatic = m[1].indexOf("static") >= 0;
        var body = atoms[getAtomIndex(m[6])], innerClass;
        var oldClassId = currentClassId, newClassId = generateClassId();
        currentClassId = newClassId;
        if (m[2] === "interface") {
          innerClass = new AstInnerInterface(m[3], transformInterfaceBody(body, m[3], m[4]), isStatic);
        } else {
          innerClass = new AstInnerClass(m[3], transformClassBody(body, m[3], m[4], m[5]), isStatic);
        }
        appendClass(innerClass, newClassId, oldClassId);
        currentClassId = oldClassId;
        return innerClass;
      }
      function AstClassMethod(name, params, body, isStatic) {
        this.name = name;
        this.params = params;
        this.body = body;
        this.isStatic = isStatic;
      }
      AstClassMethod.prototype.toString = function() {
        var paramNames = appendToLookupTable({}, this.params.getNames());
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
        };
        var body = this.params.prependMethodArgs(this.body.toString());
        var result = "function " + this.methodId + this.params + " " + body + "\n";
        replaceContext = oldContext;
        return result;
      };
      function transformClassMethod(method) {
        var m = methodsRegex.exec(method);
        methodsRegex.lastIndex = 0;
        var isStatic = m[1].indexOf("static") >= 0;
        var body = m[6] !== ";" ? atoms[getAtomIndex(m[6])] : "{}";
        return new AstClassMethod(
          m[3],
          transformParams(atoms[getAtomIndex(m[4])]),
          transformStatementsBlock(body),
          isStatic
        );
      }
      function AstClassField(definitions, fieldType, isStatic) {
        this.definitions = definitions;
        this.fieldType = fieldType;
        this.isStatic = isStatic;
      }
      AstClassField.prototype.getNames = function() {
        var names = [];
        for (var i = 0, l2 = this.definitions.length; i < l2; ++i) {
          names.push(this.definitions[i].name);
        }
        return names;
      };
      AstClassField.prototype.toString = function() {
        var thisPrefix = replaceContext({ name: "[this]" });
        if (this.isStatic) {
          var className = this.owner.name;
          var staticDeclarations = [];
          for (var i = 0, l2 = this.definitions.length; i < l2; ++i) {
            var definition = this.definitions[i];
            var name = definition.name, staticName = className + "." + name;
            var declaration = "if(" + staticName + " === void(0)) {\n " + staticName + " = " + definition.value + "; }\n$p.defineProperty(" + thisPrefix + ", '" + name + "', { get: function(){return " + staticName + ";}, set: function(val){" + staticName + " = val;} });\n";
            staticDeclarations.push(declaration);
          }
          return staticDeclarations.join("");
        }
        return thisPrefix + "." + this.definitions.join("; " + thisPrefix + ".");
      };
      function transformClassField(statement) {
        var attrAndType = attrAndTypeRegex.exec(statement);
        var isStatic = attrAndType[1].indexOf("static") >= 0;
        var definitions = statement.substring(attrAndType[0].length).split(/,\s*/g);
        var defaultTypeValue = getDefaultValueForType(attrAndType[2]);
        for (var i = 0; i < definitions.length; ++i) {
          definitions[i] = transformVarDefinition(definitions[i], defaultTypeValue);
        }
        return new AstClassField(definitions, attrAndType[2], isStatic);
      }
      function AstConstructor(params, body) {
        this.params = params;
        this.body = body;
      }
      AstConstructor.prototype.toString = function() {
        var paramNames = appendToLookupTable({}, this.params.getNames());
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
        };
        var prefix = "function $constr_" + this.params.params.length + this.params.toString();
        var body = this.params.prependMethodArgs(this.body.toString());
        if (!/\$(superCstr|constr)\b/.test(body)) {
          body = "{\n$superCstr();\n" + body.substring(1);
        }
        replaceContext = oldContext;
        return prefix + body + "\n";
      };
      function transformConstructor(cstr) {
        var m = new RegExp(/"B(\d+)"\s*"A(\d+)"/).exec(cstr);
        var params = transformParams(atoms[m[1]]);
        return new AstConstructor(params, transformStatementsBlock(atoms[m[2]]));
      }
      function AstInterfaceBody(name, interfacesNames, methodsNames, fields, innerClasses, misc) {
        var i, l2;
        this.name = name;
        this.interfacesNames = interfacesNames;
        this.methodsNames = methodsNames;
        this.fields = fields;
        this.innerClasses = innerClasses;
        this.misc = misc;
        for (i = 0, l2 = fields.length; i < l2; ++i) {
          fields[i].owner = this;
        }
      }
      AstInterfaceBody.prototype.getMembers = function(classFields, classMethods, classInners) {
        if (this.owner.base) {
          this.owner.base.body.getMembers(classFields, classMethods, classInners);
        }
        var i, j, l2, m;
        for (i = 0, l2 = this.fields.length; i < l2; ++i) {
          var fieldNames = this.fields[i].getNames();
          for (j = 0, m = fieldNames.length; j < m; ++j) {
            classFields[fieldNames[j]] = this.fields[i];
          }
        }
        for (i = 0, l2 = this.methodsNames.length; i < l2; ++i) {
          var methodName = this.methodsNames[i];
          classMethods[methodName] = true;
        }
        for (i = 0, l2 = this.innerClasses.length; i < l2; ++i) {
          var innerClass = this.innerClasses[i];
          classInners[innerClass.name] = innerClass;
        }
      };
      AstInterfaceBody.prototype.toString = function() {
        function getScopeLevel(p) {
          var i2 = 0;
          while (p) {
            ++i2;
            p = p.scope;
          }
          return i2;
        }
        var scopeLevel = getScopeLevel(this.owner);
        var className = this.name;
        var staticDefinitions = "";
        var metadata = "";
        var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};
        this.getMembers(thisClassFields, thisClassMethods, thisClassInners);
        var i, l2, j, m;
        if (this.owner.interfaces) {
          var resolvedInterfaces = [], resolvedInterface;
          for (i = 0, l2 = this.interfacesNames.length; i < l2; ++i) {
            if (!this.owner.interfaces[i]) {
              continue;
            }
            resolvedInterface = replaceContext({ name: this.interfacesNames[i] });
            resolvedInterfaces.push(resolvedInterface);
            staticDefinitions += "$p.extendInterfaceMembers(" + className + ", " + resolvedInterface + ");\n";
          }
          metadata += className + ".$interfaces = [" + resolvedInterfaces.join(", ") + "];\n";
        }
        metadata += className + ".$isInterface = true;\n";
        metadata += className + ".$methods = ['" + this.methodsNames.join("', '") + "'];\n";
        sortByWeight(this.innerClasses);
        for (i = 0, l2 = this.innerClasses.length; i < l2; ++i) {
          var innerClass = this.innerClasses[i];
          if (innerClass.isStatic) {
            staticDefinitions += className + "." + innerClass.name + " = " + innerClass + ";\n";
          }
        }
        for (i = 0, l2 = this.fields.length; i < l2; ++i) {
          var field = this.fields[i];
          if (field.isStatic) {
            staticDefinitions += className + "." + field.definitions.join(";\n" + className + ".") + ";\n";
          }
        }
        return "(function() {\nfunction " + className + "() { throw 'Unable to create the interface'; }\n" + staticDefinitions + metadata + "return " + className + ";\n})()";
      };
      transformInterfaceBody = function(body, name, baseInterfaces) {
        var declarations = body.substring(1, body.length - 1);
        declarations = extractClassesAndMethods(declarations);
        declarations = extractConstructors(declarations, name);
        var methodsNames = [], classes = [];
        declarations = declarations.replace(/"([DE])(\d+)"/g, function(all, type, index) {
          if (type === "D") {
            methodsNames.push(index);
          } else if (type === "E") {
            classes.push(index);
          }
          return "";
        });
        var fields = declarations.split(/;(?:\s*;)*/g);
        var baseInterfaceNames;
        var i, l2;
        if (baseInterfaces !== undef) {
          baseInterfaceNames = baseInterfaces.replace(/^\s*extends\s+(.+?)\s*$/g, "$1").split(/\s*,\s*/g);
        }
        for (i = 0, l2 = methodsNames.length; i < l2; ++i) {
          var method = transformClassMethod(atoms[methodsNames[i]]);
          methodsNames[i] = method.name;
        }
        for (i = 0, l2 = fields.length - 1; i < l2; ++i) {
          var field = trimSpaces(fields[i]);
          fields[i] = transformClassField(field.middle);
        }
        var tail = fields.pop();
        for (i = 0, l2 = classes.length; i < l2; ++i) {
          classes[i] = transformInnerClass(atoms[classes[i]]);
        }
        return new AstInterfaceBody(name, baseInterfaceNames, methodsNames, fields, classes, { tail });
      };
      function AstClassBody(name, baseClassName, interfacesNames, functions, methods, fields, cstrs, innerClasses, misc) {
        var i, l2;
        this.name = name;
        this.baseClassName = baseClassName;
        this.interfacesNames = interfacesNames;
        this.functions = functions;
        this.methods = methods;
        this.fields = fields;
        this.cstrs = cstrs;
        this.innerClasses = innerClasses;
        this.misc = misc;
        for (i = 0, l2 = fields.length; i < l2; ++i) {
          fields[i].owner = this;
        }
      }
      AstClassBody.prototype.getMembers = function(classFields, classMethods, classInners) {
        if (this.owner.base) {
          this.owner.base.body.getMembers(classFields, classMethods, classInners);
        }
        var i, j, l2, m;
        for (i = 0, l2 = this.fields.length; i < l2; ++i) {
          var fieldNames = this.fields[i].getNames();
          for (j = 0, m = fieldNames.length; j < m; ++j) {
            classFields[fieldNames[j]] = this.fields[i];
          }
        }
        for (i = 0, l2 = this.methods.length; i < l2; ++i) {
          var method = this.methods[i];
          classMethods[method.name] = method;
        }
        for (i = 0, l2 = this.innerClasses.length; i < l2; ++i) {
          var innerClass = this.innerClasses[i];
          classInners[innerClass.name] = innerClass;
        }
      };
      AstClassBody.prototype.toString = function() {
        function getScopeLevel(p) {
          var i2 = 0;
          while (p) {
            ++i2;
            p = p.scope;
          }
          return i2;
        }
        var scopeLevel = getScopeLevel(this.owner);
        var selfId = "$this_" + scopeLevel;
        var className = this.name;
        var result = "var " + selfId + " = this;\n";
        var staticDefinitions = "";
        var metadata = "";
        var thisClassFields = {}, thisClassMethods = {}, thisClassInners = {};
        this.getMembers(thisClassFields, thisClassMethods, thisClassInners);
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          var name = subject.name;
          if (name === "this") {
            return subject.callSign || !subject.member ? selfId + ".$self" : selfId;
          }
          if (thisClassFields.hasOwnProperty(name)) {
            return thisClassFields[name].isStatic ? className + "." + name : selfId + "." + name;
          }
          if (thisClassInners.hasOwnProperty(name)) {
            return selfId + "." + name;
          }
          if (thisClassMethods.hasOwnProperty(name)) {
            return thisClassMethods[name].isStatic ? className + "." + name : selfId + ".$self." + name;
          }
          return oldContext(subject);
        };
        var resolvedBaseClassName;
        if (this.baseClassName) {
          resolvedBaseClassName = oldContext({ name: this.baseClassName });
          result += "var $super = { $upcast: " + selfId + " };\n";
          result += "function $superCstr(){" + resolvedBaseClassName + ".apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}\n";
          metadata += className + ".$base = " + resolvedBaseClassName + ";\n";
        } else {
          result += "function $superCstr(){$p.extendClassChain(" + selfId + ")}\n";
        }
        if (this.owner.base) {
          staticDefinitions += "$p.extendStaticMembers(" + className + ", " + resolvedBaseClassName + ");\n";
        }
        var i, l2, j, m;
        if (this.owner.interfaces) {
          var resolvedInterfaces = [], resolvedInterface;
          for (i = 0, l2 = this.interfacesNames.length; i < l2; ++i) {
            if (!this.owner.interfaces[i]) {
              continue;
            }
            resolvedInterface = oldContext({ name: this.interfacesNames[i] });
            resolvedInterfaces.push(resolvedInterface);
            staticDefinitions += "$p.extendInterfaceMembers(" + className + ", " + resolvedInterface + ");\n";
          }
          metadata += className + ".$interfaces = [" + resolvedInterfaces.join(", ") + "];\n";
        }
        if (this.functions.length > 0) {
          result += this.functions.join("\n") + "\n";
        }
        sortByWeight(this.innerClasses);
        for (i = 0, l2 = this.innerClasses.length; i < l2; ++i) {
          var innerClass = this.innerClasses[i];
          if (innerClass.isStatic) {
            staticDefinitions += className + "." + innerClass.name + " = " + innerClass + ";\n";
            result += selfId + "." + innerClass.name + " = " + className + "." + innerClass.name + ";\n";
          } else {
            result += selfId + "." + innerClass.name + " = " + innerClass + ";\n";
          }
        }
        for (i = 0, l2 = this.fields.length; i < l2; ++i) {
          var field = this.fields[i];
          if (field.isStatic) {
            staticDefinitions += className + "." + field.definitions.join(";\n" + className + ".") + ";\n";
            for (j = 0, m = field.definitions.length; j < m; ++j) {
              var fieldName = field.definitions[j].name, staticName = className + "." + fieldName;
              result += "$p.defineProperty(" + selfId + ", '" + fieldName + "', {get: function(){return " + staticName + "}, set: function(val){" + staticName + " = val}});\n";
            }
          } else {
            result += selfId + "." + field.definitions.join(";\n" + selfId + ".") + ";\n";
          }
        }
        var methodOverloads = {};
        for (i = 0, l2 = this.methods.length; i < l2; ++i) {
          var method = this.methods[i];
          var overload = methodOverloads[method.name];
          var methodId = method.name + "$" + method.params.params.length;
          var hasMethodArgs = !!method.params.methodArgsParam;
          if (overload) {
            ++overload;
            methodId += "_" + overload;
          } else {
            overload = 1;
          }
          method.methodId = methodId;
          methodOverloads[method.name] = overload;
          if (method.isStatic) {
            staticDefinitions += method;
            staticDefinitions += "$p.addMethod(" + className + ", '" + method.name + "', " + methodId + ", " + hasMethodArgs + ");\n";
            result += "$p.addMethod(" + selfId + ", '" + method.name + "', " + methodId + ", " + hasMethodArgs + ");\n";
          } else {
            result += method;
            result += "$p.addMethod(" + selfId + ", '" + method.name + "', " + methodId + ", " + hasMethodArgs + ");\n";
          }
        }
        result += trim(this.misc.tail);
        if (this.cstrs.length > 0) {
          result += this.cstrs.join("\n") + "\n";
        }
        result += "function $constr() {\n";
        var cstrsIfs = [];
        for (i = 0, l2 = this.cstrs.length; i < l2; ++i) {
          var paramsLength = this.cstrs[i].params.params.length;
          var methodArgsPresent = !!this.cstrs[i].params.methodArgsParam;
          cstrsIfs.push("if(arguments.length " + (methodArgsPresent ? ">=" : "===") + " " + paramsLength + ") { $constr_" + paramsLength + ".apply(" + selfId + ", arguments); }");
        }
        if (cstrsIfs.length > 0) {
          result += cstrsIfs.join(" else ") + " else ";
        }
        result += "$superCstr();\n}\n";
        result += "$constr.apply(null, arguments);\n";
        replaceContext = oldContext;
        return "(function() {\nfunction " + className + "() {\n" + result + "}\n" + staticDefinitions + metadata + "return " + className + ";\n})()";
      };
      transformClassBody = function(body, name, baseName, interfaces) {
        var declarations = body.substring(1, body.length - 1);
        declarations = extractClassesAndMethods(declarations);
        declarations = extractConstructors(declarations, name);
        var methods = [], classes = [], cstrs = [], functions = [];
        declarations = declarations.replace(/"([DEGH])(\d+)"/g, function(all, type, index) {
          if (type === "D") {
            methods.push(index);
          } else if (type === "E") {
            classes.push(index);
          } else if (type === "H") {
            functions.push(index);
          } else {
            cstrs.push(index);
          }
          return "";
        });
        var fields = declarations.replace(/^(?:\s*;)+/, "").split(/;(?:\s*;)*/g);
        var baseClassName, interfacesNames;
        var i;
        if (baseName !== undef) {
          baseClassName = baseName.replace(/^\s*extends\s+([A-Za-z_$][\w$]*\b(?:\s*\.\s*[A-Za-z_$][\w$]*\b)*)\s*$/g, "$1");
        }
        if (interfaces !== undef) {
          interfacesNames = interfaces.replace(/^\s*implements\s+(.+?)\s*$/g, "$1").split(/\s*,\s*/g);
        }
        for (i = 0; i < functions.length; ++i) {
          functions[i] = transformFunction(atoms[functions[i]]);
        }
        for (i = 0; i < methods.length; ++i) {
          methods[i] = transformClassMethod(atoms[methods[i]]);
        }
        for (i = 0; i < fields.length - 1; ++i) {
          var field = trimSpaces(fields[i]);
          fields[i] = transformClassField(field.middle);
        }
        var tail = fields.pop();
        for (i = 0; i < cstrs.length; ++i) {
          cstrs[i] = transformConstructor(atoms[cstrs[i]]);
        }
        for (i = 0; i < classes.length; ++i) {
          classes[i] = transformInnerClass(atoms[classes[i]]);
        }
        return new AstClassBody(
          name,
          baseClassName,
          interfacesNames,
          functions,
          methods,
          fields,
          cstrs,
          classes,
          { tail }
        );
      };
      function AstInterface(name, body) {
        this.name = name;
        this.body = body;
        body.owner = this;
      }
      AstInterface.prototype.toString = function() {
        return "var " + this.name + " = " + this.body + ";\n$p." + this.name + " = " + this.name + ";\n";
      };
      function AstClass(name, body) {
        this.name = name;
        this.body = body;
        body.owner = this;
      }
      AstClass.prototype.toString = function() {
        return "var " + this.name + " = " + this.body + ";\n$p." + this.name + " = " + this.name + ";\n";
      };
      function transformGlobalClass(class_) {
        var m = classesRegex.exec(class_);
        classesRegex.lastIndex = 0;
        var body = atoms[getAtomIndex(m[6])];
        var oldClassId = currentClassId, newClassId = generateClassId();
        currentClassId = newClassId;
        var globalClass;
        if (m[2] === "interface") {
          globalClass = new AstInterface(m[3], transformInterfaceBody(body, m[3], m[4]));
        } else {
          globalClass = new AstClass(m[3], transformClassBody(body, m[3], m[4], m[5]));
        }
        appendClass(globalClass, newClassId, oldClassId);
        currentClassId = oldClassId;
        return globalClass;
      }
      function AstMethod(name, params, body) {
        this.name = name;
        this.params = params;
        this.body = body;
      }
      AstMethod.prototype.toString = function() {
        var paramNames = appendToLookupTable({}, this.params.getNames());
        var oldContext = replaceContext;
        replaceContext = function(subject) {
          return paramNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
        };
        var body = this.params.prependMethodArgs(this.body.toString());
        var result = "function " + this.name + this.params + " " + body + "\n$p." + this.name + " = " + this.name + ";\n" + this.name + " = " + this.name + ".bind($p);";
        replaceContext = oldContext;
        return result;
      };
      function transformGlobalMethod(method) {
        var m = methodsRegex.exec(method);
        var result = methodsRegex.lastIndex = 0;
        return new AstMethod(
          m[3],
          transformParams(atoms[getAtomIndex(m[4])]),
          transformStatementsBlock(atoms[getAtomIndex(m[6])])
        );
      }
      function preStatementsTransform(statements) {
        var s = statements;
        s = s.replace(/\b(catch\s*"B\d+"\s*"A\d+")(\s*catch\s*"B\d+"\s*"A\d+")+/g, "$1");
        return s;
      }
      function AstForStatement(argument, misc) {
        this.argument = argument;
        this.misc = misc;
      }
      AstForStatement.prototype.toString = function() {
        return this.misc.prefix + this.argument.toString();
      };
      function AstCatchStatement(argument, misc) {
        this.argument = argument;
        this.misc = misc;
      }
      AstCatchStatement.prototype.toString = function() {
        return this.misc.prefix + this.argument.toString();
      };
      function AstPrefixStatement(name, argument, misc) {
        this.name = name;
        this.argument = argument;
        this.misc = misc;
      }
      AstPrefixStatement.prototype.toString = function() {
        var result = this.misc.prefix;
        if (this.argument !== undef) {
          result += this.argument.toString();
        }
        return result;
      };
      function AstSwitchCase(expr) {
        this.expr = expr;
      }
      AstSwitchCase.prototype.toString = function() {
        return "case " + this.expr + ":";
      };
      function AstLabel(label) {
        this.label = label;
      }
      AstLabel.prototype.toString = function() {
        return this.label;
      };
      transformStatements = function(statements, transformMethod, transformClass) {
        var nextStatement = new RegExp(/\b(catch|for|if|switch|while|with)\s*"B(\d+)"|\b(do|else|finally|return|throw|try|break|continue)\b|("[ADEH](\d+)")|\b(case)\s+([^:]+):|\b([A-Za-z_$][\w$]*\s*:)|(;)/g);
        var res = [];
        statements = preStatementsTransform(statements);
        var lastIndex = 0, m, space;
        while ((m = nextStatement.exec(statements)) !== null) {
          if (m[1] !== undef) {
            var i = statements.lastIndexOf('"B', nextStatement.lastIndex);
            var statementsPrefix = statements.substring(lastIndex, i);
            if (m[1] === "for") {
              res.push(new AstForStatement(
                transformForExpression(atoms[m[2]]),
                { prefix: statementsPrefix }
              ));
            } else if (m[1] === "catch") {
              res.push(new AstCatchStatement(
                transformParams(atoms[m[2]]),
                { prefix: statementsPrefix }
              ));
            } else {
              res.push(new AstPrefixStatement(
                m[1],
                transformExpression(atoms[m[2]]),
                { prefix: statementsPrefix }
              ));
            }
          } else if (m[3] !== undef) {
            res.push(new AstPrefixStatement(
              m[3],
              undef,
              { prefix: statements.substring(lastIndex, nextStatement.lastIndex) }
            ));
          } else if (m[4] !== undef) {
            space = statements.substring(lastIndex, nextStatement.lastIndex - m[4].length);
            if (trim(space).length !== 0) {
              continue;
            }
            res.push(space);
            var kind = m[4].charAt(1), atomIndex = m[5];
            if (kind === "D") {
              res.push(transformMethod(atoms[atomIndex]));
            } else if (kind === "E") {
              res.push(transformClass(atoms[atomIndex]));
            } else if (kind === "H") {
              res.push(transformFunction(atoms[atomIndex]));
            } else {
              res.push(transformStatementsBlock(atoms[atomIndex]));
            }
          } else if (m[6] !== undef) {
            res.push(new AstSwitchCase(transformExpression(trim(m[7]))));
          } else if (m[8] !== undef) {
            space = statements.substring(lastIndex, nextStatement.lastIndex - m[8].length);
            if (trim(space).length !== 0) {
              continue;
            }
            res.push(new AstLabel(statements.substring(lastIndex, nextStatement.lastIndex)));
          } else {
            var statement = trimSpaces(statements.substring(lastIndex, nextStatement.lastIndex - 1));
            res.push(statement.left);
            res.push(transformStatement(statement.middle));
            res.push(statement.right + ";");
          }
          lastIndex = nextStatement.lastIndex;
        }
        var statementsTail = trimSpaces(statements.substring(lastIndex));
        res.push(statementsTail.left);
        if (statementsTail.middle !== "") {
          res.push(transformStatement(statementsTail.middle));
          res.push(";" + statementsTail.right);
        }
        return res;
      };
      function getLocalNames(statements) {
        var localNames = [];
        for (var i = 0, l2 = statements.length; i < l2; ++i) {
          var statement = statements[i];
          if (statement instanceof AstVar) {
            localNames = localNames.concat(statement.getNames());
          } else if (statement instanceof AstForStatement && statement.argument.initStatement instanceof AstVar) {
            localNames = localNames.concat(statement.argument.initStatement.getNames());
          } else if (statement instanceof AstInnerInterface || statement instanceof AstInnerClass || statement instanceof AstInterface || statement instanceof AstClass || statement instanceof AstMethod || statement instanceof AstFunction) {
            localNames.push(statement.name);
          }
        }
        return appendToLookupTable({}, localNames);
      }
      function AstStatementsBlock(statements) {
        this.statements = statements;
      }
      AstStatementsBlock.prototype.toString = function() {
        var localNames = getLocalNames(this.statements);
        var oldContext = replaceContext;
        if (!isLookupTableEmpty(localNames)) {
          replaceContext = function(subject) {
            return localNames.hasOwnProperty(subject.name) ? subject.name : oldContext(subject);
          };
        }
        var result = "{\n" + this.statements.join("") + "\n}";
        replaceContext = oldContext;
        return result;
      };
      transformStatementsBlock = function(block) {
        var content = trimSpaces(block.substring(1, block.length - 1));
        return new AstStatementsBlock(transformStatements(content.middle));
      };
      function AstRoot(statements) {
        this.statements = statements;
      }
      AstRoot.prototype.toString = function() {
        var classes = [], otherStatements = [], statement;
        for (var i = 0, len = this.statements.length; i < len; ++i) {
          statement = this.statements[i];
          if (statement instanceof AstClass || statement instanceof AstInterface) {
            classes.push(statement);
          } else {
            otherStatements.push(statement);
          }
        }
        sortByWeight(classes);
        var localNames = getLocalNames(this.statements);
        replaceContext = function(subject) {
          var name = subject.name;
          if (localNames.hasOwnProperty(name)) {
            return name;
          }
          if (globalMembers.hasOwnProperty(name) || PConstants3.hasOwnProperty(name) || defaultScope2.hasOwnProperty(name)) {
            return "$p." + name;
          }
          return name;
        };
        var result = "// this code was autogenerated from PJS\n(function($p) {\n" + classes.join("") + "\n" + otherStatements.join("") + "\n})";
        replaceContext = null;
        return result;
      };
      transformMain = function() {
        var statements = extractClassesAndMethods(atoms[0]);
        statements = statements.replace(/\bimport\s+[^;]+;/g, "");
        return new AstRoot(transformStatements(
          statements,
          transformGlobalMethod,
          transformGlobalClass
        ));
      };
      function generateMetadata(ast) {
        var globalScope = {};
        var id, class_;
        for (id in declaredClasses) {
          if (declaredClasses.hasOwnProperty(id)) {
            class_ = declaredClasses[id];
            var scopeId = class_.scopeId, name = class_.name;
            if (scopeId) {
              var scope = declaredClasses[scopeId];
              class_.scope = scope;
              if (scope.inScope === undef) {
                scope.inScope = {};
              }
              scope.inScope[name] = class_;
            } else {
              globalScope[name] = class_;
            }
          }
        }
        function findInScopes(class_2, name2) {
          var parts = name2.split(".");
          var currentScope = class_2.scope, found;
          while (currentScope) {
            if (currentScope.hasOwnProperty(parts[0])) {
              found = currentScope[parts[0]];
              break;
            }
            currentScope = currentScope.scope;
          }
          if (found === undef) {
            found = globalScope[parts[0]];
          }
          for (var i2 = 1, l3 = parts.length; i2 < l3 && found; ++i2) {
            found = found.inScope[parts[i2]];
          }
          return found;
        }
        for (id in declaredClasses) {
          if (declaredClasses.hasOwnProperty(id)) {
            class_ = declaredClasses[id];
            var baseClassName = class_.body.baseClassName;
            if (baseClassName) {
              var parent = findInScopes(class_, baseClassName);
              if (parent) {
                class_.base = parent;
                if (!parent.derived) {
                  parent.derived = [];
                }
                parent.derived.push(class_);
              }
            }
            var interfacesNames = class_.body.interfacesNames, interfaces = [], i, l2;
            if (interfacesNames && interfacesNames.length > 0) {
              for (i = 0, l2 = interfacesNames.length; i < l2; ++i) {
                var interface_ = findInScopes(class_, interfacesNames[i]);
                interfaces.push(interface_);
                if (!interface_) {
                  continue;
                }
                if (!interface_.derived) {
                  interface_.derived = [];
                }
                interface_.derived.push(class_);
              }
              if (interfaces.length > 0) {
                class_.interfaces = interfaces;
              }
            }
          }
        }
      }
      function setWeight(ast) {
        var queue = [], tocheck = {};
        var id, scopeId, class_;
        for (id in declaredClasses) {
          if (declaredClasses.hasOwnProperty(id)) {
            class_ = declaredClasses[id];
            if (!class_.inScope && !class_.derived) {
              queue.push(id);
              class_.weight = 0;
            } else {
              var dependsOn = [];
              if (class_.inScope) {
                for (scopeId in class_.inScope) {
                  if (class_.inScope.hasOwnProperty(scopeId)) {
                    dependsOn.push(class_.inScope[scopeId]);
                  }
                }
              }
              if (class_.derived) {
                dependsOn = dependsOn.concat(class_.derived);
              }
              tocheck[id] = dependsOn;
            }
          }
        }
        function removeDependentAndCheck(targetId, from) {
          var dependsOn2 = tocheck[targetId];
          if (!dependsOn2) {
            return false;
          }
          var i2 = dependsOn2.indexOf(from);
          if (i2 < 0) {
            return false;
          }
          dependsOn2.splice(i2, 1);
          if (dependsOn2.length > 0) {
            return false;
          }
          delete tocheck[targetId];
          return true;
        }
        while (queue.length > 0) {
          id = queue.shift();
          class_ = declaredClasses[id];
          if (class_.scopeId && removeDependentAndCheck(class_.scopeId, class_)) {
            queue.push(class_.scopeId);
            declaredClasses[class_.scopeId].weight = class_.weight + 1;
          }
          if (class_.base && removeDependentAndCheck(class_.base.classId, class_)) {
            queue.push(class_.base.classId);
            class_.base.weight = class_.weight + 1;
          }
          if (class_.interfaces) {
            var i, l2;
            for (i = 0, l2 = class_.interfaces.length; i < l2; ++i) {
              if (!class_.interfaces[i] || !removeDependentAndCheck(class_.interfaces[i].classId, class_)) {
                continue;
              }
              queue.push(class_.interfaces[i].classId);
              class_.interfaces[i].weight = class_.weight + 1;
            }
          }
        }
      }
      var transformed = transformMain();
      generateMetadata(transformed);
      setWeight(transformed);
      var redendered = transformed.toString();
      redendered = redendered.replace(/\s*\n(?:[\t ]*\n)+/g, "\n\n");
      redendered = redendered.replace(/__x([0-9A-F]{4})/g, function(all, hexCode) {
        return String.fromCharCode(parseInt(hexCode, 16));
      });
      return injectStrings(redendered, strings);
    }
    function preprocessCode(aCode, sketch) {
      var dm = new RegExp(/\/\*\s*@pjs\s+((?:[^\*]|\*+[^\*\/])*)\*\//g).exec(aCode);
      if (dm && dm.length === 2) {
        var jsonItems = [], directives = dm.splice(1, 2)[0].replace(/\{([\s\S]*?)\}/g, /* @__PURE__ */ function() {
          return function(all, item) {
            jsonItems.push(item);
            return "{" + (jsonItems.length - 1) + "}";
          };
        }()).replace("\n", "").replace("\r", "").split(";");
        var clean = function(s) {
          return s.replace(/^\s*["']?/, "").replace(/["']?\s*$/, "");
        };
        for (var i = 0, dl = directives.length; i < dl; i++) {
          var pair = directives[i].split("=");
          if (pair && pair.length === 2) {
            var key = clean(pair[0]), value = clean(pair[1]), list = [];
            if (key === "preload") {
              list = value.split(",");
              for (var j = 0, jl = list.length; j < jl; j++) {
                var imageName = clean(list[j]);
                sketch.imageCache.add(imageName);
              }
            } else if (key === "font") {
              list = value.split(",");
              for (var x = 0, xl = list.length; x < xl; x++) {
                var fontName = clean(list[x]), index = /^\{(\d*?)\}$/.exec(fontName);
                PFont.preloading.add(index ? JSON.parse("{" + jsonItems[index[1]] + "}") : fontName);
              }
            } else if (key === "pauseOnBlur") {
              sketch.options.pauseOnBlur = value === "true";
            } else if (key === "globalKeyEvents") {
              sketch.options.globalKeyEvents = value === "true";
            } else if (key.substring(0, 6) === "param-") {
              sketch.params[key.substring(6)] = value;
            } else {
              sketch.options[key] = value;
            }
          }
        }
      }
      return aCode;
    }
    Processing3.compile = function(pdeCode) {
      var sketch = new Processing3.Sketch();
      var code = preprocessCode(pdeCode, sketch);
      var compiledPde = parseProcessing(code);
      sketch.sourceCode = compiledPde;
      return sketch;
    };
    Processing3.logger = new PjsConsole(document2);
    return Processing3;
  }

  // src/Helpers/finalizeProcessing.js
  function finalizeProcessing(Processing3, options) {
    var window2 = options.window, document2 = options.document, XMLHttpRequest2 = window2.XMLHttpRequest, noop = options.noop, isDOMPresent = options.isDOMPresent, version = options.version, undef;
    Processing3.version = version ? version : "@DEV-VERSION@";
    Processing3.lib = {};
    Processing3.registerLibrary = function(name, library) {
      Processing3.lib[name] = library;
      if (library.hasOwnProperty("init")) {
        library.init(defaultScope);
      }
    };
    Processing3.Sketch = function(attachFunction) {
      this.attachFunction = attachFunction;
      this.options = {
        pauseOnBlur: false,
        globalKeyEvents: false
      };
      this.onLoad = noop;
      this.onSetup = noop;
      this.onPause = noop;
      this.onLoop = noop;
      this.onFrameStart = noop;
      this.onFrameEnd = noop;
      this.onExit = noop;
      this.params = {};
      this.imageCache = {
        pending: 0,
        images: {},
        // Opera requires special administration for preloading
        operaCache: {},
        // Specify an optional img arg if the image is already loaded in the DOM,
        // otherwise href will get loaded.
        add: function(href, img) {
          if (this.images[href]) {
            return;
          }
          if (!isDOMPresent) {
            this.images[href] = null;
          }
          if (!img) {
            img = new Image();
            img.onload = /* @__PURE__ */ function(owner) {
              return function() {
                owner.pending--;
              };
            }(this);
            this.pending++;
            img.src = href;
          }
          this.images[href] = img;
          if (window2.opera) {
            var div = document2.createElement("div");
            div.appendChild(img);
            div.style.position = "absolute";
            div.style.opacity = 0;
            div.style.width = "1px";
            div.style.height = "1px";
            if (!this.operaCache[href]) {
              document2.body.appendChild(div);
              this.operaCache[href] = div;
            }
          }
        }
      };
      this.sourceCode = void 0;
      this.attach = function(processing) {
        if (typeof this.attachFunction === "function") {
          this.attachFunction(processing);
        } else if (this.sourceCode) {
          var func = new Function("return (" + this.sourceCode + ");")();
          func(processing);
          this.attachFunction = func;
        } else {
          throw "Unable to attach sketch to the processing instance";
        }
      };
      this.toString = function() {
        var i;
        var code = "((function(Sketch) {\n";
        code += "var sketch = new Sketch(\n" + this.sourceCode + ");\n";
        for (i in this.options) {
          if (this.options.hasOwnProperty(i)) {
            var value = this.options[i];
            code += "sketch.options." + i + " = " + (typeof value === "string" ? '"' + value + '"' : "" + value) + ";\n";
          }
        }
        for (i in this.imageCache) {
          if (this.options.hasOwnProperty(i)) {
            code += 'sketch.imageCache.add("' + i + '");\n';
          }
        }
        code += "return sketch;\n})(Processing.Sketch))";
        return code;
      };
    };
    var loadSketchFromSources = Processing3.loadSketchFromSources = function(canvas, sources, onComplete) {
      var code = [], errors = [], sourcesCount = sources.length, loaded = 0;
      function ajaxAsync(url, callback) {
        var xhr = new XMLHttpRequest2();
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            var error;
            if (xhr.status !== 200 && xhr.status !== 0) {
              error = "Invalid XHR status " + xhr.status;
            } else if (xhr.responseText === "") {
              if ("withCredentials" in new XMLHttpRequest2() && new XMLHttpRequest2().withCredentials === false && window2.location.protocol === "file:") {
                error = "XMLHttpRequest failure, possibly due to a same-origin policy violation. You can try loading this page in another browser, or load it from http://localhost using a local webserver. See the Processing.js README for a more detailed explanation of this problem and solutions.";
              } else {
                error = "File is empty.";
              }
            }
            callback(xhr.responseText, error);
          }
        };
        xhr.open("GET", url, true);
        if (xhr.overrideMimeType) {
          xhr.overrideMimeType("application/json");
        }
        xhr.setRequestHeader("If-Modified-Since", "Fri, 01 Jan 1960 00:00:00 GMT");
        xhr.send(null);
      }
      function loadBlock(index, filename) {
        function callback(block, error) {
          code[index] = block;
          ++loaded;
          if (error) {
            errors.push(filename + " ==> " + error);
          }
          if (loaded === sourcesCount) {
            if (errors.length === 0) {
              var sketch = new Processing3(canvas, code.join("\n"));
              if (onComplete) {
                onComplete(sketch);
              }
            } else {
              throw "Processing.js: Unable to load pjs sketch files: " + errors.join("\n");
            }
          }
        }
        if (filename.charAt(0) === "#") {
          var scriptElement = document2.getElementById(filename.substring(1));
          if (scriptElement) {
            callback(scriptElement.text || scriptElement.textContent);
          } else {
            callback("", "Unable to load pjs sketch: element with id '" + filename.substring(1) + "' was not found");
          }
          return;
        }
        ajaxAsync(filename, callback);
      }
      for (var i = 0; i < sourcesCount; ++i) {
        loadBlock(i, sources[i]);
      }
    };
    var init = function() {
      document2.removeEventListener("DOMContentLoaded", init, false);
      var i;
      while (Processing3.instances.length > 0) {
        for (i = Processing3.instances.length - 1; i >= 0; i--) {
          if (Processing3.instances[i]) {
            Processing3.instances[i].exit();
          }
        }
      }
      var canvas = document2.getElementsByTagName("canvas"), filenames;
      for (i = 0, l = canvas.length; i < l; i++) {
        var processingSources = canvas[i].getAttribute("data-processing-sources");
        if (processingSources === null) {
          processingSources = canvas[i].getAttribute("data-src");
          if (processingSources === null) {
            processingSources = canvas[i].getAttribute("datasrc");
          }
        }
        if (processingSources) {
          filenames = processingSources.split(/\s+/g);
          for (var j = 0; j < filenames.length; ) {
            if (filenames[j]) {
              j++;
            } else {
              filenames.splice(j, 1);
            }
          }
          loadSketchFromSources(canvas[i], filenames);
        }
      }
      var s, last, source2, instance, nodelist = document2.getElementsByTagName("script"), scripts = [];
      for (s = nodelist.length - 1; s >= 0; s--) {
        scripts.push(nodelist[s]);
      }
      for (s = 0, last = scripts.length; s < last; s++) {
        var script = scripts[s];
        if (!script.getAttribute) {
          continue;
        }
        var type = script.getAttribute("type");
        if (type && (type.toLowerCase() === "text/processing" || type.toLowerCase() === "application/processing")) {
          var target = script.getAttribute("data-processing-target");
          canvas = undef;
          if (target) {
            canvas = document2.getElementById(target);
          } else {
            var nextSibling = script.nextSibling;
            while (nextSibling && nextSibling.nodeType !== 1) {
              nextSibling = nextSibling.nextSibling;
            }
            if (nextSibling && nextSibling.nodeName.toLowerCase() === "canvas") {
              canvas = nextSibling;
            }
          }
          if (canvas) {
            if (script.getAttribute("src")) {
              filenames = script.getAttribute("src").split(/\s+/);
              loadSketchFromSources(canvas, filenames);
              continue;
            }
            source2 = script.textContent || script.text;
            instance = new Processing3(canvas, source2);
          }
        }
      }
    };
    document2.addEventListener("DOMContentLoaded", init, false);
    Processing3.reload = init;
    Processing3.disableInit = function() {
      document2.removeEventListener("DOMContentLoaded", init, false);
    };
    return Processing3;
  }

  // src/Live2D/dist/type/csmvector.js
  var _csmVector = class _csmVector {
    /**
     * 引数付きコンストラクタ
     * @param iniitalCapacity 初期化後のキャパシティ。データサイズは_capacity * sizeof(T)
     * @param zeroClear trueなら初期化時に確保した領域を0で埋める
     */
    constructor(initialCapacity = 0) {
      __publicField(this, "_ptr");
      // コンテナの先頭アドレス
      __publicField(this, "_size");
      // コンテナの要素数
      __publicField(this, "_capacity");
      if (initialCapacity < 1) {
        this._ptr = [];
        this._capacity = 0;
        this._size = 0;
      } else {
        this._ptr = new Array(initialCapacity);
        this._capacity = initialCapacity;
        this._size = 0;
      }
    }
    /**
     * インデックスで指定した要素を返す
     */
    at(index) {
      return this._ptr[index];
    }
    /**
     * 要素をセット
     * @param index 要素をセットするインデックス
     * @param value セットする要素
     */
    set(index, value) {
      this._ptr[index] = value;
    }
    /**
     * コンテナを取得する
     */
    get(offset = 0) {
      const ret = new Array();
      for (let i = offset; i < this._size; i++) {
        ret.push(this._ptr[i]);
      }
      return ret;
    }
    /**
     * pushBack処理、コンテナに新たな要素を追加する
     * @param value PushBack処理で追加する値
     */
    pushBack(value) {
      if (this._size >= this._capacity) {
        this.prepareCapacity(this._capacity == 0 ? _csmVector.DefaultSize : this._capacity * 2);
      }
      this._ptr[this._size++] = value;
    }
    /**
     * コンテナの全要素を解放する
     */
    clear() {
      this._ptr.length = 0;
      this._size = 0;
    }
    /**
     * コンテナの要素数を返す
     * @return コンテナの要素数
     */
    getSize() {
      return this._size;
    }
    /**
     * コンテナの全要素に対して代入処理を行う
     * @param newSize 代入処理後のサイズ
     * @param value 要素に代入する値
     */
    assign(newSize, value) {
      const curSize = this._size;
      if (curSize < newSize) {
        this.prepareCapacity(newSize);
      }
      for (let i = 0; i < newSize; i++) {
        this._ptr[i] = value;
      }
      this._size = newSize;
    }
    /**
     * サイズ変更
     */
    resize(newSize, value = null) {
      this.updateSize(newSize, value, true);
    }
    /**
     * サイズ変更
     */
    updateSize(newSize, value = null, callPlacementNew = true) {
      const curSize = this._size;
      if (curSize < newSize) {
        this.prepareCapacity(newSize);
        if (callPlacementNew) {
          for (let i = this._size; i < newSize; i++) {
            if (typeof value == "function") {
              this._ptr[i] = JSON.parse(JSON.stringify(new value()));
            } else {
              this._ptr[i] = value;
            }
          }
        } else {
          for (let i = this._size; i < newSize; i++) {
            this._ptr[i] = value;
          }
        }
      } else {
        const sub = this._size - newSize;
        this._ptr.splice(this._size - sub, sub);
      }
      this._size = newSize;
    }
    /**
     * コンテナにコンテナ要素を挿入する
     * @param position 挿入する位置
     * @param begin 挿入するコンテナの開始位置
     * @param end 挿入するコンテナの終端位置
     */
    insert(position, begin, end) {
      let dstSi = position._index;
      const srcSi = begin._index;
      const srcEi = end._index;
      const addCount = srcEi - srcSi;
      this.prepareCapacity(this._size + addCount);
      const addSize = this._size - dstSi;
      if (addSize > 0) {
        for (let i = 0; i < addSize; i++) {
          this._ptr.splice(dstSi + i, 0, null);
        }
      }
      for (let i = srcSi; i < srcEi; i++, dstSi++) {
        this._ptr[dstSi] = begin._vector._ptr[i];
      }
      this._size = this._size + addCount;
    }
    /**
     * コンテナからインデックスで指定した要素を削除する
     * @param index インデックス値
     * @return true 削除実行
     * @return false 削除範囲外
     */
    remove(index) {
      if (index < 0 || this._size <= index) {
        return false;
      }
      this._ptr.splice(index, 1);
      --this._size;
      return true;
    }
    /**
     * コンテナから要素を削除して他の要素をシフトする
     * @param ite 削除する要素
     */
    erase(ite) {
      const index = ite._index;
      if (index < 0 || this._size <= index) {
        return ite;
      }
      this._ptr.splice(index, 1);
      --this._size;
      const ite2 = new iterator(this, index);
      return ite2;
    }
    /**
     * コンテナのキャパシティを確保する
     * @param newSize 新たなキャパシティ。引数の値が現在のサイズ未満の場合は何もしない.
     */
    prepareCapacity(newSize) {
      if (newSize > this._capacity) {
        if (this._capacity == 0) {
          this._ptr = new Array(newSize);
          this._capacity = newSize;
        } else {
          this._ptr.length = newSize;
          this._capacity = newSize;
        }
      }
    }
    /**
     * コンテナの先頭要素を返す
     */
    begin() {
      const ite = this._size == 0 ? this.end() : new iterator(this, 0);
      return ite;
    }
    /**
     * コンテナの終端要素を返す
     */
    end() {
      const ite = new iterator(this, this._size);
      return ite;
    }
    getOffset(offset) {
      const newVector = new _csmVector();
      newVector._ptr = this.get(offset);
      newVector._size = this.get(offset).length;
      newVector._capacity = this.get(offset).length;
      return newVector;
    }
    // コンテナ初期化のデフォルトサイズ
  };
  // コンテナのキャパシティ
  __publicField(_csmVector, "DefaultSize", 10);
  var csmVector = _csmVector;
  var iterator = class _iterator {
    /**
     * コンストラクタ
     */
    constructor(v, index) {
      __publicField(this, "_index");
      // コンテナのインデックス値
      __publicField(this, "_vector");
      this._vector = v != void 0 ? v : null;
      this._index = index != void 0 ? index : 0;
    }
    /**
     * 代入
     */
    set(ite) {
      this._index = ite._index;
      this._vector = ite._vector;
      return this;
    }
    /**
     * 前置き++演算
     */
    preIncrement() {
      ++this._index;
      return this;
    }
    /**
     * 前置き--演算
     */
    preDecrement() {
      --this._index;
      return this;
    }
    /**
     * 後置き++演算子
     */
    increment() {
      const iteold = new _iterator(this._vector, this._index++);
      return iteold;
    }
    /**
     * 後置き--演算子
     */
    decrement() {
      const iteold = new _iterator(this._vector, this._index--);
      return iteold;
    }
    /**
     * ptr
     */
    ptr() {
      return this._vector._ptr[this._index];
    }
    /**
     * =演算子のオーバーロード
     */
    substitution(ite) {
      this._index = ite._index;
      this._vector = ite._vector;
      return this;
    }
    /**
     * !=演算子のオーバーロード
     */
    notEqual(ite) {
      return this._index != ite._index || this._vector != ite._vector;
    }
    // コンテナ
  };
  var Live2DCubismFramework;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.csmVector = csmVector;
    Live2DCubismFramework42.iterator = iterator;
  })(Live2DCubismFramework || (Live2DCubismFramework = {}));

  // src/Live2D/dist/type/csmstring.js
  var csmString = class {
    /**
     * 引数付きコンストラクタ
     */
    constructor(s) {
      __publicField(this, "s");
      this.s = s;
    }
    /**
     * 文字列を後方に追加する
     *
     * @param c 追加する文字列
     * @return 更新された文字列
     */
    append(c, length) {
      this.s += length !== void 0 ? c.substr(0, length) : c;
      return this;
    }
    /**
     * 文字サイズを拡張して文字を埋める
     * @param length    拡張する文字数
     * @param v         埋める文字
     * @return 更新された文字列
     */
    expansion(length, v) {
      for (let i = 0; i < length; i++) {
        this.append(v);
      }
      return this;
    }
    /**
     * 文字列の長さをバイト数で取得する
     */
    getBytes() {
      return encodeURIComponent(this.s).replace(/%../g, "x").length;
    }
    /**
     * 文字列の長さを返す
     */
    getLength() {
      return this.s.length;
    }
    /**
     * 文字列比較 <
     * @param s 比較する文字列
     * @return true:    比較する文字列より小さい
     * @return false:   比較する文字列より大きい
     */
    isLess(s) {
      return this.s < s.s;
    }
    /**
     * 文字列比較 >
     * @param s 比較する文字列
     * @return true:    比較する文字列より大きい
     * @return false:   比較する文字列より小さい
     */
    isGreat(s) {
      return this.s > s.s;
    }
    /**
     * 文字列比較 ==
     * @param s 比較する文字列
     * @return true:    比較する文字列と等しい
     * @return false:   比較する文字列と異なる
     */
    isEqual(s) {
      return this.s == s;
    }
    /**
     * 文字列が空かどうか
     * @return true: 空の文字列
     * @return false: 値が設定されている
     */
    isEmpty() {
      return this.s.length == 0;
    }
  };
  var Live2DCubismFramework2;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.csmString = csmString;
  })(Live2DCubismFramework2 || (Live2DCubismFramework2 = {}));

  // src/Live2D/dist/id/cubismid.js
  var CubismId = class _CubismId {
    /**
     * プライベートコンストラクタ
     *
     * @note ユーザーによる生成は許可しません
     */
    constructor(id) {
      __publicField(this, "_id");
      if (typeof id === "string") {
        this._id = new csmString(id);
        return;
      }
      this._id = id;
    }
    /**
     * 内部で使用するCubismIdクラス生成メソッド
     *
     * @param id ID文字列
     * @returns CubismId
     * @note 指定したID文字列からCubismIdを取得する際は
     *       CubismIdManager().getId(id)を使用してください
     */
    static createIdInternal(id) {
      return new _CubismId(id);
    }
    /**
     * ID名を取得する
     */
    getString() {
      return this._id;
    }
    /**
     * idを比較
     * @param c 比較するid
     * @return 同じならばtrue,異なっていればfalseを返す
     */
    isEqual(c) {
      if (typeof c === "string") {
        return this._id.isEqual(c);
      } else if (c instanceof csmString) {
        return this._id.isEqual(c.s);
      } else if (c instanceof _CubismId) {
        return this._id.isEqual(c._id.s);
      }
      return false;
    }
    /**
     * idを比較
     * @param c 比較するid
     * @return 同じならばtrue,異なっていればfalseを返す
     */
    isNotEqual(c) {
      if (typeof c == "string") {
        return !this._id.isEqual(c);
      } else if (c instanceof csmString) {
        return !this._id.isEqual(c.s);
      } else if (c instanceof _CubismId) {
        return !this._id.isEqual(c._id.s);
      }
      return false;
    }
    // ID名
  };
  var Live2DCubismFramework3;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismId = CubismId;
  })(Live2DCubismFramework3 || (Live2DCubismFramework3 = {}));

  // src/Live2D/dist/id/cubismidmanager.js
  var CubismIdManager = class {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_ids");
      this._ids = new csmVector();
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      for (let i = 0; i < this._ids.getSize(); ++i) {
        this._ids.set(i, void 0);
      }
      this._ids = null;
    }
    /**
     * ID名をリストから登録
     *
     * @param ids ID名リスト
     * @param count IDの個数
     */
    registerIds(ids) {
      for (let i = 0; i < ids.length; i++) {
        this.registerId(ids[i]);
      }
    }
    /**
     * ID名を登録
     *
     * @param id ID名
     */
    registerId(id) {
      let result = null;
      if ("string" == typeof id) {
        if ((result = this.findId(id)) != null) {
          return result;
        }
        result = CubismId.createIdInternal(id);
        this._ids.pushBack(result);
      } else {
        return this.registerId(id.s);
      }
      return result;
    }
    /**
     * ID名からIDを取得する
     *
     * @param id ID名
     */
    getId(id) {
      return this.registerId(id);
    }
    /**
     * ID名からIDの確認
     *
     * @return true 存在する
     * @return false 存在しない
     */
    isExist(id) {
      if ("string" == typeof id) {
        return this.findId(id) != null;
      }
      return this.isExist(id.s);
    }
    /**
     * ID名からIDを検索する。
     *
     * @param id ID名
     * @return 登録されているID。なければNULL。
     */
    findId(id) {
      for (let i = 0; i < this._ids.getSize(); ++i) {
        if (this._ids.at(i).getString().isEqual(id)) {
          return this._ids.at(i);
        }
      }
      return null;
    }
    // 登録されているIDのリスト
  };
  var Live2DCubismFramework4;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismIdManager = CubismIdManager;
  })(Live2DCubismFramework4 || (Live2DCubismFramework4 = {}));

  // src/Live2D/dist/math/cubismmatrix44.js
  var CubismMatrix44 = class _CubismMatrix44 {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_tr");
      this._tr = new Float32Array(16);
      this.loadIdentity();
    }
    /**
     * 受け取った２つの行列の乗算を行う。
     *
     * @param a 行列a
     * @param b 行列b
     * @return 乗算結果の行列
     */
    static multiply(a, b, dst) {
      const c = new Float32Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      const n = 4;
      for (let i = 0; i < n; ++i) {
        for (let j = 0; j < n; ++j) {
          for (let k = 0; k < n; ++k) {
            c[j + i * 4] += a[k + i * 4] * b[j + k * 4];
          }
        }
      }
      for (let i = 0; i < 16; ++i) {
        dst[i] = c[i];
      }
    }
    /**
     * 単位行列に初期化する
     */
    loadIdentity() {
      const c = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
      this.setMatrix(c);
    }
    /**
     * 行列を設定
     *
     * @param tr 16個の浮動小数点数で表される4x4の行列
     */
    setMatrix(tr) {
      for (let i = 0; i < 16; ++i) {
        this._tr[i] = tr[i];
      }
    }
    /**
     * 行列を浮動小数点数の配列で取得
     *
     * @return 16個の浮動小数点数で表される4x4の行列
     */
    getArray() {
      return this._tr;
    }
    /**
     * X軸の拡大率を取得
     * @return X軸の拡大率
     */
    getScaleX() {
      return this._tr[0];
    }
    /**
     * Y軸の拡大率を取得する
     *
     * @return Y軸の拡大率
     */
    getScaleY() {
      return this._tr[5];
    }
    /**
     * X軸の移動量を取得
     * @return X軸の移動量
     */
    getTranslateX() {
      return this._tr[12];
    }
    /**
     * Y軸の移動量を取得
     * @return Y軸の移動量
     */
    getTranslateY() {
      return this._tr[13];
    }
    /**
     * X軸の値を現在の行列で計算
     *
     * @param src X軸の値
     * @return 現在の行列で計算されたX軸の値
     */
    transformX(src) {
      return this._tr[0] * src + this._tr[12];
    }
    /**
     * Y軸の値を現在の行列で計算
     *
     * @param src Y軸の値
     * @return 現在の行列で計算されたY軸の値
     */
    transformY(src) {
      return this._tr[5] * src + this._tr[13];
    }
    /**
     * X軸の値を現在の行列で逆計算
     */
    invertTransformX(src) {
      return (src - this._tr[12]) / this._tr[0];
    }
    /**
     * Y軸の値を現在の行列で逆計算
     */
    invertTransformY(src) {
      return (src - this._tr[13]) / this._tr[5];
    }
    /**
     * 現在の行列の位置を起点にして移動
     *
     * 現在の行列の位置を起点にして相対的に移動する。
     *
     * @param x X軸の移動量
     * @param y Y軸の移動量
     */
    translateRelative(x, y) {
      const tr1 = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        x,
        y,
        0,
        1
      ]);
      _CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 現在の行列の位置を移動
     *
     * 現在の行列の位置を指定した位置へ移動する
     *
     * @param x X軸の移動量
     * @param y y軸の移動量
     */
    translate(x, y) {
      this._tr[12] = x;
      this._tr[13] = y;
    }
    /**
     * 現在の行列のX軸の位置を指定した位置へ移動する
     *
     * @param x X軸の移動量
     */
    translateX(x) {
      this._tr[12] = x;
    }
    /**
     * 現在の行列のY軸の位置を指定した位置へ移動する
     *
     * @param y Y軸の移動量
     */
    translateY(y) {
      this._tr[13] = y;
    }
    /**
     * 現在の行列の拡大率を相対的に設定する
     *
     * @param x X軸の拡大率
     * @param y Y軸の拡大率
     */
    scaleRelative(x, y) {
      const tr1 = new Float32Array([
        x,
        0,
        0,
        0,
        0,
        y,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
      _CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 現在の行列の拡大率を指定した倍率に設定する
     *
     * @param x X軸の拡大率
     * @param y Y軸の拡大率
     */
    scale(x, y) {
      this._tr[0] = x;
      this._tr[5] = y;
    }
    /**
     * 引数で与えられた行列にこの行列を乗算する。
     * (引数で与えられた行列) * (この行列)
     *
     * @note 関数名と実際の計算内容に乖離があるため、今後計算順が修正される可能性があります。
     * @param m 行列
     */
    multiplyByMatrix(m) {
      _CubismMatrix44.multiply(m.getArray(), this._tr, this._tr);
    }
    /**
     * オブジェクトのコピーを生成する
     */
    clone() {
      const cloneMatrix = new _CubismMatrix44();
      for (let i = 0; i < this._tr.length; i++) {
        cloneMatrix._tr[i] = this._tr[i];
      }
      return cloneMatrix;
    }
    // 4x4行列データ
  };
  var Live2DCubismFramework5;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMatrix44 = CubismMatrix44;
  })(Live2DCubismFramework5 || (Live2DCubismFramework5 = {}));

  // src/Live2D/dist/type/csmrectf.js
  var csmRect = class {
    /**
     * コンストラクタ
     * @param x 左端X座標
     * @param y 上端Y座標
     * @param w 幅
     * @param h 高さ
     */
    constructor(x, y, w, h) {
      __publicField(this, "x");
      // 左端X座標
      __publicField(this, "y");
      // 上端Y座標
      __publicField(this, "width");
      // 幅
      __publicField(this, "height");
      this.x = x;
      this.y = y;
      this.width = w;
      this.height = h;
    }
    /**
     * 矩形中央のX座標を取得する
     */
    getCenterX() {
      return this.x + 0.5 * this.width;
    }
    /**
     * 矩形中央のY座標を取得する
     */
    getCenterY() {
      return this.y + 0.5 * this.height;
    }
    /**
     * 右側のX座標を取得する
     */
    getRight() {
      return this.x + this.width;
    }
    /**
     * 下端のY座標を取得する
     */
    getBottom() {
      return this.y + this.height;
    }
    /**
     * 矩形に値をセットする
     * @param r 矩形のインスタンス
     */
    setRect(r) {
      this.x = r.x;
      this.y = r.y;
      this.width = r.width;
      this.height = r.height;
    }
    /**
     * 矩形中央を軸にして縦横を拡縮する
     * @param w 幅方向に拡縮する量
     * @param h 高さ方向に拡縮する量
     */
    expand(w, h) {
      this.x -= w;
      this.y -= h;
      this.width += w * 2;
      this.height += h * 2;
    }
    // 高さ
  };
  var Live2DCubismFramework6;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.csmRect = csmRect;
  })(Live2DCubismFramework6 || (Live2DCubismFramework6 = {}));

  // src/Live2D/dist/rendering/cubismrenderer.js
  var CubismRenderer = class {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_mvpMatrix4x4");
      // Model-View-Projection 行列
      __publicField(this, "_modelColor");
      // モデル自体のカラー（RGBA）
      __publicField(this, "_isCulling");
      // カリングが有効ならtrue
      __publicField(this, "_isPremultipliedAlpha");
      // 乗算済みαならtrue
      __publicField(this, "_anisotropy");
      // テクスチャの異方性フィルタリングのパラメータ
      __publicField(this, "_model");
      // レンダリング対象のモデル
      __publicField(this, "_useHighPrecisionMask");
      this._isCulling = false;
      this._isPremultipliedAlpha = false;
      this._anisotropy = 0;
      this._model = null;
      this._modelColor = new CubismTextureColor();
      this._useHighPrecisionMask = false;
      this._mvpMatrix4x4 = new CubismMatrix44();
      this._mvpMatrix4x4.loadIdentity();
    }
    /**
     * レンダラのインスタンスを生成して取得する
     *
     * @return レンダラのインスタンス
     */
    static create() {
      return null;
    }
    /**
     * レンダラのインスタンスを解放する
     */
    static delete(renderer) {
      renderer = null;
    }
    /**
     * レンダラの初期化処理を実行する
     * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる
     * @param model モデルのインスタンス
     */
    initialize(model) {
      this._model = model;
    }
    /**
     * モデルを描画する
     */
    drawModel() {
      if (this.getModel() == null)
        return;
      this.saveProfile();
      this.doDrawModel();
      this.restoreProfile();
    }
    /**
     * Model-View-Projection 行列をセットする
     * 配列は複製されるので、元の配列は外で破棄して良い
     * @param matrix44 Model-View-Projection 行列
     */
    setMvpMatrix(matrix44) {
      this._mvpMatrix4x4.setMatrix(matrix44.getArray());
    }
    /**
     * Model-View-Projection 行列を取得する
     * @return Model-View-Projection 行列
     */
    getMvpMatrix() {
      return this._mvpMatrix4x4;
    }
    /**
     * モデルの色をセットする
     * 各色0.0~1.0の間で指定する（1.0が標準の状態）
     * @param red 赤チャンネルの値
     * @param green 緑チャンネルの値
     * @param blue 青チャンネルの値
     * @param alpha αチャンネルの値
     */
    setModelColor(red, green, blue, alpha) {
      if (red < 0) {
        red = 0;
      } else if (red > 1) {
        red = 1;
      }
      if (green < 0) {
        green = 0;
      } else if (green > 1) {
        green = 1;
      }
      if (blue < 0) {
        blue = 0;
      } else if (blue > 1) {
        blue = 1;
      }
      if (alpha < 0) {
        alpha = 0;
      } else if (alpha > 1) {
        alpha = 1;
      }
      this._modelColor.r = red;
      this._modelColor.g = green;
      this._modelColor.b = blue;
      this._modelColor.a = alpha;
    }
    /**
     * モデルの色を取得する
     * 各色0.0~1.0の間で指定する(1.0が標準の状態)
     *
     * @return RGBAのカラー情報
     */
    getModelColor() {
      return JSON.parse(JSON.stringify(this._modelColor));
    }
    /**
     * 透明度を考慮したモデルの色を計算する。
     *
     * @param opacity 透明度
     *
     * @return RGBAのカラー情報
     */
    getModelColorWithOpacity(opacity) {
      const modelColorRGBA = this.getModelColor();
      modelColorRGBA.a *= opacity;
      if (this.isPremultipliedAlpha()) {
        modelColorRGBA.r *= modelColorRGBA.a;
        modelColorRGBA.g *= modelColorRGBA.a;
        modelColorRGBA.b *= modelColorRGBA.a;
      }
      return modelColorRGBA;
    }
    /**
     * 乗算済みαの有効・無効をセットする
     * 有効にするならtrue、無効にするならfalseをセットする
     */
    setIsPremultipliedAlpha(enable) {
      this._isPremultipliedAlpha = enable;
    }
    /**
     * 乗算済みαの有効・無効を取得する
     * @return true 乗算済みのα有効
     * @return false 乗算済みのα無効
     */
    isPremultipliedAlpha() {
      return this._isPremultipliedAlpha;
    }
    /**
     * カリング（片面描画）の有効・無効をセットする。
     * 有効にするならtrue、無効にするならfalseをセットする
     */
    setIsCulling(culling) {
      this._isCulling = culling;
    }
    /**
     * カリング（片面描画）の有効・無効を取得する。
     * @return true カリング有効
     * @return false カリング無効
     */
    isCulling() {
      return this._isCulling;
    }
    /**
     * テクスチャの異方性フィルタリングのパラメータをセットする
     * パラメータ値の影響度はレンダラの実装に依存する
     * @param n パラメータの値
     */
    setAnisotropy(n) {
      this._anisotropy = n;
    }
    /**
     * テクスチャの異方性フィルタリングのパラメータをセットする
     * @return 異方性フィルタリングのパラメータ
     */
    getAnisotropy() {
      return this._anisotropy;
    }
    /**
     * レンダリングするモデルを取得する
     * @return レンダリングするモデル
     */
    getModel() {
      return this._model;
    }
    /**
     * マスク描画の方式を変更する。
     * falseの場合、マスクを1枚のテクスチャに分割してレンダリングする（デフォルト）
     * 高速だが、マスク個数の上限が36に限定され、質も荒くなる
     * trueの場合、パーツ描画の前にその都度必要なマスクを描き直す
     * レンダリング品質は高いが描画処理負荷は増す
     * @param high 高精細マスクに切り替えるか？
     */
    useHighPrecisionMask(high) {
      this._useHighPrecisionMask = high;
    }
    /**
     * マスクの描画方式を取得する
     * @return true 高精細方式
     * @return false デフォルト
     */
    isUsingHighPrecisionMask() {
      return this._useHighPrecisionMask;
    }
    // falseの場合、マスクを纏めて描画する trueの場合、マスクはパーツ描画ごとに書き直す
  };
  /**
   * レンダラが保持する静的なリソースを開放する
   */
  __publicField(CubismRenderer, "staticRelease");
  var CubismBlendMode;
  (function(CubismBlendMode2) {
    CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Normal"] = 0] = "CubismBlendMode_Normal";
    CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Additive"] = 1] = "CubismBlendMode_Additive";
    CubismBlendMode2[CubismBlendMode2["CubismBlendMode_Multiplicative"] = 2] = "CubismBlendMode_Multiplicative";
  })(CubismBlendMode || (CubismBlendMode = {}));
  var CubismTextureColor = class {
    /**
     * コンストラクタ
     */
    constructor(r = 1, g = 1, b = 1, a = 1) {
      __publicField(this, "r");
      // 赤チャンネル
      __publicField(this, "g");
      // 緑チャンネル
      __publicField(this, "b");
      // 青チャンネル
      __publicField(this, "a");
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }
    // αチャンネル
  };
  var CubismClippingContext = class {
    /**
     * 引数付きコンストラクタ
     */
    constructor(clippingDrawableIndices, clipCount) {
      __publicField(this, "_isUsing");
      // 現在の描画状態でマスクの準備が必要ならtrue
      __publicField(this, "_clippingIdList");
      // クリッピングマスクのIDリスト
      __publicField(this, "_clippingIdCount");
      // クリッピングマスクの数
      __publicField(this, "_layoutChannelIndex");
      // RGBAのいずれのチャンネルにこのクリップを配置するか（0:R, 1:G, 2:B, 3:A）
      __publicField(this, "_layoutBounds");
      // マスク用チャンネルのどの領域にマスクを入れるか（View座標-1~1, UVは0~1に直す）
      __publicField(this, "_allClippedDrawRect");
      // このクリッピングで、クリッピングされるすべての描画オブジェクトの囲み矩形（毎回更新）
      __publicField(this, "_matrixForMask");
      // マスクの位置計算結果を保持する行列
      __publicField(this, "_matrixForDraw");
      // 描画オブジェクトの位置計算結果を保持する行列
      __publicField(this, "_clippedDrawableIndexList");
      // このマスクにクリップされる描画オブジェクトのリスト
      __publicField(this, "_bufferIndex");
      this._clippingIdList = clippingDrawableIndices;
      this._clippingIdCount = clipCount;
      this._allClippedDrawRect = new csmRect();
      this._layoutBounds = new csmRect();
      this._clippedDrawableIndexList = [];
      this._matrixForMask = new CubismMatrix44();
      this._matrixForDraw = new CubismMatrix44();
      this._bufferIndex = 0;
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      if (this._layoutBounds != null) {
        this._layoutBounds = null;
      }
      if (this._allClippedDrawRect != null) {
        this._allClippedDrawRect = null;
      }
      if (this._clippedDrawableIndexList != null) {
        this._clippedDrawableIndexList = null;
      }
    }
    /**
     * このマスクにクリップされる描画オブジェクトを追加する
     *
     * @param drawableIndex クリッピング対象に追加する描画オブジェクトのインデックス
     */
    addClippedDrawable(drawableIndex) {
      this._clippedDrawableIndexList.push(drawableIndex);
    }
    // このマスクが割り当てられるレンダーテクスチャ（フレームバッファ）やカラーバッファのインデックス
  };
  var Live2DCubismFramework7;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismBlendMode = CubismBlendMode;
    Live2DCubismFramework42.CubismRenderer = CubismRenderer;
    Live2DCubismFramework42.CubismTextureColor = CubismTextureColor;
  })(Live2DCubismFramework7 || (Live2DCubismFramework7 = {}));

  // src/Live2D/dist/cubismframeworkconfig.js
  var CSM_LOG_LEVEL_VERBOSE = 0;
  var CSM_LOG_LEVEL_DEBUG = 1;
  var CSM_LOG_LEVEL_INFO = 2;
  var CSM_LOG_LEVEL_WARNING = 3;
  var CSM_LOG_LEVEL_ERROR = 4;
  var CSM_LOG_LEVEL = CSM_LOG_LEVEL_VERBOSE;

  // src/Live2D/dist/utils/cubismdebug.js
  var CubismLogPrint = (level, fmt, args) => {
    CubismDebug.print(level, "[CSM]" + fmt, args);
  };
  var CubismLogPrintIn = (level, fmt, args) => {
    CubismLogPrint(level, fmt + "\n", args);
  };
  var CSM_ASSERT = (expr) => {
    console.assert(expr);
  };
  var CubismLogVerbose;
  var CubismLogDebug;
  var CubismLogInfo;
  var CubismLogWarning;
  var CubismLogError;
  if (CSM_LOG_LEVEL <= CSM_LOG_LEVEL_VERBOSE) {
    CubismLogVerbose = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Verbose, "[V]" + fmt, args);
    };
    CubismLogDebug = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Debug, "[D]" + fmt, args);
    };
    CubismLogInfo = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Info, "[I]" + fmt, args);
    };
    CubismLogWarning = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
    };
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  } else if (CSM_LOG_LEVEL == CSM_LOG_LEVEL_DEBUG) {
    CubismLogDebug = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Debug, "[D]" + fmt, args);
    };
    CubismLogInfo = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Info, "[I]" + fmt, args);
    };
    CubismLogWarning = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
    };
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  } else if (CSM_LOG_LEVEL == CSM_LOG_LEVEL_INFO) {
    CubismLogInfo = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Info, "[I]" + fmt, args);
    };
    CubismLogWarning = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
    };
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  } else if (CSM_LOG_LEVEL == CSM_LOG_LEVEL_WARNING) {
    CubismLogWarning = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Warning, "[W]" + fmt, args);
    };
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  } else if (CSM_LOG_LEVEL == CSM_LOG_LEVEL_ERROR) {
    CubismLogError = (fmt, ...args) => {
      CubismLogPrintIn(LogLevel.LogLevel_Error, "[E]" + fmt, args);
    };
  }
  var CubismDebug = class {
    /**
     * ログを出力する。第一引数にログレベルを設定する。
     * CubismFramework.initialize()時にオプションで設定されたログ出力レベルを下回る場合はログに出さない。
     *
     * @param logLevel ログレベルの設定
     * @param format 書式付き文字列
     * @param args 可変長引数
     */
    static print(logLevel, format, args) {
      if (logLevel < CubismFramework.getLoggingLevel()) {
        return;
      }
      const logPrint = CubismFramework.coreLogFunction;
      if (!logPrint)
        return;
      const buffer = format.replace(/\{(\d+)\}/g, (m, k) => {
        return args[k];
      });
      logPrint(buffer);
    }
    /**
     * データから指定した長さだけダンプ出力する。
     * CubismFramework.initialize()時にオプションで設定されたログ出力レベルを下回る場合はログに出さない。
     *
     * @param logLevel ログレベルの設定
     * @param data ダンプするデータ
     * @param length ダンプする長さ
     */
    static dumpBytes(logLevel, data, length) {
      for (let i = 0; i < length; i++) {
        if (i % 16 == 0 && i > 0)
          this.print(logLevel, "\n");
        else if (i % 8 == 0 && i > 0)
          this.print(logLevel, "  ");
        this.print(logLevel, "{0} ", [data[i] & 255]);
      }
      this.print(logLevel, "\n");
    }
    /**
     * private コンストラクタ
     */
    constructor() {
    }
  };
  var Live2DCubismFramework8;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismDebug = CubismDebug;
  })(Live2DCubismFramework8 || (Live2DCubismFramework8 = {}));

  // src/Live2D/dist/type/csmmap.js
  var csmPair = class {
    /**
     * コンストラクタ
     * @param key Keyとしてセットする値
     * @param value Valueとしてセットする値
     */
    constructor(key, value) {
      __publicField(this, "first");
      // keyとして用いる変数
      __publicField(this, "second");
      this.first = key == void 0 ? null : key;
      this.second = value == void 0 ? null : value;
    }
    // valueとして用いる変数
  };
  var _csmMap = class _csmMap {
    /**
     * 引数付きコンストラクタ
     * @param size 初期化時点で確保するサイズ
     */
    constructor(size) {
      // コンテナの初期化のデフォルトサイズ
      __publicField(this, "_keyValues");
      // key-valueペアの配列
      __publicField(this, "_dummyValue");
      // 空の値を返す為のダミー
      __publicField(this, "_size");
      if (size != void 0) {
        if (size < 1) {
          this._keyValues = [];
          this._dummyValue = null;
          this._size = 0;
        } else {
          this._keyValues = new Array(size);
          this._size = size;
        }
      } else {
        this._keyValues = [];
        this._dummyValue = null;
        this._size = 0;
      }
    }
    /**
     * デストラクタ
     */
    release() {
      this.clear();
    }
    /**
     * キーを追加する
     * @param key 新たに追加するキー
     */
    appendKey(key) {
      this.prepareCapacity(this._size + 1, false);
      this._keyValues[this._size] = new csmPair(key);
      this._size += 1;
    }
    /**
     * 添字演算子[key]のオーバーロード(get)
     * @param key 添字から特定されるValue値
     */
    getValue(key) {
      let found = -1;
      for (let i = 0; i < this._size; i++) {
        if (this._keyValues[i].first == key) {
          found = i;
          break;
        }
      }
      if (found >= 0) {
        return this._keyValues[found].second;
      } else {
        this.appendKey(key);
        return this._keyValues[this._size - 1].second;
      }
    }
    /**
     * 添字演算子[key]のオーバーロード(set)
     * @param key 添字から特定されるValue値
     * @param value 代入するValue値
     */
    setValue(key, value) {
      let found = -1;
      for (let i = 0; i < this._size; i++) {
        if (this._keyValues[i].first == key) {
          found = i;
          break;
        }
      }
      if (found >= 0) {
        this._keyValues[found].second = value;
      } else {
        this.appendKey(key);
        this._keyValues[this._size - 1].second = value;
      }
    }
    /**
     * 引数で渡したKeyを持つ要素が存在するか
     * @param key 存在を確認するkey
     * @return true 引数で渡したkeyを持つ要素が存在する
     * @return false 引数で渡したkeyを持つ要素が存在しない
     */
    isExist(key) {
      for (let i = 0; i < this._size; i++) {
        if (this._keyValues[i].first == key) {
          return true;
        }
      }
      return false;
    }
    /**
     * keyValueのポインタを全て解放する
     */
    clear() {
      this._keyValues = void 0;
      this._keyValues = null;
      this._keyValues = [];
      this._size = 0;
    }
    /**
     * コンテナのサイズを取得する
     *
     * @return コンテナのサイズ
     */
    getSize() {
      return this._size;
    }
    /**
     * コンテナのキャパシティを確保する
     * @param newSize 新たなキャパシティ。引数の値が現在のサイズ未満の場合は何もしない。
     * @param fitToSize trueなら指定したサイズに合わせる。falseならサイズを2倍確保しておく。
     */
    prepareCapacity(newSize, fitToSize) {
      if (newSize > this._keyValues.length) {
        if (this._keyValues.length == 0) {
          if (!fitToSize && newSize < _csmMap.DefaultSize)
            newSize = _csmMap.DefaultSize;
          this._keyValues.length = newSize;
        } else {
          if (!fitToSize && newSize < this._keyValues.length * 2)
            newSize = this._keyValues.length * 2;
          this._keyValues.length = newSize;
        }
      }
    }
    /**
     * コンテナの先頭要素を返す
     */
    begin() {
      const ite = new iterator2(this, 0);
      return ite;
    }
    /**
     * コンテナの終端要素を返す
     */
    end() {
      const ite = new iterator2(this, this._size);
      return ite;
    }
    /**
     * コンテナから要素を削除する
     *
     * @param ite 削除する要素
     */
    erase(ite) {
      const index = ite._index;
      if (index < 0 || this._size <= index) {
        return ite;
      }
      this._keyValues.splice(index, 1);
      --this._size;
      const ite2 = new iterator2(this, index);
      return ite2;
    }
    /**
     * コンテナの値を32ビット符号付き整数型でダンプする
     */
    dumpAsInt() {
      for (let i = 0; i < this._size; i++) {
        CubismLogDebug("{0} ,", this._keyValues[i]);
        CubismLogDebug("\n");
      }
    }
    // コンテナの要素数
  };
  __publicField(_csmMap, "DefaultSize", 10);
  var csmMap = _csmMap;
  var iterator2 = class _iterator {
    /**
     * コンストラクタ
     */
    constructor(v, idx) {
      __publicField(this, "_index");
      // コンテナのインデックス値
      __publicField(this, "_map");
      this._map = v != void 0 ? v : new csmMap();
      this._index = idx != void 0 ? idx : 0;
    }
    /**
     * =演算子のオーバーロード
     */
    set(ite) {
      this._index = ite._index;
      this._map = ite._map;
      return this;
    }
    /**
     * 前置き++演算子のオーバーロード
     */
    preIncrement() {
      ++this._index;
      return this;
    }
    /**
     * 前置き--演算子のオーバーロード
     */
    preDecrement() {
      --this._index;
      return this;
    }
    /**
     * 後置き++演算子のオーバーロード
     */
    increment() {
      const iteold = new _iterator(this._map, this._index++);
      return iteold;
    }
    /**
     * 後置き--演算子のオーバーロード
     */
    decrement() {
      const iteold = new _iterator(this._map, this._index);
      this._map = iteold._map;
      this._index = iteold._index;
      return this;
    }
    /**
     * *演算子のオーバーロード
     */
    ptr() {
      return this._map._keyValues[this._index];
    }
    /**
     * !=演算
     */
    notEqual(ite) {
      return this._index != ite._index || this._map != ite._map;
    }
    // コンテナ
  };
  var Live2DCubismFramework9;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.csmMap = csmMap;
    Live2DCubismFramework42.csmPair = csmPair;
    Live2DCubismFramework42.iterator = iterator2;
  })(Live2DCubismFramework9 || (Live2DCubismFramework9 = {}));

  // src/Live2D/dist/utils/cubismjsonextension.js
  var CubismJsonExtension = class _CubismJsonExtension {
    static parseJsonObject(obj, map) {
      Object.keys(obj).forEach((key) => {
        if (typeof obj[key] == "boolean") {
          const convValue = Boolean(obj[key]);
          map.put(key, new JsonBoolean(convValue));
        } else if (typeof obj[key] == "string") {
          const convValue = String(obj[key]);
          map.put(key, new JsonString(convValue));
        } else if (typeof obj[key] == "number") {
          const convValue = Number(obj[key]);
          map.put(key, new JsonFloat(convValue));
        } else if (obj[key] instanceof Array) {
          map.put(key, _CubismJsonExtension.parseJsonArray(obj[key]));
        } else if (obj[key] instanceof Object) {
          map.put(key, _CubismJsonExtension.parseJsonObject(obj[key], new JsonMap()));
        } else if (obj[key] == null) {
          map.put(key, new JsonNullvalue());
        } else {
          map.put(key, obj[key]);
        }
      });
      return map;
    }
    static parseJsonArray(obj) {
      const arr = new JsonArray();
      Object.keys(obj).forEach((key) => {
        const convKey = Number(key);
        if (typeof convKey == "number") {
          if (typeof obj[key] == "boolean") {
            const convValue = Boolean(obj[key]);
            arr.add(new JsonBoolean(convValue));
          } else if (typeof obj[key] == "string") {
            const convValue = String(obj[key]);
            arr.add(new JsonString(convValue));
          } else if (typeof obj[key] == "number") {
            const convValue = Number(obj[key]);
            arr.add(new JsonFloat(convValue));
          } else if (obj[key] instanceof Array) {
            arr.add(this.parseJsonArray(obj[key]));
          } else if (obj[key] instanceof Object) {
            arr.add(this.parseJsonObject(obj[key], new JsonMap()));
          } else if (obj[key] == null) {
            arr.add(new JsonNullvalue());
          } else {
            arr.add(obj[key]);
          }
        } else if (obj[key] instanceof Array) {
          arr.add(this.parseJsonArray(obj[key]));
        } else if (obj[key] instanceof Object) {
          arr.add(this.parseJsonObject(obj[key], new JsonMap()));
        } else if (obj[key] == null) {
          arr.add(new JsonNullvalue());
        } else {
          const convValue = Array(obj[key]);
          for (let i = 0; i < convValue.length; i++) {
            arr.add(convValue[i]);
          }
        }
      });
      return arr;
    }
  };

  // src/Live2D/dist/utils/cubismjson.js
  var CSM_JSON_ERROR_TYPE_MISMATCH = "Error: type mismatch";
  var CSM_JSON_ERROR_INDEX_OF_BOUNDS = "Error: index out of bounds";
  var _Value = class _Value {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_stringBuffer");
    }
    /**
     * 要素を文字列型で返す(string)
     */
    getRawString(defaultValue, indent) {
      return this.getString(defaultValue, indent);
    }
    /**
     * 要素を数値型で返す(number)
     */
    toInt(defaultValue = 0) {
      return defaultValue;
    }
    /**
     * 要素を数値型で返す(number)
     */
    toFloat(defaultValue = 0) {
      return defaultValue;
    }
    /**
     * 要素を真偽値で返す(boolean)
     */
    toBoolean(defaultValue = false) {
      return defaultValue;
    }
    /**
     * サイズを返す
     */
    getSize() {
      return 0;
    }
    /**
     * 要素を配列で返す(Value[])
     */
    getArray(defaultValue = null) {
      return defaultValue;
    }
    /**
     * 要素をコンテナで返す(array)
     */
    getVector(defaultValue = new csmVector()) {
      return defaultValue;
    }
    /**
     * 要素をマップで返す(csmMap<csmString, Value>)
     */
    getMap(defaultValue) {
      return defaultValue;
    }
    /**
     * 添字演算子[index]
     */
    getValueByIndex(index) {
      return _Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);
    }
    /**
     * 添字演算子[string | csmString]
     */
    getValueByString(s) {
      return _Value.nullValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);
    }
    /**
     * マップのキー一覧をコンテナで返す
     *
     * @return マップのキーの一覧
     */
    getKeys() {
      return _Value.dummyKeys;
    }
    /**
     * Valueの種類がエラー値ならtrue
     */
    isError() {
      return false;
    }
    /**
     * Valueの種類がnullならtrue
     */
    isNull() {
      return false;
    }
    /**
     * Valueの種類が真偽値ならtrue
     */
    isBool() {
      return false;
    }
    /**
     * Valueの種類が数値型ならtrue
     */
    isFloat() {
      return false;
    }
    /**
     * Valueの種類が文字列ならtrue
     */
    isString() {
      return false;
    }
    /**
     * Valueの種類が配列ならtrue
     */
    isArray() {
      return false;
    }
    /**
     * Valueの種類がマップ型ならtrue
     */
    isMap() {
      return false;
    }
    equals(value) {
      return false;
    }
    /**
     * Valueの値が静的ならtrue、静的なら解放しない
     */
    isStatic() {
      return false;
    }
    /**
     * Valueにエラー値をセットする
     */
    setErrorNotForClientCall(errorStr) {
      return JsonError.errorValue;
    }
    /**
     * 初期化用メソッド
     */
    static staticInitializeNotForClientCall() {
      JsonBoolean.trueValue = new JsonBoolean(true);
      JsonBoolean.falseValue = new JsonBoolean(false);
      _Value.errorValue = new JsonError("ERROR", true);
      _Value.nullValue = new JsonNullvalue();
      _Value.dummyKeys = new csmVector();
    }
    /**
     * リリース用メソッド
     */
    static staticReleaseNotForClientCall() {
      JsonBoolean.trueValue = null;
      JsonBoolean.falseValue = null;
      _Value.errorValue = null;
      _Value.nullValue = null;
      _Value.dummyKeys = null;
    }
    // 一時的な返り値として返すNULL。   CubismFramework::Disposeするまではdeleteしない
  };
  // 文字列バッファ
  __publicField(_Value, "dummyKeys");
  // ダミーキー
  __publicField(_Value, "errorValue");
  // 一時的な返り値として返すエラー。 CubismFramework::Disposeするまではdeleteしない
  __publicField(_Value, "nullValue");
  var Value = _Value;
  var CubismJson = class _CubismJson {
    /**
     * コンストラクタ
     */
    constructor(buffer, length) {
      __publicField(this, "_parseCallback", CubismJsonExtension.parseJsonObject);
      // パース時に使う処理のコールバック関数
      __publicField(this, "_error");
      // パース時のエラー
      __publicField(this, "_lineCount");
      // エラー報告に用いる行数カウント
      __publicField(this, "_root");
      this._error = null;
      this._lineCount = 0;
      this._root = null;
      if (buffer != void 0) {
        this.parseBytes(buffer, length, this._parseCallback);
      }
    }
    /**
     * バイトデータから直接ロードしてパースする
     *
     * @param buffer バッファ
     * @param size バッファサイズ
     * @return CubismJsonクラスのインスタンス。失敗したらNULL
     */
    static create(buffer, size) {
      const json = new _CubismJson();
      const succeeded = json.parseBytes(buffer, size, json._parseCallback);
      if (!succeeded) {
        _CubismJson.delete(json);
        return null;
      } else {
        return json;
      }
    }
    /**
     * パースしたJSONオブジェクトの解放処理
     *
     * @param instance CubismJsonクラスのインスタンス
     */
    static delete(instance) {
      instance = null;
    }
    /**
     * パースしたJSONのルート要素を返す
     */
    getRoot() {
      return this._root;
    }
    /**
     *  UnicodeのバイナリをStringに変換
     *
     * @param buffer 変換するバイナリデータ
     * @return 変換後の文字列
     */
    static arrayBufferToString(buffer) {
      const uint8Array = new Uint8Array(buffer);
      let str = "";
      for (let i = 0, len = uint8Array.length; i < len; ++i) {
        str += "%" + this.pad(uint8Array[i].toString(16));
      }
      str = decodeURIComponent(str);
      return str;
    }
    /**
     * エンコード、パディング
     */
    static pad(n) {
      return n.length < 2 ? "0" + n : n;
    }
    /**
     * JSONのパースを実行する
     * @param buffer    パース対象のデータバイト
     * @param size      データバイトのサイズ
     * return true : 成功
     * return false: 失敗
     */
    parseBytes(buffer, size, parseCallback) {
      const endPos = new Array(1);
      const decodeBuffer = _CubismJson.arrayBufferToString(buffer);
      if (parseCallback == void 0) {
        this._root = this.parseValue(decodeBuffer, size, 0, endPos);
      } else {
        this._root = parseCallback(JSON.parse(decodeBuffer), new JsonMap());
      }
      if (this._error) {
        let strbuf = "\0";
        strbuf = "Json parse error : @line " + (this._lineCount + 1) + "\n";
        this._root = new JsonString(strbuf);
        CubismLogInfo("{0}", this._root.getRawString());
        return false;
      } else if (this._root == null) {
        this._root = new JsonError(new csmString(this._error), false);
        return false;
      }
      return true;
    }
    /**
     * パース時のエラー値を返す
     */
    getParseError() {
      return this._error;
    }
    /**
     * ルート要素の次の要素がファイルの終端だったらtrueを返す
     */
    checkEndOfFile() {
      return this._root.getArray()[1].equals("EOF");
    }
    /**
     * JSONエレメントからValue(float,String,Value*,Array,null,true,false)をパースする
     * エレメントの書式に応じて内部でParseString(), ParseObject(), ParseArray()を呼ぶ
     *
     * @param   buffer      JSONエレメントのバッファ
     * @param   length      パースする長さ
     * @param   begin       パースを開始する位置
     * @param   outEndPos   パース終了時の位置
     * @return      パースから取得したValueオブジェクト
     */
    parseValue(buffer, length, begin, outEndPos) {
      if (this._error)
        return null;
      let o = null;
      let i = begin;
      let f;
      for (; i < length; i++) {
        const c = buffer[i];
        switch (c) {
          case "-":
          case ".":
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            const afterString = new Array(1);
            f = strtod(buffer.slice(i), afterString);
            outEndPos[0] = buffer.indexOf(afterString[0]);
            return new JsonFloat(f);
          }
          case '"':
            return new JsonString(this.parseString(buffer, length, i + 1, outEndPos));
          // \"の次の文字から
          case "[":
            o = this.parseArray(buffer, length, i + 1, outEndPos);
            return o;
          case "{":
            o = this.parseObject(buffer, length, i + 1, outEndPos);
            return o;
          case "n":
            if (i + 3 < length) {
              o = new JsonNullvalue();
              outEndPos[0] = i + 4;
            } else {
              this._error = "parse null";
            }
            return o;
          case "t":
            if (i + 3 < length) {
              o = JsonBoolean.trueValue;
              outEndPos[0] = i + 4;
            } else {
              this._error = "parse true";
            }
            return o;
          case "f":
            if (i + 4 < length) {
              o = JsonBoolean.falseValue;
              outEndPos[0] = i + 5;
            } else {
              this._error = "illegal ',' position";
            }
            return o;
          case ",":
            this._error = "illegal ',' position";
            return null;
          case "]":
            outEndPos[0] = i;
            return null;
          case "\n":
            this._lineCount++;
          // falls through
          case " ":
          case "	":
          case "\r":
          default:
            break;
        }
      }
      this._error = "illegal end of value";
      return null;
    }
    /**
     * 次の「"」までの文字列をパースする。
     *
     * @param   string  ->  パース対象の文字列
     * @param   length  ->  パースする長さ
     * @param   begin   ->  パースを開始する位置
     * @param  outEndPos   ->  パース終了時の位置
     * @return      パースした文F字列要素
     */
    parseString(string, length, begin, outEndPos) {
      if (this._error) {
        return null;
      }
      if (!string) {
        this._error = "string is null";
        return null;
      }
      let i = begin;
      let c, c2;
      const ret = new csmString("");
      let bufStart = begin;
      for (; i < length; i++) {
        c = string[i];
        switch (c) {
          case '"': {
            outEndPos[0] = i + 1;
            ret.append(string.slice(bufStart), i - bufStart);
            return ret.s;
          }
          // falls through
          case "//": {
            i++;
            if (i - 1 > bufStart) {
              ret.append(string.slice(bufStart), i - bufStart);
            }
            bufStart = i + 1;
            if (i < length) {
              c2 = string[i];
              switch (c2) {
                case "\\":
                  ret.expansion(1, "\\");
                  break;
                case '"':
                  ret.expansion(1, '"');
                  break;
                case "/":
                  ret.expansion(1, "/");
                  break;
                case "b":
                  ret.expansion(1, "\b");
                  break;
                case "f":
                  ret.expansion(1, "\f");
                  break;
                case "n":
                  ret.expansion(1, "\n");
                  break;
                case "r":
                  ret.expansion(1, "\r");
                  break;
                case "t":
                  ret.expansion(1, "	");
                  break;
                case "u":
                  this._error = "parse string/unicord escape not supported";
                  break;
                default:
                  break;
              }
            } else {
              this._error = "parse string/escape error";
            }
          }
          // falls through
          default: {
            break;
          }
        }
      }
      this._error = "parse string/illegal end";
      return null;
    }
    /**
     * JSONのオブジェクトエレメントをパースしてValueオブジェクトを返す
     *
     * @param buffer    JSONエレメントのバッファ
     * @param length    パースする長さ
     * @param begin     パースを開始する位置
     * @param outEndPos パース終了時の位置
     * @return パースから取得したValueオブジェクト
     */
    parseObject(buffer, length, begin, outEndPos) {
      if (this._error) {
        return null;
      }
      if (!buffer) {
        this._error = "buffer is null";
        return null;
      }
      const ret = new JsonMap();
      let key = "";
      let i = begin;
      let c = "";
      const localRetEndPos2 = Array(1);
      let ok = false;
      for (; i < length; i++) {
        FOR_LOOP: for (; i < length; i++) {
          c = buffer[i];
          switch (c) {
            case '"':
              key = this.parseString(buffer, length, i + 1, localRetEndPos2);
              if (this._error) {
                return null;
              }
              i = localRetEndPos2[0];
              ok = true;
              break FOR_LOOP;
            //-- loopから出る
            case "}":
              outEndPos[0] = i + 1;
              return ret;
            // 空
            case ":":
              this._error = "illegal ':' position";
              break;
            case "\n":
              this._lineCount++;
            // falls through
            default:
              break;
          }
        }
        if (!ok) {
          this._error = "key not found";
          return null;
        }
        ok = false;
        FOR_LOOP2: for (; i < length; i++) {
          c = buffer[i];
          switch (c) {
            case ":":
              ok = true;
              i++;
              break FOR_LOOP2;
            case "}":
              this._error = "illegal '}' position";
              break;
            // falls through
            case "\n":
              this._lineCount++;
            // case ' ': case '\t' : case '\r':
            // falls through
            default:
              break;
          }
        }
        if (!ok) {
          this._error = "':' not found";
          return null;
        }
        const value = this.parseValue(buffer, length, i, localRetEndPos2);
        if (this._error) {
          return null;
        }
        i = localRetEndPos2[0];
        ret.put(key, value);
        FOR_LOOP3: for (; i < length; i++) {
          c = buffer[i];
          switch (c) {
            case ",":
              break FOR_LOOP3;
            case "}":
              outEndPos[0] = i + 1;
              return ret;
            // 正常終了
            case "\n":
              this._lineCount++;
            // falls through
            default:
              break;
          }
        }
      }
      this._error = "illegal end of perseObject";
      return null;
    }
    /**
     * 次の「"」までの文字列をパースする。
     * @param buffer    JSONエレメントのバッファ
     * @param length    パースする長さ
     * @param begin     パースを開始する位置
     * @param outEndPos パース終了時の位置
     * @return パースから取得したValueオブジェクト
     */
    parseArray(buffer, length, begin, outEndPos) {
      if (this._error) {
        return null;
      }
      if (!buffer) {
        this._error = "buffer is null";
        return null;
      }
      let ret = new JsonArray();
      let i = begin;
      let c;
      const localRetEndpos2 = new Array(1);
      for (; i < length; i++) {
        const value = this.parseValue(buffer, length, i, localRetEndpos2);
        if (this._error) {
          return null;
        }
        i = localRetEndpos2[0];
        if (value) {
          ret.add(value);
        }
        FOR_LOOP: for (; i < length; i++) {
          c = buffer[i];
          switch (c) {
            case ",":
              break FOR_LOOP;
            case "]":
              outEndPos[0] = i + 1;
              return ret;
            // 終了
            case "\n":
              ++this._lineCount;
            //case ' ': case '\t': case '\r':
            // falls through
            default:
              break;
          }
        }
      }
      ret = void 0;
      this._error = "illegal end of parseObject";
      return null;
    }
    // パースされたルート要素
  };
  var JsonFloat = class extends Value {
    /**
     * コンストラクタ
     */
    constructor(v) {
      super();
      __publicField(this, "_value");
      this._value = v;
    }
    /**
     * Valueの種類が数値型ならtrue
     */
    isFloat() {
      return true;
    }
    /**
     * 要素を文字列で返す(csmString型)
     */
    getString(defaultValue, indent) {
      const strbuf = "\0";
      this._value = parseFloat(strbuf);
      this._stringBuffer = strbuf;
      return this._stringBuffer;
    }
    /**
     * 要素を数値型で返す(number)
     */
    toInt(defaultValue = 0) {
      return parseInt(this._value.toString());
    }
    /**
     * 要素を数値型で返す(number)
     */
    toFloat(defaultValue = 0) {
      return this._value;
    }
    equals(value) {
      if ("number" === typeof value) {
        if (Math.round(value)) {
          return false;
        } else {
          return value == this._value;
        }
      }
      return false;
    }
    // JSON要素の値
  };
  var JsonBoolean = class extends Value {
    /**
     * 引数付きコンストラクタ
     */
    constructor(v) {
      super();
      // false
      __publicField(this, "_boolValue");
      this._boolValue = v;
    }
    /**
     * Valueの種類が真偽値ならtrue
     */
    isBool() {
      return true;
    }
    /**
     * 要素を真偽値で返す(boolean)
     */
    toBoolean(defaultValue = false) {
      return this._boolValue;
    }
    /**
     * 要素を文字列で返す(csmString型)
     */
    getString(defaultValue, indent) {
      this._stringBuffer = this._boolValue ? "true" : "false";
      return this._stringBuffer;
    }
    equals(value) {
      if ("boolean" === typeof value) {
        return value == this._boolValue;
      }
      return false;
    }
    /**
     * Valueの値が静的ならtrue, 静的なら解放しない
     */
    isStatic() {
      return true;
    }
    // JSON要素の値
  };
  __publicField(JsonBoolean, "trueValue");
  // true
  __publicField(JsonBoolean, "falseValue");
  var JsonString = class extends Value {
    constructor(s) {
      super();
      if ("string" === typeof s) {
        this._stringBuffer = s;
      }
      if (s instanceof csmString) {
        this._stringBuffer = s.s;
      }
    }
    /**
     * Valueの種類が文字列ならtrue
     */
    isString() {
      return true;
    }
    /**
     * 要素を文字列で返す(csmString型)
     */
    getString(defaultValue, indent) {
      return this._stringBuffer;
    }
    equals(value) {
      if ("string" === typeof value) {
        return this._stringBuffer == value;
      }
      if (value instanceof csmString) {
        return this._stringBuffer == value.s;
      }
      return false;
    }
  };
  var JsonError = class extends JsonString {
    /**
     * 引数付きコンストラクタ
     */
    constructor(s, isStatic) {
      var __super = (...args) => {
        super(...args);
        __publicField(this, "_isStatic");
        return this;
      };
      if ("string" === typeof s) {
        __super(s);
      } else {
        __super(s);
      }
      this._isStatic = isStatic;
    }
    /**
     * Valueの値が静的ならtrue、静的なら解放しない
     */
    isStatic() {
      return this._isStatic;
    }
    /**
     * エラー情報をセットする
     */
    setErrorNotForClientCall(s) {
      this._stringBuffer = s;
      return this;
    }
    /**
     * Valueの種類がエラー値ならtrue
     */
    isError() {
      return true;
    }
    // 静的なValueかどうか
  };
  var JsonNullvalue = class extends Value {
    /**
     * Valueの種類がNULL値ならtrue
     */
    isNull() {
      return true;
    }
    /**
     * 要素を文字列で返す(csmString型)
     */
    getString(defaultValue, indent) {
      return this._stringBuffer;
    }
    /**
     * Valueの値が静的ならtrue, 静的なら解放しない
     */
    isStatic() {
      return true;
    }
    /**
     * Valueにエラー値をセットする
     */
    setErrorNotForClientCall(s) {
      this._stringBuffer = s;
      return JsonError.nullValue;
    }
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      this._stringBuffer = "NullValue";
    }
  };
  var JsonArray = class extends Value {
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      __publicField(this, "_array");
      this._array = new csmVector();
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.preIncrement()) {
        let v = ite.ptr();
        if (v && !v.isStatic()) {
          v = void 0;
          v = null;
        }
      }
    }
    /**
     * Valueの種類が配列ならtrue
     */
    isArray() {
      return true;
    }
    /**
     * 添字演算子[index]
     */
    getValueByIndex(index) {
      if (index < 0 || this._array.getSize() <= index) {
        return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_INDEX_OF_BOUNDS);
      }
      const v = this._array.at(index);
      if (v == null) {
        return Value.nullValue;
      }
      return v;
    }
    /**
     * 添字演算子[string | csmString]
     */
    getValueByString(s) {
      return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);
    }
    /**
     * 要素を文字列で返す(csmString型)
     */
    getString(defaultValue, indent) {
      const stringBuffer = indent + "[\n";
      for (let ite = this._array.begin(); ite.notEqual(this._array.end()); ite.increment()) {
        const v = ite.ptr();
        this._stringBuffer += indent + "" + v.getString(indent + " ") + "\n";
      }
      this._stringBuffer = stringBuffer + indent + "]\n";
      return this._stringBuffer;
    }
    /**
     * 配列要素を追加する
     * @param v 追加する要素
     */
    add(v) {
      this._array.pushBack(v);
    }
    /**
     * 要素をコンテナで返す(csmVector<Value>)
     */
    getVector(defaultValue = null) {
      return this._array;
    }
    /**
     * 要素の数を返す
     */
    getSize() {
      return this._array.getSize();
    }
    // JSON要素の値
  };
  var JsonMap = class extends Value {
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      __publicField(this, "_map");
      // JSON要素の値
      __publicField(this, "_keys");
      this._map = new csmMap();
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      const ite = this._map.begin();
      while (ite.notEqual(this._map.end())) {
        let v = ite.ptr().second;
        if (v && !v.isStatic()) {
          v = void 0;
          v = null;
        }
        ite.preIncrement();
      }
    }
    /**
     * Valueの値がMap型ならtrue
     */
    isMap() {
      return true;
    }
    /**
     * 添字演算子[string | csmString]
     */
    getValueByString(s) {
      if (s instanceof csmString) {
        const ret = this._map.getValue(s.s);
        if (ret == null) {
          return Value.nullValue;
        }
        return ret;
      }
      for (let iter = this._map.begin(); iter.notEqual(this._map.end()); iter.preIncrement()) {
        if (iter.ptr().first == s) {
          if (iter.ptr().second == null) {
            return Value.nullValue;
          }
          return iter.ptr().second;
        }
      }
      return Value.nullValue;
    }
    /**
     * 添字演算子[index]
     */
    getValueByIndex(index) {
      return Value.errorValue.setErrorNotForClientCall(CSM_JSON_ERROR_TYPE_MISMATCH);
    }
    /**
     * 要素を文字列で返す(csmString型)
     */
    getString(defaultValue, indent) {
      this._stringBuffer = indent + "{\n";
      const ite = this._map.begin();
      while (ite.notEqual(this._map.end())) {
        const key = ite.ptr().first;
        const v = ite.ptr().second;
        this._stringBuffer += indent + " " + key + " : " + v.getString(indent + "   ") + " \n";
        ite.preIncrement();
      }
      this._stringBuffer += indent + "}\n";
      return this._stringBuffer;
    }
    /**
     * 要素をMap型で返す
     */
    getMap(defaultValue) {
      return this._map;
    }
    /**
     * Mapに要素を追加する
     */
    put(key, v) {
      this._map.setValue(key, v);
    }
    /**
     * Mapからキーのリストを取得する
     */
    getKeys() {
      if (!this._keys) {
        this._keys = new csmVector();
        const ite = this._map.begin();
        while (ite.notEqual(this._map.end())) {
          const key = ite.ptr().first;
          this._keys.pushBack(key);
          ite.preIncrement();
        }
      }
      return this._keys;
    }
    /**
     * Mapの要素数を取得する
     */
    getSize() {
      return this._keys.getSize();
    }
    // JSON要素の値
  };
  var Live2DCubismFramework10;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismJson = CubismJson;
    Live2DCubismFramework42.JsonArray = JsonArray;
    Live2DCubismFramework42.JsonBoolean = JsonBoolean;
    Live2DCubismFramework42.JsonError = JsonError;
    Live2DCubismFramework42.JsonFloat = JsonFloat;
    Live2DCubismFramework42.JsonMap = JsonMap;
    Live2DCubismFramework42.JsonNullvalue = JsonNullvalue;
    Live2DCubismFramework42.JsonString = JsonString;
    Live2DCubismFramework42.Value = Value;
  })(Live2DCubismFramework10 || (Live2DCubismFramework10 = {}));

  // src/Live2D/dist/live2dcubismframework.js
  function strtod(s, endPtr) {
    let index = 0;
    for (let i = 1; ; i++) {
      const testC = s.slice(i - 1, i);
      if (testC == "e" || testC == "-" || testC == "E") {
        continue;
      }
      const test = s.substring(0, i);
      const number = Number(test);
      if (isNaN(number)) {
        break;
      }
      index = i;
    }
    let d = parseFloat(s);
    if (isNaN(d)) {
      d = NaN;
    }
    endPtr[0] = s.slice(index);
    return d;
  }
  var s_isStarted = false;
  var s_isInitialized = false;
  var s_option = null;
  var s_cubismIdManager = null;
  var Constant = Object.freeze({
    vertexOffset: 0,
    // メッシュ頂点のオフセット値
    vertexStep: 2
    // メッシュ頂点のステップ値
  });
  function csmDelete(address) {
    if (!address) {
      return;
    }
    address = void 0;
  }
  var CubismFramework = class {
    /**
     * Cubism FrameworkのAPIを使用可能にする。
     *  APIを実行する前に必ずこの関数を実行すること。
     *  一度準備が完了して以降は、再び実行しても内部処理がスキップされます。
     *
     * @param    option      Optionクラスのインスタンス
     *
     * @return   準備処理が完了したらtrueが返ります。
     */
    static startUp(option = null) {
      if (s_isStarted) {
        CubismLogInfo("CubismFramework.startUp() is already done.");
        return s_isStarted;
      }
      s_option = option;
      if (s_option != null) {
        Live2DCubismCore.Logging.csmSetLogFunction(s_option.logFunction);
      }
      s_isStarted = true;
      if (s_isStarted) {
        const version = Live2DCubismCore.Version.csmGetVersion();
        const major = (version & 4278190080) >> 24;
        const minor = (version & 16711680) >> 16;
        const patch = version & 65535;
        const versionNumber = version;
        CubismLogInfo(`Live2D Cubism Core version: {0}.{1}.{2} ({3})`, ("00" + major).slice(-2), ("00" + minor).slice(-2), ("0000" + patch).slice(-4), versionNumber);
      }
      CubismLogInfo("CubismFramework.startUp() is complete.");
      return s_isStarted;
    }
    /**
     * StartUp()で初期化したCubismFrameworkの各パラメータをクリアします。
     * Dispose()したCubismFrameworkを再利用する際に利用してください。
     */
    static cleanUp() {
      s_isStarted = false;
      s_isInitialized = false;
      s_option = null;
      s_cubismIdManager = null;
    }
    /**
     * Cubism Framework内のリソースを初期化してモデルを表示可能な状態にします。<br>
     *     再度Initialize()するには先にDispose()を実行する必要があります。
     *
     * @param memorySize 初期化時メモリ量 [byte(s)]
     *    複数モデル表示時などにモデルが更新されない際に使用してください。
     *    指定する際は必ず1024*1024*16 byte(16MB)以上の値を指定してください。
     *    それ以外はすべて1024*1024*16 byteに丸めます。
     */
    static initialize(memorySize = 0) {
      CSM_ASSERT(s_isStarted);
      if (!s_isStarted) {
        CubismLogWarning("CubismFramework is not started.");
        return;
      }
      if (s_isInitialized) {
        CubismLogWarning("CubismFramework.initialize() skipped, already initialized.");
        return;
      }
      Value.staticInitializeNotForClientCall();
      s_cubismIdManager = new CubismIdManager();
      Live2DCubismCore.Memory.initializeAmountOfMemory(memorySize);
      s_isInitialized = true;
      CubismLogInfo("CubismFramework.initialize() is complete.");
    }
    /**
     * Cubism Framework内の全てのリソースを解放します。
     *      ただし、外部で確保されたリソースについては解放しません。
     *      外部で適切に破棄する必要があります。
     */
    static dispose() {
      CSM_ASSERT(s_isStarted);
      if (!s_isStarted) {
        CubismLogWarning("CubismFramework is not started.");
        return;
      }
      if (!s_isInitialized) {
        CubismLogWarning("CubismFramework.dispose() skipped, not initialized.");
        return;
      }
      Value.staticReleaseNotForClientCall();
      s_cubismIdManager.release();
      s_cubismIdManager = null;
      CubismRenderer.staticRelease();
      s_isInitialized = false;
      CubismLogInfo("CubismFramework.dispose() is complete.");
    }
    /**
     * Cubism FrameworkのAPIを使用する準備が完了したかどうか
     * @return APIを使用する準備が完了していればtrueが返ります。
     */
    static isStarted() {
      return s_isStarted;
    }
    /**
     * Cubism Frameworkのリソース初期化がすでに行われているかどうか
     * @return リソース確保が完了していればtrueが返ります
     */
    static isInitialized() {
      return s_isInitialized;
    }
    /**
     * Core APIにバインドしたログ関数を実行する
     *
     * @praram message ログメッセージ
     */
    static coreLogFunction(message) {
      if (!Live2DCubismCore.Logging.csmGetLogFunction()) {
        return;
      }
      Live2DCubismCore.Logging.csmGetLogFunction()(message);
    }
    /**
     * 現在のログ出力レベル設定の値を返す。
     *
     * @return  現在のログ出力レベル設定の値
     */
    static getLoggingLevel() {
      if (s_option != null) {
        return s_option.loggingLevel;
      }
      return LogLevel.LogLevel_Off;
    }
    /**
     * IDマネージャのインスタンスを取得する
     * @return CubismManagerクラスのインスタンス
     */
    static getIdManager() {
      return s_cubismIdManager;
    }
    /**
     * 静的クラスとして使用する
     * インスタンス化させない
     */
    constructor() {
    }
  };
  var Option = class {
    constructor() {
      __publicField(this, "logFunction");
      // ログ出力の関数オブジェクト
      __publicField(this, "loggingLevel");
    }
    // ログ出力レベルの設定
  };
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["LogLevel_Verbose"] = 0] = "LogLevel_Verbose";
    LogLevel2[LogLevel2["LogLevel_Debug"] = 1] = "LogLevel_Debug";
    LogLevel2[LogLevel2["LogLevel_Info"] = 2] = "LogLevel_Info";
    LogLevel2[LogLevel2["LogLevel_Warning"] = 3] = "LogLevel_Warning";
    LogLevel2[LogLevel2["LogLevel_Error"] = 4] = "LogLevel_Error";
    LogLevel2[LogLevel2["LogLevel_Off"] = 5] = "LogLevel_Off";
  })(LogLevel || (LogLevel = {}));
  var Live2DCubismFramework11;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.Constant = Constant;
    Live2DCubismFramework42.csmDelete = csmDelete;
    Live2DCubismFramework42.CubismFramework = CubismFramework;
  })(Live2DCubismFramework11 || (Live2DCubismFramework11 = {}));

  // src/Live2D/dist/math/cubismviewmatrix.js
  var CubismViewMatrix = class extends CubismMatrix44 {
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      __publicField(this, "_screenLeft");
      // デバイスに対応する論理座標上の範囲（左辺X軸位置）
      __publicField(this, "_screenRight");
      // デバイスに対応する論理座標上の範囲（右辺X軸位置）
      __publicField(this, "_screenTop");
      // デバイスに対応する論理座標上の範囲（上辺Y軸位置）
      __publicField(this, "_screenBottom");
      // デバイスに対応する論理座標上の範囲（下辺Y軸位置）
      __publicField(this, "_maxLeft");
      // 論理座標上の移動可能範囲（左辺X軸位置）
      __publicField(this, "_maxRight");
      // 論理座標上の移動可能範囲（右辺X軸位置）
      __publicField(this, "_maxTop");
      // 論理座標上の移動可能範囲（上辺Y軸位置）
      __publicField(this, "_maxBottom");
      // 論理座標上の移動可能範囲（下辺Y軸位置）
      __publicField(this, "_maxScale");
      // 拡大率の最大値
      __publicField(this, "_minScale");
      this._screenLeft = 0;
      this._screenRight = 0;
      this._screenTop = 0;
      this._screenBottom = 0;
      this._maxLeft = 0;
      this._maxRight = 0;
      this._maxTop = 0;
      this._maxBottom = 0;
      this._maxScale = 0;
      this._minScale = 0;
    }
    /**
     * 移動を調整
     *
     * @param x X軸の移動量
     * @param y Y軸の移動量
     */
    adjustTranslate(x, y) {
      if (this._tr[0] * this._maxLeft + (this._tr[12] + x) > this._screenLeft) {
        x = this._screenLeft - this._tr[0] * this._maxLeft - this._tr[12];
      }
      if (this._tr[0] * this._maxRight + (this._tr[12] + x) < this._screenRight) {
        x = this._screenRight - this._tr[0] * this._maxRight - this._tr[12];
      }
      if (this._tr[5] * this._maxTop + (this._tr[13] + y) < this._screenTop) {
        y = this._screenTop - this._tr[5] * this._maxTop - this._tr[13];
      }
      if (this._tr[5] * this._maxBottom + (this._tr[13] + y) > this._screenBottom) {
        y = this._screenBottom - this._tr[5] * this._maxBottom - this._tr[13];
      }
      const tr1 = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        x,
        y,
        0,
        1
      ]);
      CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * 拡大率を調整
     *
     * @param cx 拡大を行うX軸の中心位置
     * @param cy 拡大を行うY軸の中心位置
     * @param scale 拡大率
     */
    adjustScale(cx, cy, scale) {
      const maxScale = this.getMaxScale();
      const minScale = this.getMinScale();
      const targetScale = scale * this._tr[0];
      if (targetScale < minScale) {
        if (this._tr[0] > 0) {
          scale = minScale / this._tr[0];
        }
      } else if (targetScale > maxScale) {
        if (this._tr[0] > 0) {
          scale = maxScale / this._tr[0];
        }
      }
      const tr1 = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        cx,
        cy,
        0,
        1
      ]);
      const tr2 = new Float32Array([
        scale,
        0,
        0,
        0,
        0,
        scale,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
      const tr3 = new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        -cx,
        -cy,
        0,
        1
      ]);
      CubismMatrix44.multiply(tr3, this._tr, this._tr);
      CubismMatrix44.multiply(tr2, this._tr, this._tr);
      CubismMatrix44.multiply(tr1, this._tr, this._tr);
    }
    /**
     * デバイスに対応する論理座養生の範囲の設定
     *
     * @param left      左辺のX軸の位置
     * @param right     右辺のX軸の位置
     * @param bottom    下辺のY軸の位置
     * @param top       上辺のY軸の位置
     */
    setScreenRect(left, right, bottom, top) {
      this._screenLeft = left;
      this._screenRight = right;
      this._screenBottom = bottom;
      this._screenTop = top;
    }
    /**
     * デバイスに対応する論理座標上の移動可能範囲の設定
     * @param left      左辺のX軸の位置
     * @param right     右辺のX軸の位置
     * @param bottom    下辺のY軸の位置
     * @param top       上辺のY軸の位置
     */
    setMaxScreenRect(left, right, bottom, top) {
      this._maxLeft = left;
      this._maxRight = right;
      this._maxTop = top;
      this._maxBottom = bottom;
    }
    /**
     * 最大拡大率の設定
     * @param maxScale 最大拡大率
     */
    setMaxScale(maxScale) {
      this._maxScale = maxScale;
    }
    /**
     * 最小拡大率の設定
     * @param minScale 最小拡大率
     */
    setMinScale(minScale) {
      this._minScale = minScale;
    }
    /**
     * 最大拡大率の取得
     * @return 最大拡大率
     */
    getMaxScale() {
      return this._maxScale;
    }
    /**
     * 最小拡大率の取得
     * @return 最小拡大率
     */
    getMinScale() {
      return this._minScale;
    }
    /**
     * 拡大率が最大になっているかを確認する
     *
     * @return true 拡大率は最大
     * @return false 拡大率は最大ではない
     */
    isMaxScale() {
      return this.getScaleX() >= this._maxScale;
    }
    /**
     * 拡大率が最小になっているかを確認する
     *
     * @return true 拡大率は最小
     * @return false 拡大率は最小ではない
     */
    isMinScale() {
      return this.getScaleX() <= this._minScale;
    }
    /**
     * デバイスに対応する論理座標の左辺のＸ軸位置を取得する
     * @return デバイスに対応する論理座標の左辺のX軸位置
     */
    getScreenLeft() {
      return this._screenLeft;
    }
    /**
     * デバイスに対応する論理座標の右辺のＸ軸位置を取得する
     * @return デバイスに対応する論理座標の右辺のX軸位置
     */
    getScreenRight() {
      return this._screenRight;
    }
    /**
     * デバイスに対応する論理座標の下辺のY軸位置を取得する
     * @return デバイスに対応する論理座標の下辺のY軸位置
     */
    getScreenBottom() {
      return this._screenBottom;
    }
    /**
     * デバイスに対応する論理座標の上辺のY軸位置を取得する
     * @return デバイスに対応する論理座標の上辺のY軸位置
     */
    getScreenTop() {
      return this._screenTop;
    }
    /**
     * 左辺のX軸位置の最大値の取得
     * @return 左辺のX軸位置の最大値
     */
    getMaxLeft() {
      return this._maxLeft;
    }
    /**
     * 右辺のX軸位置の最大値の取得
     * @return 右辺のX軸位置の最大値
     */
    getMaxRight() {
      return this._maxRight;
    }
    /**
     * 下辺のY軸位置の最大値の取得
     * @return 下辺のY軸位置の最大値
     */
    getMaxBottom() {
      return this._maxBottom;
    }
    /**
     * 上辺のY軸位置の最大値の取得
     * @return 上辺のY軸位置の最大値
     */
    getMaxTop() {
      return this._maxTop;
    }
    // 拡大率の最小値
  };
  var Live2DCubismFramework12;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismViewMatrix = CubismViewMatrix;
  })(Live2DCubismFramework12 || (Live2DCubismFramework12 = {}));

  // src/Live2D/lappglmanager.js
  var s_instance = null;
  var LAppGlManager = class _LAppGlManager {
    /**
     * クラスのインスタンス（シングルトン）を返す。
     * インスタンスが生成されていない場合は内部でインスタンスを生成する。
     *
     * @return クラスのインスタンス
     */
    static getInstance(canvas) {
      if (s_instance == null) {
        s_instance = new _LAppGlManager(canvas);
      }
      return s_instance;
    }
    /**
     * クラスのインスタンス（シングルトン）を解放する。
     */
    static releaseInstance() {
      if (s_instance != null) {
        s_instance.release();
      }
      s_instance = null;
    }
    constructor(canvas) {
      this.gl = canvas.getContext("webgl");
      if (!this.gl) {
        alert("[L2D] Cannot initialize WebGL. This browser does not support.");
        this.gl = null;
      }
    }
    /**
     * 解放する。
     */
    release() {
    }
  };

  // src/Live2D/lappdefine.js
  var ModelDir = [
    "Ver.7"
  ];
  var ModelDirSize = ModelDir.length;
  var MotionGroupIdle = "Idle";
  var PriorityIdle = 1;
  var PriorityForce = 3;
  var MOCConsistencyValidationEnable = true;
  var CubismLoggingLevel = LogLevel.LogLevel_Verbose;

  // src/Live2D/dist/cubismdefaultparameterid.js
  var CubismDefaultParameterId = Object.freeze({
    // パーツID
    HitAreaPrefix: "HitArea",
    HitAreaHead: "Head",
    HitAreaBody: "Body",
    PartsIdCore: "Parts01Core",
    PartsArmPrefix: "Parts01Arm_",
    PartsArmLPrefix: "Parts01ArmL_",
    PartsArmRPrefix: "Parts01ArmR_",
    // パラメータID
    ParamAngleX: "ParamAngleX",
    ParamAngleY: "ParamAngleY",
    ParamAngleZ: "ParamAngleZ",
    ParamEyeLOpen: "ParamEyeLOpen",
    ParamEyeLSmile: "ParamEyeLSmile",
    ParamEyeROpen: "ParamEyeROpen",
    ParamEyeRSmile: "ParamEyeRSmile",
    ParamEyeBallX: "ParamEyeBallX",
    ParamEyeBallY: "ParamEyeBallY",
    ParamEyeBallForm: "ParamEyeBallForm",
    ParamBrowLY: "ParamBrowLY",
    ParamBrowRY: "ParamBrowRY",
    ParamBrowLX: "ParamBrowLX",
    ParamBrowRX: "ParamBrowRX",
    ParamBrowLAngle: "ParamBrowLAngle",
    ParamBrowRAngle: "ParamBrowRAngle",
    ParamBrowLForm: "ParamBrowLForm",
    ParamBrowRForm: "ParamBrowRForm",
    ParamMouthForm: "ParamMouthForm",
    ParamMouthOpenY: "ParamMouthOpenY",
    ParamCheek: "ParamCheek",
    ParamBodyAngleX: "ParamBodyAngleX",
    ParamBodyAngleY: "ParamBodyAngleY",
    ParamBodyAngleZ: "ParamBodyAngleZ",
    ParamBreath: "ParamBreath",
    ParamArmLA: "ParamArmLA",
    ParamArmRA: "ParamArmRA",
    ParamArmLB: "ParamArmLB",
    ParamArmRB: "ParamArmRB",
    ParamHandL: "ParamHandL",
    ParamHandR: "ParamHandR",
    ParamHairFront: "ParamHairFront",
    ParamHairSide: "ParamHairSide",
    ParamHairBack: "ParamHairBack",
    ParamHairFluffy: "ParamHairFluffy",
    ParamShoulderY: "ParamShoulderY",
    ParamBustX: "ParamBustX",
    ParamBustY: "ParamBustY",
    ParamBaseX: "ParamBaseX",
    ParamBaseY: "ParamBaseY",
    ParamNONE: "NONE:"
  });
  var Live2DCubismFramework13;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.HitAreaBody = CubismDefaultParameterId.HitAreaBody;
    Live2DCubismFramework42.HitAreaHead = CubismDefaultParameterId.HitAreaHead;
    Live2DCubismFramework42.HitAreaPrefix = CubismDefaultParameterId.HitAreaPrefix;
    Live2DCubismFramework42.ParamAngleX = CubismDefaultParameterId.ParamAngleX;
    Live2DCubismFramework42.ParamAngleY = CubismDefaultParameterId.ParamAngleY;
    Live2DCubismFramework42.ParamAngleZ = CubismDefaultParameterId.ParamAngleZ;
    Live2DCubismFramework42.ParamArmLA = CubismDefaultParameterId.ParamArmLA;
    Live2DCubismFramework42.ParamArmLB = CubismDefaultParameterId.ParamArmLB;
    Live2DCubismFramework42.ParamArmRA = CubismDefaultParameterId.ParamArmRA;
    Live2DCubismFramework42.ParamArmRB = CubismDefaultParameterId.ParamArmRB;
    Live2DCubismFramework42.ParamBaseX = CubismDefaultParameterId.ParamBaseX;
    Live2DCubismFramework42.ParamBaseY = CubismDefaultParameterId.ParamBaseY;
    Live2DCubismFramework42.ParamBodyAngleX = CubismDefaultParameterId.ParamBodyAngleX;
    Live2DCubismFramework42.ParamBodyAngleY = CubismDefaultParameterId.ParamBodyAngleY;
    Live2DCubismFramework42.ParamBodyAngleZ = CubismDefaultParameterId.ParamBodyAngleZ;
    Live2DCubismFramework42.ParamBreath = CubismDefaultParameterId.ParamBreath;
    Live2DCubismFramework42.ParamBrowLAngle = CubismDefaultParameterId.ParamBrowLAngle;
    Live2DCubismFramework42.ParamBrowLForm = CubismDefaultParameterId.ParamBrowLForm;
    Live2DCubismFramework42.ParamBrowLX = CubismDefaultParameterId.ParamBrowLX;
    Live2DCubismFramework42.ParamBrowLY = CubismDefaultParameterId.ParamBrowLY;
    Live2DCubismFramework42.ParamBrowRAngle = CubismDefaultParameterId.ParamBrowRAngle;
    Live2DCubismFramework42.ParamBrowRForm = CubismDefaultParameterId.ParamBrowRForm;
    Live2DCubismFramework42.ParamBrowRX = CubismDefaultParameterId.ParamBrowRX;
    Live2DCubismFramework42.ParamBrowRY = CubismDefaultParameterId.ParamBrowRY;
    Live2DCubismFramework42.ParamBustX = CubismDefaultParameterId.ParamBustX;
    Live2DCubismFramework42.ParamBustY = CubismDefaultParameterId.ParamBustY;
    Live2DCubismFramework42.ParamCheek = CubismDefaultParameterId.ParamCheek;
    Live2DCubismFramework42.ParamEyeBallForm = CubismDefaultParameterId.ParamEyeBallForm;
    Live2DCubismFramework42.ParamEyeBallX = CubismDefaultParameterId.ParamEyeBallX;
    Live2DCubismFramework42.ParamEyeBallY = CubismDefaultParameterId.ParamEyeBallY;
    Live2DCubismFramework42.ParamEyeLOpen = CubismDefaultParameterId.ParamEyeLOpen;
    Live2DCubismFramework42.ParamEyeLSmile = CubismDefaultParameterId.ParamEyeLSmile;
    Live2DCubismFramework42.ParamEyeROpen = CubismDefaultParameterId.ParamEyeROpen;
    Live2DCubismFramework42.ParamEyeRSmile = CubismDefaultParameterId.ParamEyeRSmile;
    Live2DCubismFramework42.ParamHairBack = CubismDefaultParameterId.ParamHairBack;
    Live2DCubismFramework42.ParamHairFluffy = CubismDefaultParameterId.ParamHairFluffy;
    Live2DCubismFramework42.ParamHairFront = CubismDefaultParameterId.ParamHairFront;
    Live2DCubismFramework42.ParamHairSide = CubismDefaultParameterId.ParamHairSide;
    Live2DCubismFramework42.ParamHandL = CubismDefaultParameterId.ParamHandL;
    Live2DCubismFramework42.ParamHandR = CubismDefaultParameterId.ParamHandR;
    Live2DCubismFramework42.ParamMouthForm = CubismDefaultParameterId.ParamMouthForm;
    Live2DCubismFramework42.ParamMouthOpenY = CubismDefaultParameterId.ParamMouthOpenY;
    Live2DCubismFramework42.ParamNONE = CubismDefaultParameterId.ParamNONE;
    Live2DCubismFramework42.ParamShoulderY = CubismDefaultParameterId.ParamShoulderY;
    Live2DCubismFramework42.PartsArmLPrefix = CubismDefaultParameterId.PartsArmLPrefix;
    Live2DCubismFramework42.PartsArmPrefix = CubismDefaultParameterId.PartsArmPrefix;
    Live2DCubismFramework42.PartsArmRPrefix = CubismDefaultParameterId.PartsArmRPrefix;
    Live2DCubismFramework42.PartsIdCore = CubismDefaultParameterId.PartsIdCore;
  })(Live2DCubismFramework13 || (Live2DCubismFramework13 = {}));

  // src/Live2D/dist/icubismmodelsetting.js
  var ICubismModelSetting = class {
  };
  var Live2DCubismFramework14;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.ICubismModelSetting = ICubismModelSetting;
  })(Live2DCubismFramework14 || (Live2DCubismFramework14 = {}));

  // src/Live2D/dist/cubismmodelsettingjson.js
  var FileReferences = "FileReferences";
  var Groups = "Groups";
  var Layout = "Layout";
  var HitAreas = "HitAreas";
  var Moc = "Moc";
  var Textures = "Textures";
  var Physics = "Physics";
  var Pose = "Pose";
  var Expressions = "Expressions";
  var Motions = "Motions";
  var UserData = "UserData";
  var Name = "Name";
  var FilePath = "File";
  var Id = "Id";
  var Ids = "Ids";
  var SoundPath = "Sound";
  var FadeInTime = "FadeInTime";
  var FadeOutTime = "FadeOutTime";
  var LipSync = "LipSync";
  var EyeBlink = "EyeBlink";
  var FrequestNode;
  (function(FrequestNode2) {
    FrequestNode2[FrequestNode2["FrequestNode_Groups"] = 0] = "FrequestNode_Groups";
    FrequestNode2[FrequestNode2["FrequestNode_Moc"] = 1] = "FrequestNode_Moc";
    FrequestNode2[FrequestNode2["FrequestNode_Motions"] = 2] = "FrequestNode_Motions";
    FrequestNode2[FrequestNode2["FrequestNode_Expressions"] = 3] = "FrequestNode_Expressions";
    FrequestNode2[FrequestNode2["FrequestNode_Textures"] = 4] = "FrequestNode_Textures";
    FrequestNode2[FrequestNode2["FrequestNode_Physics"] = 5] = "FrequestNode_Physics";
    FrequestNode2[FrequestNode2["FrequestNode_Pose"] = 6] = "FrequestNode_Pose";
    FrequestNode2[FrequestNode2["FrequestNode_HitAreas"] = 7] = "FrequestNode_HitAreas";
  })(FrequestNode || (FrequestNode = {}));
  var CubismModelSettingJson = class extends ICubismModelSetting {
    /**
     * 引数付きコンストラクタ
     *
     * @param buffer    Model3Jsonをバイト配列として読み込んだデータバッファ
     * @param size      Model3Jsonのデータサイズ
     */
    constructor(buffer, size) {
      super();
      __publicField(this, "_json");
      __publicField(this, "_jsonValue");
      this._json = CubismJson.create(buffer, size);
      if (this.getJson()) {
        this._jsonValue = new csmVector();
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(Groups));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Moc));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Motions));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Expressions));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Textures));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Physics));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(FileReferences).getValueByString(Pose));
        this._jsonValue.pushBack(this.getJson().getRoot().getValueByString(HitAreas));
      }
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      CubismJson.delete(this._json);
      this._jsonValue = null;
    }
    /**
     * CubismJsonオブジェクトを取得する
     *
     * @return CubismJson
     */
    getJson() {
      return this._json;
    }
    /**
     * Mocファイルの名前を取得する
     * @return Mocファイルの名前
     */
    getModelFileName() {
      if (!this.isExistModelFile()) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Moc).getRawString();
    }
    /**
     * モデルが使用するテクスチャの数を取得する
     * テクスチャの数
     */
    getTextureCount() {
      if (!this.isExistTextureFiles()) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Textures).getSize();
    }
    /**
     * テクスチャが配置されたディレクトリの名前を取得する
     * @return テクスチャが配置されたディレクトリの名前
     */
    getTextureDirectory() {
      const texturePath = this._jsonValue.at(FrequestNode.FrequestNode_Textures).getValueByIndex(0).getRawString();
      const pathArray = texturePath.split("/");
      const arrayLength = pathArray.length - 1;
      let textureDirectoryStr = "";
      for (let i = 0; i < arrayLength; i++) {
        textureDirectoryStr += pathArray[i];
        if (i < arrayLength - 1) {
          textureDirectoryStr += "/";
        }
      }
      return textureDirectoryStr;
    }
    /**
     * モデルが使用するテクスチャの名前を取得する
     * @param index 配列のインデックス値
     * @return テクスチャの名前
     */
    getTextureFileName(index) {
      return this._jsonValue.at(FrequestNode.FrequestNode_Textures).getValueByIndex(index).getRawString();
    }
    /**
     * モデルに設定された当たり判定の数を取得する
     * @return モデルに設定された当たり判定の数
     */
    getHitAreasCount() {
      if (!this.isExistHitAreas()) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_HitAreas).getSize();
    }
    /**
     * 当たり判定に設定されたIDを取得する
     *
     * @param index 配列のindex
     * @return 当たり判定に設定されたID
     */
    getHitAreaId(index) {
      return CubismFramework.getIdManager().getId(this._jsonValue.at(FrequestNode.FrequestNode_HitAreas).getValueByIndex(index).getValueByString(Id).getRawString());
    }
    /**
     * 当たり判定に設定された名前を取得する
     * @param index 配列のインデックス値
     * @return 当たり判定に設定された名前
     */
    getHitAreaName(index) {
      return this._jsonValue.at(FrequestNode.FrequestNode_HitAreas).getValueByIndex(index).getValueByString(Name).getRawString();
    }
    /**
     * 物理演算設定ファイルの名前を取得する
     * @return 物理演算設定ファイルの名前
     */
    getPhysicsFileName() {
      if (!this.isExistPhysicsFile()) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Physics).getRawString();
    }
    /**
     * パーツ切り替え設定ファイルの名前を取得する
     * @return パーツ切り替え設定ファイルの名前
     */
    getPoseFileName() {
      if (!this.isExistPoseFile()) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Pose).getRawString();
    }
    /**
     * 表情設定ファイルの数を取得する
     * @return 表情設定ファイルの数
     */
    getExpressionCount() {
      if (!this.isExistExpressionFile()) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Expressions).getSize();
    }
    /**
     * 表情設定ファイルを識別する名前（別名）を取得する
     * @param index 配列のインデックス値
     * @return 表情の名前
     */
    getExpressionName(index) {
      return this._jsonValue.at(FrequestNode.FrequestNode_Expressions).getValueByIndex(index).getValueByString(Name).getRawString();
    }
    /**
     * 表情設定ファイルの名前を取得する
     * @param index 配列のインデックス値
     * @return 表情設定ファイルの名前
     */
    getExpressionFileName(index) {
      return this._jsonValue.at(FrequestNode.FrequestNode_Expressions).getValueByIndex(index).getValueByString(FilePath).getRawString();
    }
    /**
     * モーショングループの数を取得する
     * @return モーショングループの数
     */
    getMotionGroupCount() {
      if (!this.isExistMotionGroups()) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getKeys().getSize();
    }
    /**
     * モーショングループの名前を取得する
     * @param index 配列のインデックス値
     * @return モーショングループの名前
     */
    getMotionGroupName(index) {
      if (!this.isExistMotionGroups()) {
        return null;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getKeys().at(index);
    }
    /**
     * モーショングループに含まれるモーションの数を取得する
     * @param groupName モーショングループの名前
     * @return モーショングループの数
     */
    getMotionCount(groupName) {
      if (!this.isExistMotionGroupName(groupName)) {
        return 0;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getSize();
    }
    /**
     * グループ名とインデックス値からモーションファイル名を取得する
     * @param groupName モーショングループの名前
     * @param index     配列のインデックス値
     * @return モーションファイルの名前
     */
    getMotionFileName(groupName, index) {
      if (!this.isExistMotionGroupName(groupName)) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FilePath).getRawString();
    }
    /**
     * モーションに対応するサウンドファイルの名前を取得する
     * @param groupName モーショングループの名前
     * @param index 配列のインデックス値
     * @return サウンドファイルの名前
     */
    getMotionSoundFileName(groupName, index) {
      if (!this.isExistMotionSoundFile(groupName, index)) {
        return "";
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(SoundPath).getRawString();
    }
    /**
     * モーション開始時のフェードイン処理時間を取得する
     * @param groupName モーショングループの名前
     * @param index 配列のインデックス値
     * @return フェードイン処理時間[秒]
     */
    getMotionFadeInTimeValue(groupName, index) {
      if (!this.isExistMotionFadeIn(groupName, index)) {
        return -1;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeInTime).toFloat();
    }
    /**
     * モーション終了時のフェードアウト処理時間を取得する
     * @param groupName モーショングループの名前
     * @param index 配列のインデックス値
     * @return フェードアウト処理時間[秒]
     */
    getMotionFadeOutTimeValue(groupName, index) {
      if (!this.isExistMotionFadeOut(groupName, index)) {
        return -1;
      }
      return this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeOutTime).toFloat();
    }
    /**
     * ユーザーデータのファイル名を取得する
     * @return ユーザーデータのファイル名
     */
    getUserDataFile() {
      if (!this.isExistUserDataFile()) {
        return "";
      }
      return this.getJson().getRoot().getValueByString(FileReferences).getValueByString(UserData).getRawString();
    }
    /**
     * レイアウト情報を取得する
     * @param outLayoutMap csmMapクラスのインスタンス
     * @return true レイアウト情報が存在する
     * @return false レイアウト情報が存在しない
     */
    getLayoutMap(outLayoutMap) {
      const map = this.getJson().getRoot().getValueByString(Layout).getMap();
      if (map == null) {
        return false;
      }
      let ret = false;
      for (const ite = map.begin(); ite.notEqual(map.end()); ite.preIncrement()) {
        outLayoutMap.setValue(ite.ptr().first, ite.ptr().second.toFloat());
        ret = true;
      }
      return ret;
    }
    /**
     * 目パチに関連付けられたパラメータの数を取得する
     * @return 目パチに関連付けられたパラメータの数
     */
    getEyeBlinkParameterCount() {
      if (!this.isExistEyeBlinkParameters()) {
        return 0;
      }
      let num = 0;
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {
        const refI = this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i);
        if (refI.isNull() || refI.isError()) {
          continue;
        }
        if (refI.getValueByString(Name).getRawString() == EyeBlink) {
          num = refI.getValueByString(Ids).getVector().getSize();
          break;
        }
      }
      return num;
    }
    /**
     * 目パチに関連付けられたパラメータのIDを取得する
     * @param index 配列のインデックス値
     * @return パラメータID
     */
    getEyeBlinkParameterId(index) {
      if (!this.isExistEyeBlinkParameters()) {
        return null;
      }
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {
        const refI = this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i);
        if (refI.isNull() || refI.isError()) {
          continue;
        }
        if (refI.getValueByString(Name).getRawString() == EyeBlink) {
          return CubismFramework.getIdManager().getId(refI.getValueByString(Ids).getValueByIndex(index).getRawString());
        }
      }
      return null;
    }
    /**
     * リップシンクに関連付けられたパラメータの数を取得する
     * @return リップシンクに関連付けられたパラメータの数
     */
    getLipSyncParameterCount() {
      if (!this.isExistLipSyncParameters()) {
        return 0;
      }
      let num = 0;
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {
        const refI = this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i);
        if (refI.isNull() || refI.isError()) {
          continue;
        }
        if (refI.getValueByString(Name).getRawString() == LipSync) {
          num = refI.getValueByString(Ids).getVector().getSize();
          break;
        }
      }
      return num;
    }
    /**
     * リップシンクに関連付けられたパラメータの数を取得する
     * @param index 配列のインデックス値
     * @return パラメータID
     */
    getLipSyncParameterId(index) {
      if (!this.isExistLipSyncParameters()) {
        return null;
      }
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); i++) {
        const refI = this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i);
        if (refI.isNull() || refI.isError()) {
          continue;
        }
        if (refI.getValueByString(Name).getRawString() == LipSync) {
          return CubismFramework.getIdManager().getId(refI.getValueByString(Ids).getValueByIndex(index).getRawString());
        }
      }
      return null;
    }
    /**
     * モデルファイルのキーが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistModelFile() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Moc);
      return !node.isNull() && !node.isError();
    }
    /**
     * テクスチャファイルのキーが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistTextureFiles() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Textures);
      return !node.isNull() && !node.isError();
    }
    /**
     * 当たり判定のキーが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistHitAreas() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_HitAreas);
      return !node.isNull() && !node.isError();
    }
    /**
     * 物理演算ファイルのキーが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistPhysicsFile() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Physics);
      return !node.isNull() && !node.isError();
    }
    /**
     * ポーズ設定ファイルのキーが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistPoseFile() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Pose);
      return !node.isNull() && !node.isError();
    }
    /**
     * 表情設定ファイルのキーが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistExpressionFile() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Expressions);
      return !node.isNull() && !node.isError();
    }
    /**
     * モーショングループのキーが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistMotionGroups() {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions);
      return !node.isNull() && !node.isError();
    }
    /**
     * 引数で指定したモーショングループのキーが存在するかどうかを確認する
     * @param groupName  グループ名
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistMotionGroupName(groupName) {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName);
      return !node.isNull() && !node.isError();
    }
    /**
     * 引数で指定したモーションに対応するサウンドファイルのキーが存在するかどうかを確認する
     * @param groupName  グループ名
     * @param index 配列のインデックス値
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistMotionSoundFile(groupName, index) {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(SoundPath);
      return !node.isNull() && !node.isError();
    }
    /**
     * 引数で指定したモーションに対応するフェードイン時間のキーが存在するかどうかを確認する
     * @param groupName  グループ名
     * @param index 配列のインデックス値
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistMotionFadeIn(groupName, index) {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeInTime);
      return !node.isNull() && !node.isError();
    }
    /**
     * 引数で指定したモーションに対応するフェードアウト時間のキーが存在するかどうかを確認する
     * @param groupName  グループ名
     * @param index 配列のインデックス値
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistMotionFadeOut(groupName, index) {
      const node = this._jsonValue.at(FrequestNode.FrequestNode_Motions).getValueByString(groupName).getValueByIndex(index).getValueByString(FadeOutTime);
      return !node.isNull() && !node.isError();
    }
    /**
     * UserDataのファイル名が存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistUserDataFile() {
      const node = this.getJson().getRoot().getValueByString(FileReferences).getValueByString(UserData);
      return !node.isNull() && !node.isError();
    }
    /**
     * 目ぱちに対応付けられたパラメータが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistEyeBlinkParameters() {
      if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).isNull() || this._jsonValue.at(FrequestNode.FrequestNode_Groups).isError()) {
        return false;
      }
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); ++i) {
        if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i).getValueByString(Name).getRawString() == EyeBlink) {
          return true;
        }
      }
      return false;
    }
    /**
     * リップシンクに対応付けられたパラメータが存在するかどうかを確認する
     * @return true キーが存在する
     * @return false キーが存在しない
     */
    isExistLipSyncParameters() {
      if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).isNull() || this._jsonValue.at(FrequestNode.FrequestNode_Groups).isError()) {
        return false;
      }
      for (let i = 0; i < this._jsonValue.at(FrequestNode.FrequestNode_Groups).getSize(); ++i) {
        if (this._jsonValue.at(FrequestNode.FrequestNode_Groups).getValueByIndex(i).getValueByString(Name).getRawString() == LipSync) {
          return true;
        }
      }
      return false;
    }
  };
  var Live2DCubismFramework15;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModelSettingJson = CubismModelSettingJson;
  })(Live2DCubismFramework15 || (Live2DCubismFramework15 = {}));

  // src/Live2D/dist/effect/cubismbreath.js
  var CubismBreath = class _CubismBreath {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_breathParameters");
      // 呼吸にひもづいているパラメータのリスト
      __publicField(this, "_currentTime");
      this._currentTime = 0;
    }
    /**
     * インスタンスの作成
     */
    static create() {
      return new _CubismBreath();
    }
    /**
     * インスタンスの破棄
     * @param instance 対象のCubismBreath
     */
    static delete(instance) {
      if (instance != null) {
        instance = null;
      }
    }
    /**
     * 呼吸のパラメータの紐づけ
     * @param breathParameters 呼吸を紐づけたいパラメータのリスト
     */
    setParameters(breathParameters) {
      this._breathParameters = breathParameters;
    }
    /**
     * 呼吸に紐づいているパラメータの取得
     * @return 呼吸に紐づいているパラメータのリスト
     */
    getParameters() {
      return this._breathParameters;
    }
    /**
     * モデルのパラメータの更新
     * @param model 対象のモデル
     * @param deltaTimeSeconds デルタ時間[秒]
     */
    updateParameters(model, deltaTimeSeconds) {
      this._currentTime += deltaTimeSeconds;
      const t2 = this._currentTime * 2 * 3.14159;
      for (let i = 0; i < this._breathParameters.getSize(); ++i) {
        const data = this._breathParameters.at(i);
        model.addParameterValueById(data.parameterId, data.offset + data.peak * Math.sin(t2 / data.cycle), data.weight);
      }
    }
    // 積算時間[秒]
  };
  var BreathParameterData = class {
    /**
     * コンストラクタ
     * @param parameterId   呼吸をひもづけるパラメータID
     * @param offset        呼吸を正弦波としたときの、波のオフセット
     * @param peak          呼吸を正弦波としたときの、波の高さ
     * @param cycle         呼吸を正弦波としたときの、波の周期
     * @param weight        パラメータへの重み
     */
    constructor(parameterId, offset, peak, cycle, weight) {
      __publicField(this, "parameterId");
      // 呼吸をひもづけるパラメータID\
      __publicField(this, "offset");
      // 呼吸を正弦波としたときの、波のオフセット
      __publicField(this, "peak");
      // 呼吸を正弦波としたときの、波の高さ
      __publicField(this, "cycle");
      // 呼吸を正弦波としたときの、波の周期
      __publicField(this, "weight");
      this.parameterId = parameterId == void 0 ? null : parameterId;
      this.offset = offset == void 0 ? 0 : offset;
      this.peak = peak == void 0 ? 0 : peak;
      this.cycle = cycle == void 0 ? 0 : cycle;
      this.weight = weight == void 0 ? 0 : weight;
    }
    // パラメータへの重み
  };
  var Live2DCubismFramework16;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.BreathParameterData = BreathParameterData;
    Live2DCubismFramework42.CubismBreath = CubismBreath;
  })(Live2DCubismFramework16 || (Live2DCubismFramework16 = {}));

  // src/Live2D/dist/effect/cubismeyeblink.js
  var _CubismEyeBlink = class _CubismEyeBlink {
    /**
     * コンストラクタ
     * @param modelSetting モデルの設定情報
     */
    constructor(modelSetting) {
      __publicField(this, "_blinkingState");
      // 現在の状態
      __publicField(this, "_parameterIds");
      // 操作対象のパラメータのIDのリスト
      __publicField(this, "_nextBlinkingTime");
      // 次のまばたきの時刻[秒]
      __publicField(this, "_stateStartTimeSeconds");
      // 現在の状態が開始した時刻[秒]
      __publicField(this, "_blinkingIntervalSeconds");
      // まばたきの間隔[秒]
      __publicField(this, "_closingSeconds");
      // まぶたを閉じる動作の所要時間[秒]
      __publicField(this, "_closedSeconds");
      // まぶたを閉じている動作の所要時間[秒]
      __publicField(this, "_openingSeconds");
      // まぶたを開く動作の所要時間[秒]
      __publicField(this, "_userTimeSeconds");
      this._blinkingState = EyeState.EyeState_First;
      this._nextBlinkingTime = 0;
      this._stateStartTimeSeconds = 0;
      this._blinkingIntervalSeconds = 4;
      this._closingSeconds = 0.1;
      this._closedSeconds = 0.05;
      this._openingSeconds = 0.15;
      this._userTimeSeconds = 0;
      this._parameterIds = new csmVector();
      if (modelSetting == null) {
        return;
      }
      for (let i = 0; i < modelSetting.getEyeBlinkParameterCount(); ++i) {
        this._parameterIds.pushBack(modelSetting.getEyeBlinkParameterId(i));
      }
    }
    /**
     * インスタンスを作成する
     * @param modelSetting モデルの設定情報
     * @return 作成されたインスタンス
     * @note 引数がNULLの場合、パラメータIDが設定されていない空のインスタンスを作成する。
     */
    static create(modelSetting = null) {
      return new _CubismEyeBlink(modelSetting);
    }
    /**
     * インスタンスの破棄
     * @param eyeBlink 対象のCubismEyeBlink
     */
    static delete(eyeBlink) {
      if (eyeBlink != null) {
        eyeBlink = null;
      }
    }
    /**
     * まばたきの間隔の設定
     * @param blinkingInterval まばたきの間隔の時間[秒]
     */
    setBlinkingInterval(blinkingInterval) {
      this._blinkingIntervalSeconds = blinkingInterval;
    }
    /**
     * まばたきのモーションの詳細設定
     * @param closing   まぶたを閉じる動作の所要時間[秒]
     * @param closed    まぶたを閉じている動作の所要時間[秒]
     * @param opening   まぶたを開く動作の所要時間[秒]
     */
    setBlinkingSetting(closing, closed, opening) {
      this._closingSeconds = closing;
      this._closedSeconds = closed;
      this._openingSeconds = opening;
    }
    /**
     * まばたきさせるパラメータIDのリストの設定
     * @param parameterIds パラメータのIDのリスト
     */
    setParameterIds(parameterIds) {
      this._parameterIds = parameterIds;
    }
    /**
     * まばたきさせるパラメータIDのリストの取得
     * @return パラメータIDのリスト
     */
    getParameterIds() {
      return this._parameterIds;
    }
    /**
     * モデルのパラメータの更新
     * @param model 対象のモデル
     * @param deltaTimeSeconds デルタ時間[秒]
     */
    updateParameters(model, deltaTimeSeconds) {
      this._userTimeSeconds += deltaTimeSeconds;
      let parameterValue;
      let t2 = 0;
      const blinkingState = this._blinkingState;
      switch (blinkingState) {
        case EyeState.EyeState_Closing:
          t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closingSeconds;
          if (t2 >= 1) {
            t2 = 1;
            this._blinkingState = EyeState.EyeState_Closed;
            this._stateStartTimeSeconds = this._userTimeSeconds;
          }
          parameterValue = 1 - t2;
          break;
        case EyeState.EyeState_Closed:
          t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closedSeconds;
          if (t2 >= 1) {
            this._blinkingState = EyeState.EyeState_Opening;
            this._stateStartTimeSeconds = this._userTimeSeconds;
          }
          parameterValue = 0;
          break;
        case EyeState.EyeState_Opening:
          t2 = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._openingSeconds;
          if (t2 >= 1) {
            t2 = 1;
            this._blinkingState = EyeState.EyeState_Interval;
            this._nextBlinkingTime = this.determinNextBlinkingTiming();
          }
          parameterValue = t2;
          break;
        case EyeState.EyeState_Interval:
          if (this._nextBlinkingTime < this._userTimeSeconds) {
            this._blinkingState = EyeState.EyeState_Closing;
            this._stateStartTimeSeconds = this._userTimeSeconds;
          }
          parameterValue = 1;
          break;
        case EyeState.EyeState_First:
        default:
          this._blinkingState = EyeState.EyeState_Interval;
          this._nextBlinkingTime = this.determinNextBlinkingTiming();
          parameterValue = 1;
          break;
      }
      if (!_CubismEyeBlink.CloseIfZero) {
        parameterValue = -parameterValue;
      }
      for (let i = 0; i < this._parameterIds.getSize(); ++i) {
        model.setParameterValueById(this._parameterIds.at(i), parameterValue);
      }
    }
    /**
     * 次の瞬きのタイミングの決定
     *
     * @return 次のまばたきを行う時刻[秒]
     */
    determinNextBlinkingTiming() {
      const r = Math.random();
      return this._userTimeSeconds + r * (2 * this._blinkingIntervalSeconds - 1);
    }
  };
  // デルタ時間の積算値[秒]
  /**
   * IDで指定された目のパラメータが、0のときに閉じるなら true 、1の時に閉じるなら false 。
   */
  __publicField(_CubismEyeBlink, "CloseIfZero", true);
  var CubismEyeBlink = _CubismEyeBlink;
  var EyeState;
  (function(EyeState2) {
    EyeState2[EyeState2["EyeState_First"] = 0] = "EyeState_First";
    EyeState2[EyeState2["EyeState_Interval"] = 1] = "EyeState_Interval";
    EyeState2[EyeState2["EyeState_Closing"] = 2] = "EyeState_Closing";
    EyeState2[EyeState2["EyeState_Closed"] = 3] = "EyeState_Closed";
    EyeState2[EyeState2["EyeState_Opening"] = 4] = "EyeState_Opening";
  })(EyeState || (EyeState = {}));
  var Live2DCubismFramework17;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismEyeBlink = CubismEyeBlink;
    Live2DCubismFramework42.EyeState = EyeState;
  })(Live2DCubismFramework17 || (Live2DCubismFramework17 = {}));

  // src/Live2D/dist/effect/cubismpose.js
  var Epsilon = 1e-3;
  var DefaultFadeInSeconds = 0.5;
  var FadeIn = "FadeInTime";
  var Link = "Link";
  var Groups2 = "Groups";
  var Id2 = "Id";
  var CubismPose = class _CubismPose {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_partGroups");
      // パーツグループ
      __publicField(this, "_partGroupCounts");
      // それぞれのパーツグループの個数
      __publicField(this, "_fadeTimeSeconds");
      // フェード時間[秒]
      __publicField(this, "_lastModel");
      this._fadeTimeSeconds = DefaultFadeInSeconds;
      this._lastModel = null;
      this._partGroups = new csmVector();
      this._partGroupCounts = new csmVector();
    }
    /**
     * インスタンスの作成
     * @param pose3json pose3.jsonのデータ
     * @param size pose3.jsonのデータのサイズ[byte]
     * @return 作成されたインスタンス
     */
    static create(pose3json, size) {
      const json = CubismJson.create(pose3json, size);
      if (!json) {
        return null;
      }
      const ret = new _CubismPose();
      const root = json.getRoot();
      if (!root.getValueByString(FadeIn).isNull()) {
        ret._fadeTimeSeconds = root.getValueByString(FadeIn).toFloat(DefaultFadeInSeconds);
        if (ret._fadeTimeSeconds <= 0) {
          ret._fadeTimeSeconds = DefaultFadeInSeconds;
        }
      }
      const poseListInfo = root.getValueByString(Groups2);
      const poseCount = poseListInfo.getSize();
      for (let poseIndex = 0; poseIndex < poseCount; ++poseIndex) {
        const idListInfo = poseListInfo.getValueByIndex(poseIndex);
        const idCount = idListInfo.getSize();
        let groupCount = 0;
        for (let groupIndex = 0; groupIndex < idCount; ++groupIndex) {
          const partInfo = idListInfo.getValueByIndex(groupIndex);
          const partData = new PartData();
          const parameterId = CubismFramework.getIdManager().getId(partInfo.getValueByString(Id2).getRawString());
          partData.partId = parameterId;
          if (!partInfo.getValueByString(Link).isNull()) {
            const linkListInfo = partInfo.getValueByString(Link);
            const linkCount = linkListInfo.getSize();
            for (let linkIndex = 0; linkIndex < linkCount; ++linkIndex) {
              const linkPart = new PartData();
              const linkId = CubismFramework.getIdManager().getId(linkListInfo.getValueByIndex(linkIndex).getString());
              linkPart.partId = linkId;
              partData.link.pushBack(linkPart);
            }
          }
          ret._partGroups.pushBack(partData.clone());
          ++groupCount;
        }
        ret._partGroupCounts.pushBack(groupCount);
      }
      CubismJson.delete(json);
      return ret;
    }
    /**
     * インスタンスを破棄する
     * @param pose 対象のCubismPose
     */
    static delete(pose) {
      if (pose != null) {
        pose = null;
      }
    }
    /**
     * モデルのパラメータの更新
     * @param model 対象のモデル
     * @param deltaTimeSeconds デルタ時間[秒]
     */
    updateParameters(model, deltaTimeSeconds) {
      if (model != this._lastModel) {
        this.reset(model);
      }
      this._lastModel = model;
      if (deltaTimeSeconds < 0) {
        deltaTimeSeconds = 0;
      }
      let beginIndex = 0;
      for (let i = 0; i < this._partGroupCounts.getSize(); i++) {
        const partGroupCount = this._partGroupCounts.at(i);
        this.doFade(model, deltaTimeSeconds, beginIndex, partGroupCount);
        beginIndex += partGroupCount;
      }
      this.copyPartOpacities(model);
    }
    /**
     * 表示を初期化
     * @param model 対象のモデル
     * @note 不透明度の初期値が0でないパラメータは、不透明度を１に設定する
     */
    reset(model) {
      let beginIndex = 0;
      for (let i = 0; i < this._partGroupCounts.getSize(); ++i) {
        const groupCount = this._partGroupCounts.at(i);
        for (let j = beginIndex; j < beginIndex + groupCount; ++j) {
          this._partGroups.at(j).initialize(model);
          const partsIndex = this._partGroups.at(j).partIndex;
          const paramIndex = this._partGroups.at(j).parameterIndex;
          if (partsIndex < 0) {
            continue;
          }
          model.setPartOpacityByIndex(partsIndex, j == beginIndex ? 1 : 0);
          model.setParameterValueByIndex(paramIndex, j == beginIndex ? 1 : 0);
          for (let k = 0; k < this._partGroups.at(j).link.getSize(); ++k) {
            this._partGroups.at(j).link.at(k).initialize(model);
          }
        }
        beginIndex += groupCount;
      }
    }
    /**
     * パーツの不透明度をコピー
     *
     * @param model 対象のモデル
     */
    copyPartOpacities(model) {
      for (let groupIndex = 0; groupIndex < this._partGroups.getSize(); ++groupIndex) {
        const partData = this._partGroups.at(groupIndex);
        if (partData.link.getSize() == 0) {
          continue;
        }
        const partIndex = this._partGroups.at(groupIndex).partIndex;
        const opacity = model.getPartOpacityByIndex(partIndex);
        for (let linkIndex = 0; linkIndex < partData.link.getSize(); ++linkIndex) {
          const linkPart = partData.link.at(linkIndex);
          const linkPartIndex = linkPart.partIndex;
          if (linkPartIndex < 0) {
            continue;
          }
          model.setPartOpacityByIndex(linkPartIndex, opacity);
        }
      }
    }
    /**
     * パーツのフェード操作を行う。
     * @param model 対象のモデル
     * @param deltaTimeSeconds デルタ時間[秒]
     * @param beginIndex フェード操作を行うパーツグループの先頭インデックス
     * @param partGroupCount フェード操作を行うパーツグループの個数
     */
    doFade(model, deltaTimeSeconds, beginIndex, partGroupCount) {
      let visiblePartIndex = -1;
      let newOpacity = 1;
      const phi = 0.5;
      const backOpacityThreshold = 0.15;
      for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {
        const partIndex = this._partGroups.at(i).partIndex;
        const paramIndex = this._partGroups.at(i).parameterIndex;
        if (model.getParameterValueByIndex(paramIndex) > Epsilon) {
          if (visiblePartIndex >= 0) {
            break;
          }
          visiblePartIndex = i;
          newOpacity = model.getPartOpacityByIndex(partIndex);
          newOpacity += deltaTimeSeconds / this._fadeTimeSeconds;
          if (newOpacity > 1) {
            newOpacity = 1;
          }
        }
      }
      if (visiblePartIndex < 0) {
        visiblePartIndex = 0;
        newOpacity = 1;
      }
      for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {
        const partsIndex = this._partGroups.at(i).partIndex;
        if (visiblePartIndex == i) {
          model.setPartOpacityByIndex(partsIndex, newOpacity);
        } else {
          let opacity = model.getPartOpacityByIndex(partsIndex);
          let a1;
          if (newOpacity < phi) {
            a1 = newOpacity * (phi - 1) / phi + 1;
          } else {
            a1 = (1 - newOpacity) * phi / (1 - phi);
          }
          const backOpacity = (1 - a1) * (1 - newOpacity);
          if (backOpacity > backOpacityThreshold) {
            a1 = 1 - backOpacityThreshold / (1 - newOpacity);
          }
          if (opacity > a1) {
            opacity = a1;
          }
          model.setPartOpacityByIndex(partsIndex, opacity);
        }
      }
    }
    // 前回操作したモデル
  };
  var PartData = class _PartData {
    /**
     * コンストラクタ
     */
    constructor(v) {
      __publicField(this, "partId");
      // パーツID
      __publicField(this, "parameterIndex");
      // パラメータのインデックス
      __publicField(this, "partIndex");
      // パーツのインデックス
      __publicField(this, "link");
      this.parameterIndex = 0;
      this.partIndex = 0;
      this.link = new csmVector();
      if (v != void 0) {
        this.partId = v.partId;
        for (const ite = v.link.begin(); ite.notEqual(v.link.end()); ite.preIncrement()) {
          this.link.pushBack(ite.ptr().clone());
        }
      }
    }
    /**
     * =演算子のオーバーロード
     */
    assignment(v) {
      this.partId = v.partId;
      for (const ite = v.link.begin(); ite.notEqual(v.link.end()); ite.preIncrement()) {
        this.link.pushBack(ite.ptr().clone());
      }
      return this;
    }
    /**
     * 初期化
     * @param model 初期化に使用するモデル
     */
    initialize(model) {
      this.parameterIndex = model.getParameterIndex(this.partId);
      this.partIndex = model.getPartIndex(this.partId);
      model.setParameterValueByIndex(this.parameterIndex, 1);
    }
    /**
     * オブジェクトのコピーを生成する
     */
    clone() {
      const clonePartData = new _PartData();
      clonePartData.partId = this.partId;
      clonePartData.parameterIndex = this.parameterIndex;
      clonePartData.partIndex = this.partIndex;
      clonePartData.link = new csmVector();
      for (let ite = this.link.begin(); ite.notEqual(this.link.end()); ite.increment()) {
        clonePartData.link.pushBack(ite.ptr().clone());
      }
      return clonePartData;
    }
    // 連動するパラメータ
  };
  var Live2DCubismFramework18;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismPose = CubismPose;
    Live2DCubismFramework42.PartData = PartData;
  })(Live2DCubismFramework18 || (Live2DCubismFramework18 = {}));

  // src/Live2D/dist/math/cubismmodelmatrix.js
  var CubismModelMatrix = class extends CubismMatrix44 {
    /**
     * コンストラクタ
     *
     * @param w 横幅
     * @param h 縦幅
     */
    constructor(w, h) {
      super();
      __publicField(this, "_width");
      // 横幅
      __publicField(this, "_height");
      this._width = w !== void 0 ? w : 0;
      this._height = h !== void 0 ? h : 0;
      this.setHeight(2);
    }
    /**
     * 横幅を設定
     *
     * @param w 横幅
     */
    setWidth(w) {
      const scaleX = w / this._width;
      const scaleY = scaleX;
      this.scale(scaleX, scaleY);
    }
    /**
     * 縦幅を設定
     * @param h 縦幅
     */
    setHeight(h) {
      const scaleX = h / this._height;
      const scaleY = scaleX;
      this.scale(scaleX, scaleY);
    }
    /**
     * 位置を設定
     *
     * @param x X軸の位置
     * @param y Y軸の位置
     */
    setPosition(x, y) {
      this.translate(x, y);
    }
    /**
     * 中心位置を設定
     *
     * @param x X軸の中心位置
     * @param y Y軸の中心位置
     *
     * @note widthかheightを設定したあとでないと、拡大率が正しく取得できないためずれる。
     */
    setCenterPosition(x, y) {
      this.centerX(x);
      this.centerY(y);
    }
    /**
     * 上辺の位置を設定する
     *
     * @param y 上辺のY軸位置
     */
    top(y) {
      this.setY(y);
    }
    /**
     * 下辺の位置を設定する
     *
     * @param y 下辺のY軸位置
     */
    bottom(y) {
      const h = this._height * this.getScaleY();
      this.translateY(y - h);
    }
    /**
     * 左辺の位置を設定
     *
     * @param x 左辺のX軸位置
     */
    left(x) {
      this.setX(x);
    }
    /**
     * 右辺の位置を設定
     *
     * @param x 右辺のX軸位置
     */
    right(x) {
      const w = this._width * this.getScaleX();
      this.translateX(x - w);
    }
    /**
     * X軸の中心位置を設定
     *
     * @param x X軸の中心位置
     */
    centerX(x) {
      const w = this._width * this.getScaleX();
      this.translateX(x - w / 2);
    }
    /**
     * X軸の位置を設定
     *
     * @param x X軸の位置
     */
    setX(x) {
      this.translateX(x);
    }
    /**
     * Y軸の中心位置を設定
     *
     * @param y Y軸の中心位置
     */
    centerY(y) {
      const h = this._height * this.getScaleY();
      this.translateY(y - h / 2);
    }
    /**
     * Y軸の位置を設定する
     *
     * @param y Y軸の位置
     */
    setY(y) {
      this.translateY(y);
    }
    /**
     * レイアウト情報から位置を設定
     *
     * @param layout レイアウト情報
     */
    setupFromLayout(layout) {
      const keyWidth = "width";
      const keyHeight = "height";
      const keyX = "x";
      const keyY = "y";
      const keyCenterX = "center_x";
      const keyCenterY = "center_y";
      const keyTop = "top";
      const keyBottom = "bottom";
      const keyLeft = "left";
      const keyRight = "right";
      for (const ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {
        const key = ite.ptr().first;
        const value = ite.ptr().second;
        if (key == keyWidth) {
          this.setWidth(value);
        } else if (key == keyHeight) {
          this.setHeight(value);
        }
      }
      for (const ite = layout.begin(); ite.notEqual(layout.end()); ite.preIncrement()) {
        const key = ite.ptr().first;
        const value = ite.ptr().second;
        if (key == keyX) {
          this.setX(value);
        } else if (key == keyY) {
          this.setY(value);
        } else if (key == keyCenterX) {
          this.centerX(value);
        } else if (key == keyCenterY) {
          this.centerY(value);
        } else if (key == keyTop) {
          this.top(value);
        } else if (key == keyBottom) {
          this.bottom(value);
        } else if (key == keyLeft) {
          this.left(value);
        } else if (key == keyRight) {
          this.right(value);
        }
      }
    }
    // 縦幅
  };
  var Live2DCubismFramework19;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModelMatrix = CubismModelMatrix;
  })(Live2DCubismFramework19 || (Live2DCubismFramework19 = {}));

  // src/Live2D/dist/math/cubismvector2.js
  var CubismVector2 = class _CubismVector2 {
    /**
     * コンストラクタ
     */
    constructor(x, y) {
      __publicField(this, "x");
      __publicField(this, "y");
      this.x = x;
      this.y = y;
      this.x = x == void 0 ? 0 : x;
      this.y = y == void 0 ? 0 : y;
    }
    /**
     * ベクトルの加算
     *
     * @param vector2 加算するベクトル値
     * @return 加算結果 ベクトル値
     */
    add(vector2) {
      const ret = new _CubismVector2(0, 0);
      ret.x = this.x + vector2.x;
      ret.y = this.y + vector2.y;
      return ret;
    }
    /**
     * ベクトルの減算
     *
     * @param vector2 減算するベクトル値
     * @return 減算結果 ベクトル値
     */
    substract(vector2) {
      const ret = new _CubismVector2(0, 0);
      ret.x = this.x - vector2.x;
      ret.y = this.y - vector2.y;
      return ret;
    }
    /**
     * ベクトルの乗算
     *
     * @param vector2 乗算するベクトル値
     * @return 乗算結果 ベクトル値
     */
    multiply(vector2) {
      const ret = new _CubismVector2(0, 0);
      ret.x = this.x * vector2.x;
      ret.y = this.y * vector2.y;
      return ret;
    }
    /**
     * ベクトルの乗算(スカラー)
     *
     * @param scalar 乗算するスカラー値
     * @return 乗算結果 ベクトル値
     */
    multiplyByScaler(scalar) {
      return this.multiply(new _CubismVector2(scalar, scalar));
    }
    /**
     * ベクトルの除算
     *
     * @param vector2 除算するベクトル値
     * @return 除算結果 ベクトル値
     */
    division(vector2) {
      const ret = new _CubismVector2(0, 0);
      ret.x = this.x / vector2.x;
      ret.y = this.y / vector2.y;
      return ret;
    }
    /**
     * ベクトルの除算(スカラー)
     *
     * @param scalar 除算するスカラー値
     * @return 除算結果 ベクトル値
     */
    divisionByScalar(scalar) {
      return this.division(new _CubismVector2(scalar, scalar));
    }
    /**
     * ベクトルの長さを取得する
     *
     * @return ベクトルの長さ
     */
    getLength() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * ベクトルの距離の取得
     *
     * @param a 点
     * @return ベクトルの距離
     */
    getDistanceWith(a) {
      return Math.sqrt((this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y));
    }
    /**
     * ドット積の計算
     *
     * @param a 値
     * @return 結果
     */
    dot(a) {
      return this.x * a.x + this.y * a.y;
    }
    /**
     * 正規化の適用
     */
    normalize() {
      const length = Math.pow(this.x * this.x + this.y * this.y, 0.5);
      this.x = this.x / length;
      this.y = this.y / length;
    }
    /**
     * 等しさの確認（等しいか？）
     *
     * 値が等しいか？
     *
     * @param rhs 確認する値
     * @return true 値は等しい
     * @return false 値は等しくない
     */
    isEqual(rhs) {
      return this.x == rhs.x && this.y == rhs.y;
    }
    /**
     * 等しさの確認（等しくないか？）
     *
     * 値が等しくないか？
     *
     * @param rhs 確認する値
     * @return true 値は等しくない
     * @return false 値は等しい
     */
    isNotEqual(rhs) {
      return !this.isEqual(rhs);
    }
  };
  var Live2DCubismFramework20;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismVector2 = CubismVector2;
  })(Live2DCubismFramework20 || (Live2DCubismFramework20 = {}));

  // src/Live2D/dist/math/cubismmath.js
  var _CubismMath = class _CubismMath {
    /**
     * 第一引数の値を最小値と最大値の範囲に収めた値を返す
     *
     * @param value 収められる値
     * @param min   範囲の最小値
     * @param max   範囲の最大値
     * @return 最小値と最大値の範囲に収めた値
     */
    static range(value, min, max) {
      if (value < min) {
        value = min;
      } else if (value > max) {
        value = max;
      }
      return value;
    }
    /**
     * サイン関数の値を求める
     *
     * @param x 角度値（ラジアン）
     * @return サイン関数sin(x)の値
     */
    static sin(x) {
      return Math.sin(x);
    }
    /**
     * コサイン関数の値を求める
     *
     * @param x 角度値(ラジアン)
     * @return コサイン関数cos(x)の値
     */
    static cos(x) {
      return Math.cos(x);
    }
    /**
     * 値の絶対値を求める
     *
     * @param x 絶対値を求める値
     * @return 値の絶対値
     */
    static abs(x) {
      return Math.abs(x);
    }
    /**
     * 平方根(ルート)を求める
     * @param x -> 平方根を求める値
     * @return 値の平方根
     */
    static sqrt(x) {
      return Math.sqrt(x);
    }
    /**
     * 立方根を求める
     * @param x -> 立方根を求める値
     * @return 値の立方根
     */
    static cbrt(x) {
      if (x === 0) {
        return x;
      }
      let cx = x;
      const isNegativeNumber = cx < 0;
      if (isNegativeNumber) {
        cx = -cx;
      }
      let ret;
      if (cx === Infinity) {
        ret = Infinity;
      } else {
        ret = Math.exp(Math.log(cx) / 3);
        ret = (cx / (ret * ret) + 2 * ret) / 3;
      }
      return isNegativeNumber ? -ret : ret;
    }
    /**
     * イージング処理されたサインを求める
     * フェードイン・アウト時のイージングに利用できる
     *
     * @param value イージングを行う値
     * @return イージング処理されたサイン値
     */
    static getEasingSine(value) {
      if (value < 0) {
        return 0;
      } else if (value > 1) {
        return 1;
      }
      return 0.5 - 0.5 * this.cos(value * Math.PI);
    }
    /**
     * 大きい方の値を返す
     *
     * @param left 左辺の値
     * @param right 右辺の値
     * @return 大きい方の値
     */
    static max(left, right) {
      return left > right ? left : right;
    }
    /**
     * 小さい方の値を返す
     *
     * @param left  左辺の値
     * @param right 右辺の値
     * @return 小さい方の値
     */
    static min(left, right) {
      return left > right ? right : left;
    }
    /**
     * 角度値をラジアン値に変換する
     *
     * @param degrees   角度値
     * @return 角度値から変換したラジアン値
     */
    static degreesToRadian(degrees) {
      return degrees / 180 * Math.PI;
    }
    /**
     * ラジアン値を角度値に変換する
     *
     * @param radian    ラジアン値
     * @return ラジアン値から変換した角度値
     */
    static radianToDegrees(radian) {
      return radian * 180 / Math.PI;
    }
    /**
     * ２つのベクトルからラジアン値を求める
     *
     * @param from  始点ベクトル
     * @param to    終点ベクトル
     * @return ラジアン値から求めた方向ベクトル
     */
    static directionToRadian(from, to) {
      const q1 = Math.atan2(to.y, to.x);
      const q2 = Math.atan2(from.y, from.x);
      let ret = q1 - q2;
      while (ret < -Math.PI) {
        ret += Math.PI * 2;
      }
      while (ret > Math.PI) {
        ret -= Math.PI * 2;
      }
      return ret;
    }
    /**
     * ２つのベクトルから角度値を求める
     *
     * @param from  始点ベクトル
     * @param to    終点ベクトル
     * @return 角度値から求めた方向ベクトル
     */
    static directionToDegrees(from, to) {
      const radian = this.directionToRadian(from, to);
      let degree = this.radianToDegrees(radian);
      if (to.x - from.x > 0) {
        degree = -degree;
      }
      return degree;
    }
    /**
     * ラジアン値を方向ベクトルに変換する。
     *
     * @param totalAngle    ラジアン値
     * @return ラジアン値から変換した方向ベクトル
     */
    static radianToDirection(totalAngle) {
      const ret = new CubismVector2();
      ret.x = this.sin(totalAngle);
      ret.y = this.cos(totalAngle);
      return ret;
    }
    /**
     * 三次方程式の三次項の係数が0になったときに補欠的に二次方程式の解をもとめる。
     * a * x^2 + b * x + c = 0
     *
     * @param   a -> 二次項の係数値
     * @param   b -> 一次項の係数値
     * @param   c -> 定数項の値
     * @return  二次方程式の解
     */
    static quadraticEquation(a, b, c) {
      if (this.abs(a) < _CubismMath.Epsilon) {
        if (this.abs(b) < _CubismMath.Epsilon) {
          return -c;
        }
        return -c / b;
      }
      return -(b + this.sqrt(b * b - 4 * a * c)) / (2 * a);
    }
    /**
     * カルダノの公式によってベジェのt値に該当する３次方程式の解を求める。
     * 重解になったときには0.0～1.0の値になる解を返す。
     *
     * a * x^3 + b * x^2 + c * x + d = 0
     *
     * @param   a -> 三次項の係数値
     * @param   b -> 二次項の係数値
     * @param   c -> 一次項の係数値
     * @param   d -> 定数項の値
     * @return  0.0～1.0の間にある解
     */
    static cardanoAlgorithmForBezier(a, b, c, d) {
      if (this.sqrt(a) < _CubismMath.Epsilon) {
        return this.range(this.quadraticEquation(b, c, d), 0, 1);
      }
      const ba = b / a;
      const ca = c / a;
      const da = d / a;
      const p = (3 * ca - ba * ba) / 3;
      const p3 = p / 3;
      const q = (2 * ba * ba * ba - 9 * ba * ca + 27 * da) / 27;
      const q2 = q / 2;
      const discriminant = q2 * q2 + p3 * p3 * p3;
      const center = 0.5;
      const threshold = center + 0.01;
      if (discriminant < 0) {
        const mp3 = -p / 3;
        const mp33 = mp3 * mp3 * mp3;
        const r = this.sqrt(mp33);
        const t2 = -q / (2 * r);
        const cosphi = this.range(t2, -1, 1);
        const phi = Math.acos(cosphi);
        const crtr = this.cbrt(r);
        const t1 = 2 * crtr;
        const root12 = t1 * this.cos(phi / 3) - ba / 3;
        if (this.abs(root12 - center) < threshold) {
          return this.range(root12, 0, 1);
        }
        const root2 = t1 * this.cos((phi + 2 * Math.PI) / 3) - ba / 3;
        if (this.abs(root2 - center) < threshold) {
          return this.range(root2, 0, 1);
        }
        const root3 = t1 * this.cos((phi + 4 * Math.PI) / 3) - ba / 3;
        return this.range(root3, 0, 1);
      }
      if (discriminant == 0) {
        let u12;
        if (q2 < 0) {
          u12 = this.cbrt(-q2);
        } else {
          u12 = -this.cbrt(q2);
        }
        const root12 = 2 * u12 - ba / 3;
        if (this.abs(root12 - center) < threshold) {
          return this.range(root12, 0, 1);
        }
        const root2 = -u12 - ba / 3;
        return this.range(root2, 0, 1);
      }
      const sd = this.sqrt(discriminant);
      const u1 = this.cbrt(sd - q2);
      const v1 = this.cbrt(sd + q2);
      const root1 = u1 - v1 - ba / 3;
      return this.range(root1, 0, 1);
    }
    /**
     * 浮動小数点の余りを求める。
     *
     * @param dividend 被除数（割られる値）
     * @param divisor 除数（割る値）
     * @returns 余り
     */
    static mod(dividend, divisor) {
      if (!isFinite(dividend) || divisor === 0 || isNaN(dividend) || isNaN(divisor)) {
        console.warn(`divided: ${dividend}, divisor: ${divisor} mod() returns 'NaN'.`);
        return NaN;
      }
      const absDividend = Math.abs(dividend);
      const absDivisor = Math.abs(divisor);
      let result = absDividend - Math.floor(absDividend / absDivisor) * absDivisor;
      result *= Math.sign(dividend);
      return result;
    }
    /**
     * コンストラクタ
     */
    constructor() {
    }
  };
  __publicField(_CubismMath, "Epsilon", 1e-5);
  var CubismMath = _CubismMath;
  var Live2DCubismFramework21;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMath = CubismMath;
  })(Live2DCubismFramework21 || (Live2DCubismFramework21 = {}));

  // src/Live2D/dist/math/cubismtargetpoint.js
  var FrameRate = 30;
  var Epsilon2 = 0.01;
  var CubismTargetPoint = class {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_faceTargetX");
      // 顔の向きのX目標値（この値に近づいていく）
      __publicField(this, "_faceTargetY");
      // 顔の向きのY目標値（この値に近づいていく）
      __publicField(this, "_faceX");
      // 顔の向きX（-1.0 ~ 1.0）
      __publicField(this, "_faceY");
      // 顔の向きY（-1.0 ~ 1.0）
      __publicField(this, "_faceVX");
      // 顔の向きの変化速度X
      __publicField(this, "_faceVY");
      // 顔の向きの変化速度Y
      __publicField(this, "_lastTimeSeconds");
      // 最後の実行時間[秒]
      __publicField(this, "_userTimeSeconds");
      this._faceTargetX = 0;
      this._faceTargetY = 0;
      this._faceX = 0;
      this._faceY = 0;
      this._faceVX = 0;
      this._faceVY = 0;
      this._lastTimeSeconds = 0;
      this._userTimeSeconds = 0;
    }
    /**
     * 更新処理
     */
    update(deltaTimeSeconds) {
      this._userTimeSeconds += deltaTimeSeconds;
      const faceParamMaxV = 40 / 10;
      const maxV = faceParamMaxV * 1 / FrameRate;
      if (this._lastTimeSeconds == 0) {
        this._lastTimeSeconds = this._userTimeSeconds;
        return;
      }
      const deltaTimeWeight = (this._userTimeSeconds - this._lastTimeSeconds) * FrameRate;
      this._lastTimeSeconds = this._userTimeSeconds;
      const timeToMaxSpeed = 0.15;
      const frameToMaxSpeed = timeToMaxSpeed * FrameRate;
      const maxA = deltaTimeWeight * maxV / frameToMaxSpeed;
      const dx = this._faceTargetX - this._faceX;
      const dy = this._faceTargetY - this._faceY;
      if (CubismMath.abs(dx) <= Epsilon2 && CubismMath.abs(dy) <= Epsilon2) {
        return;
      }
      const d = CubismMath.sqrt(dx * dx + dy * dy);
      const vx = maxV * dx / d;
      const vy = maxV * dy / d;
      let ax = vx - this._faceVX;
      let ay = vy - this._faceVY;
      const a = CubismMath.sqrt(ax * ax + ay * ay);
      if (a < -maxA || a > maxA) {
        ax *= maxA / a;
        ay *= maxA / a;
      }
      this._faceVX += ax;
      this._faceVY += ay;
      {
        const maxV2 = 0.5 * (CubismMath.sqrt(maxA * maxA + 16 * maxA * d - 8 * maxA * d) - maxA);
        const curV = CubismMath.sqrt(this._faceVX * this._faceVX + this._faceVY * this._faceVY);
        if (curV > maxV2) {
          this._faceVX *= maxV2 / curV;
          this._faceVY *= maxV2 / curV;
        }
      }
      this._faceX += this._faceVX;
      this._faceY += this._faceVY;
    }
    /**
     * X軸の顔の向きの値を取得
     *
     * @return X軸の顔の向きの値（-1.0 ~ 1.0）
     */
    getX() {
      return this._faceX;
    }
    /**
     * Y軸の顔の向きの値を取得
     *
     * @return Y軸の顔の向きの値（-1.0 ~ 1.0）
     */
    getY() {
      return this._faceY;
    }
    /**
     * 顔の向きの目標値を設定
     *
     * @param x X軸の顔の向きの値（-1.0 ~ 1.0）
     * @param y Y軸の顔の向きの値（-1.0 ~ 1.0）
     */
    set(x, y) {
      this._faceTargetX = x;
      this._faceTargetY = y;
    }
    // デルタ時間の積算値[秒]
  };
  var Live2DCubismFramework22;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismTargetPoint = CubismTargetPoint;
  })(Live2DCubismFramework22 || (Live2DCubismFramework22 = {}));

  // src/Live2D/dist/motion/acubismmotion.js
  var ACubismMotion = class {
    /**
     * コンストラクタ
     */
    constructor() {
      /**
       * モーション再生終了コールバックの登録
       *
       * モーション再生終了コールバックを登録する。
       * isFinishedフラグを設定するタイミングで呼び出される。
       * 以下の状態の際には呼び出されない:
       *   1. 再生中のモーションが「ループ」として設定されているとき
       *   2. コールバックが登録されていない時
       *
       * @param onFinishedMotionHandler モーション再生終了コールバック関数
       */
      __publicField(this, "setFinishedMotionHandler", (onFinishedMotionHandler) => this._onFinishedMotion = onFinishedMotionHandler);
      /**
       * モーション再生終了コールバックの取得
       *
       * モーション再生終了コールバックを取得する。
       *
       * @return 登録されているモーション再生終了コールバック関数
       */
      __publicField(this, "getFinishedMotionHandler", () => this._onFinishedMotion);
      __publicField(this, "_fadeInSeconds");
      // フェードインにかかる時間[秒]
      __publicField(this, "_fadeOutSeconds");
      // フェードアウトにかかる時間[秒]
      __publicField(this, "_weight");
      // モーションの重み
      __publicField(this, "_offsetSeconds");
      // モーション再生の開始時間[秒]
      __publicField(this, "_firedEventValues");
      // モーション再生終了コールバック関数
      __publicField(this, "_onFinishedMotion");
      this._fadeInSeconds = -1;
      this._fadeOutSeconds = -1;
      this._weight = 1;
      this._offsetSeconds = 0;
      this._firedEventValues = new csmVector();
    }
    /**
     * インスタンスの破棄
     */
    static delete(motion) {
      motion.release();
      motion = null;
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      this._weight = 0;
    }
    /**
     * モデルのパラメータ
     * @param model 対象のモデル
     * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
     * @param userTimeSeconds デルタ時間の積算値[秒]
     */
    updateParameters(model, motionQueueEntry, userTimeSeconds) {
      if (!motionQueueEntry.isAvailable() || motionQueueEntry.isFinished()) {
        return;
      }
      this.setupMotionQueueEntry(motionQueueEntry, userTimeSeconds);
      const fadeWeight = this.updateFadeWeight(motionQueueEntry, userTimeSeconds);
      this.doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry);
      if (motionQueueEntry.getEndTime() > 0 && motionQueueEntry.getEndTime() < userTimeSeconds) {
        motionQueueEntry.setIsFinished(true);
      }
    }
    /**
     * @brief モデルの再生開始処理
     *
     * モーションの再生を開始するためのセットアップを行う。
     *
     * @param[in]   motionQueueEntry    CubismMotionQueueManagerで管理されているモーション
     * @param[in]   userTimeSeconds     デルタ時間の積算値[秒]
     */
    setupMotionQueueEntry(motionQueueEntry, userTimeSeconds) {
      if (motionQueueEntry == null || motionQueueEntry.isStarted()) {
        return;
      }
      if (!motionQueueEntry.isAvailable()) {
        return;
      }
      motionQueueEntry.setIsStarted(true);
      motionQueueEntry.setStartTime(userTimeSeconds - this._offsetSeconds);
      motionQueueEntry.setFadeInStartTime(userTimeSeconds);
      const duration = this.getDuration();
      if (motionQueueEntry.getEndTime() < 0) {
        motionQueueEntry.setEndTime(duration <= 0 ? -1 : motionQueueEntry.getStartTime() + duration);
      }
    }
    /**
     * @brief モデルのウェイト更新
     *
     * モーションのウェイトを更新する。
     *
     * @param[in]   motionQueueEntry    CubismMotionQueueManagerで管理されているモーション
     * @param[in]   userTimeSeconds     デルタ時間の積算値[秒]
     */
    updateFadeWeight(motionQueueEntry, userTimeSeconds) {
      if (motionQueueEntry == null) {
        CubismDebug.print(LogLevel.LogLevel_Error, "motionQueueEntry is null.");
      }
      let fadeWeight = this._weight;
      const fadeIn = this._fadeInSeconds == 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds);
      const fadeOut = this._fadeOutSeconds == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds);
      fadeWeight = fadeWeight * fadeIn * fadeOut;
      motionQueueEntry.setState(userTimeSeconds, fadeWeight);
      CSM_ASSERT(0 <= fadeWeight && fadeWeight <= 1);
      return fadeWeight;
    }
    /**
     * フェードインの時間を設定する
     * @param fadeInSeconds フェードインにかかる時間[秒]
     */
    setFadeInTime(fadeInSeconds) {
      this._fadeInSeconds = fadeInSeconds;
    }
    /**
     * フェードアウトの時間を設定する
     * @param fadeOutSeconds フェードアウトにかかる時間[秒]
     */
    setFadeOutTime(fadeOutSeconds) {
      this._fadeOutSeconds = fadeOutSeconds;
    }
    /**
     * フェードアウトにかかる時間の取得
     * @return フェードアウトにかかる時間[秒]
     */
    getFadeOutTime() {
      return this._fadeOutSeconds;
    }
    /**
     * フェードインにかかる時間の取得
     * @return フェードインにかかる時間[秒]
     */
    getFadeInTime() {
      return this._fadeInSeconds;
    }
    /**
     * モーション適用の重みの設定
     * @param weight 重み（0.0 - 1.0）
     */
    setWeight(weight) {
      this._weight = weight;
    }
    /**
     * モーション適用の重みの取得
     * @return 重み（0.0 - 1.0）
     */
    getWeight() {
      return this._weight;
    }
    /**
     * モーションの長さの取得
     * @return モーションの長さ[秒]
     *
     * @note ループの時は「-1」。
     *       ループでない場合は、オーバーライドする。
     *       正の値の時は取得される時間で終了する。
     *       「-1」の時は外部から停止命令がない限り終わらない処理となる。
     */
    getDuration() {
      return -1;
    }
    /**
     * モーションのループ1回分の長さの取得
     * @return モーションのループ一回分の長さ[秒]
     *
     * @note ループしない場合は、getDuration()と同じ値を返す
     *       ループ一回分の長さが定義できない場合(プログラム的に動き続けるサブクラスなど)の場合は「-1」を返す
     */
    getLoopDuration() {
      return -1;
    }
    /**
     * モーション再生の開始時刻の設定
     * @param offsetSeconds モーション再生の開始時刻[秒]
     */
    setOffsetTime(offsetSeconds) {
      this._offsetSeconds = offsetSeconds;
    }
    /**
     * モデルのパラメータ更新
     *
     * イベント発火のチェック。
     * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。
     *
     * @param beforeCheckTimeSeconds 前回のイベントチェック時間[秒]
     * @param motionTimeSeconds 今回の再生時間[秒]
     */
    getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
      return this._firedEventValues;
    }
    /**
     * 透明度のカーブが存在するかどうかを確認する
     *
     * @returns true  -> キーが存在する
     *          false -> キーが存在しない
     */
    isExistModelOpacity() {
      return false;
    }
    /**
     * 透明度のカーブのインデックスを返す
     *
     * @returns success:透明度のカーブのインデックス
     */
    getModelOpacityIndex() {
      return -1;
    }
    /**
     * 透明度のIdを返す
     *
     * @param index モーションカーブのインデックス
     * @returns success:透明度のId
     */
    getModelOpacityId(index) {
      return null;
    }
    /**
     * 指定時間の透明度の値を返す
     *
     * @returns success:モーションの現在時間におけるOpacityの値
     *
     * @note  更新後の値を取るにはUpdateParameters() の後に呼び出す。
     */
    getModelOpacityValue() {
      return 1;
    }
  };
  var Live2DCubismFramework23;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.ACubismMotion = ACubismMotion;
  })(Live2DCubismFramework23 || (Live2DCubismFramework23 = {}));

  // src/Live2D/dist/motion/cubismexpressionmotion.js
  var ExpressionKeyFadeIn = "FadeInTime";
  var ExpressionKeyFadeOut = "FadeOutTime";
  var ExpressionKeyParameters = "Parameters";
  var ExpressionKeyId = "Id";
  var ExpressionKeyValue = "Value";
  var ExpressionKeyBlend = "Blend";
  var BlendValueAdd = "Add";
  var BlendValueMultiply = "Multiply";
  var BlendValueOverwrite = "Overwrite";
  var DefaultFadeTime = 1;
  var _CubismExpressionMotion = class _CubismExpressionMotion extends ACubismMotion {
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      __publicField(this, "_parameters");
      // 表情のパラメータ情報リスト
      /**
       * 表情の現在のウェイト
       *
       * @deprecated 不具合を引き起こす要因となるため非推奨。
       */
      __publicField(this, "_fadeWeight");
      this._parameters = new csmVector();
      this._fadeWeight = 0;
    }
    // 乗算適用の初期値
    /**
     * インスタンスを作成する。
     * @param buffer expファイルが読み込まれているバッファ
     * @param size バッファのサイズ
     * @return 作成されたインスタンス
     */
    static create(buffer, size) {
      const expression = new _CubismExpressionMotion();
      expression.parse(buffer, size);
      return expression;
    }
    /**
     * モデルのパラメータの更新の実行
     * @param model 対象のモデル
     * @param userTimeSeconds デルタ時間の積算値[秒]
     * @param weight モーションの重み
     * @param motionQueueEntry CubismMotionQueueManagerで管理されているモーション
     */
    doUpdateParameters(model, userTimeSeconds, weight, motionQueueEntry) {
      for (let i = 0; i < this._parameters.getSize(); ++i) {
        const parameter = this._parameters.at(i);
        switch (parameter.blendType) {
          case ExpressionBlendType.Additive: {
            model.addParameterValueById(parameter.parameterId, parameter.value, weight);
            break;
          }
          case ExpressionBlendType.Multiply: {
            model.multiplyParameterValueById(parameter.parameterId, parameter.value, weight);
            break;
          }
          case ExpressionBlendType.Overwrite: {
            model.setParameterValueById(parameter.parameterId, parameter.value, weight);
            break;
          }
          default:
            break;
        }
      }
    }
    /**
     * @brief 表情によるモデルのパラメータの計算
     *
     * モデルの表情に関するパラメータを計算する。
     *
     * @param[in]   model                        対象のモデル
     * @param[in]   userTimeSeconds              デルタ時間の積算値[秒]
     * @param[in]   motionQueueEntry             CubismMotionQueueManagerで管理されているモーション
     * @param[in]   expressionParameterValues    モデルに適用する各パラメータの値
     * @param[in]   expressionIndex              表情のインデックス
     * @param[in]   fadeWeight                   表情のウェイト
     */
    calculateExpressionParameters(model, userTimeSeconds, motionQueueEntry, expressionParameterValues, expressionIndex, fadeWeight) {
      if (motionQueueEntry == null || expressionParameterValues == null) {
        return;
      }
      if (!motionQueueEntry.isAvailable()) {
        return;
      }
      this._fadeWeight = this.updateFadeWeight(motionQueueEntry, userTimeSeconds);
      for (let i = 0; i < expressionParameterValues.getSize(); ++i) {
        const expressionParameterValue = expressionParameterValues.at(i);
        if (expressionParameterValue.parameterId == null) {
          continue;
        }
        const currentParameterValue = expressionParameterValue.overwriteValue = model.getParameterValueById(expressionParameterValue.parameterId);
        const expressionParameters = this.getExpressionParameters();
        let parameterIndex = -1;
        for (let j = 0; j < expressionParameters.getSize(); ++j) {
          if (expressionParameterValue.parameterId != expressionParameters.at(j).parameterId) {
            continue;
          }
          parameterIndex = j;
          break;
        }
        if (parameterIndex < 0) {
          if (expressionIndex == 0) {
            expressionParameterValue.additiveValue = _CubismExpressionMotion.DefaultAdditiveValue;
            expressionParameterValue.multiplyValue = _CubismExpressionMotion.DefaultMultiplyValue;
            expressionParameterValue.overwriteValue = currentParameterValue;
          } else {
            expressionParameterValue.additiveValue = this.calculateValue(expressionParameterValue.additiveValue, _CubismExpressionMotion.DefaultAdditiveValue, fadeWeight);
            expressionParameterValue.multiplyValue = this.calculateValue(expressionParameterValue.multiplyValue, _CubismExpressionMotion.DefaultMultiplyValue, fadeWeight);
            expressionParameterValue.overwriteValue = this.calculateValue(expressionParameterValue.overwriteValue, currentParameterValue, fadeWeight);
          }
          continue;
        }
        const value = expressionParameters.at(parameterIndex).value;
        let newAdditiveValue, newMultiplyValue, newOverwriteValue;
        switch (expressionParameters.at(parameterIndex).blendType) {
          case ExpressionBlendType.Additive:
            newAdditiveValue = value;
            newMultiplyValue = _CubismExpressionMotion.DefaultMultiplyValue;
            newOverwriteValue = currentParameterValue;
            break;
          case ExpressionBlendType.Multiply:
            newAdditiveValue = _CubismExpressionMotion.DefaultAdditiveValue;
            newMultiplyValue = value;
            newOverwriteValue = currentParameterValue;
            break;
          case ExpressionBlendType.Overwrite:
            newAdditiveValue = _CubismExpressionMotion.DefaultAdditiveValue;
            newMultiplyValue = _CubismExpressionMotion.DefaultMultiplyValue;
            newOverwriteValue = value;
            break;
          default:
            return;
        }
        if (expressionIndex == 0) {
          expressionParameterValue.additiveValue = newAdditiveValue;
          expressionParameterValue.multiplyValue = newMultiplyValue;
          expressionParameterValue.overwriteValue = newOverwriteValue;
        } else {
          expressionParameterValue.additiveValue = expressionParameterValue.additiveValue * (1 - fadeWeight) + newAdditiveValue * fadeWeight;
          expressionParameterValue.multiplyValue = expressionParameterValue.multiplyValue * (1 - fadeWeight) + newMultiplyValue * fadeWeight;
          expressionParameterValue.overwriteValue = expressionParameterValue.overwriteValue * (1 - fadeWeight) + newOverwriteValue * fadeWeight;
        }
      }
    }
    /**
     * @brief 表情が参照しているパラメータを取得
     *
     * 表情が参照しているパラメータを取得する
     *
     * @return 表情パラメータ
     */
    getExpressionParameters() {
      return this._parameters;
    }
    /**
     * @brief 表情のフェードの値を取得
     *
     * 現在の表情のフェードのウェイト値を取得する
     *
     * @returns 表情のフェードのウェイト値
     *
     * @deprecated CubismExpressionMotion.fadeWeightが削除予定のため非推奨。
     * CubismExpressionMotionManager.getFadeWeight(index: number): number を使用してください。
     * @see CubismExpressionMotionManager#getFadeWeight(index: number)
     */
    getFadeWeight() {
      return this._fadeWeight;
    }
    parse(buffer, size) {
      const json = CubismJson.create(buffer, size);
      if (!json) {
        return;
      }
      const root = json.getRoot();
      this.setFadeInTime(root.getValueByString(ExpressionKeyFadeIn).toFloat(DefaultFadeTime));
      this.setFadeOutTime(root.getValueByString(ExpressionKeyFadeOut).toFloat(DefaultFadeTime));
      const parameterCount = root.getValueByString(ExpressionKeyParameters).getSize();
      this._parameters.prepareCapacity(parameterCount);
      for (let i = 0; i < parameterCount; ++i) {
        const param = root.getValueByString(ExpressionKeyParameters).getValueByIndex(i);
        const parameterId = CubismFramework.getIdManager().getId(param.getValueByString(ExpressionKeyId).getRawString());
        const value = param.getValueByString(ExpressionKeyValue).toFloat();
        let blendType;
        if (param.getValueByString(ExpressionKeyBlend).isNull() || param.getValueByString(ExpressionKeyBlend).getString() == BlendValueAdd) {
          blendType = ExpressionBlendType.Additive;
        } else if (param.getValueByString(ExpressionKeyBlend).getString() == BlendValueMultiply) {
          blendType = ExpressionBlendType.Multiply;
        } else if (param.getValueByString(ExpressionKeyBlend).getString() == BlendValueOverwrite) {
          blendType = ExpressionBlendType.Overwrite;
        } else {
          blendType = ExpressionBlendType.Additive;
        }
        const item = new ExpressionParameter();
        item.parameterId = parameterId;
        item.blendType = blendType;
        item.value = value;
        this._parameters.pushBack(item);
      }
      CubismJson.delete(json);
    }
    /**
     * @brief ブレンド計算
     *
     * 入力された値でブレンド計算をする。
     *
     * @param source 現在の値
     * @param destination 適用する値
     * @param weight ウェイト
     * @returns 計算結果
     */
    calculateValue(source2, destination, fadeWeight) {
      return source2 * (1 - fadeWeight) + destination * fadeWeight;
    }
  };
  __publicField(_CubismExpressionMotion, "DefaultAdditiveValue", 0);
  // 加算適用の初期値
  __publicField(_CubismExpressionMotion, "DefaultMultiplyValue", 1);
  var CubismExpressionMotion = _CubismExpressionMotion;
  var ExpressionBlendType;
  (function(ExpressionBlendType2) {
    ExpressionBlendType2[ExpressionBlendType2["Additive"] = 0] = "Additive";
    ExpressionBlendType2[ExpressionBlendType2["Multiply"] = 1] = "Multiply";
    ExpressionBlendType2[ExpressionBlendType2["Overwrite"] = 2] = "Overwrite";
  })(ExpressionBlendType || (ExpressionBlendType = {}));
  var ExpressionParameter = class {
    constructor() {
      __publicField(this, "parameterId");
      // パラメータID
      __publicField(this, "blendType");
      // パラメータの演算種類
      __publicField(this, "value");
    }
    // 値
  };
  var Live2DCubismFramework24;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismExpressionMotion = CubismExpressionMotion;
    Live2DCubismFramework42.ExpressionBlendType = ExpressionBlendType;
    Live2DCubismFramework42.ExpressionParameter = ExpressionParameter;
  })(Live2DCubismFramework24 || (Live2DCubismFramework24 = {}));

  // src/Live2D/dist/motion/cubismmotionqueueentry.js
  var CubismMotionQueueEntry = class {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_autoDelete");
      // 自動削除
      __publicField(this, "_motion");
      // モーション
      __publicField(this, "_available");
      // 有効化フラグ
      __publicField(this, "_finished");
      // 終了フラグ
      __publicField(this, "_started");
      // 開始フラグ
      __publicField(this, "_startTimeSeconds");
      // モーション再生開始時刻[秒]
      __publicField(this, "_fadeInStartTimeSeconds");
      // フェードイン開始時刻（ループの時は初回のみ）[秒]
      __publicField(this, "_endTimeSeconds");
      // 終了予定時刻[秒]
      __publicField(this, "_stateTimeSeconds");
      // 時刻の状態[秒]
      __publicField(this, "_stateWeight");
      // 重みの状態
      __publicField(this, "_lastEventCheckSeconds");
      // 最終のMotion側のチェックした時間
      __publicField(this, "_fadeOutSeconds");
      // フェードアウト時間[秒]
      __publicField(this, "_isTriggeredFadeOut");
      // フェードアウト開始フラグ
      __publicField(this, "_motionQueueEntryHandle");
      this._autoDelete = false;
      this._motion = null;
      this._available = true;
      this._finished = false;
      this._started = false;
      this._startTimeSeconds = -1;
      this._fadeInStartTimeSeconds = 0;
      this._endTimeSeconds = -1;
      this._stateTimeSeconds = 0;
      this._stateWeight = 0;
      this._lastEventCheckSeconds = 0;
      this._motionQueueEntryHandle = this;
      this._fadeOutSeconds = 0;
      this._isTriggeredFadeOut = false;
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      if (this._autoDelete && this._motion) {
        ACubismMotion.delete(this._motion);
      }
    }
    /**
     * フェードアウト時間と開始判定の設定
     * @param fadeOutSeconds フェードアウトにかかる時間[秒]
     */
    setFadeOut(fadeOutSeconds) {
      this._fadeOutSeconds = fadeOutSeconds;
      this._isTriggeredFadeOut = true;
    }
    /**
     * フェードアウトの開始
     * @param fadeOutSeconds フェードアウトにかかる時間[秒]
     * @param userTimeSeconds デルタ時間の積算値[秒]
     */
    startFadeOut(fadeOutSeconds, userTimeSeconds) {
      const newEndTimeSeconds = userTimeSeconds + fadeOutSeconds;
      this._isTriggeredFadeOut = true;
      if (this._endTimeSeconds < 0 || newEndTimeSeconds < this._endTimeSeconds) {
        this._endTimeSeconds = newEndTimeSeconds;
      }
    }
    /**
     * モーションの終了の確認
     *
     * @return true モーションが終了した
     * @return false 終了していない
     */
    isFinished() {
      return this._finished;
    }
    /**
     * モーションの開始の確認
     * @return true モーションが開始した
     * @return false 開始していない
     */
    isStarted() {
      return this._started;
    }
    /**
     * モーションの開始時刻の取得
     * @return モーションの開始時刻[秒]
     */
    getStartTime() {
      return this._startTimeSeconds;
    }
    /**
     * フェードインの開始時刻の取得
     * @return フェードインの開始時刻[秒]
     */
    getFadeInStartTime() {
      return this._fadeInStartTimeSeconds;
    }
    /**
     * フェードインの終了時刻の取得
     * @return フェードインの終了時刻の取得
     */
    getEndTime() {
      return this._endTimeSeconds;
    }
    /**
     * モーションの開始時刻の設定
     * @param startTime モーションの開始時刻
     */
    setStartTime(startTime) {
      this._startTimeSeconds = startTime;
    }
    /**
     * フェードインの開始時刻の設定
     * @param startTime フェードインの開始時刻[秒]
     */
    setFadeInStartTime(startTime) {
      this._fadeInStartTimeSeconds = startTime;
    }
    /**
     * フェードインの終了時刻の設定
     * @param endTime フェードインの終了時刻[秒]
     */
    setEndTime(endTime) {
      this._endTimeSeconds = endTime;
    }
    /**
     * モーションの終了の設定
     * @param f trueならモーションの終了
     */
    setIsFinished(f) {
      this._finished = f;
    }
    /**
     * モーション開始の設定
     * @param f trueならモーションの開始
     */
    setIsStarted(f) {
      this._started = f;
    }
    /**
     * モーションの有効性の確認
     * @return true モーションは有効
     * @return false モーションは無効
     */
    isAvailable() {
      return this._available;
    }
    /**
     * モーションの有効性の設定
     * @param v trueならモーションは有効
     */
    setIsAvailable(v) {
      this._available = v;
    }
    /**
     * モーションの状態の設定
     * @param timeSeconds 現在時刻[秒]
     * @param weight モーション尾重み
     */
    setState(timeSeconds, weight) {
      this._stateTimeSeconds = timeSeconds;
      this._stateWeight = weight;
    }
    /**
     * モーションの現在時刻の取得
     * @return モーションの現在時刻[秒]
     */
    getStateTime() {
      return this._stateTimeSeconds;
    }
    /**
     * モーションの重みの取得
     * @return モーションの重み
     */
    getStateWeight() {
      return this._stateWeight;
    }
    /**
     * 最後にイベントの発火をチェックした時間を取得
     *
     * @return 最後にイベントの発火をチェックした時間[秒]
     */
    getLastCheckEventSeconds() {
      return this._lastEventCheckSeconds;
    }
    /**
     * 最後にイベントをチェックした時間を設定
     * @param checkSeconds 最後にイベントをチェックした時間[秒]
     */
    setLastCheckEventSeconds(checkSeconds) {
      this._lastEventCheckSeconds = checkSeconds;
    }
    /**
     * フェードアウト開始判定の取得
     * @return フェードアウト開始するかどうか
     */
    isTriggeredFadeOut() {
      return this._isTriggeredFadeOut;
    }
    /**
     * フェードアウト時間の取得
     * @return フェードアウト時間[秒]
     */
    getFadeOutSeconds() {
      return this._fadeOutSeconds;
    }
    /**
     * モーションの取得
     *
     * @return モーション
     */
    getCubismMotion() {
      return this._motion;
    }
    // インスタンスごとに一意の値を持つ識別番号
  };
  var Live2DCubismFramework25;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionQueueEntry = CubismMotionQueueEntry;
  })(Live2DCubismFramework25 || (Live2DCubismFramework25 = {}));

  // src/Live2D/dist/motion/cubismmotionqueuemanager.js
  var CubismMotionQueueManager = class {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_userTimeSeconds");
      // デルタ時間の積算値[秒]
      __publicField(this, "_motions");
      // モーション
      __publicField(this, "_eventCallBack");
      // コールバック関数
      __publicField(this, "_eventCustomData");
      this._userTimeSeconds = 0;
      this._eventCallBack = null;
      this._eventCustomData = null;
      this._motions = new csmVector();
    }
    /**
     * デストラクタ
     */
    release() {
      for (let i = 0; i < this._motions.getSize(); ++i) {
        if (this._motions.at(i)) {
          this._motions.at(i).release();
          this._motions.set(i, null);
        }
      }
      this._motions = null;
    }
    /**
     * 指定したモーションの開始
     *
     * 指定したモーションを開始する。同じタイプのモーションが既にある場合は、既存のモーションに終了フラグを立て、フェードアウトを開始させる。
     *
     * @param   motion          開始するモーション
     * @param   autoDelete      再生が終了したモーションのインスタンスを削除するなら true
     * @param   userTimeSeconds Deprecated: デルタ時間の積算値[秒] 関数内で参照していないため使用は非推奨。
     * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」
     */
    startMotion(motion, autoDelete, userTimeSeconds) {
      if (motion == null) {
        return InvalidMotionQueueEntryHandleValue;
      }
      let motionQueueEntry = null;
      for (let i = 0; i < this._motions.getSize(); ++i) {
        motionQueueEntry = this._motions.at(i);
        if (motionQueueEntry == null) {
          continue;
        }
        motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime());
      }
      motionQueueEntry = new CubismMotionQueueEntry();
      motionQueueEntry._autoDelete = autoDelete;
      motionQueueEntry._motion = motion;
      this._motions.pushBack(motionQueueEntry);
      return motionQueueEntry._motionQueueEntryHandle;
    }
    /**
     * 全てのモーションの終了の確認
     * @return true 全て終了している
     * @return false 終了していない
     */
    isFinished() {
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
        let motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          ite = this._motions.erase(ite);
          continue;
        }
        const motion = motionQueueEntry._motion;
        if (motion == null) {
          motionQueueEntry.release();
          motionQueueEntry = null;
          ite = this._motions.erase(ite);
          continue;
        }
        if (!motionQueueEntry.isFinished()) {
          return false;
        } else {
          ite.preIncrement();
        }
      }
      return true;
    }
    /**
     * 指定したモーションの終了の確認
     * @param motionQueueEntryNumber モーションの識別番号
     * @return true 全て終了している
     * @return false 終了していない
     */
    isFinishedByHandle(motionQueueEntryNumber) {
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.increment()) {
        const motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          continue;
        }
        if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber && !motionQueueEntry.isFinished()) {
          return false;
        }
      }
      return true;
    }
    /**
     * 全てのモーションを停止する
     */
    stopAllMotions() {
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
        let motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          ite = this._motions.erase(ite);
          continue;
        }
        motionQueueEntry.release();
        motionQueueEntry = null;
        ite = this._motions.erase(ite);
      }
    }
    /**
     * @brief CubismMotionQueueEntryの配列の取得
     *
     * CubismMotionQueueEntryの配列を取得する。
     *
     * @return  CubismMotionQueueEntryの配列へのポインタ
     * @retval  NULL   見つからなかった
     */
    getCubismMotionQueueEntries() {
      return this._motions;
    }
    /**
       * 指定したCubismMotionQueueEntryの取得
    
       * @param   motionQueueEntryNumber  モーションの識別番号
       * @return  指定したCubismMotionQueueEntry
       * @return  null   見つからなかった
       */
    getCubismMotionQueueEntry(motionQueueEntryNumber) {
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ite.preIncrement()) {
        const motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          continue;
        }
        if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber) {
          return motionQueueEntry;
        }
      }
      return null;
    }
    /**
     * イベントを受け取るCallbackの登録
     *
     * @param callback コールバック関数
     * @param customData コールバックに返されるデータ
     */
    setEventCallback(callback, customData = null) {
      this._eventCallBack = callback;
      this._eventCustomData = customData;
    }
    /**
     * モーションを更新して、モデルにパラメータ値を反映する。
     *
     * @param   model   対象のモデル
     * @param   userTimeSeconds   デルタ時間の積算値[秒]
     * @return  true    モデルへパラメータ値の反映あり
     * @return  false   モデルへパラメータ値の反映なし(モーションの変化なし)
     */
    doUpdateMotion(model, userTimeSeconds) {
      let updated = false;
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
        let motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          ite = this._motions.erase(ite);
          continue;
        }
        const motion = motionQueueEntry._motion;
        if (motion == null) {
          motionQueueEntry.release();
          motionQueueEntry = null;
          ite = this._motions.erase(ite);
          continue;
        }
        motion.updateParameters(model, motionQueueEntry, userTimeSeconds);
        updated = true;
        const firedList = motion.getFiredEvent(motionQueueEntry.getLastCheckEventSeconds() - motionQueueEntry.getStartTime(), userTimeSeconds - motionQueueEntry.getStartTime());
        for (let i = 0; i < firedList.getSize(); ++i) {
          this._eventCallBack(this, firedList.at(i), this._eventCustomData);
        }
        motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);
        if (motionQueueEntry.isFinished()) {
          motionQueueEntry.release();
          motionQueueEntry = null;
          ite = this._motions.erase(ite);
        } else {
          if (motionQueueEntry.isTriggeredFadeOut()) {
            motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), userTimeSeconds);
          }
          ite.preIncrement();
        }
      }
      return updated;
    }
    // コールバックに戻されるデータ
  };
  var InvalidMotionQueueEntryHandleValue = -1;
  var Live2DCubismFramework26;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionQueueManager = CubismMotionQueueManager;
    Live2DCubismFramework42.InvalidMotionQueueEntryHandleValue = InvalidMotionQueueEntryHandleValue;
  })(Live2DCubismFramework26 || (Live2DCubismFramework26 = {}));

  // src/Live2D/dist/motion/cubismexpressionmotionmanager.js
  var ExpressionParameterValue = class {
    constructor() {
      __publicField(this, "parameterId");
      // パラメーターID
      __publicField(this, "additiveValue");
      // 加算値
      __publicField(this, "multiplyValue");
      // 乗算値
      __publicField(this, "overwriteValue");
    }
    // 上書き値
  };
  var CubismExpressionMotionManager = class extends CubismMotionQueueManager {
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      __publicField(this, "_expressionParameterValues");
      ///< モデルに適用する各パラメータの値
      __publicField(this, "_fadeWeights");
      ///< 再生中の表情のウェイト
      __publicField(this, "_currentPriority");
      ///< 現在再生中のモーションの優先度
      __publicField(this, "_reservePriority");
      ///< 再生予定のモーションの優先度。再生中は0になる。モーションファイルを別スレッドで読み込むときの機能。
      __publicField(this, "_startExpressionTime");
      this._currentPriority = 0;
      this._reservePriority = 0;
      this._expressionParameterValues = new csmVector();
      this._fadeWeights = new csmVector();
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      if (this._expressionParameterValues) {
        csmDelete(this._expressionParameterValues);
        this._expressionParameterValues = null;
      }
      if (this._fadeWeights) {
        csmDelete(this._fadeWeights);
        this._fadeWeights = null;
      }
    }
    /**
     * @brief 再生中のモーションの優先度の取得
     *
     * 再生中のモーションの優先度を取得する。
     *
     * @returns モーションの優先度
     */
    getCurrentPriority() {
      return this._currentPriority;
    }
    /**
     * @brief 予約中のモーションの優先度の取得
     *
     * 予約中のモーションの優先度を取得する。
     *
     * @return  モーションの優先度
     */
    getReservePriority() {
      return this._reservePriority;
    }
    /**
     * @brief 再生中のモーションのウェイトを取得する。
     *
     * @param[in]    index    表情のインデックス
     * @returns               表情モーションのウェイト
     */
    getFadeWeight(index) {
      return this._fadeWeights.at(index);
    }
    /**
     * @brief 予約中のモーションの優先度の設定
     *
     * 予約中のモーションの優先度を設定する。
     *
     * @param[in]   priority     優先度
     */
    setReservePriority(priority) {
      this._reservePriority = priority;
    }
    /**
     * @brief 優先度を設定してモーションの開始
     *
     * 優先度を設定してモーションを開始する。
     *
     * @param[in]   motion          モーション
     * @param[in]   autoDelete      再生が終了したモーションのインスタンスを削除するならtrue
     * @param[in]   priority        優先度
     * @return                      開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」
     */
    startMotionPriority(motion, autoDelete, priority) {
      if (priority == this.getReservePriority()) {
        this.setReservePriority(0);
      }
      this._currentPriority = priority;
      this._fadeWeights.pushBack(0);
      return this.startMotion(motion, autoDelete);
    }
    /**
     * @brief モーションの更新
     *
     * モーションを更新して、モデルにパラメータ値を反映する。
     *
     * @param[in]   model   対象のモデル
     * @param[in]   deltaTimeSeconds    デルタ時間[秒]
     * @retval  true    更新されている
     * @retval  false   更新されていない
     */
    updateMotion(model, deltaTimeSeconds) {
      this._userTimeSeconds += deltaTimeSeconds;
      let updated = false;
      const motions = this.getCubismMotionQueueEntries();
      let expressionWeight = 0;
      let expressionIndex = 0;
      for (let ite = this._motions.begin(); ite.notEqual(this._motions.end()); ) {
        const motionQueueEntry = ite.ptr();
        if (motionQueueEntry == null) {
          ite = motions.erase(ite);
          continue;
        }
        const expressionMotion = motionQueueEntry.getCubismMotion();
        if (expressionMotion == null) {
          csmDelete(motionQueueEntry);
          ite = motions.erase(ite);
          continue;
        }
        const expressionParameters = expressionMotion.getExpressionParameters();
        if (motionQueueEntry.isAvailable()) {
          for (let i = 0; i < expressionParameters.getSize(); ++i) {
            if (expressionParameters.at(i).parameterId == null) {
              continue;
            }
            let index = -1;
            for (let j = 0; j < this._expressionParameterValues.getSize(); ++j) {
              if (this._expressionParameterValues.at(j).parameterId != expressionParameters.at(i).parameterId) {
                continue;
              }
              index = j;
              break;
            }
            if (index >= 0) {
              continue;
            }
            const item = new ExpressionParameterValue();
            item.parameterId = expressionParameters.at(i).parameterId;
            item.additiveValue = CubismExpressionMotion.DefaultAdditiveValue;
            item.multiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
            item.overwriteValue = model.getParameterValueById(item.parameterId);
            this._expressionParameterValues.pushBack(item);
          }
        }
        expressionMotion.setupMotionQueueEntry(motionQueueEntry, this._userTimeSeconds);
        this._fadeWeights.set(expressionIndex, expressionMotion.updateFadeWeight(motionQueueEntry, this._userTimeSeconds));
        expressionMotion.calculateExpressionParameters(model, this._userTimeSeconds, motionQueueEntry, this._expressionParameterValues, expressionIndex, this._fadeWeights.at(expressionIndex));
        expressionWeight += expressionMotion.getFadeInTime() == 0 ? 1 : CubismMath.getEasingSine((this._userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / expressionMotion.getFadeInTime());
        updated = true;
        if (motionQueueEntry.isTriggeredFadeOut()) {
          motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), this._userTimeSeconds);
        }
        ite.preIncrement();
        ++expressionIndex;
      }
      if (motions.getSize() > 1) {
        const expressionMotion = motions.at(motions.getSize() - 1).getCubismMotion();
        const latestFadeWeight = this._fadeWeights.at(this._fadeWeights.getSize() - 1);
        if (latestFadeWeight >= 1) {
          for (let i = motions.getSize() - 2; i >= 0; --i) {
            const motionQueueEntry = motions.at(i);
            csmDelete(motionQueueEntry);
            motions.remove(i);
            this._fadeWeights.remove(i);
          }
        }
      }
      if (expressionWeight > 1) {
        expressionWeight = 1;
      }
      for (let i = 0; i < this._expressionParameterValues.getSize(); ++i) {
        const expressionParameterValue = this._expressionParameterValues.at(i);
        model.setParameterValueById(expressionParameterValue.parameterId, (expressionParameterValue.overwriteValue + expressionParameterValue.additiveValue) * expressionParameterValue.multiplyValue, expressionWeight);
        expressionParameterValue.additiveValue = CubismExpressionMotion.DefaultAdditiveValue;
        expressionParameterValue.multiplyValue = CubismExpressionMotion.DefaultMultiplyValue;
      }
      return updated;
    }
    ///< 表情の再生開始時刻
  };
  var Live2DCubismFramework27;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismExpressionMotionManager = CubismExpressionMotionManager;
  })(Live2DCubismFramework27 || (Live2DCubismFramework27 = {}));

  // src/Live2D/dist/motion/cubismmotioninternal.js
  var CubismMotionCurveTarget;
  (function(CubismMotionCurveTarget2) {
    CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_Model"] = 0] = "CubismMotionCurveTarget_Model";
    CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_Parameter"] = 1] = "CubismMotionCurveTarget_Parameter";
    CubismMotionCurveTarget2[CubismMotionCurveTarget2["CubismMotionCurveTarget_PartOpacity"] = 2] = "CubismMotionCurveTarget_PartOpacity";
  })(CubismMotionCurveTarget || (CubismMotionCurveTarget = {}));
  var CubismMotionSegmentType;
  (function(CubismMotionSegmentType2) {
    CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Linear"] = 0] = "CubismMotionSegmentType_Linear";
    CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Bezier"] = 1] = "CubismMotionSegmentType_Bezier";
    CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_Stepped"] = 2] = "CubismMotionSegmentType_Stepped";
    CubismMotionSegmentType2[CubismMotionSegmentType2["CubismMotionSegmentType_InverseStepped"] = 3] = "CubismMotionSegmentType_InverseStepped";
  })(CubismMotionSegmentType || (CubismMotionSegmentType = {}));
  var CubismMotionPoint = class {
    constructor() {
      __publicField(this, "time", 0);
      // 時間[秒]
      __publicField(this, "value", 0);
    }
    // 値
  };
  var CubismMotionSegment = class {
    /**
     * @brief コンストラクタ
     *
     * コンストラクタ。
     */
    constructor() {
      __publicField(this, "evaluate");
      // 使用する評価関数
      __publicField(this, "basePointIndex");
      // 最初のセグメントへのインデックス
      __publicField(this, "segmentType");
      this.evaluate = null;
      this.basePointIndex = 0;
      this.segmentType = 0;
    }
    // セグメントの種類
  };
  var CubismMotionCurve = class {
    constructor() {
      __publicField(this, "type");
      // カーブの種類
      __publicField(this, "id");
      // カーブのID
      __publicField(this, "segmentCount");
      // セグメントの個数
      __publicField(this, "baseSegmentIndex");
      // 最初のセグメントのインデックス
      __publicField(this, "fadeInTime");
      // フェードインにかかる時間[秒]
      __publicField(this, "fadeOutTime");
      this.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;
      this.segmentCount = 0;
      this.baseSegmentIndex = 0;
      this.fadeInTime = 0;
      this.fadeOutTime = 0;
    }
    // フェードアウトにかかる時間[秒]
  };
  var CubismMotionEvent = class {
    constructor() {
      __publicField(this, "fireTime", 0);
      __publicField(this, "value");
    }
  };
  var CubismMotionData = class {
    constructor() {
      __publicField(this, "duration");
      // モーションの長さ[秒]
      __publicField(this, "loop");
      // ループするかどうか
      __publicField(this, "curveCount");
      // カーブの個数
      __publicField(this, "eventCount");
      // UserDataの個数
      __publicField(this, "fps");
      // フレームレート
      __publicField(this, "curves");
      // カーブのリスト
      __publicField(this, "segments");
      // セグメントのリスト
      __publicField(this, "points");
      // ポイントのリスト
      __publicField(this, "events");
      this.duration = 0;
      this.loop = false;
      this.curveCount = 0;
      this.eventCount = 0;
      this.fps = 0;
      this.curves = new csmVector();
      this.segments = new csmVector();
      this.points = new csmVector();
      this.events = new csmVector();
    }
    // イベントのリスト
  };
  var Live2DCubismFramework28;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionCurve = CubismMotionCurve;
    Live2DCubismFramework42.CubismMotionCurveTarget = CubismMotionCurveTarget;
    Live2DCubismFramework42.CubismMotionData = CubismMotionData;
    Live2DCubismFramework42.CubismMotionEvent = CubismMotionEvent;
    Live2DCubismFramework42.CubismMotionPoint = CubismMotionPoint;
    Live2DCubismFramework42.CubismMotionSegment = CubismMotionSegment;
    Live2DCubismFramework42.CubismMotionSegmentType = CubismMotionSegmentType;
  })(Live2DCubismFramework28 || (Live2DCubismFramework28 = {}));

  // src/Live2D/dist/motion/cubismmotionjson.js
  var Meta = "Meta";
  var Duration = "Duration";
  var Loop = "Loop";
  var AreBeziersRestricted = "AreBeziersRestricted";
  var CurveCount = "CurveCount";
  var Fps = "Fps";
  var TotalSegmentCount = "TotalSegmentCount";
  var TotalPointCount = "TotalPointCount";
  var Curves = "Curves";
  var Target = "Target";
  var Id3 = "Id";
  var FadeInTime2 = "FadeInTime";
  var FadeOutTime2 = "FadeOutTime";
  var Segments = "Segments";
  var UserData2 = "UserData";
  var UserDataCount = "UserDataCount";
  var TotalUserDataSize = "TotalUserDataSize";
  var Time = "Time";
  var Value2 = "Value";
  var CubismMotionJson = class {
    /**
     * コンストラクタ
     * @param buffer motion3.jsonが読み込まれているバッファ
     * @param size バッファのサイズ
     */
    constructor(buffer, size) {
      __publicField(this, "_json");
      this._json = CubismJson.create(buffer, size);
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      CubismJson.delete(this._json);
    }
    /**
     * モーションの長さを取得する
     * @return モーションの長さ[秒]
     */
    getMotionDuration() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(Duration).toFloat();
    }
    /**
     * モーションのループ情報の取得
     * @return true ループする
     * @return false ループしない
     */
    isMotionLoop() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(Loop).toBoolean();
    }
    getEvaluationOptionFlag(flagType) {
      if (EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted == flagType) {
        return this._json.getRoot().getValueByString(Meta).getValueByString(AreBeziersRestricted).toBoolean();
      }
      return false;
    }
    /**
     * モーションカーブの個数の取得
     * @return モーションカーブの個数
     */
    getMotionCurveCount() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(CurveCount).toInt();
    }
    /**
     * モーションのフレームレートの取得
     * @return フレームレート[FPS]
     */
    getMotionFps() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(Fps).toFloat();
    }
    /**
     * モーションのセグメントの総合計の取得
     * @return モーションのセグメントの取得
     */
    getMotionTotalSegmentCount() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(TotalSegmentCount).toInt();
    }
    /**
     * モーションのカーブの制御店の総合計の取得
     * @return モーションのカーブの制御点の総合計
     */
    getMotionTotalPointCount() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(TotalPointCount).toInt();
    }
    /**
     * モーションのフェードイン時間の存在
     * @return true 存在する
     * @return false 存在しない
     */
    isExistMotionFadeInTime() {
      return !this._json.getRoot().getValueByString(Meta).getValueByString(FadeInTime2).isNull();
    }
    /**
     * モーションのフェードアウト時間の存在
     * @return true 存在する
     * @return false 存在しない
     */
    isExistMotionFadeOutTime() {
      return !this._json.getRoot().getValueByString(Meta).getValueByString(FadeOutTime2).isNull();
    }
    /**
     * モーションのフェードイン時間の取得
     * @return フェードイン時間[秒]
     */
    getMotionFadeInTime() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(FadeInTime2).toFloat();
    }
    /**
     * モーションのフェードアウト時間の取得
     * @return フェードアウト時間[秒]
     */
    getMotionFadeOutTime() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(FadeOutTime2).toFloat();
    }
    /**
     * モーションのカーブの種類の取得
     * @param curveIndex カーブのインデックス
     * @return カーブの種類
     */
    getMotionCurveTarget(curveIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Target).getRawString();
    }
    /**
     * モーションのカーブのIDの取得
     * @param curveIndex カーブのインデックス
     * @return カーブのID
     */
    getMotionCurveId(curveIndex) {
      return CubismFramework.getIdManager().getId(this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Id3).getRawString());
    }
    /**
     * モーションのカーブのフェードイン時間の存在
     * @param curveIndex カーブのインデックス
     * @return true 存在する
     * @return false 存在しない
     */
    isExistMotionCurveFadeInTime(curveIndex) {
      return !this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeInTime2).isNull();
    }
    /**
     * モーションのカーブのフェードアウト時間の存在
     * @param curveIndex カーブのインデックス
     * @return true 存在する
     * @return false 存在しない
     */
    isExistMotionCurveFadeOutTime(curveIndex) {
      return !this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeOutTime2).isNull();
    }
    /**
     * モーションのカーブのフェードイン時間の取得
     * @param curveIndex カーブのインデックス
     * @return フェードイン時間[秒]
     */
    getMotionCurveFadeInTime(curveIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeInTime2).toFloat();
    }
    /**
     * モーションのカーブのフェードアウト時間の取得
     * @param curveIndex カーブのインデックス
     * @return フェードアウト時間[秒]
     */
    getMotionCurveFadeOutTime(curveIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(FadeOutTime2).toFloat();
    }
    /**
     * モーションのカーブのセグメントの個数を取得する
     * @param curveIndex カーブのインデックス
     * @return モーションのカーブのセグメントの個数
     */
    getMotionCurveSegmentCount(curveIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Segments).getVector().getSize();
    }
    /**
     * モーションのカーブのセグメントの値の取得
     * @param curveIndex カーブのインデックス
     * @param segmentIndex セグメントのインデックス
     * @return セグメントの値
     */
    getMotionCurveSegment(curveIndex, segmentIndex) {
      return this._json.getRoot().getValueByString(Curves).getValueByIndex(curveIndex).getValueByString(Segments).getValueByIndex(segmentIndex).toFloat();
    }
    /**
     * イベントの個数の取得
     * @return イベントの個数
     */
    getEventCount() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(UserDataCount).toInt();
    }
    /**
     *  イベントの総文字数の取得
     * @return イベントの総文字数
     */
    getTotalEventValueSize() {
      return this._json.getRoot().getValueByString(Meta).getValueByString(TotalUserDataSize).toInt();
    }
    /**
     * イベントの時間の取得
     * @param userDataIndex イベントのインデックス
     * @return イベントの時間[秒]
     */
    getEventTime(userDataIndex) {
      return this._json.getRoot().getValueByString(UserData2).getValueByIndex(userDataIndex).getValueByString(Time).toFloat();
    }
    /**
     * イベントの取得
     * @param userDataIndex イベントのインデックス
     * @return イベントの文字列
     */
    getEventValue(userDataIndex) {
      return new csmString(this._json.getRoot().getValueByString(UserData2).getValueByIndex(userDataIndex).getValueByString(Value2).getRawString());
    }
    // motion3.jsonのデータ
  };
  var EvaluationOptionFlag;
  (function(EvaluationOptionFlag2) {
    EvaluationOptionFlag2[EvaluationOptionFlag2["EvaluationOptionFlag_AreBeziersRistricted"] = 0] = "EvaluationOptionFlag_AreBeziersRistricted";
  })(EvaluationOptionFlag || (EvaluationOptionFlag = {}));
  var Live2DCubismFramework29;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionJson = CubismMotionJson;
  })(Live2DCubismFramework29 || (Live2DCubismFramework29 = {}));

  // src/Live2D/dist/motion/cubismmotion.js
  var EffectNameEyeBlink = "EyeBlink";
  var EffectNameLipSync = "LipSync";
  var TargetNameModel = "Model";
  var TargetNameParameter = "Parameter";
  var TargetNamePartOpacity = "PartOpacity";
  var IdNameOpacity = "Opacity";
  var UseOldBeziersCurveMotion = false;
  function lerpPoints(a, b, t2) {
    const result = new CubismMotionPoint();
    result.time = a.time + (b.time - a.time) * t2;
    result.value = a.value + (b.value - a.value) * t2;
    return result;
  }
  function linearEvaluate(points, time) {
    let t2 = (time - points[0].time) / (points[1].time - points[0].time);
    if (t2 < 0) {
      t2 = 0;
    }
    return points[0].value + (points[1].value - points[0].value) * t2;
  }
  function bezierEvaluate(points, time) {
    let t2 = (time - points[0].time) / (points[3].time - points[0].time);
    if (t2 < 0) {
      t2 = 0;
    }
    const p01 = lerpPoints(points[0], points[1], t2);
    const p12 = lerpPoints(points[1], points[2], t2);
    const p23 = lerpPoints(points[2], points[3], t2);
    const p012 = lerpPoints(p01, p12, t2);
    const p123 = lerpPoints(p12, p23, t2);
    return lerpPoints(p012, p123, t2).value;
  }
  function bezierEvaluateCardanoInterpretation(points, time) {
    const x = time;
    const x1 = points[0].time;
    const x2 = points[3].time;
    const cx1 = points[1].time;
    const cx2 = points[2].time;
    const a = x2 - 3 * cx2 + 3 * cx1 - x1;
    const b = 3 * cx2 - 6 * cx1 + 3 * x1;
    const c = 3 * cx1 - 3 * x1;
    const d = x1 - x;
    const t2 = CubismMath.cardanoAlgorithmForBezier(a, b, c, d);
    const p01 = lerpPoints(points[0], points[1], t2);
    const p12 = lerpPoints(points[1], points[2], t2);
    const p23 = lerpPoints(points[2], points[3], t2);
    const p012 = lerpPoints(p01, p12, t2);
    const p123 = lerpPoints(p12, p23, t2);
    return lerpPoints(p012, p123, t2).value;
  }
  function steppedEvaluate(points, time) {
    return points[0].value;
  }
  function inverseSteppedEvaluate(points, time) {
    return points[1].value;
  }
  function evaluateCurve(motionData, index, time) {
    const curve = motionData.curves.at(index);
    let target = -1;
    const totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;
    let pointPosition = 0;
    for (let i = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {
      pointPosition = motionData.segments.at(i).basePointIndex + (motionData.segments.at(i).segmentType == CubismMotionSegmentType.CubismMotionSegmentType_Bezier ? 3 : 1);
      if (motionData.points.at(pointPosition).time > time) {
        target = i;
        break;
      }
    }
    if (target == -1) {
      return motionData.points.at(pointPosition).value;
    }
    const segment = motionData.segments.at(target);
    return segment.evaluate(motionData.points.get(segment.basePointIndex), time);
  }
  var CubismMotion = class _CubismMotion extends ACubismMotion {
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      __publicField(this, "_sourceFrameRate");
      // ロードしたファイルのFPS。記述が無ければデフォルト値15fpsとなる
      __publicField(this, "_loopDurationSeconds");
      // mtnファイルで定義される一連のモーションの長さ
      __publicField(this, "_isLoop");
      // ループするか?
      __publicField(this, "_isLoopFadeIn");
      // ループ時にフェードインが有効かどうかのフラグ。初期値では有効。
      __publicField(this, "_lastWeight");
      // 最後に設定された重み
      __publicField(this, "_motionData");
      // 実際のモーションデータ本体
      __publicField(this, "_eyeBlinkParameterIds");
      // 自動まばたきを適用するパラメータIDハンドルのリスト。  モデル（モデルセッティング）とパラメータを対応付ける。
      __publicField(this, "_lipSyncParameterIds");
      // リップシンクを適用するパラメータIDハンドルのリスト。  モデル（モデルセッティング）とパラメータを対応付ける。
      __publicField(this, "_modelCurveIdEyeBlink");
      // モデルが持つ自動まばたき用パラメータIDのハンドル。  モデルとモーションを対応付ける。
      __publicField(this, "_modelCurveIdLipSync");
      // モデルが持つリップシンク用パラメータIDのハンドル。  モデルとモーションを対応付ける。
      __publicField(this, "_modelCurveIdOpacity");
      // モデルが持つ不透明度用パラメータIDのハンドル。  モデルとモーションを対応付ける。
      __publicField(this, "_modelOpacity");
      this._sourceFrameRate = 30;
      this._loopDurationSeconds = -1;
      this._isLoop = false;
      this._isLoopFadeIn = true;
      this._lastWeight = 0;
      this._motionData = null;
      this._modelCurveIdEyeBlink = null;
      this._modelCurveIdLipSync = null;
      this._modelCurveIdOpacity = null;
      this._eyeBlinkParameterIds = null;
      this._lipSyncParameterIds = null;
      this._modelOpacity = 1;
    }
    /**
     * インスタンスを作成する
     *
     * @param buffer motion3.jsonが読み込まれているバッファ
     * @param size バッファのサイズ
     * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数
     * @return 作成されたインスタンス
     */
    static create(buffer, size, onFinishedMotionHandler) {
      const ret = new _CubismMotion();
      ret.parse(buffer, size);
      ret._sourceFrameRate = ret._motionData.fps;
      ret._loopDurationSeconds = ret._motionData.duration;
      ret._onFinishedMotion = onFinishedMotionHandler;
      return ret;
    }
    /**
     * モデルのパラメータの更新の実行
     * @param model             対象のモデル
     * @param userTimeSeconds   現在の時刻[秒]
     * @param fadeWeight        モーションの重み
     * @param motionQueueEntry  CubismMotionQueueManagerで管理されているモーション
     */
    doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry) {
      if (this._modelCurveIdEyeBlink == null) {
        this._modelCurveIdEyeBlink = CubismFramework.getIdManager().getId(EffectNameEyeBlink);
      }
      if (this._modelCurveIdLipSync == null) {
        this._modelCurveIdLipSync = CubismFramework.getIdManager().getId(EffectNameLipSync);
      }
      if (this._modelCurveIdOpacity == null) {
        this._modelCurveIdOpacity = CubismFramework.getIdManager().getId(IdNameOpacity);
      }
      let timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();
      if (timeOffsetSeconds < 0) {
        timeOffsetSeconds = 0;
      }
      let lipSyncValue = Number.MAX_VALUE;
      let eyeBlinkValue = Number.MAX_VALUE;
      const maxTargetSize = 64;
      let lipSyncFlags = 0;
      let eyeBlinkFlags = 0;
      if (this._eyeBlinkParameterIds.getSize() > maxTargetSize) {
        CubismLogDebug("too many eye blink targets : {0}", this._eyeBlinkParameterIds.getSize());
      }
      if (this._lipSyncParameterIds.getSize() > maxTargetSize) {
        CubismLogDebug("too many lip sync targets : {0}", this._lipSyncParameterIds.getSize());
      }
      const tmpFadeIn = this._fadeInSeconds <= 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds);
      const tmpFadeOut = this._fadeOutSeconds <= 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds);
      let value;
      let c, parameterIndex;
      let time = timeOffsetSeconds;
      if (this._isLoop) {
        while (time > this._motionData.duration) {
          time -= this._motionData.duration;
        }
      }
      const curves = this._motionData.curves;
      for (c = 0; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c) {
        value = evaluateCurve(this._motionData, c, time);
        if (curves.at(c).id == this._modelCurveIdEyeBlink) {
          eyeBlinkValue = value;
        } else if (curves.at(c).id == this._modelCurveIdLipSync) {
          lipSyncValue = value;
        } else if (curves.at(c).id == this._modelCurveIdOpacity) {
          this._modelOpacity = value;
          model.setModelOapcity(this.getModelOpacityValue());
        }
      }
      let parameterMotionCurveCount = 0;
      for (; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c) {
        parameterMotionCurveCount++;
        parameterIndex = model.getParameterIndex(curves.at(c).id);
        if (parameterIndex == -1) {
          continue;
        }
        const sourceValue = model.getParameterValueByIndex(parameterIndex);
        value = evaluateCurve(this._motionData, c, time);
        if (eyeBlinkValue != Number.MAX_VALUE) {
          for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < maxTargetSize; ++i) {
            if (this._eyeBlinkParameterIds.at(i) == curves.at(c).id) {
              value *= eyeBlinkValue;
              eyeBlinkFlags |= 1 << i;
              break;
            }
          }
        }
        if (lipSyncValue != Number.MAX_VALUE) {
          for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < maxTargetSize; ++i) {
            if (this._lipSyncParameterIds.at(i) == curves.at(c).id) {
              value += lipSyncValue;
              lipSyncFlags |= 1 << i;
              break;
            }
          }
        }
        let v;
        if (curves.at(c).fadeInTime < 0 && curves.at(c).fadeOutTime < 0) {
          v = sourceValue + (value - sourceValue) * fadeWeight;
        } else {
          let fin;
          let fout;
          if (curves.at(c).fadeInTime < 0) {
            fin = tmpFadeIn;
          } else {
            fin = curves.at(c).fadeInTime == 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / curves.at(c).fadeInTime);
          }
          if (curves.at(c).fadeOutTime < 0) {
            fout = tmpFadeOut;
          } else {
            fout = curves.at(c).fadeOutTime == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / curves.at(c).fadeOutTime);
          }
          const paramWeight = this._weight * fin * fout;
          v = sourceValue + (value - sourceValue) * paramWeight;
        }
        model.setParameterValueByIndex(parameterIndex, v, 1);
      }
      {
        if (eyeBlinkValue != Number.MAX_VALUE) {
          for (let i = 0; i < this._eyeBlinkParameterIds.getSize() && i < maxTargetSize; ++i) {
            const sourceValue = model.getParameterValueById(this._eyeBlinkParameterIds.at(i));
            if (eyeBlinkFlags >> i & 1) {
              continue;
            }
            const v = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;
            model.setParameterValueById(this._eyeBlinkParameterIds.at(i), v);
          }
        }
        if (lipSyncValue != Number.MAX_VALUE) {
          for (let i = 0; i < this._lipSyncParameterIds.getSize() && i < maxTargetSize; ++i) {
            const sourceValue = model.getParameterValueById(this._lipSyncParameterIds.at(i));
            if (lipSyncFlags >> i & 1) {
              continue;
            }
            const v = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;
            model.setParameterValueById(this._lipSyncParameterIds.at(i), v);
          }
        }
      }
      for (; c < this._motionData.curveCount && curves.at(c).type == CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c) {
        parameterIndex = model.getParameterIndex(curves.at(c).id);
        if (parameterIndex == -1) {
          continue;
        }
        value = evaluateCurve(this._motionData, c, time);
        model.setParameterValueByIndex(parameterIndex, value);
      }
      if (timeOffsetSeconds >= this._motionData.duration) {
        if (this._isLoop) {
          motionQueueEntry.setStartTime(userTimeSeconds);
          if (this._isLoopFadeIn) {
            motionQueueEntry.setFadeInStartTime(userTimeSeconds);
          }
        } else {
          if (this._onFinishedMotion) {
            this._onFinishedMotion(this);
          }
          motionQueueEntry.setIsFinished(true);
        }
      }
      this._lastWeight = fadeWeight;
    }
    /**
     * ループ情報の設定
     * @param loop ループ情報
     */
    setIsLoop(loop) {
      this._isLoop = loop;
    }
    /**
     * ループ情報の取得
     * @return true ループする
     * @return false ループしない
     */
    isLoop() {
      return this._isLoop;
    }
    /**
     * ループ時のフェードイン情報の設定
     * @param loopFadeIn  ループ時のフェードイン情報
     */
    setIsLoopFadeIn(loopFadeIn) {
      this._isLoopFadeIn = loopFadeIn;
    }
    /**
     * ループ時のフェードイン情報の取得
     *
     * @return  true    する
     * @return  false   しない
     */
    isLoopFadeIn() {
      return this._isLoopFadeIn;
    }
    /**
     * モーションの長さを取得する。
     *
     * @return  モーションの長さ[秒]
     */
    getDuration() {
      return this._isLoop ? -1 : this._loopDurationSeconds;
    }
    /**
     * モーションのループ時の長さを取得する。
     *
     * @return  モーションのループ時の長さ[秒]
     */
    getLoopDuration() {
      return this._loopDurationSeconds;
    }
    /**
     * パラメータに対するフェードインの時間を設定する。
     *
     * @param parameterId     パラメータID
     * @param value           フェードインにかかる時間[秒]
     */
    setParameterFadeInTime(parameterId, value) {
      const curves = this._motionData.curves;
      for (let i = 0; i < this._motionData.curveCount; ++i) {
        if (parameterId == curves.at(i).id) {
          curves.at(i).fadeInTime = value;
          return;
        }
      }
    }
    /**
     * パラメータに対するフェードアウトの時間の設定
     * @param parameterId     パラメータID
     * @param value           フェードアウトにかかる時間[秒]
     */
    setParameterFadeOutTime(parameterId, value) {
      const curves = this._motionData.curves;
      for (let i = 0; i < this._motionData.curveCount; ++i) {
        if (parameterId == curves.at(i).id) {
          curves.at(i).fadeOutTime = value;
          return;
        }
      }
    }
    /**
     * パラメータに対するフェードインの時間の取得
     * @param    parameterId     パラメータID
     * @return   フェードインにかかる時間[秒]
     */
    getParameterFadeInTime(parameterId) {
      const curves = this._motionData.curves;
      for (let i = 0; i < this._motionData.curveCount; ++i) {
        if (parameterId == curves.at(i).id) {
          return curves.at(i).fadeInTime;
        }
      }
      return -1;
    }
    /**
     * パラメータに対するフェードアウトの時間を取得
     *
     * @param   parameterId     パラメータID
     * @return   フェードアウトにかかる時間[秒]
     */
    getParameterFadeOutTime(parameterId) {
      const curves = this._motionData.curves;
      for (let i = 0; i < this._motionData.curveCount; ++i) {
        if (parameterId == curves.at(i).id) {
          return curves.at(i).fadeOutTime;
        }
      }
      return -1;
    }
    /**
     * 自動エフェクトがかかっているパラメータIDリストの設定
     * @param eyeBlinkParameterIds    自動まばたきがかかっているパラメータIDのリスト
     * @param lipSyncParameterIds     リップシンクがかかっているパラメータIDのリスト
     */
    setEffectIds(eyeBlinkParameterIds, lipSyncParameterIds) {
      this._eyeBlinkParameterIds = eyeBlinkParameterIds;
      this._lipSyncParameterIds = lipSyncParameterIds;
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      this._motionData = void 0;
      this._motionData = null;
    }
    /**
     * motion3.jsonをパースする。
     *
     * @param motionJson  motion3.jsonが読み込まれているバッファ
     * @param size        バッファのサイズ
     */
    parse(motionJson, size) {
      this._motionData = new CubismMotionData();
      let json = new CubismMotionJson(motionJson, size);
      if (!json) {
        json.release();
        json = void 0;
        return;
      }
      this._motionData.duration = json.getMotionDuration();
      this._motionData.loop = json.isMotionLoop();
      this._motionData.curveCount = json.getMotionCurveCount();
      this._motionData.fps = json.getMotionFps();
      this._motionData.eventCount = json.getEventCount();
      const areBeziersRestructed = json.getEvaluationOptionFlag(EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted);
      if (json.isExistMotionFadeInTime()) {
        this._fadeInSeconds = json.getMotionFadeInTime() < 0 ? 1 : json.getMotionFadeInTime();
      } else {
        this._fadeInSeconds = 1;
      }
      if (json.isExistMotionFadeOutTime()) {
        this._fadeOutSeconds = json.getMotionFadeOutTime() < 0 ? 1 : json.getMotionFadeOutTime();
      } else {
        this._fadeOutSeconds = 1;
      }
      this._motionData.curves.updateSize(this._motionData.curveCount, CubismMotionCurve, true);
      this._motionData.segments.updateSize(json.getMotionTotalSegmentCount(), CubismMotionSegment, true);
      this._motionData.points.updateSize(json.getMotionTotalPointCount(), CubismMotionPoint, true);
      this._motionData.events.updateSize(this._motionData.eventCount, CubismMotionEvent, true);
      let totalPointCount = 0;
      let totalSegmentCount = 0;
      for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {
        if (json.getMotionCurveTarget(curveCount) == TargetNameModel) {
          this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;
        } else if (json.getMotionCurveTarget(curveCount) == TargetNameParameter) {
          this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;
        } else if (json.getMotionCurveTarget(curveCount) == TargetNamePartOpacity) {
          this._motionData.curves.at(curveCount).type = CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;
        } else {
          CubismLogWarning('Warning : Unable to get segment type from Curve! The number of "CurveCount" may be incorrect!');
        }
        this._motionData.curves.at(curveCount).id = json.getMotionCurveId(curveCount);
        this._motionData.curves.at(curveCount).baseSegmentIndex = totalSegmentCount;
        this._motionData.curves.at(curveCount).fadeInTime = json.isExistMotionCurveFadeInTime(curveCount) ? json.getMotionCurveFadeInTime(curveCount) : -1;
        this._motionData.curves.at(curveCount).fadeOutTime = json.isExistMotionCurveFadeOutTime(curveCount) ? json.getMotionCurveFadeOutTime(curveCount) : -1;
        for (let segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount); ) {
          if (segmentPosition == 0) {
            this._motionData.segments.at(totalSegmentCount).basePointIndex = totalPointCount;
            this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition);
            this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
            totalPointCount += 1;
            segmentPosition += 2;
          } else {
            this._motionData.segments.at(totalSegmentCount).basePointIndex = totalPointCount - 1;
          }
          const segment = json.getMotionCurveSegment(curveCount, segmentPosition);
          const segmentType = segment;
          switch (segmentType) {
            case CubismMotionSegmentType.CubismMotionSegmentType_Linear: {
              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Linear;
              this._motionData.segments.at(totalSegmentCount).evaluate = linearEvaluate;
              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
              totalPointCount += 1;
              segmentPosition += 3;
              break;
            }
            case CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {
              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Bezier;
              if (areBeziersRestructed || UseOldBeziersCurveMotion) {
                this._motionData.segments.at(totalSegmentCount).evaluate = bezierEvaluate;
              } else {
                this._motionData.segments.at(totalSegmentCount).evaluate = bezierEvaluateCardanoInterpretation;
              }
              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
              this._motionData.points.at(totalPointCount + 1).time = json.getMotionCurveSegment(curveCount, segmentPosition + 3);
              this._motionData.points.at(totalPointCount + 1).value = json.getMotionCurveSegment(curveCount, segmentPosition + 4);
              this._motionData.points.at(totalPointCount + 2).time = json.getMotionCurveSegment(curveCount, segmentPosition + 5);
              this._motionData.points.at(totalPointCount + 2).value = json.getMotionCurveSegment(curveCount, segmentPosition + 6);
              totalPointCount += 3;
              segmentPosition += 7;
              break;
            }
            case CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {
              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Stepped;
              this._motionData.segments.at(totalSegmentCount).evaluate = steppedEvaluate;
              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
              totalPointCount += 1;
              segmentPosition += 3;
              break;
            }
            case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {
              this._motionData.segments.at(totalSegmentCount).segmentType = CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;
              this._motionData.segments.at(totalSegmentCount).evaluate = inverseSteppedEvaluate;
              this._motionData.points.at(totalPointCount).time = json.getMotionCurveSegment(curveCount, segmentPosition + 1);
              this._motionData.points.at(totalPointCount).value = json.getMotionCurveSegment(curveCount, segmentPosition + 2);
              totalPointCount += 1;
              segmentPosition += 3;
              break;
            }
            default: {
              CSM_ASSERT(0);
              break;
            }
          }
          ++this._motionData.curves.at(curveCount).segmentCount;
          ++totalSegmentCount;
        }
      }
      for (let userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {
        this._motionData.events.at(userdatacount).fireTime = json.getEventTime(userdatacount);
        this._motionData.events.at(userdatacount).value = json.getEventValue(userdatacount);
      }
      json.release();
      json = void 0;
      json = null;
    }
    /**
     * モデルのパラメータ更新
     *
     * イベント発火のチェック。
     * 入力する時間は呼ばれるモーションタイミングを０とした秒数で行う。
     *
     * @param beforeCheckTimeSeconds   前回のイベントチェック時間[秒]
     * @param motionTimeSeconds        今回の再生時間[秒]
     */
    getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {
      this._firedEventValues.updateSize(0);
      for (let u = 0; u < this._motionData.eventCount; ++u) {
        if (this._motionData.events.at(u).fireTime > beforeCheckTimeSeconds && this._motionData.events.at(u).fireTime <= motionTimeSeconds) {
          this._firedEventValues.pushBack(new csmString(this._motionData.events.at(u).value.s));
        }
      }
      return this._firedEventValues;
    }
    /**
     * 透明度のカーブが存在するかどうかを確認する
     *
     * @returns true  -> キーが存在する
     *          false -> キーが存在しない
     */
    isExistModelOpacity() {
      for (let i = 0; i < this._motionData.curveCount; i++) {
        const curve = this._motionData.curves.at(i);
        if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
          continue;
        }
        if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
          return true;
        }
      }
      return false;
    }
    /**
     * 透明度のカーブのインデックスを返す
     *
     * @returns success:透明度のカーブのインデックス
     */
    getModelOpacityIndex() {
      if (this.isExistModelOpacity()) {
        for (let i = 0; i < this._motionData.curveCount; i++) {
          const curve = this._motionData.curves.at(i);
          if (curve.type != CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
            continue;
          }
          if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
            return i;
          }
        }
      }
      return -1;
    }
    /**
     * 透明度のIdを返す
     *
     * @param index モーションカーブのインデックス
     * @returns success:透明度のカーブのインデックス
     */
    getModelOpacityId(index) {
      if (index != -1) {
        const curve = this._motionData.curves.at(index);
        if (curve.type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model) {
          if (curve.id.getString().s.localeCompare(IdNameOpacity) == 0) {
            return CubismFramework.getIdManager().getId(curve.id.getString().s);
          }
        }
      }
      return null;
    }
    /**
     * 現在時間の透明度の値を返す
     *
     * @returns success:モーションの当該時間におけるOpacityの値
     */
    getModelOpacityValue() {
      return this._modelOpacity;
    }
    // モーションから取得した不透明度
  };
  var Live2DCubismFramework30;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotion = CubismMotion;
  })(Live2DCubismFramework30 || (Live2DCubismFramework30 = {}));

  // src/Live2D/dist/motion/cubismmotionmanager.js
  var CubismMotionManager = class extends CubismMotionQueueManager {
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      __publicField(this, "_currentPriority");
      // 現在再生中のモーションの優先度
      __publicField(this, "_reservePriority");
      this._currentPriority = 0;
      this._reservePriority = 0;
    }
    /**
     * 再生中のモーションの優先度の取得
     * @return  モーションの優先度
     */
    getCurrentPriority() {
      return this._currentPriority;
    }
    /**
     * 予約中のモーションの優先度を取得する。
     * @return  モーションの優先度
     */
    getReservePriority() {
      return this._reservePriority;
    }
    /**
     * 予約中のモーションの優先度を設定する。
     * @param   val     優先度
     */
    setReservePriority(val) {
      this._reservePriority = val;
    }
    /**
     * 優先度を設定してモーションを開始する。
     *
     * @param motion          モーション
     * @param autoDelete      再生が狩猟したモーションのインスタンスを削除するならtrue
     * @param priority        優先度
     * @return                開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するIsFinished()の引数で使用する。開始できない時は「-1」
     */
    startMotionPriority(motion, autoDelete, priority) {
      if (priority == this._reservePriority) {
        this._reservePriority = 0;
      }
      this._currentPriority = priority;
      return super.startMotion(motion, autoDelete);
    }
    /**
     * モーションを更新して、モデルにパラメータ値を反映する。
     *
     * @param model   対象のモデル
     * @param deltaTimeSeconds    デルタ時間[秒]
     * @return  true    更新されている
     * @return  false   更新されていない
     */
    updateMotion(model, deltaTimeSeconds) {
      this._userTimeSeconds += deltaTimeSeconds;
      const updated = super.doUpdateMotion(model, this._userTimeSeconds);
      if (this.isFinished()) {
        this._currentPriority = 0;
      }
      return updated;
    }
    /**
     * モーションを予約する。
     *
     * @param   priority    優先度
     * @return  true    予約できた
     * @return  false   予約できなかった
     */
    reserveMotion(priority) {
      if (priority <= this._reservePriority || priority <= this._currentPriority) {
        return false;
      }
      this._reservePriority = priority;
      return true;
    }
    // 再生予定のモーションの優先度。再生中は0になる。モーションファイルを別スレッドで読み込むときの機能。
  };
  var Live2DCubismFramework31;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMotionManager = CubismMotionManager;
  })(Live2DCubismFramework31 || (Live2DCubismFramework31 = {}));

  // src/Live2D/dist/physics/cubismphysicsinternal.js
  var CubismPhysicsTargetType;
  (function(CubismPhysicsTargetType2) {
    CubismPhysicsTargetType2[CubismPhysicsTargetType2["CubismPhysicsTargetType_Parameter"] = 0] = "CubismPhysicsTargetType_Parameter";
  })(CubismPhysicsTargetType || (CubismPhysicsTargetType = {}));
  var CubismPhysicsSource;
  (function(CubismPhysicsSource2) {
    CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_X"] = 0] = "CubismPhysicsSource_X";
    CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_Y"] = 1] = "CubismPhysicsSource_Y";
    CubismPhysicsSource2[CubismPhysicsSource2["CubismPhysicsSource_Angle"] = 2] = "CubismPhysicsSource_Angle";
  })(CubismPhysicsSource || (CubismPhysicsSource = {}));
  var PhysicsJsonEffectiveForces = class {
    constructor() {
      __publicField(this, "gravity");
      // 重力
      __publicField(this, "wind");
      this.gravity = new CubismVector2(0, 0);
      this.wind = new CubismVector2(0, 0);
    }
    // 風
  };
  var CubismPhysicsParameter = class {
    constructor() {
      __publicField(this, "id");
      // パラメータ
      __publicField(this, "targetType");
    }
    // 適用先の種類
  };
  var CubismPhysicsNormalization = class {
    constructor() {
      __publicField(this, "minimum");
      // 最大値
      __publicField(this, "maximum");
      // 最小値
      __publicField(this, "defalut");
    }
    // デフォルト値
  };
  var CubismPhysicsParticle = class {
    constructor() {
      __publicField(this, "initialPosition");
      // 初期位置
      __publicField(this, "mobility");
      // 動きやすさ
      __publicField(this, "delay");
      // 遅れ
      __publicField(this, "acceleration");
      // 加速度
      __publicField(this, "radius");
      // 距離
      __publicField(this, "position");
      // 現在の位置
      __publicField(this, "lastPosition");
      // 最後の位置
      __publicField(this, "lastGravity");
      // 最後の重力
      __publicField(this, "force");
      // 現在かかっている力
      __publicField(this, "velocity");
      this.initialPosition = new CubismVector2(0, 0);
      this.position = new CubismVector2(0, 0);
      this.lastPosition = new CubismVector2(0, 0);
      this.lastGravity = new CubismVector2(0, 0);
      this.force = new CubismVector2(0, 0);
      this.velocity = new CubismVector2(0, 0);
    }
    // 現在の速度
  };
  var CubismPhysicsSubRig = class {
    constructor() {
      __publicField(this, "inputCount");
      // 入力の個数
      __publicField(this, "outputCount");
      // 出力の個数
      __publicField(this, "particleCount");
      // 物理点の個数
      __publicField(this, "baseInputIndex");
      // 入力の最初のインデックス
      __publicField(this, "baseOutputIndex");
      // 出力の最初のインデックス
      __publicField(this, "baseParticleIndex");
      // 物理点の最初のインデックス
      __publicField(this, "normalizationPosition");
      // 正規化された位置
      __publicField(this, "normalizationAngle");
      this.normalizationPosition = new CubismPhysicsNormalization();
      this.normalizationAngle = new CubismPhysicsNormalization();
    }
    // 正規化された角度
  };
  var CubismPhysicsInput = class {
    constructor() {
      __publicField(this, "source");
      // 入力元のパラメータ
      __publicField(this, "sourceParameterIndex");
      // 入力元のパラメータのインデックス
      __publicField(this, "weight");
      // 重み
      __publicField(this, "type");
      // 入力の種類
      __publicField(this, "reflect");
      // 値が反転されているかどうか
      __publicField(this, "getNormalizedParameterValue");
      this.source = new CubismPhysicsParameter();
    }
    // 正規化されたパラメータ値の取得関数
  };
  var CubismPhysicsOutput = class {
    constructor() {
      __publicField(this, "destination");
      // 出力先のパラメータ
      __publicField(this, "destinationParameterIndex");
      // 出力先のパラメータのインデックス
      __publicField(this, "vertexIndex");
      // 振り子のインデックス
      __publicField(this, "translationScale");
      // 移動値のスケール
      __publicField(this, "angleScale");
      // 角度のスケール
      __publicField(this, "weight");
      // 重み
      __publicField(this, "type");
      // 出力の種類
      __publicField(this, "reflect");
      // 値が反転されているかどうか
      __publicField(this, "valueBelowMinimum");
      // 最小値を下回った時の値
      __publicField(this, "valueExceededMaximum");
      // 最大値をこえた時の値
      __publicField(this, "getValue");
      // 物理演算の値の取得関数
      __publicField(this, "getScale");
      this.destination = new CubismPhysicsParameter();
      this.translationScale = new CubismVector2(0, 0);
    }
    // 物理演算のスケール値の取得関数
  };
  var CubismPhysicsRig = class {
    constructor() {
      __publicField(this, "subRigCount");
      // 物理演算の物理点の個数
      __publicField(this, "settings");
      // 物理演算の物理点の管理のリスト
      __publicField(this, "inputs");
      // 物理演算の入力のリスト
      __publicField(this, "outputs");
      // 物理演算の出力のリスト
      __publicField(this, "particles");
      // 物理演算の物理点のリスト
      __publicField(this, "gravity");
      // 重力
      __publicField(this, "wind");
      // 風
      __publicField(this, "fps");
      this.settings = new csmVector();
      this.inputs = new csmVector();
      this.outputs = new csmVector();
      this.particles = new csmVector();
      this.gravity = new CubismVector2(0, 0);
      this.wind = new CubismVector2(0, 0);
      this.fps = 0;
    }
    //物理演算動作FPS
  };
  var Live2DCubismFramework32;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismPhysicsInput = CubismPhysicsInput;
    Live2DCubismFramework42.CubismPhysicsNormalization = CubismPhysicsNormalization;
    Live2DCubismFramework42.CubismPhysicsOutput = CubismPhysicsOutput;
    Live2DCubismFramework42.CubismPhysicsParameter = CubismPhysicsParameter;
    Live2DCubismFramework42.CubismPhysicsParticle = CubismPhysicsParticle;
    Live2DCubismFramework42.CubismPhysicsRig = CubismPhysicsRig;
    Live2DCubismFramework42.CubismPhysicsSource = CubismPhysicsSource;
    Live2DCubismFramework42.CubismPhysicsSubRig = CubismPhysicsSubRig;
    Live2DCubismFramework42.CubismPhysicsTargetType = CubismPhysicsTargetType;
    Live2DCubismFramework42.PhysicsJsonEffectiveForces = PhysicsJsonEffectiveForces;
  })(Live2DCubismFramework32 || (Live2DCubismFramework32 = {}));

  // src/Live2D/dist/physics/cubismphysicsjson.js
  var Position = "Position";
  var X = "X";
  var Y = "Y";
  var Angle = "Angle";
  var Type = "Type";
  var Id4 = "Id";
  var Meta2 = "Meta";
  var EffectiveForces = "EffectiveForces";
  var TotalInputCount = "TotalInputCount";
  var TotalOutputCount = "TotalOutputCount";
  var PhysicsSettingCount = "PhysicsSettingCount";
  var Gravity = "Gravity";
  var Wind = "Wind";
  var VertexCount = "VertexCount";
  var Fps2 = "Fps";
  var PhysicsSettings = "PhysicsSettings";
  var Normalization = "Normalization";
  var Minimum = "Minimum";
  var Maximum = "Maximum";
  var Default = "Default";
  var Reflect2 = "Reflect";
  var Weight = "Weight";
  var Input = "Input";
  var Source = "Source";
  var Output = "Output";
  var Scale = "Scale";
  var VertexIndex = "VertexIndex";
  var Destination = "Destination";
  var Vertices = "Vertices";
  var Mobility = "Mobility";
  var Delay = "Delay";
  var Radius = "Radius";
  var Acceleration = "Acceleration";
  var CubismPhysicsJson = class {
    /**
     * コンストラクタ
     * @param buffer physics3.jsonが読み込まれているバッファ
     * @param size バッファのサイズ
     */
    constructor(buffer, size) {
      __publicField(this, "_json");
      this._json = CubismJson.create(buffer, size);
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      CubismJson.delete(this._json);
    }
    /**
     * 重力の取得
     * @return 重力
     */
    getGravity() {
      const ret = new CubismVector2(0, 0);
      ret.x = this._json.getRoot().getValueByString(Meta2).getValueByString(EffectiveForces).getValueByString(Gravity).getValueByString(X).toFloat();
      ret.y = this._json.getRoot().getValueByString(Meta2).getValueByString(EffectiveForces).getValueByString(Gravity).getValueByString(Y).toFloat();
      return ret;
    }
    /**
     * 風の取得
     * @return 風
     */
    getWind() {
      const ret = new CubismVector2(0, 0);
      ret.x = this._json.getRoot().getValueByString(Meta2).getValueByString(EffectiveForces).getValueByString(Wind).getValueByString(X).toFloat();
      ret.y = this._json.getRoot().getValueByString(Meta2).getValueByString(EffectiveForces).getValueByString(Wind).getValueByString(Y).toFloat();
      return ret;
    }
    /**
     * 物理演算設定FPSの取得
     * @return 物理演算設定FPS
     */
    getFps() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(Fps2).toFloat(0);
    }
    /**
     * 物理店の管理の個数の取得
     * @return 物理店の管理の個数
     */
    getSubRigCount() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(PhysicsSettingCount).toInt();
    }
    /**
     * 入力の総合計の取得
     * @return 入力の総合計
     */
    getTotalInputCount() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(TotalInputCount).toInt();
    }
    /**
     * 出力の総合計の取得
     * @return 出力の総合計
     */
    getTotalOutputCount() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(TotalOutputCount).toInt();
    }
    /**
     * 物理点の個数の取得
     * @return 物理点の個数
     */
    getVertexCount() {
      return this._json.getRoot().getValueByString(Meta2).getValueByString(VertexCount).toInt();
    }
    /**
     * 正規化された位置の最小値の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @return 正規化された位置の最小値
     */
    getNormalizationPositionMinimumValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Minimum).toFloat();
    }
    /**
     * 正規化された位置の最大値の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @return 正規化された位置の最大値
     */
    getNormalizationPositionMaximumValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Maximum).toFloat();
    }
    /**
     * 正規化された位置のデフォルト値の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @return 正規化された位置のデフォルト値
     */
    getNormalizationPositionDefaultValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Position).getValueByString(Default).toFloat();
    }
    /**
     * 正規化された角度の最小値の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @return 正規化された角度の最小値
     */
    getNormalizationAngleMinimumValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Minimum).toFloat();
    }
    /**
     * 正規化された角度の最大値の取得
     * @param physicsSettingIndex
     * @return 正規化された角度の最大値
     */
    getNormalizationAngleMaximumValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Maximum).toFloat();
    }
    /**
     * 正規化された角度のデフォルト値の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @return 正規化された角度のデフォルト値
     */
    getNormalizationAngleDefaultValue(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Normalization).getValueByString(Angle).getValueByString(Default).toFloat();
    }
    /**
     * 入力の個数の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @return 入力の個数
     */
    getInputCount(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getVector().getSize();
    }
    /**
     * 入力の重みの取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param inputIndex 入力のインデックス
     * @return 入力の重み
     */
    getInputWeight(physicsSettingIndex, inputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Weight).toFloat();
    }
    /**
     * 入力の反転の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param inputIndex 入力のインデックス
     * @return 入力の反転
     */
    getInputReflect(physicsSettingIndex, inputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Reflect2).toBoolean();
    }
    /**
     * 入力の種類の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param inputIndex 入力のインデックス
     * @return 入力の種類
     */
    getInputType(physicsSettingIndex, inputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Type).getRawString();
    }
    /**
     * 入力元のIDの取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param inputIndex 入力のインデックス
     * @return 入力元のID
     */
    getInputSourceId(physicsSettingIndex, inputIndex) {
      return CubismFramework.getIdManager().getId(this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Input).getValueByIndex(inputIndex).getValueByString(Source).getValueByString(Id4).getRawString());
    }
    /**
     * 出力の個数の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @return 出力の個数
     */
    getOutputCount(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getVector().getSize();
    }
    /**
     * 出力の物理点のインデックスの取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param outputIndex 出力のインデックス
     * @return 出力の物理点のインデックス
     */
    getOutputVertexIndex(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(VertexIndex).toInt();
    }
    /**
     * 出力の角度のスケールを取得する
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param outputIndex 出力のインデックス
     * @return 出力の角度のスケール
     */
    getOutputAngleScale(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Scale).toFloat();
    }
    /**
     * 出力の重みの取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param outputIndex 出力のインデックス
     * @return 出力の重み
     */
    getOutputWeight(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Weight).toFloat();
    }
    /**
     * 出力先のIDの取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param outputIndex 出力のインデックス
     * @return 出力先のID
     */
    getOutputDestinationId(physicsSettingIndex, outputIndex) {
      return CubismFramework.getIdManager().getId(this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Destination).getValueByString(Id4).getRawString());
    }
    /**
     * 出力の種類の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param outputIndex 出力のインデックス
     * @return 出力の種類
     */
    getOutputType(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Type).getRawString();
    }
    /**
     * 出力の反転の取得
     * @param physicsSettingIndex 物理演算のインデックス
     * @param outputIndex 出力のインデックス
     * @return 出力の反転
     */
    getOutputReflect(physicsSettingIndex, outputIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Output).getValueByIndex(outputIndex).getValueByString(Reflect2).toBoolean();
    }
    /**
     * 物理点の個数の取得
     * @param physicsSettingIndex 物理演算男設定のインデックス
     * @return 物理点の個数
     */
    getParticleCount(physicsSettingIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getVector().getSize();
    }
    /**
     * 物理点の動きやすさの取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param vertexIndex 物理点のインデックス
     * @return 物理点の動きやすさ
     */
    getParticleMobility(physicsSettingIndex, vertexIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Mobility).toFloat();
    }
    /**
     * 物理点の遅れの取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param vertexIndex 物理点のインデックス
     * @return 物理点の遅れ
     */
    getParticleDelay(physicsSettingIndex, vertexIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Delay).toFloat();
    }
    /**
     * 物理点の加速度の取得
     * @param physicsSettingIndex 物理演算の設定
     * @param vertexIndex 物理点のインデックス
     * @return 物理点の加速度
     */
    getParticleAcceleration(physicsSettingIndex, vertexIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Acceleration).toFloat();
    }
    /**
     * 物理点の距離の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param vertexIndex 物理点のインデックス
     * @return 物理点の距離
     */
    getParticleRadius(physicsSettingIndex, vertexIndex) {
      return this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Radius).toFloat();
    }
    /**
     * 物理点の位置の取得
     * @param physicsSettingIndex 物理演算の設定のインデックス
     * @param vertexInde 物理点のインデックス
     * @return 物理点の位置
     */
    getParticlePosition(physicsSettingIndex, vertexIndex) {
      const ret = new CubismVector2(0, 0);
      ret.x = this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Position).getValueByString(X).toFloat();
      ret.y = this._json.getRoot().getValueByString(PhysicsSettings).getValueByIndex(physicsSettingIndex).getValueByString(Vertices).getValueByIndex(vertexIndex).getValueByString(Position).getValueByString(Y).toFloat();
      return ret;
    }
    // physics3.jsonデータ
  };
  var Live2DCubismFramework33;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismPhysicsJson = CubismPhysicsJson;
  })(Live2DCubismFramework33 || (Live2DCubismFramework33 = {}));

  // src/Live2D/dist/physics/cubismphysics.js
  var PhysicsTypeTagX = "X";
  var PhysicsTypeTagY = "Y";
  var PhysicsTypeTagAngle = "Angle";
  var AirResistance = 5;
  var MaximumWeight = 100;
  var MovementThreshold = 1e-3;
  var MaxDeltaTime = 5;
  var CubismPhysics = class _CubismPhysics {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_physicsRig");
      // 物理演算のデータ
      __publicField(this, "_options");
      // オプション
      __publicField(this, "_currentRigOutputs");
      ///< 最新の振り子計算の結果
      __publicField(this, "_previousRigOutputs");
      ///< 一つ前の振り子計算の結果
      __publicField(this, "_currentRemainTime");
      ///< 物理演算が処理していない時間
      __publicField(this, "_parameterCaches");
      ///< Evaluateで利用するパラメータのキャッシュ
      __publicField(this, "_parameterInputCaches");
      this._physicsRig = null;
      this._options = new Options();
      this._options.gravity.y = -1;
      this._options.gravity.x = 0;
      this._options.wind.x = 0;
      this._options.wind.y = 0;
      this._currentRigOutputs = new csmVector();
      this._previousRigOutputs = new csmVector();
      this._currentRemainTime = 0;
      this._parameterCaches = null;
      this._parameterInputCaches = null;
    }
    /**
     * インスタンスの作成
     * @param buffer    physics3.jsonが読み込まれているバッファ
     * @param size      バッファのサイズ
     * @return 作成されたインスタンス
     */
    static create(buffer, size) {
      const ret = new _CubismPhysics();
      ret.parse(buffer, size);
      ret._physicsRig.gravity.y = 0;
      return ret;
    }
    /**
     * インスタンスを破棄する
     * @param physics 破棄するインスタンス
     */
    static delete(physics) {
      if (physics != null) {
        physics.release();
        physics = null;
      }
    }
    /**
     * physics3.jsonをパースする。
     * @param physicsJson physics3.jsonが読み込まれているバッファ
     * @param size バッファのサイズ
     */
    parse(physicsJson, size) {
      this._physicsRig = new CubismPhysicsRig();
      let json = new CubismPhysicsJson(physicsJson, size);
      this._physicsRig.gravity = json.getGravity();
      this._physicsRig.wind = json.getWind();
      this._physicsRig.subRigCount = json.getSubRigCount();
      this._physicsRig.fps = json.getFps();
      this._physicsRig.settings.updateSize(this._physicsRig.subRigCount, CubismPhysicsSubRig, true);
      this._physicsRig.inputs.updateSize(json.getTotalInputCount(), CubismPhysicsInput, true);
      this._physicsRig.outputs.updateSize(json.getTotalOutputCount(), CubismPhysicsOutput, true);
      this._physicsRig.particles.updateSize(json.getVertexCount(), CubismPhysicsParticle, true);
      this._currentRigOutputs.clear();
      this._previousRigOutputs.clear();
      let inputIndex = 0, outputIndex = 0, particleIndex = 0;
      for (let i = 0; i < this._physicsRig.settings.getSize(); ++i) {
        this._physicsRig.settings.at(i).normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(i);
        this._physicsRig.settings.at(i).normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(i);
        this._physicsRig.settings.at(i).normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(i);
        this._physicsRig.settings.at(i).normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(i);
        this._physicsRig.settings.at(i).normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(i);
        this._physicsRig.settings.at(i).normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(i);
        this._physicsRig.settings.at(i).inputCount = json.getInputCount(i);
        this._physicsRig.settings.at(i).baseInputIndex = inputIndex;
        for (let j = 0; j < this._physicsRig.settings.at(i).inputCount; ++j) {
          this._physicsRig.inputs.at(inputIndex + j).sourceParameterIndex = -1;
          this._physicsRig.inputs.at(inputIndex + j).weight = json.getInputWeight(i, j);
          this._physicsRig.inputs.at(inputIndex + j).reflect = json.getInputReflect(i, j);
          if (json.getInputType(i, j) == PhysicsTypeTagX) {
            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;
            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;
          } else if (json.getInputType(i, j) == PhysicsTypeTagY) {
            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;
            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;
          } else if (json.getInputType(i, j) == PhysicsTypeTagAngle) {
            this._physicsRig.inputs.at(inputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;
            this._physicsRig.inputs.at(inputIndex + j).getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;
          }
          this._physicsRig.inputs.at(inputIndex + j).source.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
          this._physicsRig.inputs.at(inputIndex + j).source.id = json.getInputSourceId(i, j);
        }
        inputIndex += this._physicsRig.settings.at(i).inputCount;
        this._physicsRig.settings.at(i).outputCount = json.getOutputCount(i);
        this._physicsRig.settings.at(i).baseOutputIndex = outputIndex;
        const currentRigOutput = new PhysicsOutput();
        currentRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);
        const previousRigOutput = new PhysicsOutput();
        previousRigOutput.outputs.resize(this._physicsRig.settings.at(i).outputCount);
        for (let j = 0; j < this._physicsRig.settings.at(i).outputCount; ++j) {
          currentRigOutput.outputs.set(j, 0);
          previousRigOutput.outputs.set(j, 0);
          this._physicsRig.outputs.at(outputIndex + j).destinationParameterIndex = -1;
          this._physicsRig.outputs.at(outputIndex + j).vertexIndex = json.getOutputVertexIndex(i, j);
          this._physicsRig.outputs.at(outputIndex + j).angleScale = json.getOutputAngleScale(i, j);
          this._physicsRig.outputs.at(outputIndex + j).weight = json.getOutputWeight(i, j);
          this._physicsRig.outputs.at(outputIndex + j).destination.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;
          this._physicsRig.outputs.at(outputIndex + j).destination.id = json.getOutputDestinationId(i, j);
          if (json.getOutputType(i, j) == PhysicsTypeTagX) {
            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_X;
            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationX;
            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationX;
          } else if (json.getOutputType(i, j) == PhysicsTypeTagY) {
            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Y;
            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputTranslationY;
            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleTranslationY;
          } else if (json.getOutputType(i, j) == PhysicsTypeTagAngle) {
            this._physicsRig.outputs.at(outputIndex + j).type = CubismPhysicsSource.CubismPhysicsSource_Angle;
            this._physicsRig.outputs.at(outputIndex + j).getValue = getOutputAngle;
            this._physicsRig.outputs.at(outputIndex + j).getScale = getOutputScaleAngle;
          }
          this._physicsRig.outputs.at(outputIndex + j).reflect = json.getOutputReflect(i, j);
        }
        this._currentRigOutputs.pushBack(currentRigOutput);
        this._previousRigOutputs.pushBack(previousRigOutput);
        outputIndex += this._physicsRig.settings.at(i).outputCount;
        this._physicsRig.settings.at(i).particleCount = json.getParticleCount(i);
        this._physicsRig.settings.at(i).baseParticleIndex = particleIndex;
        for (let j = 0; j < this._physicsRig.settings.at(i).particleCount; ++j) {
          this._physicsRig.particles.at(particleIndex + j).mobility = json.getParticleMobility(i, j);
          this._physicsRig.particles.at(particleIndex + j).delay = json.getParticleDelay(i, j);
          this._physicsRig.particles.at(particleIndex + j).acceleration = json.getParticleAcceleration(i, j);
          this._physicsRig.particles.at(particleIndex + j).radius = json.getParticleRadius(i, j);
          this._physicsRig.particles.at(particleIndex + j).position = json.getParticlePosition(i, j);
        }
        particleIndex += this._physicsRig.settings.at(i).particleCount;
      }
      this.initialize();
      json.release();
      json = void 0;
      json = null;
    }
    /**
     * 現在のパラメータ値で物理演算が安定化する状態を演算する。
     * @param model 物理演算の結果を適用するモデル
     */
    stabilization(model) {
      var _a, _b, _c, _d;
      let totalAngle;
      let weight;
      let radAngle;
      let outputValue;
      const totalTranslation = new CubismVector2();
      let currentSetting;
      let currentInputs;
      let currentOutputs;
      let currentParticles;
      const parameterValues = model.getModel().parameters.values;
      const parameterMaximumValues = model.getModel().parameters.maximumValues;
      const parameterMinimumValues = model.getModel().parameters.minimumValues;
      const parameterDefaultValues = model.getModel().parameters.defaultValues;
      if (((_b = (_a = this._parameterCaches) == null ? void 0 : _a.length) != null ? _b : 0) < model.getParameterCount()) {
        this._parameterCaches = new Float32Array(model.getParameterCount());
      }
      if (((_d = (_c = this._parameterInputCaches) == null ? void 0 : _c.length) != null ? _d : 0) < model.getParameterCount()) {
        this._parameterInputCaches = new Float32Array(model.getParameterCount());
      }
      for (let j = 0; j < model.getParameterCount(); ++j) {
        this._parameterCaches[j] = parameterValues[j];
        this._parameterInputCaches[j] = parameterValues[j];
      }
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        totalAngle = { angle: 0 };
        totalTranslation.x = 0;
        totalTranslation.y = 0;
        currentSetting = this._physicsRig.settings.at(settingIndex);
        currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);
        currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);
        currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);
        for (let i = 0; i < currentSetting.inputCount; ++i) {
          weight = currentInputs[i].weight / MaximumWeight;
          if (currentInputs[i].sourceParameterIndex == -1) {
            currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);
          }
          currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, parameterValues[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);
          this._parameterCaches[currentInputs[i].sourceParameterIndex] = parameterValues[currentInputs[i].sourceParameterIndex];
        }
        radAngle = CubismMath.degreesToRadian(-totalAngle.angle);
        totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);
        totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);
        updateParticlesForStabilization(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum);
        for (let i = 0; i < currentSetting.outputCount; ++i) {
          const particleIndex = currentOutputs[i].vertexIndex;
          if (currentOutputs[i].destinationParameterIndex == -1) {
            currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);
          }
          if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {
            continue;
          }
          let translation = new CubismVector2();
          translation = currentParticles[particleIndex].position.substract(currentParticles[particleIndex - 1].position);
          outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);
          this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);
          this._previousRigOutputs.at(settingIndex).outputs.set(i, outputValue);
          const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
          const outParameterCaches = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) : parameterValues.slice(destinationParameterIndex);
          updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);
          for (let offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {
            parameterValues[offset] = this._parameterCaches[offset] = outParameterCaches[outParamIndex];
          }
        }
      }
    }
    /**
     * 物理演算の評価
     *
     * Pendulum interpolation weights
     *
     * 振り子の計算結果は保存され、パラメータへの出力は保存された前回の結果で補間されます。
     * The result of the pendulum calculation is saved and
     * the output to the parameters is interpolated with the saved previous result of the pendulum calculation.
     *
     * 図で示すと[1]と[2]で補間されます。
     * The figure shows the interpolation between [1] and [2].
     *
     * 補間の重みは最新の振り子計算タイミングと次回のタイミングの間で見た現在時間で決定する。
     * The weight of the interpolation are determined by the current time seen between
     * the latest pendulum calculation timing and the next timing.
     *
     * 図で示すと[2]と[4]の間でみた(3)の位置の重みになる。
     * Figure shows the weight of position (3) as seen between [2] and [4].
     *
     * 解釈として振り子計算のタイミングと重み計算のタイミングがズレる。
     * As an interpretation, the pendulum calculation and weights are misaligned.
     *
     * physics3.jsonにFPS情報が存在しない場合は常に前の振り子状態で設定される。
     * If there is no FPS information in physics3.json, it is always set in the previous pendulum state.
     *
     * この仕様は補間範囲を逸脱したことが原因の震えたような見た目を回避を目的にしている。
     * The purpose of this specification is to avoid the quivering appearance caused by deviations from the interpolation range.
     *
     * ------------ time -------------->
     *
     *                 |+++++|------| <- weight
     * ==[1]====#=====[2]---(3)----(4)
     *          ^ output contents
     *
     * 1:_previousRigOutputs
     * 2:_currentRigOutputs
     * 3:_currentRemainTime (now rendering)
     * 4:next particles timing
     * @param model 物理演算の結果を適用するモデル
     * @param deltaTimeSeconds デルタ時間[秒]
     */
    evaluate(model, deltaTimeSeconds) {
      var _a, _b, _c, _d;
      let totalAngle;
      let weight;
      let radAngle;
      let outputValue;
      const totalTranslation = new CubismVector2();
      let currentSetting;
      let currentInputs;
      let currentOutputs;
      let currentParticles;
      if (0 >= deltaTimeSeconds) {
        return;
      }
      const parameterValues = model.getModel().parameters.values;
      const parameterMaximumValues = model.getModel().parameters.maximumValues;
      const parameterMinimumValues = model.getModel().parameters.minimumValues;
      const parameterDefaultValues = model.getModel().parameters.defaultValues;
      let physicsDeltaTime;
      this._currentRemainTime += deltaTimeSeconds;
      if (this._currentRemainTime > MaxDeltaTime) {
        this._currentRemainTime = 0;
      }
      if (((_b = (_a = this._parameterCaches) == null ? void 0 : _a.length) != null ? _b : 0) < model.getParameterCount()) {
        this._parameterCaches = new Float32Array(model.getParameterCount());
      }
      if (((_d = (_c = this._parameterInputCaches) == null ? void 0 : _c.length) != null ? _d : 0) < model.getParameterCount()) {
        this._parameterInputCaches = new Float32Array(model.getParameterCount());
        for (let j = 0; j < model.getParameterCount(); ++j) {
          this._parameterInputCaches[j] = parameterValues[j];
        }
      }
      if (this._physicsRig.fps > 0) {
        physicsDeltaTime = 1 / this._physicsRig.fps;
      } else {
        physicsDeltaTime = deltaTimeSeconds;
      }
      while (this._currentRemainTime >= physicsDeltaTime) {
        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
          currentSetting = this._physicsRig.settings.at(settingIndex);
          currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);
          for (let i = 0; i < currentSetting.outputCount; ++i) {
            this._previousRigOutputs.at(settingIndex).outputs.set(i, this._currentRigOutputs.at(settingIndex).outputs.at(i));
          }
        }
        const inputWeight = physicsDeltaTime / this._currentRemainTime;
        for (let j = 0; j < model.getParameterCount(); ++j) {
          this._parameterCaches[j] = this._parameterInputCaches[j] * (1 - inputWeight) + parameterValues[j] * inputWeight;
          this._parameterInputCaches[j] = this._parameterCaches[j];
        }
        for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
          totalAngle = { angle: 0 };
          totalTranslation.x = 0;
          totalTranslation.y = 0;
          currentSetting = this._physicsRig.settings.at(settingIndex);
          currentInputs = this._physicsRig.inputs.get(currentSetting.baseInputIndex);
          currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);
          currentParticles = this._physicsRig.particles.get(currentSetting.baseParticleIndex);
          for (let i = 0; i < currentSetting.inputCount; ++i) {
            weight = currentInputs[i].weight / MaximumWeight;
            if (currentInputs[i].sourceParameterIndex == -1) {
              currentInputs[i].sourceParameterIndex = model.getParameterIndex(currentInputs[i].source.id);
            }
            currentInputs[i].getNormalizedParameterValue(totalTranslation, totalAngle, this._parameterCaches[currentInputs[i].sourceParameterIndex], parameterMinimumValues[currentInputs[i].sourceParameterIndex], parameterMaximumValues[currentInputs[i].sourceParameterIndex], parameterDefaultValues[currentInputs[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInputs[i].reflect, weight);
          }
          radAngle = CubismMath.degreesToRadian(-totalAngle.angle);
          totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);
          totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);
          updateParticles(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum, physicsDeltaTime, AirResistance);
          for (let i = 0; i < currentSetting.outputCount; ++i) {
            const particleIndex = currentOutputs[i].vertexIndex;
            if (currentOutputs[i].destinationParameterIndex == -1) {
              currentOutputs[i].destinationParameterIndex = model.getParameterIndex(currentOutputs[i].destination.id);
            }
            if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {
              continue;
            }
            const translation = new CubismVector2();
            translation.x = currentParticles[particleIndex].position.x - currentParticles[particleIndex - 1].position.x;
            translation.y = currentParticles[particleIndex].position.y - currentParticles[particleIndex - 1].position.y;
            outputValue = currentOutputs[i].getValue(translation, currentParticles, particleIndex, currentOutputs[i].reflect, this._options.gravity);
            this._currentRigOutputs.at(settingIndex).outputs.set(i, outputValue);
            const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
            const outParameterCaches = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(JSON.stringify(this._parameterCaches.subarray(destinationParameterIndex))) : this._parameterCaches.slice(destinationParameterIndex);
            updateOutputParameterValue(outParameterCaches, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], outputValue, currentOutputs[i]);
            for (let offset = destinationParameterIndex, outParamIndex = 0; offset < this._parameterCaches.length; offset++, outParamIndex++) {
              this._parameterCaches[offset] = outParameterCaches[outParamIndex];
            }
          }
        }
        this._currentRemainTime -= physicsDeltaTime;
      }
      const alpha = this._currentRemainTime / physicsDeltaTime;
      this.interpolate(model, alpha);
    }
    /**
     * 物理演算結果の適用
     * 振り子演算の最新の結果と一つ前の結果から指定した重みで適用する。
     * @param model 物理演算の結果を適用するモデル
     * @param weight 最新結果の重み
     */
    interpolate(model, weight) {
      let currentOutputs;
      let currentSetting;
      const parameterValues = model.getModel().parameters.values;
      const parameterMaximumValues = model.getModel().parameters.maximumValues;
      const parameterMinimumValues = model.getModel().parameters.minimumValues;
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        currentSetting = this._physicsRig.settings.at(settingIndex);
        currentOutputs = this._physicsRig.outputs.get(currentSetting.baseOutputIndex);
        for (let i = 0; i < currentSetting.outputCount; ++i) {
          if (currentOutputs[i].destinationParameterIndex == -1) {
            continue;
          }
          const destinationParameterIndex = currentOutputs[i].destinationParameterIndex;
          const outParameterValues = !Float32Array.prototype.slice && "subarray" in Float32Array.prototype ? JSON.parse(JSON.stringify(parameterValues.subarray(destinationParameterIndex))) : parameterValues.slice(destinationParameterIndex);
          updateOutputParameterValue(outParameterValues, parameterMinimumValues[destinationParameterIndex], parameterMaximumValues[destinationParameterIndex], this._previousRigOutputs.at(settingIndex).outputs.at(i) * (1 - weight) + this._currentRigOutputs.at(settingIndex).outputs.at(i) * weight, currentOutputs[i]);
          for (let offset = destinationParameterIndex, outParamIndex = 0; offset < parameterValues.length; offset++, outParamIndex++) {
            parameterValues[offset] = outParameterValues[outParamIndex];
          }
        }
      }
    }
    /**
     * オプションの設定
     * @param options オプション
     */
    setOptions(options) {
      this._options = options;
    }
    /**
     * オプションの取得
     * @return オプション
     */
    getOption() {
      return this._options;
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      this._physicsRig = void 0;
      this._physicsRig = null;
    }
    /**
     * 初期化する
     */
    initialize() {
      let strand;
      let currentSetting;
      let radius;
      for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {
        currentSetting = this._physicsRig.settings.at(settingIndex);
        strand = this._physicsRig.particles.get(currentSetting.baseParticleIndex);
        strand[0].initialPosition = new CubismVector2(0, 0);
        strand[0].lastPosition = new CubismVector2(strand[0].initialPosition.x, strand[0].initialPosition.y);
        strand[0].lastGravity = new CubismVector2(0, -1);
        strand[0].lastGravity.y *= -1;
        strand[0].velocity = new CubismVector2(0, 0);
        strand[0].force = new CubismVector2(0, 0);
        for (let i = 1; i < currentSetting.particleCount; ++i) {
          radius = new CubismVector2(0, 0);
          radius.y = strand[i].radius;
          strand[i].initialPosition = new CubismVector2(strand[i - 1].initialPosition.x + radius.x, strand[i - 1].initialPosition.y + radius.y);
          strand[i].position = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);
          strand[i].lastPosition = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);
          strand[i].lastGravity = new CubismVector2(0, -1);
          strand[i].lastGravity.y *= -1;
          strand[i].velocity = new CubismVector2(0, 0);
          strand[i].force = new CubismVector2(0, 0);
        }
      }
    }
    ///< UpdateParticlesが動くときの入力をキャッシュ
  };
  var Options = class {
    constructor() {
      __publicField(this, "gravity");
      // 重力方向
      __publicField(this, "wind");
      this.gravity = new CubismVector2(0, 0);
      this.wind = new CubismVector2(0, 0);
    }
    // 風の方向
  };
  var PhysicsOutput = class {
    constructor() {
      __publicField(this, "outputs");
      this.outputs = new csmVector(0);
    }
    // 物理演算出力結果
  };
  function sign(value) {
    let ret = 0;
    if (value > 0) {
      ret = 1;
    } else if (value < 0) {
      ret = -1;
    }
    return ret;
  }
  function getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
    targetTranslation.x += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;
  }
  function getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {
    targetTranslation.y += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;
  }
  function getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {
    targetAngle.angle += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationAngle.minimum, normalizationAngle.maximum, normalizationAngle.defalut, isInverted) * weight;
  }
  function getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue = translation.x;
    if (isInverted) {
      outputValue *= -1;
    }
    return outputValue;
  }
  function getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue = translation.y;
    if (isInverted) {
      outputValue *= -1;
    }
    return outputValue;
  }
  function getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {
    let outputValue;
    if (particleIndex >= 2) {
      parentGravity = particles[particleIndex - 1].position.substract(particles[particleIndex - 2].position);
    } else {
      parentGravity = parentGravity.multiplyByScaler(-1);
    }
    outputValue = CubismMath.directionToRadian(parentGravity, translation);
    if (isInverted) {
      outputValue *= -1;
    }
    return outputValue;
  }
  function getRangeValue(min, max) {
    const maxValue = CubismMath.max(min, max);
    const minValue = CubismMath.min(min, max);
    return CubismMath.abs(maxValue - minValue);
  }
  function getDefaultValue(min, max) {
    const minValue = CubismMath.min(min, max);
    return minValue + getRangeValue(min, max) / 2;
  }
  function getOutputScaleTranslationX(translationScale, angleScale) {
    return JSON.parse(JSON.stringify(translationScale.x));
  }
  function getOutputScaleTranslationY(translationScale, angleScale) {
    return JSON.parse(JSON.stringify(translationScale.y));
  }
  function getOutputScaleAngle(translationScale, angleScale) {
    return JSON.parse(JSON.stringify(angleScale));
  }
  function updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {
    let delay;
    let radian;
    let direction = new CubismVector2(0, 0);
    let velocity = new CubismVector2(0, 0);
    let force = new CubismVector2(0, 0);
    let newDirection = new CubismVector2(0, 0);
    strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);
    const totalRadian = CubismMath.degreesToRadian(totalAngle);
    const currentGravity = CubismMath.radianToDirection(totalRadian);
    currentGravity.normalize();
    for (let i = 1; i < strandCount; ++i) {
      strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);
      strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);
      delay = strand[i].delay * deltaTimeSeconds * 30;
      direction = strand[i].position.substract(strand[i - 1].position);
      radian = CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) / airResistance;
      direction.x = CubismMath.cos(radian) * direction.x - direction.y * CubismMath.sin(radian);
      direction.y = CubismMath.sin(radian) * direction.x + direction.y * CubismMath.cos(radian);
      strand[i].position = strand[i - 1].position.add(direction);
      velocity = strand[i].velocity.multiplyByScaler(delay);
      force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);
      strand[i].position = strand[i].position.add(velocity).add(force);
      newDirection = strand[i].position.substract(strand[i - 1].position);
      newDirection.normalize();
      strand[i].position = strand[i - 1].position.add(newDirection.multiplyByScaler(strand[i].radius));
      if (CubismMath.abs(strand[i].position.x) < thresholdValue) {
        strand[i].position.x = 0;
      }
      if (delay != 0) {
        strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);
        strand[i].velocity = strand[i].velocity.divisionByScalar(delay);
        strand[i].velocity = strand[i].velocity.multiplyByScaler(strand[i].mobility);
      }
      strand[i].force = new CubismVector2(0, 0);
      strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);
    }
  }
  function updateParticlesForStabilization(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue) {
    let force = new CubismVector2(0, 0);
    strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);
    const totalRadian = CubismMath.degreesToRadian(totalAngle);
    const currentGravity = CubismMath.radianToDirection(totalRadian);
    currentGravity.normalize();
    for (let i = 1; i < strandCount; ++i) {
      strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);
      strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);
      strand[i].velocity = new CubismVector2(0, 0);
      force = strand[i].force;
      force.normalize();
      force = force.multiplyByScaler(strand[i].radius);
      strand[i].position = strand[i - 1].position.add(force);
      if (CubismMath.abs(strand[i].position.x) < thresholdValue) {
        strand[i].position.x = 0;
      }
      strand[i].force = new CubismVector2(0, 0);
      strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);
    }
  }
  function updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {
    let value;
    const outputScale = output.getScale(output.translationScale, output.angleScale);
    value = translation * outputScale;
    if (value < parameterValueMinimum) {
      if (value < output.valueBelowMinimum) {
        output.valueBelowMinimum = value;
      }
      value = parameterValueMinimum;
    } else if (value > parameterValueMaximum) {
      if (value > output.valueExceededMaximum) {
        output.valueExceededMaximum = value;
      }
      value = parameterValueMaximum;
    }
    const weight = output.weight / MaximumWeight;
    if (weight >= 1) {
      parameterValue[0] = value;
    } else {
      value = parameterValue[0] * (1 - weight) + value * weight;
      parameterValue[0] = value;
    }
  }
  function normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {
    let result = 0;
    const maxValue = CubismMath.max(parameterMaximum, parameterMinimum);
    if (maxValue < value) {
      value = maxValue;
    }
    const minValue = CubismMath.min(parameterMaximum, parameterMinimum);
    if (minValue > value) {
      value = minValue;
    }
    const minNormValue = CubismMath.min(normalizedMinimum, normalizedMaximum);
    const maxNormValue = CubismMath.max(normalizedMinimum, normalizedMaximum);
    const middleNormValue = normalizedDefault;
    const middleValue = getDefaultValue(minValue, maxValue);
    const paramValue = value - middleValue;
    switch (sign(paramValue)) {
      case 1: {
        const nLength = maxNormValue - middleNormValue;
        const pLength = maxValue - middleValue;
        if (pLength != 0) {
          result = paramValue * (nLength / pLength);
          result += middleNormValue;
        }
        break;
      }
      case -1: {
        const nLength = minNormValue - middleNormValue;
        const pLength = minValue - middleValue;
        if (pLength != 0) {
          result = paramValue * (nLength / pLength);
          result += middleNormValue;
        }
        break;
      }
      case 0: {
        result = middleNormValue;
        break;
      }
      default: {
        break;
      }
    }
    return isInverted ? result : result * -1;
  }
  var Live2DCubismFramework34;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismPhysics = CubismPhysics;
    Live2DCubismFramework42.Options = Options;
  })(Live2DCubismFramework34 || (Live2DCubismFramework34 = {}));

  // src/Live2D/dist/rendering/cubismclippingmanager.js
  var ColorChannelCount = 4;
  var ClippingMaskMaxCountOnDefault = 36;
  var ClippingMaskMaxCountOnMultiRenderTexture = 32;
  var CubismClippingManager = class {
    /**
     * コンストラクタ
     */
    constructor(clippingContextFactory) {
      __publicField(this, "_clearedFrameBufferFlags");
      //マスクのクリアフラグの配列
      __publicField(this, "_channelColors");
      __publicField(this, "_clippingContextListForMask");
      // マスク用クリッピングコンテキストのリスト
      __publicField(this, "_clippingContextListForDraw");
      // 描画用クリッピングコンテキストのリスト
      __publicField(this, "_clippingMaskBufferSize");
      // クリッピングマスクのバッファサイズ（初期値:256）
      __publicField(this, "_renderTextureCount");
      // 生成するレンダーテクスチャの枚数
      __publicField(this, "_tmpMatrix");
      // マスク計算用の行列
      __publicField(this, "_tmpMatrixForMask");
      // マスク計算用の行列
      __publicField(this, "_tmpMatrixForDraw");
      // マスク計算用の行列
      __publicField(this, "_tmpBoundsOnModel");
      // マスク配置計算用の矩形
      __publicField(this, "_clippingContexttConstructor");
      this._renderTextureCount = 0;
      this._clippingMaskBufferSize = 256;
      this._clippingContextListForMask = new csmVector();
      this._clippingContextListForDraw = new csmVector();
      this._channelColors = new csmVector();
      this._tmpBoundsOnModel = new csmRect();
      this._tmpMatrix = new CubismMatrix44();
      this._tmpMatrixForMask = new CubismMatrix44();
      this._tmpMatrixForDraw = new CubismMatrix44();
      this._clippingContexttConstructor = clippingContextFactory;
      let tmp = new CubismTextureColor();
      tmp.r = 1;
      tmp.g = 0;
      tmp.b = 0;
      tmp.a = 0;
      this._channelColors.pushBack(tmp);
      tmp = new CubismTextureColor();
      tmp.r = 0;
      tmp.g = 1;
      tmp.b = 0;
      tmp.a = 0;
      this._channelColors.pushBack(tmp);
      tmp = new CubismTextureColor();
      tmp.r = 0;
      tmp.g = 0;
      tmp.b = 1;
      tmp.a = 0;
      this._channelColors.pushBack(tmp);
      tmp = new CubismTextureColor();
      tmp.r = 0;
      tmp.g = 0;
      tmp.b = 0;
      tmp.a = 1;
      this._channelColors.pushBack(tmp);
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {
        if (this._clippingContextListForMask.at(i)) {
          this._clippingContextListForMask.at(i).release();
          this._clippingContextListForMask.set(i, void 0);
        }
        this._clippingContextListForMask.set(i, null);
      }
      this._clippingContextListForMask = null;
      for (let i = 0; i < this._clippingContextListForDraw.getSize(); i++) {
        this._clippingContextListForDraw.set(i, null);
      }
      this._clippingContextListForDraw = null;
      for (let i = 0; i < this._channelColors.getSize(); i++) {
        this._channelColors.set(i, null);
      }
      this._channelColors = null;
      if (this._clearedFrameBufferFlags != null) {
        this._clearedFrameBufferFlags.clear();
      }
      this._clearedFrameBufferFlags = null;
    }
    /**
     * マネージャの初期化処理
     * クリッピングマスクを使う描画オブジェクトの登録を行う
     * @param model モデルのインスタンス
     * @param renderTextureCount バッファの生成数
     */
    initialize(model, renderTextureCount) {
      if (renderTextureCount % 1 != 0) {
        CubismLogWarning("The number of render textures must be specified as an integer. The decimal point is rounded down and corrected to an integer.");
        renderTextureCount = ~~renderTextureCount;
      }
      if (renderTextureCount < 1) {
        CubismLogWarning("The number of render textures must be an integer greater than or equal to 1. Set the number of render textures to 1.");
      }
      this._renderTextureCount = renderTextureCount < 1 ? 1 : renderTextureCount;
      this._clearedFrameBufferFlags = new csmVector(this._renderTextureCount);
      for (let i = 0; i < model.getDrawableCount(); i++) {
        if (model.getDrawableMaskCounts()[i] <= 0) {
          this._clippingContextListForDraw.pushBack(null);
          continue;
        }
        let clippingContext = this.findSameClip(model.getDrawableMasks()[i], model.getDrawableMaskCounts()[i]);
        if (clippingContext == null) {
          clippingContext = new this._clippingContexttConstructor(this, model.getDrawableMasks()[i], model.getDrawableMaskCounts()[i]);
          this._clippingContextListForMask.pushBack(clippingContext);
        }
        clippingContext.addClippedDrawable(i);
        this._clippingContextListForDraw.pushBack(clippingContext);
      }
    }
    /**
     * 既にマスクを作っているかを確認
     * 作っている様であれば該当するクリッピングマスクのインスタンスを返す
     * 作っていなければNULLを返す
     * @param drawableMasks 描画オブジェクトをマスクする描画オブジェクトのリスト
     * @param drawableMaskCounts 描画オブジェクトをマスクする描画オブジェクトの数
     * @return 該当するクリッピングマスクが存在すればインスタンスを返し、なければNULLを返す
     */
    findSameClip(drawableMasks, drawableMaskCounts) {
      for (let i = 0; i < this._clippingContextListForMask.getSize(); i++) {
        const clippingContext = this._clippingContextListForMask.at(i);
        const count = clippingContext._clippingIdCount;
        if (count != drawableMaskCounts) {
          continue;
        }
        let sameCount = 0;
        for (let j = 0; j < count; j++) {
          const clipId = clippingContext._clippingIdList[j];
          for (let k = 0; k < count; k++) {
            if (drawableMasks[k] == clipId) {
              sameCount++;
              break;
            }
          }
        }
        if (sameCount == count) {
          return clippingContext;
        }
      }
      return null;
    }
    /**
     * 高精細マスク処理用の行列を計算する
     * @param model モデルのインスタンス
     * @param isRightHanded 処理が右手系であるか
     */
    setupMatrixForHighPrecision(model, isRightHanded) {
      let usingClipCount = 0;
      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
        const cc = this._clippingContextListForMask.at(clipIndex);
        this.calcClippedDrawTotalBounds(model, cc);
        if (cc._isUsing) {
          usingClipCount++;
        }
      }
      if (usingClipCount > 0) {
        this.setupLayoutBounds(0);
        if (this._clearedFrameBufferFlags.getSize() != this._renderTextureCount) {
          this._clearedFrameBufferFlags.clear();
          for (let i = 0; i < this._renderTextureCount; i++) {
            this._clearedFrameBufferFlags.pushBack(false);
          }
        } else {
          for (let i = 0; i < this._renderTextureCount; i++) {
            this._clearedFrameBufferFlags.set(i, false);
          }
        }
        for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
          const clipContext = this._clippingContextListForMask.at(clipIndex);
          const allClippedDrawRect = clipContext._allClippedDrawRect;
          const layoutBoundsOnTex01 = clipContext._layoutBounds;
          const margin = 0.05;
          let scaleX = 0;
          let scaleY = 0;
          const ppu = model.getPixelsPerUnit();
          const maskPixelSize = clipContext.getClippingManager().getClippingMaskBufferSize();
          const physicalMaskWidth = layoutBoundsOnTex01.width * maskPixelSize;
          const physicalMaskHeight = layoutBoundsOnTex01.height * maskPixelSize;
          this._tmpBoundsOnModel.setRect(allClippedDrawRect);
          if (this._tmpBoundsOnModel.width * ppu > physicalMaskWidth) {
            this._tmpBoundsOnModel.expand(allClippedDrawRect.width * margin, 0);
            scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
          } else {
            scaleX = ppu / physicalMaskWidth;
          }
          if (this._tmpBoundsOnModel.height * ppu > physicalMaskHeight) {
            this._tmpBoundsOnModel.expand(0, allClippedDrawRect.height * margin);
            scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
          } else {
            scaleY = ppu / physicalMaskHeight;
          }
          this.createMatrixForMask(isRightHanded, layoutBoundsOnTex01, scaleX, scaleY);
          clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());
          clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());
        }
      }
    }
    /**
     * マスク作成・描画用の行列を作成する。
     * @param isRightHanded 座標を右手系として扱うかを指定
     * @param layoutBoundsOnTex01 マスクを収める領域
     * @param scaleX 描画オブジェクトの伸縮率
     * @param scaleY 描画オブジェクトの伸縮率
     */
    createMatrixForMask(isRightHanded, layoutBoundsOnTex01, scaleX, scaleY) {
      this._tmpMatrix.loadIdentity();
      {
        this._tmpMatrix.translateRelative(-1, -1);
        this._tmpMatrix.scaleRelative(2, 2);
      }
      {
        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);
        this._tmpMatrix.scaleRelative(scaleX, scaleY);
        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
      }
      this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());
      this._tmpMatrix.loadIdentity();
      {
        this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y * (isRightHanded ? -1 : 1));
        this._tmpMatrix.scaleRelative(scaleX, scaleY * (isRightHanded ? -1 : 1));
        this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
      }
      this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());
    }
    /**
     * クリッピングコンテキストを配置するレイアウト
     * 指定された数のレンダーテクスチャを極力いっぱいに使ってマスクをレイアウトする
     * マスクグループの数が4以下ならRGBA各チャンネルに一つずつマスクを配置し、5以上6以下ならRGBAを2,2,1,1と配置する。
     *
     * @param usingClipCount 配置するクリッピングコンテキストの数
     */
    setupLayoutBounds(usingClipCount) {
      const useClippingMaskMaxCount = this._renderTextureCount <= 1 ? ClippingMaskMaxCountOnDefault : ClippingMaskMaxCountOnMultiRenderTexture * this._renderTextureCount;
      if (usingClipCount <= 0 || usingClipCount > useClippingMaskMaxCount) {
        if (usingClipCount > useClippingMaskMaxCount) {
          CubismLogError("not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}", usingClipCount - useClippingMaskMaxCount, this._renderTextureCount, usingClipCount);
        }
        for (let index = 0; index < this._clippingContextListForMask.getSize(); index++) {
          const clipContext = this._clippingContextListForMask.at(index);
          clipContext._layoutChannelIndex = 0;
          clipContext._layoutBounds.x = 0;
          clipContext._layoutBounds.y = 0;
          clipContext._layoutBounds.width = 1;
          clipContext._layoutBounds.height = 1;
          clipContext._bufferIndex = 0;
        }
        return;
      }
      const layoutCountMaxValue = this._renderTextureCount <= 1 ? 9 : 8;
      let countPerSheetDiv = usingClipCount / this._renderTextureCount;
      const reduceLayoutTextureCount = usingClipCount % this._renderTextureCount;
      countPerSheetDiv = Math.ceil(countPerSheetDiv);
      let divCount = countPerSheetDiv / ColorChannelCount;
      const modCount = countPerSheetDiv % ColorChannelCount;
      divCount = ~~divCount;
      let curClipIndex = 0;
      for (let renderTextureIndex = 0; renderTextureIndex < this._renderTextureCount; renderTextureIndex++) {
        for (let channelIndex = 0; channelIndex < ColorChannelCount; channelIndex++) {
          let layoutCount = divCount + (channelIndex < modCount ? 1 : 0);
          const checkChannelIndex = modCount + (divCount < 1 ? -1 : 0);
          if (channelIndex == checkChannelIndex && reduceLayoutTextureCount > 0) {
            layoutCount -= !(renderTextureIndex < reduceLayoutTextureCount) ? 1 : 0;
          }
          if (layoutCount == 0) {
          } else if (layoutCount == 1) {
            const clipContext = this._clippingContextListForMask.at(curClipIndex++);
            clipContext._layoutChannelIndex = channelIndex;
            clipContext._layoutBounds.x = 0;
            clipContext._layoutBounds.y = 0;
            clipContext._layoutBounds.width = 1;
            clipContext._layoutBounds.height = 1;
            clipContext._bufferIndex = renderTextureIndex;
          } else if (layoutCount == 2) {
            for (let i = 0; i < layoutCount; i++) {
              let xpos = i % 2;
              xpos = ~~xpos;
              const cc = this._clippingContextListForMask.at(curClipIndex++);
              cc._layoutChannelIndex = channelIndex;
              cc._layoutBounds.x = xpos * 0.5;
              cc._layoutBounds.y = 0;
              cc._layoutBounds.width = 0.5;
              cc._layoutBounds.height = 1;
              cc._bufferIndex = renderTextureIndex;
            }
          } else if (layoutCount <= 4) {
            for (let i = 0; i < layoutCount; i++) {
              let xpos = i % 2;
              let ypos = i / 2;
              xpos = ~~xpos;
              ypos = ~~ypos;
              const cc = this._clippingContextListForMask.at(curClipIndex++);
              cc._layoutChannelIndex = channelIndex;
              cc._layoutBounds.x = xpos * 0.5;
              cc._layoutBounds.y = ypos * 0.5;
              cc._layoutBounds.width = 0.5;
              cc._layoutBounds.height = 0.5;
              cc._bufferIndex = renderTextureIndex;
            }
          } else if (layoutCount <= layoutCountMaxValue) {
            for (let i = 0; i < layoutCount; i++) {
              let xpos = i % 3;
              let ypos = i / 3;
              xpos = ~~xpos;
              ypos = ~~ypos;
              const cc = this._clippingContextListForMask.at(curClipIndex++);
              cc._layoutChannelIndex = channelIndex;
              cc._layoutBounds.x = xpos / 3;
              cc._layoutBounds.y = ypos / 3;
              cc._layoutBounds.width = 1 / 3;
              cc._layoutBounds.height = 1 / 3;
              cc._bufferIndex = renderTextureIndex;
            }
          } else {
            CubismLogError("not supported mask count : {0}\n[Details] render texture count : {1}, mask count : {2}", usingClipCount - useClippingMaskMaxCount, this._renderTextureCount, usingClipCount);
            for (let index = 0; index < layoutCount; index++) {
              const cc = this._clippingContextListForMask.at(curClipIndex++);
              cc._layoutChannelIndex = 0;
              cc._layoutBounds.x = 0;
              cc._layoutBounds.y = 0;
              cc._layoutBounds.width = 1;
              cc._layoutBounds.height = 1;
              cc._bufferIndex = 0;
            }
          }
        }
      }
    }
    /**
     * マスクされる描画オブジェクト群全体を囲む矩形（モデル座標系）を計算する
     * @param model モデルのインスタンス
     * @param clippingContext クリッピングマスクのコンテキスト
     */
    calcClippedDrawTotalBounds(model, clippingContext) {
      let clippedDrawTotalMinX = Number.MAX_VALUE;
      let clippedDrawTotalMinY = Number.MAX_VALUE;
      let clippedDrawTotalMaxX = Number.MIN_VALUE;
      let clippedDrawTotalMaxY = Number.MIN_VALUE;
      const clippedDrawCount = clippingContext._clippedDrawableIndexList.length;
      for (let clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {
        const drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];
        const drawableVertexCount = model.getDrawableVertexCount(drawableIndex);
        const drawableVertexes = model.getDrawableVertices(drawableIndex);
        let minX = Number.MAX_VALUE;
        let minY = Number.MAX_VALUE;
        let maxX = -Number.MAX_VALUE;
        let maxY = -Number.MAX_VALUE;
        const loop = drawableVertexCount * Constant.vertexStep;
        for (let pi = Constant.vertexOffset; pi < loop; pi += Constant.vertexStep) {
          const x = drawableVertexes[pi];
          const y = drawableVertexes[pi + 1];
          if (x < minX) {
            minX = x;
          }
          if (x > maxX) {
            maxX = x;
          }
          if (y < minY) {
            minY = y;
          }
          if (y > maxY) {
            maxY = y;
          }
        }
        if (minX == Number.MAX_VALUE) {
          continue;
        }
        if (minX < clippedDrawTotalMinX) {
          clippedDrawTotalMinX = minX;
        }
        if (minY < clippedDrawTotalMinY) {
          clippedDrawTotalMinY = minY;
        }
        if (maxX > clippedDrawTotalMaxX) {
          clippedDrawTotalMaxX = maxX;
        }
        if (maxY > clippedDrawTotalMaxY) {
          clippedDrawTotalMaxY = maxY;
        }
        if (clippedDrawTotalMinX == Number.MAX_VALUE) {
          clippingContext._allClippedDrawRect.x = 0;
          clippingContext._allClippedDrawRect.y = 0;
          clippingContext._allClippedDrawRect.width = 0;
          clippingContext._allClippedDrawRect.height = 0;
          clippingContext._isUsing = false;
        } else {
          clippingContext._isUsing = true;
          const w = clippedDrawTotalMaxX - clippedDrawTotalMinX;
          const h = clippedDrawTotalMaxY - clippedDrawTotalMinY;
          clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;
          clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;
          clippingContext._allClippedDrawRect.width = w;
          clippingContext._allClippedDrawRect.height = h;
        }
      }
    }
    /**
     * 画面描画に使用するクリッピングマスクのリストを取得する
     * @return 画面描画に使用するクリッピングマスクのリスト
     */
    getClippingContextListForDraw() {
      return this._clippingContextListForDraw;
    }
    /**
     * クリッピングマスクバッファのサイズを取得する
     * @return クリッピングマスクバッファのサイズ
     */
    getClippingMaskBufferSize() {
      return this._clippingMaskBufferSize;
    }
    /**
     * このバッファのレンダーテクスチャの枚数を取得する
     * @return このバッファのレンダーテクスチャの枚数
     */
    getRenderTextureCount() {
      return this._renderTextureCount;
    }
    /**
     * カラーチャンネル（RGBA）のフラグを取得する
     * @param channelNo カラーチャンネル（RGBA）の番号（0:R, 1:G, 2:B, 3:A）
     */
    getChannelFlagAsColor(channelNo) {
      return this._channelColors.at(channelNo);
    }
    /**
     * クリッピングマスクバッファのサイズを設定する
     * @param size クリッピングマスクバッファのサイズ
     */
    setClippingMaskBufferSize(size) {
      this._clippingMaskBufferSize = size;
    }
  };

  // src/Live2D/dist/rendering/cubismshader_webgl.js
  var s_instance2;
  var ShaderCount = 10;
  var CubismShader_WebGL = class _CubismShader_WebGL {
    /**
     * privateなコンストラクタ
     */
    constructor() {
      __publicField(this, "_shaderSets");
      // ロードしたシェーダープログラムを保持する変数
      __publicField(this, "gl");
      this._shaderSets = new csmVector();
    }
    /**
     * インスタンスを取得する（シングルトン）
     * @return インスタンス
     */
    static getInstance() {
      if (s_instance2 == null) {
        s_instance2 = new _CubismShader_WebGL();
        return s_instance2;
      }
      return s_instance2;
    }
    /**
     * インスタンスを開放する（シングルトン）
     */
    static deleteInstance() {
      if (s_instance2) {
        s_instance2.release();
        s_instance2 = null;
      }
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      this.releaseShaderProgram();
    }
    /**
     * 描画用のシェーダプログラムの一連のセットアップを実行する
     * @param renderer レンダラー
     * @param model 描画対象のモデル
     * @param index 描画対象のメッシュのインデックス
     */
    setupShaderProgramForDraw(renderer, model, index) {
      if (!renderer.isPremultipliedAlpha()) {
        CubismLogError("NoPremultipliedAlpha is not allowed");
      }
      if (this._shaderSets.getSize() == 0) {
        this.generateShaders();
      }
      let srcColor;
      let dstColor;
      let srcAlpha;
      let dstAlpha;
      const masked = renderer.getClippingContextBufferForDraw() != null;
      const invertedMask = model.getDrawableInvertedMaskBit(index);
      const offset = masked ? invertedMask ? 2 : 1 : 0;
      let shaderSet;
      switch (model.getDrawableBlendMode(index)) {
        case CubismBlendMode.CubismBlendMode_Normal:
        default:
          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_NormalPremultipliedAlpha + offset);
          srcColor = this.gl.ONE;
          dstColor = this.gl.ONE_MINUS_SRC_ALPHA;
          srcAlpha = this.gl.ONE;
          dstAlpha = this.gl.ONE_MINUS_SRC_ALPHA;
          break;
        case CubismBlendMode.CubismBlendMode_Additive:
          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_AddPremultipliedAlpha + offset);
          srcColor = this.gl.ONE;
          dstColor = this.gl.ONE;
          srcAlpha = this.gl.ZERO;
          dstAlpha = this.gl.ONE;
          break;
        case CubismBlendMode.CubismBlendMode_Multiplicative:
          shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_MultPremultipliedAlpha + offset);
          srcColor = this.gl.DST_COLOR;
          dstColor = this.gl.ONE_MINUS_SRC_ALPHA;
          srcAlpha = this.gl.ZERO;
          dstAlpha = this.gl.ONE;
          break;
      }
      this.gl.useProgram(shaderSet.shaderProgram);
      if (renderer._bufferData.vertex == null) {
        renderer._bufferData.vertex = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.vertex);
      const vertexArray = model.getDrawableVertices(index);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
      this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);
      if (renderer._bufferData.uv == null) {
        renderer._bufferData.uv = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
      const uvArray = model.getDrawableVertexUvs(index);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
      this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
      if (masked) {
        this.gl.activeTexture(this.gl.TEXTURE1);
        const tex = renderer.getClippingContextBufferForDraw().getClippingManager().getColorBuffer().at(renderer.getClippingContextBufferForDraw()._bufferIndex);
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);
        this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForDraw()._matrixForDraw.getArray());
        const channelIndex = renderer.getClippingContextBufferForDraw()._layoutChannelIndex;
        const colorChannel = renderer.getClippingContextBufferForDraw().getClippingManager().getChannelFlagAsColor(channelIndex);
        this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.r, colorChannel.g, colorChannel.b, colorChannel.a);
      }
      const textureNo = model.getDrawableTextureIndex(index);
      const textureId = renderer.getBindedTextures().getValue(textureNo);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
      const matrix4x4 = renderer.getMvpMatrix();
      this.gl.uniformMatrix4fv(shaderSet.uniformMatrixLocation, false, matrix4x4.getArray());
      const baseColor = renderer.getModelColorWithOpacity(model.getDrawableOpacity(index));
      const multiplyColor = model.getMultiplyColor(index);
      const screenColor = model.getScreenColor(index);
      this.gl.uniform4f(shaderSet.uniformBaseColorLocation, baseColor.r, baseColor.g, baseColor.b, baseColor.a);
      this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.r, multiplyColor.g, multiplyColor.b, multiplyColor.a);
      this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.r, screenColor.g, screenColor.b, screenColor.a);
      if (renderer._bufferData.index == null) {
        renderer._bufferData.index = this.gl.createBuffer();
      }
      const indexArray = model.getDrawableVertexIndices(index);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, renderer._bufferData.index);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);
      this.gl.blendFuncSeparate(srcColor, dstColor, srcAlpha, dstAlpha);
    }
    /**
     * マスク用のシェーダプログラムの一連のセットアップを実行する
     * @param renderer レンダラー
     * @param model 描画対象のモデル
     * @param index 描画対象のメッシュのインデックス
     */
    setupShaderProgramForMask(renderer, model, index) {
      if (!renderer.isPremultipliedAlpha()) {
        CubismLogError("NoPremultipliedAlpha is not allowed");
      }
      if (this._shaderSets.getSize() == 0) {
        this.generateShaders();
      }
      const shaderSet = this._shaderSets.at(ShaderNames.ShaderNames_SetupMask);
      this.gl.useProgram(shaderSet.shaderProgram);
      if (renderer._bufferData.vertex == null) {
        renderer._bufferData.vertex = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.vertex);
      const vertexArray = model.getDrawableVertices(index);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);
      this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);
      if (renderer._bufferData.uv == null) {
        renderer._bufferData.uv = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
      const textureNo = model.getDrawableTextureIndex(index);
      const textureId = renderer.getBindedTextures().getValue(textureNo);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);
      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);
      if (renderer._bufferData.uv == null) {
        renderer._bufferData.uv = this.gl.createBuffer();
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, renderer._bufferData.uv);
      const uvArray = model.getDrawableVertexUvs(index);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);
      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);
      this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);
      const context = renderer.getClippingContextBufferForMask();
      const channelIndex = renderer.getClippingContextBufferForMask()._layoutChannelIndex;
      const colorChannel = renderer.getClippingContextBufferForMask().getClippingManager().getChannelFlagAsColor(channelIndex);
      this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.r, colorChannel.g, colorChannel.b, colorChannel.a);
      this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, renderer.getClippingContextBufferForMask()._matrixForMask.getArray());
      const rect = renderer.getClippingContextBufferForMask()._layoutBounds;
      this.gl.uniform4f(shaderSet.uniformBaseColorLocation, rect.x * 2 - 1, rect.y * 2 - 1, rect.getRight() * 2 - 1, rect.getBottom() * 2 - 1);
      const multiplyColor = model.getMultiplyColor(index);
      const screenColor = model.getScreenColor(index);
      this.gl.uniform4f(shaderSet.uniformMultiplyColorLocation, multiplyColor.r, multiplyColor.g, multiplyColor.b, multiplyColor.a);
      this.gl.uniform4f(shaderSet.uniformScreenColorLocation, screenColor.r, screenColor.g, screenColor.b, screenColor.a);
      const srcColor = this.gl.ZERO;
      const dstColor = this.gl.ONE_MINUS_SRC_COLOR;
      const srcAlpha = this.gl.ZERO;
      const dstAlpha = this.gl.ONE_MINUS_SRC_ALPHA;
      if (renderer._bufferData.index == null) {
        renderer._bufferData.index = this.gl.createBuffer();
      }
      const indexArray = model.getDrawableVertexIndices(index);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, renderer._bufferData.index);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);
      this.gl.blendFuncSeparate(srcColor, dstColor, srcAlpha, dstAlpha);
    }
    /**
     * シェーダープログラムを解放する
     */
    releaseShaderProgram() {
      for (let i = 0; i < this._shaderSets.getSize(); i++) {
        this.gl.deleteProgram(this._shaderSets.at(i).shaderProgram);
        this._shaderSets.at(i).shaderProgram = 0;
        this._shaderSets.set(i, void 0);
        this._shaderSets.set(i, null);
      }
    }
    /**
     * シェーダープログラムを初期化する
     * @param vertShaderSrc 頂点シェーダのソース
     * @param fragShaderSrc フラグメントシェーダのソース
     */
    generateShaders() {
      for (let i = 0; i < ShaderCount; i++) {
        this._shaderSets.pushBack(new CubismShaderSet());
      }
      this._shaderSets.at(0).shaderProgram = this.loadShaderProgram(vertexShaderSrcSetupMask, fragmentShaderSrcsetupMask);
      this._shaderSets.at(1).shaderProgram = this.loadShaderProgram(vertexShaderSrc, fragmentShaderSrcPremultipliedAlpha);
      this._shaderSets.at(2).shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskPremultipliedAlpha);
      this._shaderSets.at(3).shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskInvertedPremultipliedAlpha);
      this._shaderSets.at(4).shaderProgram = this._shaderSets.at(1).shaderProgram;
      this._shaderSets.at(5).shaderProgram = this._shaderSets.at(2).shaderProgram;
      this._shaderSets.at(6).shaderProgram = this._shaderSets.at(3).shaderProgram;
      this._shaderSets.at(7).shaderProgram = this._shaderSets.at(1).shaderProgram;
      this._shaderSets.at(8).shaderProgram = this._shaderSets.at(2).shaderProgram;
      this._shaderSets.at(9).shaderProgram = this._shaderSets.at(3).shaderProgram;
      this._shaderSets.at(0).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, "a_position");
      this._shaderSets.at(0).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(0).shaderProgram, "a_texCoord");
      this._shaderSets.at(0).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "s_texture0");
      this._shaderSets.at(0).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(0).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_channelFlag");
      this._shaderSets.at(0).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_baseColor");
      this._shaderSets.at(0).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(0).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(0).shaderProgram, "u_screenColor");
      this._shaderSets.at(1).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, "a_position");
      this._shaderSets.at(1).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(1).shaderProgram, "a_texCoord");
      this._shaderSets.at(1).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "s_texture0");
      this._shaderSets.at(1).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "u_matrix");
      this._shaderSets.at(1).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "u_baseColor");
      this._shaderSets.at(1).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(1).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(1).shaderProgram, "u_screenColor");
      this._shaderSets.at(2).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, "a_position");
      this._shaderSets.at(2).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(2).shaderProgram, "a_texCoord");
      this._shaderSets.at(2).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "s_texture0");
      this._shaderSets.at(2).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "s_texture1");
      this._shaderSets.at(2).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_matrix");
      this._shaderSets.at(2).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(2).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_channelFlag");
      this._shaderSets.at(2).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_baseColor");
      this._shaderSets.at(2).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(2).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(2).shaderProgram, "u_screenColor");
      this._shaderSets.at(3).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, "a_position");
      this._shaderSets.at(3).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(3).shaderProgram, "a_texCoord");
      this._shaderSets.at(3).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "s_texture0");
      this._shaderSets.at(3).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "s_texture1");
      this._shaderSets.at(3).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_matrix");
      this._shaderSets.at(3).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(3).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_channelFlag");
      this._shaderSets.at(3).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_baseColor");
      this._shaderSets.at(3).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(3).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(3).shaderProgram, "u_screenColor");
      this._shaderSets.at(4).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, "a_position");
      this._shaderSets.at(4).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(4).shaderProgram, "a_texCoord");
      this._shaderSets.at(4).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "s_texture0");
      this._shaderSets.at(4).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "u_matrix");
      this._shaderSets.at(4).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "u_baseColor");
      this._shaderSets.at(4).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(4).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(4).shaderProgram, "u_screenColor");
      this._shaderSets.at(5).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, "a_position");
      this._shaderSets.at(5).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(5).shaderProgram, "a_texCoord");
      this._shaderSets.at(5).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "s_texture0");
      this._shaderSets.at(5).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "s_texture1");
      this._shaderSets.at(5).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_matrix");
      this._shaderSets.at(5).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(5).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_channelFlag");
      this._shaderSets.at(5).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_baseColor");
      this._shaderSets.at(5).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(5).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(5).shaderProgram, "u_screenColor");
      this._shaderSets.at(6).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, "a_position");
      this._shaderSets.at(6).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(6).shaderProgram, "a_texCoord");
      this._shaderSets.at(6).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "s_texture0");
      this._shaderSets.at(6).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "s_texture1");
      this._shaderSets.at(6).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_matrix");
      this._shaderSets.at(6).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(6).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_channelFlag");
      this._shaderSets.at(6).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_baseColor");
      this._shaderSets.at(6).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(6).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(6).shaderProgram, "u_screenColor");
      this._shaderSets.at(7).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, "a_position");
      this._shaderSets.at(7).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(7).shaderProgram, "a_texCoord");
      this._shaderSets.at(7).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "s_texture0");
      this._shaderSets.at(7).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "u_matrix");
      this._shaderSets.at(7).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "u_baseColor");
      this._shaderSets.at(7).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(7).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(7).shaderProgram, "u_screenColor");
      this._shaderSets.at(8).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, "a_position");
      this._shaderSets.at(8).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(8).shaderProgram, "a_texCoord");
      this._shaderSets.at(8).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "s_texture0");
      this._shaderSets.at(8).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "s_texture1");
      this._shaderSets.at(8).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_matrix");
      this._shaderSets.at(8).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(8).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_channelFlag");
      this._shaderSets.at(8).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_baseColor");
      this._shaderSets.at(8).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(8).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(8).shaderProgram, "u_screenColor");
      this._shaderSets.at(9).attributePositionLocation = this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, "a_position");
      this._shaderSets.at(9).attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets.at(9).shaderProgram, "a_texCoord");
      this._shaderSets.at(9).samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "s_texture0");
      this._shaderSets.at(9).samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "s_texture1");
      this._shaderSets.at(9).uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_matrix");
      this._shaderSets.at(9).uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_clipMatrix");
      this._shaderSets.at(9).uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_channelFlag");
      this._shaderSets.at(9).uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_baseColor");
      this._shaderSets.at(9).uniformMultiplyColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_multiplyColor");
      this._shaderSets.at(9).uniformScreenColorLocation = this.gl.getUniformLocation(this._shaderSets.at(9).shaderProgram, "u_screenColor");
    }
    /**
     * シェーダプログラムをロードしてアドレスを返す
     * @param vertexShaderSource    頂点シェーダのソース
     * @param fragmentShaderSource  フラグメントシェーダのソース
     * @return シェーダプログラムのアドレス
     */
    loadShaderProgram(vertexShaderSource, fragmentShaderSource) {
      let shaderProgram = this.gl.createProgram();
      let vertShader = this.compileShaderSource(this.gl.VERTEX_SHADER, vertexShaderSource);
      if (!vertShader) {
        CubismLogError("Vertex shader compile error!");
        return 0;
      }
      let fragShader = this.compileShaderSource(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
      if (!fragShader) {
        CubismLogError("Vertex shader compile error!");
        return 0;
      }
      this.gl.attachShader(shaderProgram, vertShader);
      this.gl.attachShader(shaderProgram, fragShader);
      this.gl.linkProgram(shaderProgram);
      const linkStatus = this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS);
      if (!linkStatus) {
        CubismLogError("Failed to link program: {0}", shaderProgram);
        this.gl.deleteShader(vertShader);
        vertShader = 0;
        this.gl.deleteShader(fragShader);
        fragShader = 0;
        if (shaderProgram) {
          this.gl.deleteProgram(shaderProgram);
          shaderProgram = 0;
        }
        return 0;
      }
      this.gl.deleteShader(vertShader);
      this.gl.deleteShader(fragShader);
      return shaderProgram;
    }
    /**
     * シェーダープログラムをコンパイルする
     * @param shaderType シェーダタイプ(Vertex/Fragment)
     * @param shaderSource シェーダソースコード
     *
     * @return コンパイルされたシェーダープログラム
     */
    compileShaderSource(shaderType, shaderSource) {
      const source2 = shaderSource;
      const shader = this.gl.createShader(shaderType);
      this.gl.shaderSource(shader, source2);
      this.gl.compileShader(shader);
      if (!shader) {
        const log = this.gl.getShaderInfoLog(shader);
        CubismLogError("Shader compile log: {0} ", log);
      }
      const status = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);
      if (!status) {
        this.gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
    setGl(gl) {
      this.gl = gl;
    }
    // webglコンテキスト
  };
  var CubismShaderSet = class {
    constructor() {
      __publicField(this, "shaderProgram");
      // シェーダープログラムのアドレス
      __publicField(this, "attributePositionLocation");
      // シェーダープログラムに渡す変数のアドレス（Position）
      __publicField(this, "attributeTexCoordLocation");
      // シェーダープログラムに渡す変数のアドレス（TexCoord）
      __publicField(this, "uniformMatrixLocation");
      // シェーダープログラムに渡す変数のアドレス（Matrix）
      __publicField(this, "uniformClipMatrixLocation");
      // シェーダープログラムに渡す変数のアドレス（ClipMatrix）
      __publicField(this, "samplerTexture0Location");
      // シェーダープログラムに渡す変数のアドレス（Texture0）
      __publicField(this, "samplerTexture1Location");
      // シェーダープログラムに渡す変数のアドレス（Texture1）
      __publicField(this, "uniformBaseColorLocation");
      // シェーダープログラムに渡す変数のアドレス（BaseColor）
      __publicField(this, "uniformChannelFlagLocation");
      // シェーダープログラムに渡す変数のアドレス（ChannelFlag）
      __publicField(this, "uniformMultiplyColorLocation");
      // シェーダープログラムに渡す変数のアドレス（MultiplyColor）
      __publicField(this, "uniformScreenColorLocation");
    }
    // シェーダープログラムに渡す変数のアドレス（ScreenColor）
  };
  var ShaderNames;
  (function(ShaderNames2) {
    ShaderNames2[ShaderNames2["ShaderNames_SetupMask"] = 0] = "ShaderNames_SetupMask";
    ShaderNames2[ShaderNames2["ShaderNames_NormalPremultipliedAlpha"] = 1] = "ShaderNames_NormalPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_NormalMaskedPremultipliedAlpha"] = 2] = "ShaderNames_NormalMaskedPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_NomralMaskedInvertedPremultipliedAlpha"] = 3] = "ShaderNames_NomralMaskedInvertedPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_AddPremultipliedAlpha"] = 4] = "ShaderNames_AddPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_AddMaskedPremultipliedAlpha"] = 5] = "ShaderNames_AddMaskedPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_AddMaskedPremultipliedAlphaInverted"] = 6] = "ShaderNames_AddMaskedPremultipliedAlphaInverted";
    ShaderNames2[ShaderNames2["ShaderNames_MultPremultipliedAlpha"] = 7] = "ShaderNames_MultPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_MultMaskedPremultipliedAlpha"] = 8] = "ShaderNames_MultMaskedPremultipliedAlpha";
    ShaderNames2[ShaderNames2["ShaderNames_MultMaskedPremultipliedAlphaInverted"] = 9] = "ShaderNames_MultMaskedPremultipliedAlphaInverted";
  })(ShaderNames || (ShaderNames = {}));
  var vertexShaderSrcSetupMask = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_myPos;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_clipMatrix * a_position;   v_myPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
  var fragmentShaderSrcsetupMask = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_myPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;void main(){   float isInside =        step(u_baseColor.x, v_myPos.x/v_myPos.w)       * step(u_baseColor.y, v_myPos.y/v_myPos.w)       * step(v_myPos.x/v_myPos.w, u_baseColor.z)       * step(v_myPos.y/v_myPos.w, u_baseColor.w);   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;}";
  var vertexShaderSrc = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;uniform mat4       u_matrix;void main(){   gl_Position = u_matrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
  var vertexShaderSrcMasked = "attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform mat4       u_matrix;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_matrix * a_position;   v_clipPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}";
  var fragmentShaderSrcPremultipliedAlpha = "precision mediump float;varying vec2       v_texCoord;uniform vec4       u_baseColor;uniform sampler2D  s_texture0;uniform vec4       u_multiplyColor;uniform vec4       u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 color = texColor * u_baseColor;   gl_FragColor = vec4(color.rgb, color.a);}";
  var fragmentShaderSrcMaskPremultipliedAlpha = "precision mediump float;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;uniform sampler2D  s_texture1;uniform vec4       u_multiplyColor;uniform vec4       u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 col_formask = texColor * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * maskVal;   gl_FragColor = col_formask;}";
  var fragmentShaderSrcMaskInvertedPremultipliedAlpha = "precision mediump float;varying vec2      v_texCoord;varying vec4      v_clipPos;uniform sampler2D s_texture0;uniform sampler2D s_texture1;uniform vec4      u_channelFlag;uniform vec4      u_baseColor;uniform vec4      u_multiplyColor;uniform vec4      u_screenColor;void main(){   vec4 texColor = texture2D(s_texture0, v_texCoord);   texColor.rgb = texColor.rgb * u_multiplyColor.rgb;   texColor.rgb = (texColor.rgb + u_screenColor.rgb * texColor.a) - (texColor.rgb * u_screenColor.rgb);   vec4 col_formask = texColor * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * (1.0 - maskVal);   gl_FragColor = col_formask;}";
  var Live2DCubismFramework35;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismShaderSet = CubismShaderSet;
    Live2DCubismFramework42.CubismShader_WebGL = CubismShader_WebGL;
    Live2DCubismFramework42.ShaderNames = ShaderNames;
  })(Live2DCubismFramework35 || (Live2DCubismFramework35 = {}));

  // src/Live2D/dist/rendering/cubismrenderer_webgl.js
  var s_viewport;
  var s_fbo;
  var CubismClippingManager_WebGL = class extends CubismClippingManager {
    /**
     * コンストラクタ
     */
    constructor() {
      super(CubismClippingContext_WebGL);
      __publicField(this, "_currentMaskRenderTexture");
      // マスク用レンダーテクスチャのアドレス
      __publicField(this, "_maskRenderTextures");
      // レンダーテクスチャのリスト
      __publicField(this, "_maskColorBuffers");
      // マスク用カラーバッファーのアドレスのリスト
      __publicField(this, "_currentFrameNo");
      // マスクテクスチャに与えるフレーム番号
      __publicField(this, "_maskTexture");
      // マスク用のテクスチャリソースのリスト
      __publicField(this, "gl");
    }
    /**
     * テンポラリのレンダーテクスチャのアドレスを取得する
     * FrameBufferObjectが存在しない場合、新しく生成する
     *
     * @return レンダーテクスチャの配列
     */
    getMaskRenderTexture() {
      if (this._maskTexture && this._maskTexture.textures != null) {
        this._maskTexture.frameNo = this._currentFrameNo;
      } else {
        if (this._maskRenderTextures != null) {
          this._maskRenderTextures.clear();
        }
        this._maskRenderTextures = new csmVector();
        if (this._maskColorBuffers != null) {
          this._maskColorBuffers.clear();
        }
        this._maskColorBuffers = new csmVector();
        const size = this._clippingMaskBufferSize;
        for (let index = 0; index < this._renderTextureCount; index++) {
          this._maskColorBuffers.pushBack(this.gl.createTexture());
          this.gl.bindTexture(this.gl.TEXTURE_2D, this._maskColorBuffers.at(index));
          this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, size, size, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
          this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
          this.gl.bindTexture(this.gl.TEXTURE_2D, null);
          this._maskRenderTextures.pushBack(this.gl.createFramebuffer());
          this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._maskRenderTextures.at(index));
          this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this._maskColorBuffers.at(index), 0);
        }
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
        this._maskTexture = new CubismRenderTextureResource(this._currentFrameNo, this._maskRenderTextures);
      }
      return this._maskTexture.textures;
    }
    /**
     * WebGLレンダリングコンテキストを設定する
     * @param gl WebGLレンダリングコンテキスト
     */
    setGL(gl) {
      this.gl = gl;
    }
    /**
     * クリッピングコンテキストを作成する。モデル描画時に実行する。
     * @param model モデルのインスタンス
     * @param renderer レンダラのインスタンス
     */
    setupClippingContext(model, renderer) {
      this._currentFrameNo++;
      let usingClipCount = 0;
      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
        const cc = this._clippingContextListForMask.at(clipIndex);
        this.calcClippedDrawTotalBounds(model, cc);
        if (cc._isUsing) {
          usingClipCount++;
        }
      }
      if (usingClipCount > 0) {
        this.gl.viewport(0, 0, this._clippingMaskBufferSize, this._clippingMaskBufferSize);
        this._currentMaskRenderTexture = this.getMaskRenderTexture().at(0);
        renderer.preDraw();
        this.setupLayoutBounds(usingClipCount);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._currentMaskRenderTexture);
        if (this._clearedFrameBufferFlags.getSize() != this._renderTextureCount) {
          this._clearedFrameBufferFlags.clear();
          this._clearedFrameBufferFlags = new csmVector(this._renderTextureCount);
        }
        for (let index = 0; index < this._clearedFrameBufferFlags.getSize(); index++) {
          this._clearedFrameBufferFlags.set(index, false);
        }
        for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.getSize(); clipIndex++) {
          const clipContext = this._clippingContextListForMask.at(clipIndex);
          const allClipedDrawRect = clipContext._allClippedDrawRect;
          const layoutBoundsOnTex01 = clipContext._layoutBounds;
          const margin = 0.05;
          let scaleX = 0;
          let scaleY = 0;
          const clipContextRenderTexture = this.getMaskRenderTexture().at(clipContext._bufferIndex);
          if (this._currentMaskRenderTexture != clipContextRenderTexture) {
            this._currentMaskRenderTexture = clipContextRenderTexture;
            renderer.preDraw();
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._currentMaskRenderTexture);
          }
          this._tmpBoundsOnModel.setRect(allClipedDrawRect);
          this._tmpBoundsOnModel.expand(allClipedDrawRect.width * margin, allClipedDrawRect.height * margin);
          scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;
          scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;
          {
            this._tmpMatrix.loadIdentity();
            {
              this._tmpMatrix.translateRelative(-1, -1);
              this._tmpMatrix.scaleRelative(2, 2);
            }
            {
              this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);
              this._tmpMatrix.scaleRelative(scaleX, scaleY);
              this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
            }
            this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());
          }
          {
            this._tmpMatrix.loadIdentity();
            {
              this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);
              this._tmpMatrix.scaleRelative(scaleX, scaleY);
              this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);
            }
            this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());
          }
          clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());
          clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());
          const clipDrawCount = clipContext._clippingIdCount;
          for (let i = 0; i < clipDrawCount; i++) {
            const clipDrawIndex = clipContext._clippingIdList[i];
            if (!model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {
              continue;
            }
            renderer.setIsCulling(model.getDrawableCulling(clipDrawIndex) != false);
            if (!this._clearedFrameBufferFlags.at(clipContext._bufferIndex)) {
              this.gl.clearColor(1, 1, 1, 1);
              this.gl.clear(this.gl.COLOR_BUFFER_BIT);
              this._clearedFrameBufferFlags.set(clipContext._bufferIndex, true);
            }
            renderer.setClippingContextBufferForMask(clipContext);
            renderer.drawMeshWebGL(model, clipDrawIndex);
          }
        }
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
        renderer.setClippingContextBufferForMask(null);
        this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);
      }
    }
    /**
     * カラーバッファを取得する
     * @return カラーバッファ
     */
    getColorBuffer() {
      return this._maskColorBuffers;
    }
    /**
     * マスクの合計数をカウント
     * @returns
     */
    getClippingMaskCount() {
      return this._clippingContextListForMask.getSize();
    }
    // WebGLレンダリングコンテキスト
  };
  var CubismRenderTextureResource = class {
    /**
     * 引数付きコンストラクタ
     * @param frameNo レンダラーのフレーム番号
     * @param texture テクスチャのアドレス
     */
    constructor(frameNo, texture) {
      __publicField(this, "frameNo");
      // レンダラのフレーム番号
      __publicField(this, "textures");
      this.frameNo = frameNo;
      this.textures = texture;
    }
    // テクスチャのアドレス
  };
  var CubismClippingContext_WebGL = class extends CubismClippingContext {
    /**
     * 引数付きコンストラクタ
     */
    constructor(manager, clippingDrawableIndices, clipCount) {
      super(clippingDrawableIndices, clipCount);
      __publicField(this, "_owner");
      this._owner = manager;
    }
    /**
     * このマスクを管理するマネージャのインスタンスを取得する
     * @return クリッピングマネージャのインスタンス
     */
    getClippingManager() {
      return this._owner;
    }
    setGl(gl) {
      this._owner.setGL(gl);
    }
    // このマスクを管理しているマネージャのインスタンス
  };
  var CubismRendererProfile_WebGL = class {
    constructor() {
      __publicField(this, "_lastArrayBufferBinding");
      ///< モデル描画直前の頂点バッファ
      __publicField(this, "_lastElementArrayBufferBinding");
      ///< モデル描画直前のElementバッファ
      __publicField(this, "_lastProgram");
      ///< モデル描画直前のシェーダプログラムバッファ
      __publicField(this, "_lastActiveTexture");
      ///< モデル描画直前のアクティブなテクスチャ
      __publicField(this, "_lastTexture0Binding2D");
      ///< モデル描画直前のテクスチャユニット0
      __publicField(this, "_lastTexture1Binding2D");
      ///< モデル描画直前のテクスチャユニット1
      __publicField(this, "_lastVertexAttribArrayEnabled");
      ///< モデル描画直前のテクスチャユニット1
      __publicField(this, "_lastScissorTest");
      ///< モデル描画直前のGL_VERTEX_ATTRIB_ARRAY_ENABLEDパラメータ
      __publicField(this, "_lastBlend");
      ///< モデル描画直前のGL_SCISSOR_TESTパラメータ
      __publicField(this, "_lastStencilTest");
      ///< モデル描画直前のGL_STENCIL_TESTパラメータ
      __publicField(this, "_lastDepthTest");
      ///< モデル描画直前のGL_DEPTH_TESTパラメータ
      __publicField(this, "_lastCullFace");
      ///< モデル描画直前のGL_CULL_FACEパラメータ
      __publicField(this, "_lastFrontFace");
      ///< モデル描画直前のGL_CULL_FACEパラメータ
      __publicField(this, "_lastColorMask");
      ///< モデル描画直前のGL_COLOR_WRITEMASKパラメータ
      __publicField(this, "_lastBlending");
      ///< モデル描画直前のカラーブレンディングパラメータ
      __publicField(this, "_lastFBO");
      ///< モデル描画直前のフレームバッファ
      __publicField(this, "_lastViewport");
      ///< モデル描画直前のビューポート
      __publicField(this, "gl");
      this._lastVertexAttribArrayEnabled = new Array(4);
      this._lastColorMask = new Array(4);
      this._lastBlending = new Array(4);
      this._lastViewport = new Array(4);
    }
    setGlEnable(index, enabled) {
      if (enabled)
        this.gl.enable(index);
      else
        this.gl.disable(index);
    }
    setGlEnableVertexAttribArray(index, enabled) {
      if (enabled)
        this.gl.enableVertexAttribArray(index);
      else
        this.gl.disableVertexAttribArray(index);
    }
    save() {
      if (this.gl == null) {
        CubismLogError("'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function.");
        return;
      }
      this._lastArrayBufferBinding = this.gl.getParameter(this.gl.ARRAY_BUFFER_BINDING);
      this._lastElementArrayBufferBinding = this.gl.getParameter(this.gl.ELEMENT_ARRAY_BUFFER_BINDING);
      this._lastProgram = this.gl.getParameter(this.gl.CURRENT_PROGRAM);
      this._lastActiveTexture = this.gl.getParameter(this.gl.ACTIVE_TEXTURE);
      this.gl.activeTexture(this.gl.TEXTURE1);
      this._lastTexture1Binding2D = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this._lastTexture0Binding2D = this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
      this._lastVertexAttribArrayEnabled[0] = this.gl.getVertexAttrib(0, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);
      this._lastVertexAttribArrayEnabled[1] = this.gl.getVertexAttrib(1, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);
      this._lastVertexAttribArrayEnabled[2] = this.gl.getVertexAttrib(2, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);
      this._lastVertexAttribArrayEnabled[3] = this.gl.getVertexAttrib(3, this.gl.VERTEX_ATTRIB_ARRAY_ENABLED);
      this._lastScissorTest = this.gl.isEnabled(this.gl.SCISSOR_TEST);
      this._lastStencilTest = this.gl.isEnabled(this.gl.STENCIL_TEST);
      this._lastDepthTest = this.gl.isEnabled(this.gl.DEPTH_TEST);
      this._lastCullFace = this.gl.isEnabled(this.gl.CULL_FACE);
      this._lastBlend = this.gl.isEnabled(this.gl.BLEND);
      this._lastFrontFace = this.gl.getParameter(this.gl.FRONT_FACE);
      this._lastColorMask = this.gl.getParameter(this.gl.COLOR_WRITEMASK);
      this._lastBlending[0] = this.gl.getParameter(this.gl.BLEND_SRC_RGB);
      this._lastBlending[1] = this.gl.getParameter(this.gl.BLEND_DST_RGB);
      this._lastBlending[2] = this.gl.getParameter(this.gl.BLEND_SRC_ALPHA);
      this._lastBlending[3] = this.gl.getParameter(this.gl.BLEND_DST_ALPHA);
      this._lastFBO = this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
      this._lastViewport = this.gl.getParameter(this.gl.VIEWPORT);
    }
    restore() {
      if (this.gl == null) {
        CubismLogError("'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function.");
        return;
      }
      this.gl.useProgram(this._lastProgram);
      this.setGlEnableVertexAttribArray(0, this._lastVertexAttribArrayEnabled[0]);
      this.setGlEnableVertexAttribArray(1, this._lastVertexAttribArrayEnabled[1]);
      this.setGlEnableVertexAttribArray(2, this._lastVertexAttribArrayEnabled[2]);
      this.setGlEnableVertexAttribArray(3, this._lastVertexAttribArrayEnabled[3]);
      this.setGlEnable(this.gl.SCISSOR_TEST, this._lastScissorTest);
      this.setGlEnable(this.gl.STENCIL_TEST, this._lastStencilTest);
      this.setGlEnable(this.gl.DEPTH_TEST, this._lastDepthTest);
      this.setGlEnable(this.gl.CULL_FACE, this._lastCullFace);
      this.setGlEnable(this.gl.BLEND, this._lastBlend);
      this.gl.frontFace(this._lastFrontFace);
      this.gl.colorMask(this._lastColorMask[0], this._lastColorMask[1], this._lastColorMask[2], this._lastColorMask[3]);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this._lastArrayBufferBinding);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this._lastElementArrayBufferBinding);
      this.gl.activeTexture(this.gl.TEXTURE1);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture1Binding2D);
      this.gl.activeTexture(this.gl.TEXTURE0);
      this.gl.bindTexture(this.gl.TEXTURE_2D, this._lastTexture0Binding2D);
      this.gl.activeTexture(this._lastActiveTexture);
      this.gl.blendFuncSeparate(this._lastBlending[0], this._lastBlending[1], this._lastBlending[2], this._lastBlending[3]);
    }
    setGl(gl) {
      this.gl = gl;
    }
  };
  var CubismRenderer_WebGL = class extends CubismRenderer {
    /**
     * コンストラクタ
     */
    constructor() {
      super();
      __publicField(this, "_textures");
      // モデルが参照するテクスチャとレンダラでバインドしているテクスチャとのマップ
      __publicField(this, "_sortedDrawableIndexList");
      // 描画オブジェクトのインデックスを描画順に並べたリスト
      __publicField(this, "_clippingManager");
      // クリッピングマスク管理オブジェクト
      __publicField(this, "_clippingContextBufferForMask");
      // マスクテクスチャに描画するためのクリッピングコンテキスト
      __publicField(this, "_clippingContextBufferForDraw");
      // 画面上描画するためのクリッピングコンテキスト
      __publicField(this, "_rendererProfile");
      __publicField(this, "firstDraw");
      __publicField(this, "_bufferData");
      // 頂点バッファデータ
      __publicField(this, "_extension");
      // 拡張機能
      __publicField(this, "gl");
      this._clippingContextBufferForMask = null;
      this._clippingContextBufferForDraw = null;
      this._rendererProfile = new CubismRendererProfile_WebGL();
      this.firstDraw = true;
      this._textures = new csmMap();
      this._sortedDrawableIndexList = new csmVector();
      this._bufferData = {
        vertex: WebGLBuffer = null,
        uv: WebGLBuffer = null,
        index: WebGLBuffer = null
      };
      this._textures.prepareCapacity(32, true);
    }
    /**
     * レンダラの初期化処理を実行する
     * 引数に渡したモデルからレンダラの初期化処理に必要な情報を取り出すことができる
     *
     * @param model モデルのインスタンス
     * @param maskBufferCount バッファの生成数
     */
    initialize(model, maskBufferCount = 1) {
      if (model.isUsingMasking()) {
        this._clippingManager = new CubismClippingManager_WebGL();
        this._clippingManager.initialize(model, maskBufferCount);
      }
      this._sortedDrawableIndexList.resize(model.getDrawableCount(), 0);
      super.initialize(model);
    }
    /**
     * WebGLテクスチャのバインド処理
     * CubismRendererにテクスチャを設定し、CubismRenderer内でその画像を参照するためのIndex値を戻り値とする
     * @param modelTextureNo セットするモデルテクスチャの番号
     * @param glTextureNo WebGLテクスチャの番号
     */
    bindTexture(modelTextureNo, glTexture) {
      this._textures.setValue(modelTextureNo, glTexture);
    }
    /**
     * WebGLにバインドされたテクスチャのリストを取得する
     * @return テクスチャのリスト
     */
    getBindedTextures() {
      return this._textures;
    }
    /**
     * クリッピングマスクバッファのサイズを設定する
     * マスク用のFrameBufferを破棄、再作成する為処理コストは高い
     * @param size クリッピングマスクバッファのサイズ
     */
    setClippingMaskBufferSize(size) {
      if (!this._model.isUsingMasking()) {
        return;
      }
      const renderTextureCount = this._clippingManager.getRenderTextureCount();
      this._clippingManager.release();
      this._clippingManager = void 0;
      this._clippingManager = null;
      this._clippingManager = new CubismClippingManager_WebGL();
      this._clippingManager.setClippingMaskBufferSize(size);
      this._clippingManager.initialize(
        this.getModel(),
        renderTextureCount
        // インスタンス破棄前に保存したレンダーテクスチャの数
      );
    }
    /**
     * クリッピングマスクバッファのサイズを取得する
     * @return クリッピングマスクバッファのサイズ
     */
    getClippingMaskBufferSize() {
      return this._model.isUsingMasking() ? this._clippingManager.getClippingMaskBufferSize() : -1;
    }
    /**
     * レンダーテクスチャの枚数を取得する
     * @return レンダーテクスチャの枚数
     */
    getRenderTextureCount() {
      return this._model.isUsingMasking() ? this._clippingManager.getRenderTextureCount() : -1;
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      if (this._clippingManager) {
        this._clippingManager.release();
        this._clippingManager = void 0;
        this._clippingManager = null;
      }
      if (this.gl == null) {
        return;
      }
      this.gl.deleteBuffer(this._bufferData.vertex);
      this._bufferData.vertex = null;
      this.gl.deleteBuffer(this._bufferData.uv);
      this._bufferData.uv = null;
      this.gl.deleteBuffer(this._bufferData.index);
      this._bufferData.index = null;
      this._bufferData = null;
      this._textures = null;
    }
    /**
     * モデルを描画する実際の処理
     */
    doDrawModel() {
      if (this.gl == null) {
        CubismLogError("'gl' is null. WebGLRenderingContext is required.\nPlease call 'CubimRenderer_WebGL.startUp' function.");
        return;
      }
      if (this._clippingManager != null) {
        this.preDraw();
        if (this.isUsingHighPrecisionMask()) {
          this._clippingManager.setupMatrixForHighPrecision(this.getModel(), false);
        } else {
          this._clippingManager.setupClippingContext(this.getModel(), this);
        }
      }
      this.preDraw();
      const drawableCount = this.getModel().getDrawableCount();
      const renderOrder = this.getModel().getDrawableRenderOrders();
      for (let i = 0; i < drawableCount; ++i) {
        const order = renderOrder[i];
        this._sortedDrawableIndexList.set(order, i);
      }
      for (let i = 0; i < drawableCount; ++i) {
        const drawableIndex = this._sortedDrawableIndexList.at(i);
        if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {
          continue;
        }
        const clipContext = this._clippingManager != null ? this._clippingManager.getClippingContextListForDraw().at(drawableIndex) : null;
        if (clipContext != null && this.isUsingHighPrecisionMask()) {
          if (clipContext._isUsing) {
            this.gl.viewport(0, 0, this._clippingManager.getClippingMaskBufferSize(), this._clippingManager.getClippingMaskBufferSize());
            this.preDraw();
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, clipContext.getClippingManager().getMaskRenderTexture().at(clipContext._bufferIndex));
            this.gl.clearColor(1, 1, 1, 1);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
          }
          {
            const clipDrawCount = clipContext._clippingIdCount;
            for (let index = 0; index < clipDrawCount; index++) {
              const clipDrawIndex = clipContext._clippingIdList[index];
              if (!this._model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {
                continue;
              }
              this.setIsCulling(this._model.getDrawableCulling(clipDrawIndex) != false);
              this.setClippingContextBufferForMask(clipContext);
              this.drawMeshWebGL(this._model, clipDrawIndex);
            }
          }
          {
            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);
            this.setClippingContextBufferForMask(null);
            this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);
            this.preDraw();
          }
        }
        this.setClippingContextBufferForDraw(clipContext);
        this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));
        this.drawMeshWebGL(this._model, drawableIndex);
      }
    }
    /**
     * 描画オブジェクト（アートメッシュ）を描画する。
     * @param model 描画対象のモデル
     * @param index 描画対象のメッシュのインデックス
     */
    drawMeshWebGL(model, index) {
      if (this.isCulling()) {
        this.gl.enable(this.gl.CULL_FACE);
      } else {
        this.gl.disable(this.gl.CULL_FACE);
      }
      this.gl.frontFace(this.gl.CCW);
      if (this.isGeneratingMask()) {
        CubismShader_WebGL.getInstance().setupShaderProgramForMask(this, model, index);
      } else {
        CubismShader_WebGL.getInstance().setupShaderProgramForDraw(this, model, index);
      }
      {
        const indexCount = model.getDrawableVertexIndexCount(index);
        this.gl.drawElements(this.gl.TRIANGLES, indexCount, this.gl.UNSIGNED_SHORT, 0);
      }
      this.gl.useProgram(null);
      this.setClippingContextBufferForDraw(null);
      this.setClippingContextBufferForMask(null);
    }
    saveProfile() {
      this._rendererProfile.save();
    }
    restoreProfile() {
      this._rendererProfile.restore();
    }
    /**
     * レンダラが保持する静的なリソースを解放する
     * WebGLの静的なシェーダープログラムを解放する
     */
    static doStaticRelease() {
      CubismShader_WebGL.deleteInstance();
    }
    /**
     * レンダーステートを設定する
     * @param fbo アプリケーション側で指定しているフレームバッファ
     * @param viewport ビューポート
     */
    setRenderState(fbo, viewport) {
      s_fbo = fbo;
      s_viewport = viewport;
    }
    /**
     * 描画開始時の追加処理
     * モデルを描画する前にクリッピングマスクに必要な処理を実装している
     */
    preDraw() {
      if (this.firstDraw) {
        this.firstDraw = false;
      }
      this.gl.disable(this.gl.SCISSOR_TEST);
      this.gl.disable(this.gl.STENCIL_TEST);
      this.gl.disable(this.gl.DEPTH_TEST);
      this.gl.frontFace(this.gl.CW);
      this.gl.enable(this.gl.BLEND);
      this.gl.colorMask(true, true, true, true);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
      if (this.getAnisotropy() > 0 && this._extension) {
        for (let i = 0; i < this._textures.getSize(); ++i) {
          this.gl.bindTexture(this.gl.TEXTURE_2D, this._textures.getValue(i));
          this.gl.texParameterf(this.gl.TEXTURE_2D, this._extension.TEXTURE_MAX_ANISOTROPY_EXT, this.getAnisotropy());
        }
      }
    }
    /**
     * マスクテクスチャに描画するクリッピングコンテキストをセットする
     */
    setClippingContextBufferForMask(clip) {
      this._clippingContextBufferForMask = clip;
    }
    /**
     * マスクテクスチャに描画するクリッピングコンテキストを取得する
     * @return マスクテクスチャに描画するクリッピングコンテキスト
     */
    getClippingContextBufferForMask() {
      return this._clippingContextBufferForMask;
    }
    /**
     * 画面上に描画するクリッピングコンテキストをセットする
     */
    setClippingContextBufferForDraw(clip) {
      this._clippingContextBufferForDraw = clip;
    }
    /**
     * 画面上に描画するクリッピングコンテキストを取得する
     * @return 画面上に描画するクリッピングコンテキスト
     */
    getClippingContextBufferForDraw() {
      return this._clippingContextBufferForDraw;
    }
    /**
     * マスク生成時かを判定する
     * @returns 判定値
     */
    isGeneratingMask() {
      return this.getClippingContextBufferForMask() != null;
    }
    /**
     * glの設定
     */
    startUp(gl) {
      this.gl = gl;
      if (this._clippingManager) {
        this._clippingManager.setGL(gl);
      }
      CubismShader_WebGL.getInstance().setGl(gl);
      this._rendererProfile.setGl(gl);
      this._extension = this.gl.getExtension("EXT_texture_filter_anisotropic") || this.gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this.gl.getExtension("MOZ_EXT_texture_filter_anisotropic");
    }
    // webglコンテキスト
  };
  CubismRenderer.staticRelease = () => {
    CubismRenderer_WebGL.doStaticRelease();
  };
  var Live2DCubismFramework36;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismClippingContext = CubismClippingContext_WebGL;
    Live2DCubismFramework42.CubismClippingManager_WebGL = CubismClippingManager_WebGL;
    Live2DCubismFramework42.CubismRenderTextureResource = CubismRenderTextureResource;
    Live2DCubismFramework42.CubismRenderer_WebGL = CubismRenderer_WebGL;
  })(Live2DCubismFramework36 || (Live2DCubismFramework36 = {}));

  // src/Live2D/dist/model/cubismmodel.js
  var DrawableColorData = class {
    constructor(isOverwritten = false, color = new CubismTextureColor()) {
      __publicField(this, "isOverwritten");
      __publicField(this, "color");
      this.isOverwritten = isOverwritten;
      this.color = color;
    }
  };
  var PartColorData = class {
    constructor(isOverwritten = false, color = new CubismTextureColor()) {
      __publicField(this, "isOverwritten");
      __publicField(this, "color");
      this.isOverwritten = isOverwritten;
      this.color = color;
    }
  };
  var DrawableCullingData = class {
    /**
     * コンストラクタ
     *
     * @param isOverwritten
     * @param isCulling
     */
    constructor(isOverwritten = false, isCulling = false) {
      __publicField(this, "isOverwritten");
      __publicField(this, "isCulling");
      this.isOverwritten = isOverwritten;
      this.isCulling = isCulling;
    }
  };
  var CubismModel = class {
    /**
     * コンストラクタ
     * @param model モデル
     */
    constructor(model) {
      __publicField(this, "_notExistPartOpacities");
      // 存在していないパーツの不透明度のリスト
      __publicField(this, "_notExistPartId");
      // 存在していないパーツIDのリスト
      __publicField(this, "_notExistParameterValues");
      // 存在していないパラメータの値のリスト
      __publicField(this, "_notExistParameterId");
      // 存在していないパラメータIDのリスト
      __publicField(this, "_savedParameters");
      // 保存されたパラメータ
      __publicField(this, "_isOverwrittenModelMultiplyColors");
      // SDK上でモデル全体の乗算色を上書きするか判定するフラグ
      __publicField(this, "_isOverwrittenModelScreenColors");
      // SDK上でモデル全体のスクリーン色を上書きするか判定するフラグ
      __publicField(this, "_userMultiplyColors");
      // Drawableごとに設定する乗算色と上書きフラグを管理するリスト
      __publicField(this, "_userScreenColors");
      // Drawableごとに設定するスクリーン色と上書きフラグを管理するリスト
      __publicField(this, "_userPartScreenColors");
      // Part 乗算色の配列
      __publicField(this, "_userPartMultiplyColors");
      // Part スクリーン色の配列
      __publicField(this, "_partChildDrawables");
      // Partの子DrawableIndexの配列
      __publicField(this, "_model");
      // モデル
      __publicField(this, "_parameterValues");
      // パラメータの値のリスト
      __publicField(this, "_parameterMaximumValues");
      // パラメータの最大値のリスト
      __publicField(this, "_parameterMinimumValues");
      // パラメータの最小値のリスト
      __publicField(this, "_partOpacities");
      // パーツの不透明度のリスト
      __publicField(this, "_modelOpacity");
      // モデルの不透明度
      __publicField(this, "_parameterIds");
      __publicField(this, "_partIds");
      __publicField(this, "_drawableIds");
      __publicField(this, "_isOverwrittenCullings");
      // モデルのカリング設定をすべて上書きするか？
      __publicField(this, "_userCullings");
      this._model = model;
      this._parameterValues = null;
      this._parameterMaximumValues = null;
      this._parameterMinimumValues = null;
      this._partOpacities = null;
      this._savedParameters = new csmVector();
      this._parameterIds = new csmVector();
      this._drawableIds = new csmVector();
      this._partIds = new csmVector();
      this._isOverwrittenModelMultiplyColors = false;
      this._isOverwrittenModelScreenColors = false;
      this._isOverwrittenCullings = false;
      this._modelOpacity = 1;
      this._userMultiplyColors = new csmVector();
      this._userScreenColors = new csmVector();
      this._userCullings = new csmVector();
      this._userPartMultiplyColors = new csmVector();
      this._userPartScreenColors = new csmVector();
      this._partChildDrawables = new csmVector();
      this._notExistPartId = new csmMap();
      this._notExistParameterId = new csmMap();
      this._notExistParameterValues = new csmMap();
      this._notExistPartOpacities = new csmMap();
    }
    /**
     * モデルのパラメータの更新
     */
    update() {
      this._model.update();
      this._model.drawables.resetDynamicFlags();
    }
    /**
     * PixelsPerUnitを取得する
     * @returns PixelsPerUnit
     */
    getPixelsPerUnit() {
      if (this._model == null) {
        return 0;
      }
      return this._model.canvasinfo.PixelsPerUnit;
    }
    /**
     * キャンバスの幅を取得する
     */
    getCanvasWidth() {
      if (this._model == null) {
        return 0;
      }
      return this._model.canvasinfo.CanvasWidth / this._model.canvasinfo.PixelsPerUnit;
    }
    /**
     * キャンバスの高さを取得する
     */
    getCanvasHeight() {
      if (this._model == null) {
        return 0;
      }
      return this._model.canvasinfo.CanvasHeight / this._model.canvasinfo.PixelsPerUnit;
    }
    /**
     * パラメータを保存する
     */
    saveParameters() {
      const parameterCount = this._model.parameters.count;
      const savedParameterCount = this._savedParameters.getSize();
      for (let i = 0; i < parameterCount; ++i) {
        if (i < savedParameterCount) {
          this._savedParameters.set(i, this._parameterValues[i]);
        } else {
          this._savedParameters.pushBack(this._parameterValues[i]);
        }
      }
    }
    /**
     * 乗算色を取得する
     * @param index Drawablesのインデックス
     * @returns 指定したdrawableの乗算色(RGBA)
     */
    getMultiplyColor(index) {
      if (this.getOverwriteFlagForModelMultiplyColors() || this.getOverwriteFlagForDrawableMultiplyColors(index)) {
        return this._userMultiplyColors.at(index).color;
      }
      const color = this.getDrawableMultiplyColor(index);
      return color;
    }
    /**
     * スクリーン色を取得する
     * @param index Drawablesのインデックス
     * @returns 指定したdrawableのスクリーン色(RGBA)
     */
    getScreenColor(index) {
      if (this.getOverwriteFlagForModelScreenColors() || this.getOverwriteFlagForDrawableScreenColors(index)) {
        return this._userScreenColors.at(index).color;
      }
      const color = this.getDrawableScreenColor(index);
      return color;
    }
    /**
     * 乗算色をセットする
     * @param index Drawablesのインデックス
     * @param color 設定する乗算色(CubismTextureColor)
     */
    setMultiplyColorByTextureColor(index, color) {
      this.setMultiplyColorByRGBA(index, color.r, color.g, color.b, color.a);
    }
    /**
     * 乗算色をセットする
     * @param index Drawablesのインデックス
     * @param r 設定する乗算色のR値
     * @param g 設定する乗算色のG値
     * @param b 設定する乗算色のB値
     * @param a 設定する乗算色のA値
     */
    setMultiplyColorByRGBA(index, r, g, b, a = 1) {
      this._userMultiplyColors.at(index).color.r = r;
      this._userMultiplyColors.at(index).color.g = g;
      this._userMultiplyColors.at(index).color.b = b;
      this._userMultiplyColors.at(index).color.a = a;
    }
    /**
     * スクリーン色をセットする
     * @param index Drawablesのインデックス
     * @param color 設定するスクリーン色(CubismTextureColor)
     */
    setScreenColorByTextureColor(index, color) {
      this.setScreenColorByRGBA(index, color.r, color.g, color.b, color.a);
    }
    /**
     * スクリーン色をセットする
     * @param index Drawablesのインデックス
     * @param r 設定するスクリーン色のR値
     * @param g 設定するスクリーン色のG値
     * @param b 設定するスクリーン色のB値
     * @param a 設定するスクリーン色のA値
     */
    setScreenColorByRGBA(index, r, g, b, a = 1) {
      this._userScreenColors.at(index).color.r = r;
      this._userScreenColors.at(index).color.g = g;
      this._userScreenColors.at(index).color.b = b;
      this._userScreenColors.at(index).color.a = a;
    }
    /**
     * partの乗算色を取得する
     * @param partIndex partのインデックス
     * @returns 指定したpartの乗算色
     */
    getPartMultiplyColor(partIndex) {
      return this._userPartMultiplyColors.at(partIndex).color;
    }
    /**
     * partのスクリーン色を取得する
     * @param partIndex partのインデックス
     * @returns 指定したpartのスクリーン色
     */
    getPartScreenColor(partIndex) {
      return this._userPartScreenColors.at(partIndex).color;
    }
    /**
     * partのOverwriteColor setter関数
     * @param partIndex partのインデックス
     * @param r 設定する色のR値
     * @param g 設定する色のG値
     * @param b 設定する色のB値
     * @param a 設定する色のA値
     * @param partColors 設定するpartのカラーデータ配列
     * @param drawableColors partに関連するDrawableのカラーデータ配列
     */
    setPartColor(partIndex, r, g, b, a, partColors, drawableColors) {
      partColors.at(partIndex).color.r = r;
      partColors.at(partIndex).color.g = g;
      partColors.at(partIndex).color.b = b;
      partColors.at(partIndex).color.a = a;
      if (partColors.at(partIndex).isOverwritten) {
        for (let i = 0; i < this._partChildDrawables.at(partIndex).getSize(); ++i) {
          const drawableIndex = this._partChildDrawables.at(partIndex).at(i);
          drawableColors.at(drawableIndex).color.r = r;
          drawableColors.at(drawableIndex).color.g = g;
          drawableColors.at(drawableIndex).color.b = b;
          drawableColors.at(drawableIndex).color.a = a;
        }
      }
    }
    /**
     * 乗算色をセットする
     * @param partIndex partのインデックス
     * @param color 設定する乗算色(CubismTextureColor)
     */
    setPartMultiplyColorByTextureColor(partIndex, color) {
      this.setPartMultiplyColorByRGBA(partIndex, color.r, color.g, color.b, color.a);
    }
    /**
     * 乗算色をセットする
     * @param partIndex partのインデックス
     * @param r 設定する乗算色のR値
     * @param g 設定する乗算色のG値
     * @param b 設定する乗算色のB値
     * @param a 設定する乗算色のA値
     */
    setPartMultiplyColorByRGBA(partIndex, r, g, b, a) {
      this.setPartColor(partIndex, r, g, b, a, this._userPartMultiplyColors, this._userMultiplyColors);
    }
    /**
     * スクリーン色をセットする
     * @param partIndex partのインデックス
     * @param color 設定するスクリーン色(CubismTextureColor)
     */
    setPartScreenColorByTextureColor(partIndex, color) {
      this.setPartScreenColorByRGBA(partIndex, color.r, color.g, color.b, color.a);
    }
    /**
     * スクリーン色をセットする
     * @param partIndex partのインデックス
     * @param r 設定するスクリーン色のR値
     * @param g 設定するスクリーン色のG値
     * @param b 設定するスクリーン色のB値
     * @param a 設定するスクリーン色のA値
     */
    setPartScreenColorByRGBA(partIndex, r, g, b, a) {
      this.setPartColor(partIndex, r, g, b, a, this._userPartScreenColors, this._userScreenColors);
    }
    /**
     * SDKから指定したモデルの乗算色を上書きするか
     * @returns true -> SDKからの情報を優先する
     *          false -> モデルに設定されている色情報を使用
     */
    getOverwriteFlagForModelMultiplyColors() {
      return this._isOverwrittenModelMultiplyColors;
    }
    /**
     * SDKから指定したモデルのスクリーン色を上書きするか
     * @returns true -> SDKからの情報を優先する
     *          false -> モデルに設定されている色情報を使用
     */
    getOverwriteFlagForModelScreenColors() {
      return this._isOverwrittenModelScreenColors;
    }
    /**
     * SDKから指定したモデルの乗算色を上書きするかセットする
     * @param value true -> SDKからの情報を優先する
     *              false -> モデルに設定されている色情報を使用
     */
    setOverwriteFlagForModelMultiplyColors(value) {
      this._isOverwrittenModelMultiplyColors = value;
    }
    /**
     * SDKから指定したモデルのスクリーン色を上書きするかセットする
     * @param value true -> SDKからの情報を優先する
     *              false -> モデルに設定されている色情報を使用
     */
    setOverwriteFlagForModelScreenColors(value) {
      this._isOverwrittenModelScreenColors = value;
    }
    /**
     * SDKから指定したDrawableIndexの乗算色を上書きするか
     * @returns true -> SDKからの情報を優先する
     *          false -> モデルに設定されている色情報を使用
     */
    getOverwriteFlagForDrawableMultiplyColors(drawableindex) {
      return this._userMultiplyColors.at(drawableindex).isOverwritten;
    }
    /**
     * SDKから指定したDrawableIndexのスクリーン色を上書きするか
     * @returns true -> SDKからの情報を優先する
     *          false -> モデルに設定されている色情報を使用
     */
    getOverwriteFlagForDrawableScreenColors(drawableindex) {
      return this._userScreenColors.at(drawableindex).isOverwritten;
    }
    /**
     * SDKから指定したDrawableIndexの乗算色を上書きするかセットする
     * @param value true -> SDKからの情報を優先する
     *              false -> モデルに設定されている色情報を使用
     */
    setOverwriteFlagForDrawableMultiplyColors(drawableindex, value) {
      this._userMultiplyColors.at(drawableindex).isOverwritten = value;
    }
    /**
     * SDKから指定したDrawableIndexのスクリーン色を上書きするかセットする
     * @param value true -> SDKからの情報を優先する
     *              false -> モデルに設定されている色情報を使用
     */
    setOverwriteFlagForDrawableScreenColors(drawableindex, value) {
      this._userScreenColors.at(drawableindex).isOverwritten = value;
    }
    /**
     * SDKからpartの乗算色を上書きするか
     * @param partIndex partのインデックス
     * @returns true    ->  SDKからの情報を優先する
     *          false   ->  モデルに設定されている色情報を使用
     */
    getOverwriteColorForPartMultiplyColors(partIndex) {
      return this._userPartMultiplyColors.at(partIndex).isOverwritten;
    }
    /**
     * SDKからpartのスクリーン色を上書きするか
     * @param partIndex partのインデックス
     * @returns true    ->  SDKからの情報を優先する
     *          false   ->  モデルに設定されている色情報を使用
     */
    getOverwriteColorForPartScreenColors(partIndex) {
      return this._userPartScreenColors.at(partIndex).isOverwritten;
    }
    /**
     * partのOverwriteFlag setter関数
     * @param partIndex partのインデックス
     * @param value true -> SDKからの情報を優先する
     *              false -> モデルに設定されている色情報を使用
     * @param partColors 設定するpartのカラーデータ配列
     * @param drawableColors partに関連するDrawableのカラーデータ配列
     */
    setOverwriteColorForPartColors(partIndex, value, partColors, drawableColors) {
      partColors.at(partIndex).isOverwritten = value;
      for (let i = 0; i < this._partChildDrawables.at(partIndex).getSize(); ++i) {
        const drawableIndex = this._partChildDrawables.at(partIndex).at(i);
        drawableColors.at(drawableIndex).isOverwritten = value;
        if (value) {
          drawableColors.at(drawableIndex).color.r = partColors.at(partIndex).color.r;
          drawableColors.at(drawableIndex).color.g = partColors.at(partIndex).color.g;
          drawableColors.at(drawableIndex).color.b = partColors.at(partIndex).color.b;
          drawableColors.at(drawableIndex).color.a = partColors.at(partIndex).color.a;
        }
      }
    }
    /**
     * SDKからpartのスクリーン色を上書きするかをセットする
     * @param partIndex partのインデックス
     * @param value true -> SDKからの情報を優先する
     *              false -> モデルに設定されている色情報を使用
     */
    setOverwriteColorForPartMultiplyColors(partIndex, value) {
      this._userPartMultiplyColors.at(partIndex).isOverwritten = value;
      this.setOverwriteColorForPartColors(partIndex, value, this._userPartMultiplyColors, this._userMultiplyColors);
    }
    /**
     * SDKからpartのスクリーン色を上書きするかをセットする
     * @param partIndex partのインデックス
     * @param value true -> SDKからの情報を優先する
     *              false -> モデルに設定されている色情報を使用
     */
    setOverwriteColorForPartScreenColors(partIndex, value) {
      this._userPartScreenColors.at(partIndex).isOverwritten = value;
      this.setOverwriteColorForPartColors(partIndex, value, this._userPartScreenColors, this._userScreenColors);
    }
    /**
     * Drawableのカリング情報を取得する。
     *
     * @param   drawableIndex   Drawableのインデックス
     * @return  Drawableのカリング情報
     */
    getDrawableCulling(drawableIndex) {
      if (this.getOverwriteFlagForModelCullings() || this.getOverwriteFlagForDrawableCullings(drawableIndex)) {
        return this._userCullings.at(drawableIndex).isCulling;
      }
      const constantFlags = this._model.drawables.constantFlags;
      return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(constantFlags[drawableIndex]);
    }
    /**
     * Drawableのカリング情報を設定する。
     *
     * @param drawableIndex Drawableのインデックス
     * @param isCulling カリング情報
     */
    setDrawableCulling(drawableIndex, isCulling) {
      this._userCullings.at(drawableIndex).isCulling = isCulling;
    }
    /**
     * SDKからモデル全体のカリング設定を上書きするか。
     *
     * @retval  true    ->  SDK上のカリング設定を使用
     * @retval  false   ->  モデルのカリング設定を使用
     */
    getOverwriteFlagForModelCullings() {
      return this._isOverwrittenCullings;
    }
    /**
     * SDKからモデル全体のカリング設定を上書きするかを設定する。
     *
     * @param isOverwrittenCullings SDK上のカリング設定を使うならtrue、モデルのカリング設定を使うならfalse
     */
    setOverwriteFlagForModelCullings(isOverwrittenCullings) {
      this._isOverwrittenCullings = isOverwrittenCullings;
    }
    /**
     *
     * @param drawableIndex Drawableのインデックス
     * @retval  true    ->  SDK上のカリング設定を使用
     * @retval  false   ->  モデルのカリング設定を使用
     */
    getOverwriteFlagForDrawableCullings(drawableIndex) {
      return this._userCullings.at(drawableIndex).isOverwritten;
    }
    /**
     *
     * @param drawableIndex Drawableのインデックス
     * @param isOverwrittenCullings SDK上のカリング設定を使うならtrue、モデルのカリング設定を使うならfalse
     */
    setOverwriteFlagForDrawableCullings(drawableIndex, isOverwrittenCullings) {
      this._userCullings.at(drawableIndex).isOverwritten = isOverwrittenCullings;
    }
    /**
     * モデルの不透明度を取得する
     *
     * @returns 不透明度の値
     */
    getModelOapcity() {
      return this._modelOpacity;
    }
    /**
     * モデルの不透明度を設定する
     *
     * @param value 不透明度の値
     */
    setModelOapcity(value) {
      this._modelOpacity = value;
    }
    /**
     * モデルを取得
     */
    getModel() {
      return this._model;
    }
    /**
     * パーツのインデックスを取得
     * @param partId パーツのID
     * @return パーツのインデックス
     */
    getPartIndex(partId) {
      let partIndex;
      const partCount = this._model.parts.count;
      for (partIndex = 0; partIndex < partCount; ++partIndex) {
        if (partId == this._partIds.at(partIndex)) {
          return partIndex;
        }
      }
      if (this._notExistPartId.isExist(partId)) {
        return this._notExistPartId.getValue(partId);
      }
      partIndex = partCount + this._notExistPartId.getSize();
      this._notExistPartId.setValue(partId, partIndex);
      this._notExistPartOpacities.appendKey(partIndex);
      return partIndex;
    }
    /**
     * パーツのIDを取得する。
     *
     * @param partIndex 取得するパーツのインデックス
     * @return パーツのID
     */
    getPartId(partIndex) {
      const partId = this._model.parts.ids[partIndex];
      return CubismFramework.getIdManager().getId(partId);
    }
    /**
     * パーツの個数の取得
     * @return パーツの個数
     */
    getPartCount() {
      const partCount = this._model.parts.count;
      return partCount;
    }
    /**
     * パーツの不透明度の設定(Index)
     * @param partIndex パーツのインデックス
     * @param opacity 不透明度
     */
    setPartOpacityByIndex(partIndex, opacity) {
      if (this._notExistPartOpacities.isExist(partIndex)) {
        this._notExistPartOpacities.setValue(partIndex, opacity);
        return;
      }
      CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
      this._partOpacities[partIndex] = opacity;
    }
    /**
     * パーツの不透明度の設定(Id)
     * @param partId パーツのID
     * @param opacity パーツの不透明度
     */
    setPartOpacityById(partId, opacity) {
      const index = this.getPartIndex(partId);
      if (index < 0) {
        return;
      }
      this.setPartOpacityByIndex(index, opacity);
    }
    /**
     * パーツの不透明度の取得(index)
     * @param partIndex パーツのインデックス
     * @return パーツの不透明度
     */
    getPartOpacityByIndex(partIndex) {
      if (this._notExistPartOpacities.isExist(partIndex)) {
        return this._notExistPartOpacities.getValue(partIndex);
      }
      CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());
      return this._partOpacities[partIndex];
    }
    /**
     * パーツの不透明度の取得(id)
     * @param partId パーツのＩｄ
     * @return パーツの不透明度
     */
    getPartOpacityById(partId) {
      const index = this.getPartIndex(partId);
      if (index < 0) {
        return 0;
      }
      return this.getPartOpacityByIndex(index);
    }
    /**
     * パラメータのインデックスの取得
     * @param パラメータID
     * @return パラメータのインデックス
     */
    getParameterIndex(parameterId) {
      let parameterIndex;
      const idCount = this._model.parameters.count;
      for (parameterIndex = 0; parameterIndex < idCount; ++parameterIndex) {
        if (parameterId != this._parameterIds.at(parameterIndex)) {
          continue;
        }
        return parameterIndex;
      }
      if (this._notExistParameterId.isExist(parameterId)) {
        return this._notExistParameterId.getValue(parameterId);
      }
      parameterIndex = this._model.parameters.count + this._notExistParameterId.getSize();
      this._notExistParameterId.setValue(parameterId, parameterIndex);
      this._notExistParameterValues.appendKey(parameterIndex);
      return parameterIndex;
    }
    /**
     * パラメータの個数の取得
     * @return パラメータの個数
     */
    getParameterCount() {
      return this._model.parameters.count;
    }
    /**
     * パラメータの種類の取得
     * @param parameterIndex パラメータのインデックス
     * @return csmParameterType_Normal -> 通常のパラメータ
     *          csmParameterType_BlendShape -> ブレンドシェイプパラメータ
     */
    getParameterType(parameterIndex) {
      return this._model.parameters.types[parameterIndex];
    }
    /**
     * パラメータの最大値の取得
     * @param parameterIndex パラメータのインデックス
     * @return パラメータの最大値
     */
    getParameterMaximumValue(parameterIndex) {
      return this._model.parameters.maximumValues[parameterIndex];
    }
    /**
     * パラメータの最小値の取得
     * @param parameterIndex パラメータのインデックス
     * @return パラメータの最小値
     */
    getParameterMinimumValue(parameterIndex) {
      return this._model.parameters.minimumValues[parameterIndex];
    }
    /**
     * パラメータのデフォルト値の取得
     * @param parameterIndex パラメータのインデックス
     * @return パラメータのデフォルト値
     */
    getParameterDefaultValue(parameterIndex) {
      return this._model.parameters.defaultValues[parameterIndex];
    }
    /**
     * 指定したパラメータindexのIDを取得
     *
     * @param parameterIndex パラメータのインデックス
     * @returns パラメータID
     */
    getParameterId(parameterIndex) {
      return CubismFramework.getIdManager().getId(this._model.parameters.ids[parameterIndex]);
    }
    /**
     * パラメータの値の取得
     * @param parameterIndex    パラメータのインデックス
     * @return パラメータの値
     */
    getParameterValueByIndex(parameterIndex) {
      if (this._notExistParameterValues.isExist(parameterIndex)) {
        return this._notExistParameterValues.getValue(parameterIndex);
      }
      CSM_ASSERT(0 <= parameterIndex && parameterIndex < this.getParameterCount());
      return this._parameterValues[parameterIndex];
    }
    /**
     * パラメータの値の取得
     * @param parameterId    パラメータのID
     * @return パラメータの値
     */
    getParameterValueById(parameterId) {
      const parameterIndex = this.getParameterIndex(parameterId);
      return this.getParameterValueByIndex(parameterIndex);
    }
    /**
     * パラメータの値の設定
     * @param parameterIndex パラメータのインデックス
     * @param value パラメータの値
     * @param weight 重み
     */
    setParameterValueByIndex(parameterIndex, value, weight = 1) {
      if (this._notExistParameterValues.isExist(parameterIndex)) {
        this._notExistParameterValues.setValue(parameterIndex, weight == 1 ? value : this._notExistParameterValues.getValue(parameterIndex) * (1 - weight) + value * weight);
        return;
      }
      CSM_ASSERT(0 <= parameterIndex && parameterIndex < this.getParameterCount());
      if (this._model.parameters.maximumValues[parameterIndex] < value) {
        value = this._model.parameters.maximumValues[parameterIndex];
      }
      if (this._model.parameters.minimumValues[parameterIndex] > value) {
        value = this._model.parameters.minimumValues[parameterIndex];
      }
      this._parameterValues[parameterIndex] = weight == 1 ? value : this._parameterValues[parameterIndex] = this._parameterValues[parameterIndex] * (1 - weight) + value * weight;
    }
    /**
     * パラメータの値の設定
     * @param parameterId パラメータのID
     * @param value パラメータの値
     * @param weight 重み
     */
    setParameterValueById(parameterId, value, weight = 1) {
      const index = this.getParameterIndex(parameterId);
      this.setParameterValueByIndex(index, value, weight);
    }
    /**
     * パラメータの値の加算(index)
     * @param parameterIndex パラメータインデックス
     * @param value 加算する値
     * @param weight 重み
     */
    addParameterValueByIndex(parameterIndex, value, weight = 1) {
      this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) + value * weight);
    }
    /**
     * パラメータの値の加算(id)
     * @param parameterId パラメータＩＤ
     * @param value 加算する値
     * @param weight 重み
     */
    addParameterValueById(parameterId, value, weight = 1) {
      const index = this.getParameterIndex(parameterId);
      this.addParameterValueByIndex(index, value, weight);
    }
    /**
     * パラメータの値の乗算
     * @param parameterId パラメータのID
     * @param value 乗算する値
     * @param weight 重み
     */
    multiplyParameterValueById(parameterId, value, weight = 1) {
      const index = this.getParameterIndex(parameterId);
      this.multiplyParameterValueByIndex(index, value, weight);
    }
    /**
     * パラメータの値の乗算
     * @param parameterIndex パラメータのインデックス
     * @param value 乗算する値
     * @param weight 重み
     */
    multiplyParameterValueByIndex(parameterIndex, value, weight = 1) {
      this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) * (1 + (value - 1) * weight));
    }
    /**
     * Drawableのインデックスの取得
     * @param drawableId DrawableのID
     * @return Drawableのインデックス
     */
    getDrawableIndex(drawableId) {
      const drawableCount = this._model.drawables.count;
      for (let drawableIndex = 0; drawableIndex < drawableCount; ++drawableIndex) {
        if (this._drawableIds.at(drawableIndex) == drawableId) {
          return drawableIndex;
        }
      }
      return -1;
    }
    /**
     * Drawableの個数の取得
     * @return drawableの個数
     */
    getDrawableCount() {
      const drawableCount = this._model.drawables.count;
      return drawableCount;
    }
    /**
     * DrawableのIDを取得する
     * @param drawableIndex Drawableのインデックス
     * @return drawableのID
     */
    getDrawableId(drawableIndex) {
      const parameterIds = this._model.drawables.ids;
      return CubismFramework.getIdManager().getId(parameterIds[drawableIndex]);
    }
    /**
     * Drawableの描画順リストの取得
     * @return Drawableの描画順リスト
     */
    getDrawableRenderOrders() {
      const renderOrders = this._model.drawables.renderOrders;
      return renderOrders;
    }
    /**
     * @deprecated
     * 関数名が誤っていたため、代替となる getDrawableTextureIndex を追加し、この関数は非推奨となりました。
     *
     * Drawableのテクスチャインデックスリストの取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableのテクスチャインデックスリスト
     */
    getDrawableTextureIndices(drawableIndex) {
      return this.getDrawableTextureIndex(drawableIndex);
    }
    /**
     * Drawableのテクスチャインデックスの取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableのテクスチャインデックス
     */
    getDrawableTextureIndex(drawableIndex) {
      const textureIndices = this._model.drawables.textureIndices;
      return textureIndices[drawableIndex];
    }
    /**
     * DrawableのVertexPositionsの変化情報の取得
     *
     * 直近のCubismModel.update関数でDrawableの頂点情報が変化したかを取得する。
     *
     * @param   drawableIndex   Drawableのインデックス
     * @retval  true    Drawableの頂点情報が直近のCubismModel.update関数で変化した
     * @retval  false   Drawableの頂点情報が直近のCubismModel.update関数で変化していない
     */
    getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawableの頂点インデックスの個数の取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableの頂点インデックスの個数
     */
    getDrawableVertexIndexCount(drawableIndex) {
      const indexCounts = this._model.drawables.indexCounts;
      return indexCounts[drawableIndex];
    }
    /**
     * Drawableの頂点の個数の取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableの頂点の個数
     */
    getDrawableVertexCount(drawableIndex) {
      const vertexCounts = this._model.drawables.vertexCounts;
      return vertexCounts[drawableIndex];
    }
    /**
     * Drawableの頂点リストの取得
     * @param drawableIndex drawableのインデックス
     * @return drawableの頂点リスト
     */
    getDrawableVertices(drawableIndex) {
      return this.getDrawableVertexPositions(drawableIndex);
    }
    /**
     * Drawableの頂点インデックスリストの取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableの頂点インデックスリスト
     */
    getDrawableVertexIndices(drawableIndex) {
      const indicesArray = this._model.drawables.indices;
      return indicesArray[drawableIndex];
    }
    /**
     * Drawableの頂点リストの取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableの頂点リスト
     */
    getDrawableVertexPositions(drawableIndex) {
      const verticesArray = this._model.drawables.vertexPositions;
      return verticesArray[drawableIndex];
    }
    /**
     * Drawableの頂点のUVリストの取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableの頂点UVリスト
     */
    getDrawableVertexUvs(drawableIndex) {
      const uvsArray = this._model.drawables.vertexUvs;
      return uvsArray[drawableIndex];
    }
    /**
     * Drawableの不透明度の取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableの不透明度
     */
    getDrawableOpacity(drawableIndex) {
      const opacities = this._model.drawables.opacities;
      return opacities[drawableIndex];
    }
    /**
     * Drawableの乗算色の取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableの乗算色(RGBA)
     * スクリーン色はRGBAで取得されるが、Aは必ず0
     */
    getDrawableMultiplyColor(drawableIndex) {
      const multiplyColors = this._model.drawables.multiplyColors;
      const index = drawableIndex * 4;
      const multiplyColor = new CubismTextureColor();
      multiplyColor.r = multiplyColors[index];
      multiplyColor.g = multiplyColors[index + 1];
      multiplyColor.b = multiplyColors[index + 2];
      multiplyColor.a = multiplyColors[index + 3];
      return multiplyColor;
    }
    /**
     * Drawableのスクリーン色の取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableのスクリーン色(RGBA)
     * スクリーン色はRGBAで取得されるが、Aは必ず0
     */
    getDrawableScreenColor(drawableIndex) {
      const screenColors = this._model.drawables.screenColors;
      const index = drawableIndex * 4;
      const screenColor = new CubismTextureColor();
      screenColor.r = screenColors[index];
      screenColor.g = screenColors[index + 1];
      screenColor.b = screenColors[index + 2];
      screenColor.a = screenColors[index + 3];
      return screenColor;
    }
    /**
     * Drawableの親パーツのインデックスの取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableの親パーツのインデックス
     */
    getDrawableParentPartIndex(drawableIndex) {
      return this._model.drawables.parentPartIndices[drawableIndex];
    }
    /**
     * Drawableのブレンドモードを取得
     * @param drawableIndex Drawableのインデックス
     * @return drawableのブレンドモード
     */
    getDrawableBlendMode(drawableIndex) {
      const constantFlags = this._model.drawables.constantFlags;
      return Live2DCubismCore.Utils.hasBlendAdditiveBit(constantFlags[drawableIndex]) ? CubismBlendMode.CubismBlendMode_Additive : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(constantFlags[drawableIndex]) ? CubismBlendMode.CubismBlendMode_Multiplicative : CubismBlendMode.CubismBlendMode_Normal;
    }
    /**
     * Drawableのマスクの反転使用の取得
     *
     * Drawableのマスク使用時の反転設定を取得する。
     * マスクを使用しない場合は無視される。
     *
     * @param drawableIndex Drawableのインデックス
     * @return Drawableの反転設定
     */
    getDrawableInvertedMaskBit(drawableIndex) {
      const constantFlags = this._model.drawables.constantFlags;
      return Live2DCubismCore.Utils.hasIsInvertedMaskBit(constantFlags[drawableIndex]);
    }
    /**
     * Drawableのクリッピングマスクリストの取得
     * @return Drawableのクリッピングマスクリスト
     */
    getDrawableMasks() {
      const masks = this._model.drawables.masks;
      return masks;
    }
    /**
     * Drawableのクリッピングマスクの個数リストの取得
     * @return Drawableのクリッピングマスクの個数リスト
     */
    getDrawableMaskCounts() {
      const maskCounts = this._model.drawables.maskCounts;
      return maskCounts;
    }
    /**
     * クリッピングマスクの使用状態
     *
     * @return true クリッピングマスクを使用している
     * @return false クリッピングマスクを使用していない
     */
    isUsingMasking() {
      for (let d = 0; d < this._model.drawables.count; ++d) {
        if (this._model.drawables.maskCounts[d] <= 0) {
          continue;
        }
        return true;
      }
      return false;
    }
    /**
     * Drawableの表示情報を取得する
     *
     * @param drawableIndex Drawableのインデックス
     * @return true Drawableが表示
     * @return false Drawableが非表示
     */
    getDrawableDynamicFlagIsVisible(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasIsVisibleBit(dynamicFlags[drawableIndex]);
    }
    /**
     * DrawableのDrawOrderの変化情報の取得
     *
     * 直近のCubismModel.update関数でdrawableのdrawOrderが変化したかを取得する。
     * drawOrderはartMesh上で指定する0から1000の情報
     * @param drawableIndex drawableのインデックス
     * @return true drawableの不透明度が直近のCubismModel.update関数で変化した
     * @return false drawableの不透明度が直近のCubismModel.update関数で変化している
     */
    getDrawableDynamicFlagVisibilityDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawableの不透明度の変化情報の取得
     *
     * 直近のCubismModel.update関数でdrawableの不透明度が変化したかを取得する。
     *
     * @param drawableIndex drawableのインデックス
     * @return true Drawableの不透明度が直近のCubismModel.update関数で変化した
     * @return false Drawableの不透明度が直近のCubismModel.update関数で変化してない
     */
    getDrawableDynamicFlagOpacityDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasOpacityDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawableの描画順序の変化情報の取得
     *
     * 直近のCubismModel.update関数でDrawableの描画の順序が変化したかを取得する。
     *
     * @param drawableIndex Drawableのインデックス
     * @return true Drawableの描画の順序が直近のCubismModel.update関数で変化した
     * @return false Drawableの描画の順序が直近のCubismModel.update関数で変化してない
     */
    getDrawableDynamicFlagRenderOrderDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * Drawableの乗算色・スクリーン色の変化情報の取得
     *
     * 直近のCubismModel.update関数でDrawableの乗算色・スクリーン色が変化したかを取得する。
     *
     * @param drawableIndex Drawableのインデックス
     * @return true Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化した
     * @return false Drawableの乗算色・スクリーン色が直近のCubismModel.update関数で変化してない
     */
    getDrawableDynamicFlagBlendColorDidChange(drawableIndex) {
      const dynamicFlags = this._model.drawables.dynamicFlags;
      return Live2DCubismCore.Utils.hasBlendColorDidChangeBit(dynamicFlags[drawableIndex]);
    }
    /**
     * 保存されたパラメータの読み込み
     */
    loadParameters() {
      let parameterCount = this._model.parameters.count;
      const savedParameterCount = this._savedParameters.getSize();
      if (parameterCount > savedParameterCount) {
        parameterCount = savedParameterCount;
      }
      for (let i = 0; i < parameterCount; ++i) {
        this._parameterValues[i] = this._savedParameters.at(i);
      }
    }
    /**
     * 初期化する
     */
    initialize() {
      CSM_ASSERT(this._model);
      this._parameterValues = this._model.parameters.values;
      this._partOpacities = this._model.parts.opacities;
      this._parameterMaximumValues = this._model.parameters.maximumValues;
      this._parameterMinimumValues = this._model.parameters.minimumValues;
      {
        const parameterIds = this._model.parameters.ids;
        const parameterCount = this._model.parameters.count;
        this._parameterIds.prepareCapacity(parameterCount);
        for (let i = 0; i < parameterCount; ++i) {
          this._parameterIds.pushBack(CubismFramework.getIdManager().getId(parameterIds[i]));
        }
      }
      const partCount = this._model.parts.count;
      {
        const partIds = this._model.parts.ids;
        this._partIds.prepareCapacity(partCount);
        for (let i = 0; i < partCount; ++i) {
          this._partIds.pushBack(CubismFramework.getIdManager().getId(partIds[i]));
        }
        this._userPartMultiplyColors.prepareCapacity(partCount);
        this._userPartScreenColors.prepareCapacity(partCount);
        this._partChildDrawables.prepareCapacity(partCount);
      }
      {
        const drawableIds = this._model.drawables.ids;
        const drawableCount = this._model.drawables.count;
        this._userMultiplyColors.prepareCapacity(drawableCount);
        this._userScreenColors.prepareCapacity(drawableCount);
        this._userCullings.prepareCapacity(drawableCount);
        const userCulling = new DrawableCullingData(false, false);
        {
          for (let i = 0; i < partCount; ++i) {
            const multiplyColor = new CubismTextureColor(1, 1, 1, 1);
            const screenColor = new CubismTextureColor(0, 0, 0, 1);
            const userMultiplyColor = new PartColorData(false, multiplyColor);
            const userScreenColor = new PartColorData(false, screenColor);
            this._userPartMultiplyColors.pushBack(userMultiplyColor);
            this._userPartScreenColors.pushBack(userScreenColor);
            this._partChildDrawables.pushBack(new csmVector());
            this._partChildDrawables.at(i).prepareCapacity(drawableCount);
          }
        }
        {
          for (let i = 0; i < drawableCount; ++i) {
            const multiplyColor = new CubismTextureColor(1, 1, 1, 1);
            const screenColor = new CubismTextureColor(0, 0, 0, 1);
            const userMultiplyColor = new DrawableColorData(false, multiplyColor);
            const userScreenColor = new DrawableColorData(false, screenColor);
            this._drawableIds.pushBack(CubismFramework.getIdManager().getId(drawableIds[i]));
            this._userMultiplyColors.pushBack(userMultiplyColor);
            this._userScreenColors.pushBack(userScreenColor);
            this._userCullings.pushBack(userCulling);
            const parentIndex = this.getDrawableParentPartIndex(i);
            if (parentIndex >= 0) {
              this._partChildDrawables.at(parentIndex).pushBack(i);
            }
          }
        }
      }
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      this._model.release();
      this._model = null;
    }
    // カリング設定の配列
  };
  var Live2DCubismFramework37;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModel = CubismModel;
  })(Live2DCubismFramework37 || (Live2DCubismFramework37 = {}));

  // src/Live2D/dist/model/cubismmoc.js
  var CubismMoc = class _CubismMoc {
    /**
     * コンストラクタ
     */
    constructor(moc) {
      __publicField(this, "_moc");
      // Mocデータ
      __publicField(this, "_modelCount");
      // Mocデータから作られたモデルの個数
      __publicField(this, "_mocVersion");
      this._moc = moc;
      this._modelCount = 0;
      this._mocVersion = 0;
    }
    /**
     * Mocデータの作成
     */
    static create(mocBytes, shouldCheckMocConsistency) {
      let cubismMoc = null;
      if (shouldCheckMocConsistency) {
        const consistency = this.hasMocConsistency(mocBytes);
        if (!consistency) {
          CubismLogError(`Inconsistent MOC3.`);
          return cubismMoc;
        }
      }
      const moc = Live2DCubismCore.Moc.fromArrayBuffer(mocBytes);
      if (moc) {
        cubismMoc = new _CubismMoc(moc);
        cubismMoc._mocVersion = Live2DCubismCore.Version.csmGetMocVersion(moc, mocBytes);
      }
      return cubismMoc;
    }
    /**
     * Mocデータを削除
     *
     * Mocデータを削除する
     */
    static delete(moc) {
      moc._moc._release();
      moc._moc = null;
      moc = null;
    }
    /**
     * モデルを作成する
     *
     * @return Mocデータから作成されたモデル
     */
    createModel() {
      let cubismModel = null;
      const model = Live2DCubismCore.Model.fromMoc(this._moc);
      if (model) {
        cubismModel = new CubismModel(model);
        cubismModel.initialize();
        ++this._modelCount;
      }
      return cubismModel;
    }
    /**
     * モデルを削除する
     */
    deleteModel(model) {
      if (model != null) {
        model.release();
        model = null;
        --this._modelCount;
      }
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      CSM_ASSERT(this._modelCount == 0);
      this._moc._release();
      this._moc = null;
    }
    /**
     * 最新の.moc3 Versionを取得
     */
    getLatestMocVersion() {
      return Live2DCubismCore.Version.csmGetLatestMocVersion();
    }
    /**
     * 読み込んだモデルの.moc3 Versionを取得
     */
    getMocVersion() {
      return this._mocVersion;
    }
    /**
     * .moc3 の整合性を検証する
     */
    static hasMocConsistency(mocBytes) {
      const isConsistent = Live2DCubismCore.Moc.prototype.hasMocConsistency(mocBytes);
      return isConsistent === 1 ? true : false;
    }
    // 読み込んだモデルの.moc3 Version
  };
  var Live2DCubismFramework38;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismMoc = CubismMoc;
  })(Live2DCubismFramework38 || (Live2DCubismFramework38 = {}));

  // src/Live2D/dist/model/cubismmodeluserdatajson.js
  var Meta3 = "Meta";
  var UserDataCount2 = "UserDataCount";
  var TotalUserDataSize2 = "TotalUserDataSize";
  var UserData3 = "UserData";
  var Target2 = "Target";
  var Id5 = "Id";
  var Value3 = "Value";
  var CubismModelUserDataJson = class {
    /**
     * コンストラクタ
     * @param buffer    userdata3.jsonが読み込まれているバッファ
     * @param size      バッファのサイズ
     */
    constructor(buffer, size) {
      __publicField(this, "_json");
      this._json = CubismJson.create(buffer, size);
    }
    /**
     * デストラクタ相当の処理
     */
    release() {
      CubismJson.delete(this._json);
    }
    /**
     * ユーザーデータ個数の取得
     * @return ユーザーデータの個数
     */
    getUserDataCount() {
      return this._json.getRoot().getValueByString(Meta3).getValueByString(UserDataCount2).toInt();
    }
    /**
     * ユーザーデータ総文字列数の取得
     *
     * @return ユーザーデータ総文字列数
     */
    getTotalUserDataSize() {
      return this._json.getRoot().getValueByString(Meta3).getValueByString(TotalUserDataSize2).toInt();
    }
    /**
     * ユーザーデータのタイプの取得
     *
     * @return ユーザーデータのタイプ
     */
    getUserDataTargetType(i) {
      return this._json.getRoot().getValueByString(UserData3).getValueByIndex(i).getValueByString(Target2).getRawString();
    }
    /**
     * ユーザーデータのターゲットIDの取得
     *
     * @param i インデックス
     * @return ユーザーデータターゲットID
     */
    getUserDataId(i) {
      return CubismFramework.getIdManager().getId(this._json.getRoot().getValueByString(UserData3).getValueByIndex(i).getValueByString(Id5).getRawString());
    }
    /**
     * ユーザーデータの文字列の取得
     *
     * @param i インデックス
     * @return ユーザーデータ
     */
    getUserDataValue(i) {
      return this._json.getRoot().getValueByString(UserData3).getValueByIndex(i).getValueByString(Value3).getRawString();
    }
  };
  var Live2DCubismFramework39;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModelUserDataJson = CubismModelUserDataJson;
  })(Live2DCubismFramework39 || (Live2DCubismFramework39 = {}));

  // src/Live2D/dist/model/cubismmodeluserdata.js
  var ArtMesh = "ArtMesh";
  var CubismModelUserDataNode = class {
    constructor() {
      __publicField(this, "targetType");
      // ユーザーデータターゲットタイプ
      __publicField(this, "targetId");
      // ユーザーデータターゲットのID
      __publicField(this, "value");
    }
    // ユーザーデータ
  };
  var CubismModelUserData = class _CubismModelUserData {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_userDataNodes");
      // ユーザーデータ構造体配列
      __publicField(this, "_artMeshUserDataNode");
      this._userDataNodes = new csmVector();
      this._artMeshUserDataNode = new csmVector();
    }
    /**
     * インスタンスの作成
     *
     * @param buffer    userdata3.jsonが読み込まれているバッファ
     * @param size      バッファのサイズ
     * @return 作成されたインスタンス
     */
    static create(buffer, size) {
      const ret = new _CubismModelUserData();
      ret.parseUserData(buffer, size);
      return ret;
    }
    /**
     * インスタンスを破棄する
     *
     * @param modelUserData 破棄するインスタンス
     */
    static delete(modelUserData) {
      if (modelUserData != null) {
        modelUserData.release();
        modelUserData = null;
      }
    }
    /**
     * ArtMeshのユーザーデータのリストの取得
     *
     * @return ユーザーデータリスト
     */
    getArtMeshUserDatas() {
      return this._artMeshUserDataNode;
    }
    /**
     * userdata3.jsonのパース
     *
     * @param buffer    userdata3.jsonが読み込まれているバッファ
     * @param size      バッファのサイズ
     */
    parseUserData(buffer, size) {
      let json = new CubismModelUserDataJson(buffer, size);
      if (!json) {
        json.release();
        json = void 0;
        return;
      }
      const typeOfArtMesh = CubismFramework.getIdManager().getId(ArtMesh);
      const nodeCount = json.getUserDataCount();
      for (let i = 0; i < nodeCount; i++) {
        const addNode = new CubismModelUserDataNode();
        addNode.targetId = json.getUserDataId(i);
        addNode.targetType = CubismFramework.getIdManager().getId(json.getUserDataTargetType(i));
        addNode.value = new csmString(json.getUserDataValue(i));
        this._userDataNodes.pushBack(addNode);
        if (addNode.targetType == typeOfArtMesh) {
          this._artMeshUserDataNode.pushBack(addNode);
        }
      }
      json.release();
      json = void 0;
    }
    /**
     * デストラクタ相当の処理
     *
     * ユーザーデータ構造体配列を解放する
     */
    release() {
      for (let i = 0; i < this._userDataNodes.getSize(); ++i) {
        this._userDataNodes.set(i, null);
      }
      this._userDataNodes = null;
    }
    // 閲覧リストの保持
  };
  var Live2DCubismFramework40;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismModelUserData = CubismModelUserData;
    Live2DCubismFramework42.CubismModelUserDataNode = CubismModelUserDataNode;
  })(Live2DCubismFramework40 || (Live2DCubismFramework40 = {}));

  // src/Live2D/dist/model/cubismusermodel.js
  var CubismUserModel = class _CubismUserModel {
    /**
     * コンストラクタ
     */
    constructor() {
      __publicField(this, "_moc");
      // Mocデータ
      __publicField(this, "_model");
      // Modelインスタンス
      __publicField(this, "_motionManager");
      // モーション管理
      __publicField(this, "_expressionManager");
      // 表情管理
      __publicField(this, "_eyeBlink");
      // 自動まばたき
      __publicField(this, "_breath");
      // 呼吸
      __publicField(this, "_modelMatrix");
      // モデル行列
      __publicField(this, "_pose");
      // ポーズ管理
      __publicField(this, "_dragManager");
      // マウスドラッグ
      __publicField(this, "_physics");
      // 物理演算
      __publicField(this, "_modelUserData");
      // ユーザーデータ
      __publicField(this, "_initialized");
      // 初期化されたかどうか
      __publicField(this, "_updating");
      // 更新されたかどうか
      __publicField(this, "_opacity");
      // 不透明度
      __publicField(this, "_lipsync");
      // リップシンクするかどうか
      __publicField(this, "_lastLipSyncValue");
      // 最後のリップシンクの制御地
      __publicField(this, "_dragX");
      // マウスドラッグのX位置
      __publicField(this, "_dragY");
      // マウスドラッグのY位置
      __publicField(this, "_accelerationX");
      // X軸方向の加速度
      __publicField(this, "_accelerationY");
      // Y軸方向の加速度
      __publicField(this, "_accelerationZ");
      // Z軸方向の加速度
      __publicField(this, "_mocConsistency");
      // MOC3一貫性検証するかどうか
      __publicField(this, "_debugMode");
      // デバッグモードかどうか
      __publicField(this, "_renderer");
      this._moc = null;
      this._model = null;
      this._motionManager = null;
      this._expressionManager = null;
      this._eyeBlink = null;
      this._breath = null;
      this._modelMatrix = null;
      this._pose = null;
      this._dragManager = null;
      this._physics = null;
      this._modelUserData = null;
      this._initialized = false;
      this._updating = false;
      this._opacity = 1;
      this._lipsync = true;
      this._lastLipSyncValue = 0;
      this._dragX = 0;
      this._dragY = 0;
      this._accelerationX = 0;
      this._accelerationY = 0;
      this._accelerationZ = 0;
      this._mocConsistency = false;
      this._debugMode = false;
      this._renderer = null;
      this._motionManager = new CubismMotionManager();
      this._motionManager.setEventCallback(_CubismUserModel.cubismDefaultMotionEventCallback, this);
      this._expressionManager = new CubismExpressionMotionManager();
      this._dragManager = new CubismTargetPoint();
    }
    /**
     * 初期化状態の取得
     *
     * 初期化されている状態か？
     *
     * @return true     初期化されている
     * @return false    初期化されていない
     */
    isInitialized() {
      return this._initialized;
    }
    /**
     * 初期化状態の設定
     *
     * 初期化状態を設定する。
     *
     * @param v 初期化状態
     */
    setInitialized(v) {
      this._initialized = v;
    }
    /**
     * 更新状態の取得
     *
     * 更新されている状態か？
     *
     * @return true     更新されている
     * @return false    更新されていない
     */
    isUpdating() {
      return this._updating;
    }
    /**
     * 更新状態の設定
     *
     * 更新状態を設定する
     *
     * @param v 更新状態
     */
    setUpdating(v) {
      this._updating = v;
    }
    /**
     * マウスドラッグ情報の設定
     * @param ドラッグしているカーソルのX位置
     * @param ドラッグしているカーソルのY位置
     */
    setDragging(x, y) {
      this._dragManager.set(x, y);
    }
    /**
     * 加速度の情報を設定する
     * @param x X軸方向の加速度
     * @param y Y軸方向の加速度
     * @param z Z軸方向の加速度
     */
    setAcceleration(x, y, z) {
      this._accelerationX = x;
      this._accelerationY = y;
      this._accelerationZ = z;
    }
    /**
     * モデル行列を取得する
     * @return モデル行列
     */
    getModelMatrix() {
      return this._modelMatrix;
    }
    /**
     * 不透明度の設定
     * @param a 不透明度
     */
    setOpacity(a) {
      this._opacity = a;
    }
    /**
     * 不透明度の取得
     * @return 不透明度
     */
    getOpacity() {
      return this._opacity;
    }
    /**
     * モデルデータを読み込む
     *
     * @param buffer    moc3ファイルが読み込まれているバッファ
     */
    loadModel(buffer, shouldCheckMocConsistency = false) {
      this._moc = CubismMoc.create(buffer, shouldCheckMocConsistency);
      if (this._moc == null) {
        CubismLogError("Failed to CubismMoc.create().");
        return;
      }
      this._model = this._moc.createModel();
      if (this._model == null) {
        CubismLogError("Failed to CreateModel().");
        return;
      }
      this._model.saveParameters();
      this._modelMatrix = new CubismModelMatrix(this._model.getCanvasWidth(), this._model.getCanvasHeight());
    }
    /**
     * モーションデータを読み込む
     * @param buffer motion3.jsonファイルが読み込まれているバッファ
     * @param size バッファのサイズ
     * @param name モーションの名前
     * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数
     * @return モーションクラス
     */
    loadMotion(buffer, size, name, onFinishedMotionHandler) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadMotion().");
        return null;
      }
      return CubismMotion.create(buffer, size, onFinishedMotionHandler);
    }
    /**
     * 表情データの読み込み
     * @param buffer expファイルが読み込まれているバッファ
     * @param size バッファのサイズ
     * @param name 表情の名前
     */
    loadExpression(buffer, size, name) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadExpression().");
        return null;
      }
      return CubismExpressionMotion.create(buffer, size);
    }
    /**
     * ポーズデータの読み込み
     * @param buffer pose3.jsonが読み込まれているバッファ
     * @param size バッファのサイズ
     */
    loadPose(buffer, size) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadPose().");
        return;
      }
      this._pose = CubismPose.create(buffer, size);
    }
    /**
     * モデルに付属するユーザーデータを読み込む
     * @param buffer userdata3.jsonが読み込まれているバッファ
     * @param size バッファのサイズ
     */
    loadUserData(buffer, size) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadUserData().");
        return;
      }
      this._modelUserData = CubismModelUserData.create(buffer, size);
    }
    /**
     * 物理演算データの読み込み
     * @param buffer  physics3.jsonが読み込まれているバッファ
     * @param size    バッファのサイズ
     */
    loadPhysics(buffer, size) {
      if (buffer == null || size == 0) {
        CubismLogError("Failed to loadPhysics().");
        return;
      }
      this._physics = CubismPhysics.create(buffer, size);
    }
    /**
     * 当たり判定の取得
     * @param drawableId 検証したいDrawableのID
     * @param pointX X位置
     * @param pointY Y位置
     * @return true ヒットしている
     * @return false ヒットしていない
     */
    isHit(drawableId, pointX, pointY) {
      const drawIndex = this._model.getDrawableIndex(drawableId);
      if (drawIndex < 0) {
        return false;
      }
      const count = this._model.getDrawableVertexCount(drawIndex);
      const vertices = this._model.getDrawableVertices(drawIndex);
      let left = vertices[0];
      let right = vertices[0];
      let top = vertices[1];
      let bottom = vertices[1];
      for (let j = 1; j < count; ++j) {
        const x = vertices[Constant.vertexOffset + j * Constant.vertexStep];
        const y = vertices[Constant.vertexOffset + j * Constant.vertexStep + 1];
        if (x < left) {
          left = x;
        }
        if (x > right) {
          right = x;
        }
        if (y < top) {
          top = y;
        }
        if (y > bottom) {
          bottom = y;
        }
      }
      const tx = this._modelMatrix.invertTransformX(pointX);
      const ty = this._modelMatrix.invertTransformY(pointY);
      return left <= tx && tx <= right && top <= ty && ty <= bottom;
    }
    /**
     * モデルの取得
     * @return モデル
     */
    getModel() {
      return this._model;
    }
    /**
     * レンダラの取得
     * @return レンダラ
     */
    getRenderer() {
      return this._renderer;
    }
    /**
     * レンダラを作成して初期化を実行する
     * @param maskBufferCount バッファの生成数
     */
    createRenderer(maskBufferCount = 1) {
      if (this._renderer) {
        this.deleteRenderer();
      }
      this._renderer = new CubismRenderer_WebGL();
      this._renderer.initialize(this._model, maskBufferCount);
    }
    /**
     * レンダラの解放
     */
    deleteRenderer() {
      if (this._renderer != null) {
        this._renderer.release();
        this._renderer = null;
      }
    }
    /**
     * イベント発火時の標準処理
     *
     * Eventが再生処理時にあった場合の処理をする。
     * 継承で上書きすることを想定している。
     * 上書きしない場合はログ出力をする。
     *
     * @param eventValue 発火したイベントの文字列データ
     */
    motionEventFired(eventValue) {
      CubismLogInfo("{0}", eventValue.s);
    }
    /**
     * イベント用のコールバック
     *
     * CubismMotionQueueManagerにイベント用に登録するためのCallback。
     * CubismUserModelの継承先のEventFiredを呼ぶ。
     *
     * @param caller 発火したイベントを管理していたモーションマネージャー、比較用
     * @param eventValue 発火したイベントの文字列データ
     * @param customData CubismUserModelを継承したインスタンスを想定
     */
    static cubismDefaultMotionEventCallback(caller, eventValue, customData) {
      const model = customData;
      if (model != null) {
        model.motionEventFired(eventValue);
      }
    }
    /**
     * デストラクタに相当する処理
     */
    release() {
      if (this._motionManager != null) {
        this._motionManager.release();
        this._motionManager = null;
      }
      if (this._expressionManager != null) {
        this._expressionManager.release();
        this._expressionManager = null;
      }
      if (this._moc != null) {
        this._moc.deleteModel(this._model);
        this._moc.release();
        this._moc = null;
      }
      this._modelMatrix = null;
      CubismPose.delete(this._pose);
      CubismEyeBlink.delete(this._eyeBlink);
      CubismBreath.delete(this._breath);
      this._dragManager = null;
      CubismPhysics.delete(this._physics);
      CubismModelUserData.delete(this._modelUserData);
      this.deleteRenderer();
    }
    // レンダラ
  };
  var Live2DCubismFramework41;
  (function(Live2DCubismFramework42) {
    Live2DCubismFramework42.CubismUserModel = CubismUserModel;
  })(Live2DCubismFramework41 || (Live2DCubismFramework41 = {}));

  // src/Live2D/lapppal.js
  var LAppPal = class {
    /**
     * ファイルをバイトデータとして読みこむ
     *
     * @param filePath 読み込み対象ファイルのパス
     * @return
     * {
     *      buffer,   読み込んだバイトデータ
     *      size        ファイルサイズ
     * }
     */
    static loadFileAsBytes(filePath, callback) {
      fetch(filePath).then((response) => response.arrayBuffer()).then((arrayBuffer) => callback(arrayBuffer, arrayBuffer.byteLength));
    }
    /**
     * デルタ時間（前回フレームとの差分）を取得する
     * @return デルタ時間[ms]
     */
    static getDeltaTime() {
      return this.s_deltaTime;
    }
    static updateTime() {
      this.s_currentFrame = Date.now();
      this.s_deltaTime = (this.s_currentFrame - this.s_lastFrame) / 1e3;
      this.s_lastFrame = this.s_currentFrame;
    }
    /**
     * メッセージを出力する
     * @param message 文字列
     */
    static printMessage(message) {
      console.log(message);
    }
  };
  LAppPal.lastUpdate = Date.now();
  LAppPal.s_currentFrame = 0;
  LAppPal.s_lastFrame = 0;
  LAppPal.s_deltaTime = 0;

  // src/Live2D/lappwavfilehandler.js
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var s_instance3 = null;
  var LAppWavFileHandler = class _LAppWavFileHandler {
    /**
     * クラスのインスタンス（シングルトン）を返す。
     * インスタンスが生成されていない場合は内部でインスタンスを生成する。
     *
     * @return クラスのインスタンス
     * @deprecated このクラスでのシングルトンパターンの使用は非推奨となりました。代わりに new LAppWavFileHandler() を使用してください。
     */
    static getInstance() {
      if (s_instance3 == null) {
        s_instance3 = new _LAppWavFileHandler();
      }
      return s_instance3;
    }
    /**
     * クラスのインスタンス（シングルトン）を解放する。
     *
     * @deprecated この関数は getInstance() が非推奨になったことに伴い、非推奨となりました。
     */
    static releaseInstance() {
      if (s_instance3 != null) {
        s_instance3 = void 0;
      }
      s_instance3 = null;
    }
    update(deltaTimeSeconds) {
      let goalOffset;
      let rms;
      if (this._pcmData == null || this._sampleOffset >= this._wavFileInfo._samplesPerChannel) {
        this._lastRms = 0;
        return false;
      }
      this._userTimeSeconds += deltaTimeSeconds;
      goalOffset = Math.floor(this._userTimeSeconds * this._wavFileInfo._samplingRate);
      if (goalOffset > this._wavFileInfo._samplesPerChannel) {
        goalOffset = this._wavFileInfo._samplesPerChannel;
      }
      rms = 0;
      for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
        for (let sampleCount = this._sampleOffset; sampleCount < goalOffset; sampleCount++) {
          const pcm = this._pcmData[channelCount][sampleCount];
          rms += pcm * pcm;
        }
      }
      rms = Math.sqrt(rms / (this._wavFileInfo._numberOfChannels * (goalOffset - this._sampleOffset)));
      this._lastRms = rms;
      this._sampleOffset = goalOffset;
      return true;
    }
    start(filePath) {
      this._sampleOffset = 0;
      this._userTimeSeconds = 0;
      this._lastRms = 0;
      this.loadWavFile(filePath);
    }
    getRms() {
      return this._lastRms;
    }
    loadWavFile(filePath) {
      return new Promise((resolveValue) => {
        let ret = false;
        if (this._pcmData != null) {
          this.releasePcmData();
        }
        const asyncFileLoad = () => __awaiter(this, void 0, void 0, function* () {
          return fetch(filePath).then((responce) => {
            return responce.arrayBuffer();
          });
        });
        const asyncWavFileManager = (() => __awaiter(this, void 0, void 0, function* () {
          this._byteReader._fileByte = yield asyncFileLoad();
          this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);
          this._byteReader._fileSize = this._byteReader._fileByte.byteLength;
          this._byteReader._readOffset = 0;
          if (this._byteReader._fileByte == null || this._byteReader._fileSize < 4) {
            resolveValue(false);
            return;
          }
          this._wavFileInfo._fileName = filePath;
          try {
            if (!this._byteReader.getCheckSignature("RIFF")) {
              ret = false;
              throw new Error('Cannot find Signeture "RIFF".');
            }
            this._byteReader.get32LittleEndian();
            if (!this._byteReader.getCheckSignature("WAVE")) {
              ret = false;
              throw new Error('Cannot find Signeture "WAVE".');
            }
            if (!this._byteReader.getCheckSignature("fmt ")) {
              ret = false;
              throw new Error('Cannot find Signeture "fmt".');
            }
            const fmtChunkSize = this._byteReader.get32LittleEndian();
            if (this._byteReader.get16LittleEndian() != 1) {
              ret = false;
              throw new Error("File is not linear PCM.");
            }
            this._wavFileInfo._numberOfChannels = this._byteReader.get16LittleEndian();
            this._wavFileInfo._samplingRate = this._byteReader.get32LittleEndian();
            this._byteReader.get32LittleEndian();
            this._byteReader.get16LittleEndian();
            this._wavFileInfo._bitsPerSample = this._byteReader.get16LittleEndian();
            if (fmtChunkSize > 16) {
              this._byteReader._readOffset += fmtChunkSize - 16;
            }
            while (!this._byteReader.getCheckSignature("data") && this._byteReader._readOffset < this._byteReader._fileSize) {
              this._byteReader._readOffset += this._byteReader.get32LittleEndian() + 4;
            }
            if (this._byteReader._readOffset >= this._byteReader._fileSize) {
              ret = false;
              throw new Error('Cannot find "data" Chunk.');
            }
            {
              const dataChunkSize = this._byteReader.get32LittleEndian();
              this._wavFileInfo._samplesPerChannel = dataChunkSize * 8 / (this._wavFileInfo._bitsPerSample * this._wavFileInfo._numberOfChannels);
            }
            this._pcmData = new Array(this._wavFileInfo._numberOfChannels);
            for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
              this._pcmData[channelCount] = new Float32Array(this._wavFileInfo._samplesPerChannel);
            }
            for (let sampleCount = 0; sampleCount < this._wavFileInfo._samplesPerChannel; sampleCount++) {
              for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
                this._pcmData[channelCount][sampleCount] = this.getPcmSample();
              }
            }
            ret = true;
            resolveValue(ret);
          } catch (e) {
            console.log(e);
          }
        }))().then(() => {
          resolveValue(ret);
        });
      });
    }
    getPcmSample() {
      let pcm32;
      switch (this._wavFileInfo._bitsPerSample) {
        case 8:
          pcm32 = this._byteReader.get8() - 128;
          pcm32 <<= 24;
          break;
        case 16:
          pcm32 = this._byteReader.get16LittleEndian() << 16;
          break;
        case 24:
          pcm32 = this._byteReader.get24LittleEndian() << 8;
          break;
        default:
          pcm32 = 0;
          break;
      }
      return pcm32 / 2147483647;
    }
    /**
     * 指定したチャンネルから音声サンプルの配列を取得する
     *
     * @param usechannel 利用するチャンネル
     * @returns 指定したチャンネルの音声サンプルの配列
     */
    getPcmDataChannel(usechannel) {
      if (!this._pcmData || !(usechannel < this._pcmData.length)) {
        return null;
      }
      return Float32Array.from(this._pcmData[usechannel]);
    }
    /**
     * 音声のサンプリング周波数を取得する。
     *
     * @returns 音声のサンプリング周波数
     */
    getWavSamplingRate() {
      if (!this._wavFileInfo || this._wavFileInfo._samplingRate < 1) {
        return null;
      }
      return this._wavFileInfo._samplingRate;
    }
    releasePcmData() {
      for (let channelCount = 0; channelCount < this._wavFileInfo._numberOfChannels; channelCount++) {
        delete this._pcmData[channelCount];
      }
      delete this._pcmData;
      this._pcmData = null;
    }
    constructor() {
      this._loadFiletoBytes = (arrayBuffer, length) => {
        this._byteReader._fileByte = arrayBuffer;
        this._byteReader._fileDataView = new DataView(this._byteReader._fileByte);
        this._byteReader._fileSize = length;
      };
      this._pcmData = null;
      this._userTimeSeconds = 0;
      this._lastRms = 0;
      this._sampleOffset = 0;
      this._wavFileInfo = new WavFileInfo();
      this._byteReader = new ByteReader();
    }
  };
  var WavFileInfo = class {
    constructor() {
      this._fileName = "";
      this._numberOfChannels = 0;
      this._bitsPerSample = 0;
      this._samplingRate = 0;
      this._samplesPerChannel = 0;
    }
  };
  var ByteReader = class {
    constructor() {
      this._fileByte = null;
      this._fileDataView = null;
      this._fileSize = 0;
      this._readOffset = 0;
    }
    /**
     * @brief 8ビット読み込み
     * @return Csm::csmUint8 読み取った8ビット値
     */
    get8() {
      const ret = this._fileDataView.getUint8(this._readOffset);
      this._readOffset++;
      return ret;
    }
    /**
     * @brief 16ビット読み込み（リトルエンディアン）
     * @return Csm::csmUint16 読み取った16ビット値
     */
    get16LittleEndian() {
      const ret = this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
      this._readOffset += 2;
      return ret;
    }
    /**
     * @brief 24ビット読み込み（リトルエンディアン）
     * @return Csm::csmUint32 読み取った24ビット値（下位24ビットに設定）
     */
    get24LittleEndian() {
      const ret = this._fileDataView.getUint8(this._readOffset + 2) << 16 | this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
      this._readOffset += 3;
      return ret;
    }
    /**
     * @brief 32ビット読み込み（リトルエンディアン）
     * @return Csm::csmUint32 読み取った32ビット値
     */
    get32LittleEndian() {
      const ret = this._fileDataView.getUint8(this._readOffset + 3) << 24 | this._fileDataView.getUint8(this._readOffset + 2) << 16 | this._fileDataView.getUint8(this._readOffset + 1) << 8 | this._fileDataView.getUint8(this._readOffset);
      this._readOffset += 4;
      return ret;
    }
    /**
     * @brief シグネチャの取得と参照文字列との一致チェック
     * @param[in] reference 検査対象のシグネチャ文字列
     * @retval  true    一致している
     * @retval  false   一致していない
     */
    getCheckSignature(reference) {
      const getSignature = new Uint8Array(4);
      const referenceString = new TextEncoder().encode(reference);
      if (reference.length != 4) {
        return false;
      }
      for (let signatureOffset = 0; signatureOffset < 4; signatureOffset++) {
        getSignature[signatureOffset] = this.get8();
      }
      return getSignature[0] == referenceString[0] && getSignature[1] == referenceString[1] && getSignature[2] == referenceString[2] && getSignature[3] == referenceString[3];
    }
  };

  // src/Live2D/lappmodel.js
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var LoadStep;
  (function(LoadStep2) {
    LoadStep2[LoadStep2["LoadAssets"] = 0] = "LoadAssets";
    LoadStep2[LoadStep2["LoadModel"] = 1] = "LoadModel";
    LoadStep2[LoadStep2["WaitLoadModel"] = 2] = "WaitLoadModel";
    LoadStep2[LoadStep2["LoadExpression"] = 3] = "LoadExpression";
    LoadStep2[LoadStep2["WaitLoadExpression"] = 4] = "WaitLoadExpression";
    LoadStep2[LoadStep2["LoadPhysics"] = 5] = "LoadPhysics";
    LoadStep2[LoadStep2["WaitLoadPhysics"] = 6] = "WaitLoadPhysics";
    LoadStep2[LoadStep2["LoadPose"] = 7] = "LoadPose";
    LoadStep2[LoadStep2["WaitLoadPose"] = 8] = "WaitLoadPose";
    LoadStep2[LoadStep2["SetupEyeBlink"] = 9] = "SetupEyeBlink";
    LoadStep2[LoadStep2["SetupBreath"] = 10] = "SetupBreath";
    LoadStep2[LoadStep2["LoadUserData"] = 11] = "LoadUserData";
    LoadStep2[LoadStep2["WaitLoadUserData"] = 12] = "WaitLoadUserData";
    LoadStep2[LoadStep2["SetupEyeBlinkIds"] = 13] = "SetupEyeBlinkIds";
    LoadStep2[LoadStep2["SetupLipSyncIds"] = 14] = "SetupLipSyncIds";
    LoadStep2[LoadStep2["SetupLayout"] = 15] = "SetupLayout";
    LoadStep2[LoadStep2["LoadMotion"] = 16] = "LoadMotion";
    LoadStep2[LoadStep2["WaitLoadMotion"] = 17] = "WaitLoadMotion";
    LoadStep2[LoadStep2["CompleteInitialize"] = 18] = "CompleteInitialize";
    LoadStep2[LoadStep2["CompleteSetupModel"] = 19] = "CompleteSetupModel";
    LoadStep2[LoadStep2["LoadTexture"] = 20] = "LoadTexture";
    LoadStep2[LoadStep2["WaitLoadTexture"] = 21] = "WaitLoadTexture";
    LoadStep2[LoadStep2["CompleteSetup"] = 22] = "CompleteSetup";
  })(LoadStep || (LoadStep = {}));
  var LAppModel = class extends CubismUserModel {
    /**
     * model3.jsonが置かれたディレクトリとファイルパスからモデルを生成する
     * @param dir
     * @param fileName
     */
    loadAssets(dir, fileName, callback = null) {
      this._modelHomeDir = dir;
      fetch(`${this._modelHomeDir}${fileName}`).then((response) => response.arrayBuffer()).then((arrayBuffer) => {
        const setting = new CubismModelSettingJson(arrayBuffer, arrayBuffer.byteLength);
        this._state = LoadStep.LoadModel;
        this.setupModel(setting);
        if (callback) {
          callback();
        }
      }).catch((error) => {
        CubismLogError(`Failed to load file ${this._modelHomeDir}${fileName}`);
      });
    }
    /**
     * model3.jsonからモデルを生成する。
     * model3.jsonの記述に従ってモデル生成、モーション、物理演算などのコンポーネント生成を行う。
     *
     * @param setting ICubismModelSettingのインスタンス
     */
    setupModel(setting) {
      this._updating = true;
      this._initialized = false;
      this._modelSetting = setting;
      if (this._modelSetting.getModelFileName() != "") {
        const modelFileName = this._modelSetting.getModelFileName();
        fetch(`${this._modelHomeDir}${modelFileName}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(`Failed to load file ${this._modelHomeDir}${modelFileName}`);
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          this.loadModel(arrayBuffer, this._mocConsistency);
          this._state = LoadStep.LoadExpression;
          loadCubismExpression();
        });
        this._state = LoadStep.WaitLoadModel;
      } else {
        LAppPal.printMessage("Model data does not exist.");
      }
      const loadCubismExpression = () => {
        if (this._modelSetting.getExpressionCount() > 0) {
          const count = this._modelSetting.getExpressionCount();
          for (let i = 0; i < count; i++) {
            const expressionName = this._modelSetting.getExpressionName(i);
            const expressionFileName = this._modelSetting.getExpressionFileName(i);
            fetch(`${this._modelHomeDir}${expressionFileName}`).then((response) => {
              if (response.ok) {
                return response.arrayBuffer();
              } else if (response.status >= 400) {
                CubismLogError(`Failed to load file ${this._modelHomeDir}${expressionFileName}`);
                return new ArrayBuffer(0);
              }
            }).then((arrayBuffer) => {
              const motion = this.loadExpression(arrayBuffer, arrayBuffer.byteLength, expressionName);
              if (this._expressions.getValue(expressionName) != null) {
                ACubismMotion.delete(this._expressions.getValue(expressionName));
                this._expressions.setValue(expressionName, null);
              }
              this._expressions.setValue(expressionName, motion);
              this._expressionCount++;
              if (this._expressionCount >= count) {
                this._state = LoadStep.LoadPhysics;
                loadCubismPhysics();
              }
            });
          }
          this._state = LoadStep.WaitLoadExpression;
        } else {
          this._state = LoadStep.LoadPhysics;
          loadCubismPhysics();
        }
      };
      const loadCubismPhysics = () => {
        if (this._modelSetting.getPhysicsFileName() != "") {
          const physicsFileName = this._modelSetting.getPhysicsFileName();
          fetch(`${this._modelHomeDir}${physicsFileName}`).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            } else if (response.status >= 400) {
              CubismLogError(`Failed to load file ${this._modelHomeDir}${physicsFileName}`);
              return new ArrayBuffer(0);
            }
          }).then((arrayBuffer) => {
            this.loadPhysics(arrayBuffer, arrayBuffer.byteLength);
            this._state = LoadStep.LoadPose;
            loadCubismPose();
          });
          this._state = LoadStep.WaitLoadPhysics;
        } else {
          this._state = LoadStep.LoadPose;
          loadCubismPose();
        }
      };
      const loadCubismPose = () => {
        if (this._modelSetting.getPoseFileName() != "") {
          const poseFileName = this._modelSetting.getPoseFileName();
          fetch(`${this._modelHomeDir}${poseFileName}`).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            } else if (response.status >= 400) {
              CubismLogError(`Failed to load file ${this._modelHomeDir}${poseFileName}`);
              return new ArrayBuffer(0);
            }
          }).then((arrayBuffer) => {
            this.loadPose(arrayBuffer, arrayBuffer.byteLength);
            this._state = LoadStep.SetupEyeBlink;
            setupEyeBlink();
          });
          this._state = LoadStep.WaitLoadPose;
        } else {
          this._state = LoadStep.SetupEyeBlink;
          setupEyeBlink();
        }
      };
      const setupEyeBlink = () => {
        if (this._modelSetting.getEyeBlinkParameterCount() > 0) {
          this._eyeBlink = CubismEyeBlink.create(this._modelSetting);
          this._state = LoadStep.SetupBreath;
        }
        setupBreath();
      };
      const setupBreath = () => {
        this._breath = CubismBreath.create();
        const breathParameters = new csmVector();
        breathParameters.pushBack(new BreathParameterData(this._idParamAngleX, 0, 15, 6.5345, 0.5));
        breathParameters.pushBack(new BreathParameterData(this._idParamAngleY, 0, 8, 3.5345, 0.5));
        breathParameters.pushBack(new BreathParameterData(this._idParamAngleZ, 0, 10, 5.5345, 0.5));
        breathParameters.pushBack(new BreathParameterData(this._idParamBodyAngleX, 0, 4, 15.5345, 0.5));
        breathParameters.pushBack(new BreathParameterData(CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamBreath), 0.5, 0.5, 3.2345, 1));
        this._breath.setParameters(breathParameters);
        this._state = LoadStep.LoadUserData;
        loadUserData();
      };
      const loadUserData = () => {
        if (this._modelSetting.getUserDataFile() != "") {
          const userDataFile = this._modelSetting.getUserDataFile();
          fetch(`${this._modelHomeDir}${userDataFile}`).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            } else if (response.status >= 400) {
              CubismLogError(`Failed to load file ${this._modelHomeDir}${userDataFile}`);
              return new ArrayBuffer(0);
            }
          }).then((arrayBuffer) => {
            this.loadUserData(arrayBuffer, arrayBuffer.byteLength);
            this._state = LoadStep.SetupEyeBlinkIds;
            setupEyeBlinkIds();
          });
          this._state = LoadStep.WaitLoadUserData;
        } else {
          this._state = LoadStep.SetupEyeBlinkIds;
          setupEyeBlinkIds();
        }
      };
      const setupEyeBlinkIds = () => {
        const eyeBlinkIdCount = this._modelSetting.getEyeBlinkParameterCount();
        for (let i = 0; i < eyeBlinkIdCount; ++i) {
          this._eyeBlinkIds.pushBack(this._modelSetting.getEyeBlinkParameterId(i));
        }
        this._state = LoadStep.SetupLipSyncIds;
        setupLipSyncIds();
      };
      const setupLipSyncIds = () => {
        const lipSyncIdCount = this._modelSetting.getLipSyncParameterCount();
        for (let i = 0; i < lipSyncIdCount; ++i) {
          this._lipSyncIds.pushBack(this._modelSetting.getLipSyncParameterId(i));
        }
        this._state = LoadStep.SetupLayout;
        setupLayout();
      };
      const setupLayout = () => {
        const layout = new csmMap();
        if (this._modelSetting == null || this._modelMatrix == null) {
          CubismLogError("Failed to setupLayout().");
          return;
        }
        this._modelSetting.getLayoutMap(layout);
        this._modelMatrix.setupFromLayout(layout);
        this._state = LoadStep.LoadMotion;
        loadCubismMotion();
      };
      const loadCubismMotion = () => {
        this._state = LoadStep.WaitLoadMotion;
        this._model.saveParameters();
        this._allMotionCount = 0;
        this._motionCount = 0;
        const group = [];
        const motionGroupCount = this._modelSetting.getMotionGroupCount();
        for (let i = 0; i < motionGroupCount; i++) {
          group[i] = this._modelSetting.getMotionGroupName(i);
          this._allMotionCount += this._modelSetting.getMotionCount(group[i]);
        }
        for (let i = 0; i < motionGroupCount; i++) {
          this.preLoadMotionGroup(group[i]);
        }
        if (motionGroupCount == 0) {
          this._state = LoadStep.LoadTexture;
          this._motionManager.stopAllMotions();
          this._updating = false;
          this._initialized = true;
          this.createRenderer();
          this.setupTextures();
          this.getRenderer().startUp(this.gl);
        }
      };
    }
    /**
     * テクスチャユニットにテクスチャをロードする
     */
    setupTextures() {
      const usePremultiply = true;
      if (this._state == LoadStep.LoadTexture) {
        const textureCount = this._modelSetting.getTextureCount();
        for (let modelTextureNumber = 0; modelTextureNumber < textureCount; modelTextureNumber++) {
          if (this._modelSetting.getTextureFileName(modelTextureNumber) == "") {
            console.log("getTextureFileName null");
            continue;
          }
          let texturePath = this._modelSetting.getTextureFileName(modelTextureNumber);
          texturePath = this._modelHomeDir + texturePath;
          const onLoad = (textureInfo) => {
            this.getRenderer().bindTexture(modelTextureNumber, textureInfo.id);
            this._textureCount++;
            if (this._textureCount >= textureCount) {
              this._state = LoadStep.CompleteSetup;
            }
          };
          this._textureManager.createTextureFromPngFile(texturePath, usePremultiply, onLoad);
          this.getRenderer().setIsPremultipliedAlpha(usePremultiply);
        }
        this._state = LoadStep.WaitLoadTexture;
      }
    }
    /**
     * レンダラを再構築する
     */
    reloadRenderer() {
      this.deleteRenderer();
      this.createRenderer();
      this.setupTextures();
    }
    /**
     * 更新
     */
    update() {
      if (this._state != LoadStep.CompleteSetup)
        return;
      const deltaTimeSeconds = LAppPal.getDeltaTime();
      this._userTimeSeconds += deltaTimeSeconds;
      this._dragManager.update(deltaTimeSeconds);
      this._dragX = this._dragManager.getX();
      this._dragY = this._dragManager.getY();
      let motionUpdated = false;
      this._model.loadParameters();
      if (this._motionManager.isFinished()) {
        this.startRandomMotion(MotionGroupIdle, PriorityIdle);
      } else {
        motionUpdated = this._motionManager.updateMotion(this._model, deltaTimeSeconds);
      }
      this._model.saveParameters();
      if (!motionUpdated) {
        if (this._eyeBlink != null) {
          this._eyeBlink.updateParameters(this._model, deltaTimeSeconds);
        }
      }
      if (this._expressionManager != null) {
        this._expressionManager.updateMotion(this._model, deltaTimeSeconds);
      }
      this._model.addParameterValueById(this._idParamAngleX, this._dragX * 30);
      this._model.addParameterValueById(this._idParamAngleY, this._dragY * 30);
      this._model.addParameterValueById(this._idParamAngleZ, this._dragX * this._dragY * -30);
      this._model.addParameterValueById(this._idParamBodyAngleX, this._dragX * 10);
      this._model.addParameterValueById(this._idParamEyeBallX, this._dragX);
      this._model.addParameterValueById(this._idParamEyeBallY, this._dragY);
      if (this._breath != null) {
        this._breath.updateParameters(this._model, deltaTimeSeconds);
      }
      if (this._physics != null) {
        this._physics.evaluate(this._model, deltaTimeSeconds);
      }
      if (this._lipsync) {
        let value = 0;
        this._wavFileHandler.update(deltaTimeSeconds);
        value = this._wavFileHandler.getRms();
        for (let i = 0; i < this._lipSyncIds.getSize(); ++i) {
          this._model.addParameterValueById(this._lipSyncIds.at(i), value, 0.8);
        }
      }
      if (this._pose != null) {
        this._pose.updateParameters(this._model, deltaTimeSeconds);
      }
      this._model.update();
    }
    /**
     * 引数で指定したモーションの再生を開始する
     * @param group モーショングループ名
     * @param no グループ内の番号
     * @param priority 優先度
     * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数
     * @return 開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するisFinished()の引数で使用する。開始できない時は[-1]
     */
    startMotion(group, no, priority, onFinishedMotionHandler) {
      if (priority == PriorityForce) {
        this._motionManager.setReservePriority(priority);
      } else if (!this._motionManager.reserveMotion(priority)) {
        if (this._debugMode) {
          LAppPal.printMessage("[APP]can't start motion.");
        }
        return InvalidMotionQueueEntryHandleValue;
      }
      const motionFileName = this._modelSetting.getMotionFileName(group, no);
      const name = `${group}_${no}`;
      let motion = this._motions.getValue(name);
      let autoDelete = false;
      if (motion == null) {
        fetch(`${this._modelHomeDir}${motionFileName}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(`Failed to load file ${this._modelHomeDir}${motionFileName}`);
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          motion = this.loadMotion(arrayBuffer, arrayBuffer.byteLength, null, onFinishedMotionHandler);
          if (motion == null) {
            return;
          }
          let fadeTime = this._modelSetting.getMotionFadeInTimeValue(group, no);
          if (fadeTime >= 0) {
            motion.setFadeInTime(fadeTime);
          }
          fadeTime = this._modelSetting.getMotionFadeOutTimeValue(group, no);
          if (fadeTime >= 0) {
            motion.setFadeOutTime(fadeTime);
          }
          motion.setEffectIds(this._eyeBlinkIds, this._lipSyncIds);
          autoDelete = true;
        });
      } else {
        motion.setFinishedMotionHandler(onFinishedMotionHandler);
      }
      const voice = this._modelSetting.getMotionSoundFileName(group, no);
      if (voice.localeCompare("") != 0) {
        let path = voice;
        path = this._modelHomeDir + path;
        this._wavFileHandler.start(path);
      }
      if (this._debugMode) {
        LAppPal.printMessage(`[APP]start motion: [${group}_${no}`);
      }
      return this._motionManager.startMotionPriority(motion, autoDelete, priority);
    }
    /**
     * ランダムに選ばれたモーションの再生を開始する。
     * @param group モーショングループ名
     * @param priority 優先度
     * @param onFinishedMotionHandler モーション再生終了時に呼び出されるコールバック関数
     * @return 開始したモーションの識別番号を返す。個別のモーションが終了したか否かを判定するisFinished()の引数で使用する。開始できない時は[-1]
     */
    startRandomMotion(group, priority, onFinishedMotionHandler) {
      if (this._modelSetting.getMotionCount(group) == 0) {
        return InvalidMotionQueueEntryHandleValue;
      }
      const no = Math.floor(Math.random() * this._modelSetting.getMotionCount(group));
      return this.startMotion(group, no, priority, onFinishedMotionHandler);
    }
    endMotion() {
      this._motionManager.stopAllMotions();
    }
    /**
     * 引数で指定した表情モーションをセットする
     *
     * @param expressionId 表情モーションのID
     */
    setExpression(expressionId) {
      const motion = this._expressions.getValue(expressionId);
      if (this._debugMode) {
        LAppPal.printMessage(`[APP]expression: [${expressionId}]`);
      }
      if (motion != null) {
        this._expressionManager.startMotionPriority(motion, false, PriorityForce);
      } else {
        if (this._debugMode) {
          LAppPal.printMessage(`[APP]expression[${expressionId}] is null`);
        }
      }
    }
    /**
     * ランダムに選ばれた表情モーションをセットする
     */
    setRandomExpression() {
      if (this._expressions.getSize() == 0) {
        return;
      }
      const no = Math.floor(Math.random() * this._expressions.getSize());
      for (let i = 0; i < this._expressions.getSize(); i++) {
        if (i == no) {
          const name = this._expressions._keyValues[i].first;
          this.setExpression(name);
          return;
        }
      }
    }
    unsetExpression() {
      this._expressionManager.stopAllMotions();
    }
    /**
     * イベントの発火を受け取る
     */
    motionEventFired(eventValue) {
      CubismLogInfo("{0} is fired on LAppModel!!", eventValue.s);
    }
    /**
     * 当たり判定テスト
     * 指定ＩＤの頂点リストから矩形を計算し、座標をが矩形範囲内か判定する。
     *
     * @param hitArenaName  当たり判定をテストする対象のID
     * @param x             判定を行うX座標
     * @param y             判定を行うY座標
     */
    hitTest(hitArenaName, x, y) {
      if (this._opacity < 1) {
        return false;
      }
      const count = this._modelSetting.getHitAreasCount();
      for (let i = 0; i < count; i++) {
        if (this._modelSetting.getHitAreaName(i) == hitArenaName) {
          const drawId = this._modelSetting.getHitAreaId(i);
          return this.isHit(drawId, x, y);
        }
      }
      return false;
    }
    /**
     * モーションデータをグループ名から一括でロードする。
     * モーションデータの名前は内部でModelSettingから取得する。
     *
     * @param group モーションデータのグループ名
     */
    preLoadMotionGroup(group) {
      for (let i = 0; i < this._modelSetting.getMotionCount(group); i++) {
        const motionFileName = this._modelSetting.getMotionFileName(group, i);
        const name = `${group}_${i}`;
        if (this._debugMode) {
          LAppPal.printMessage(`[APP]load motion: ${motionFileName} => [${name}]`);
        }
        fetch(`${this._modelHomeDir}${motionFileName}`).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          } else if (response.status >= 400) {
            CubismLogError(`Failed to load file ${this._modelHomeDir}${motionFileName}`);
            return new ArrayBuffer(0);
          }
        }).then((arrayBuffer) => {
          const tmpMotion = this.loadMotion(arrayBuffer, arrayBuffer.byteLength, name);
          if (tmpMotion != null) {
            let fadeTime = this._modelSetting.getMotionFadeInTimeValue(group, i);
            if (fadeTime >= 0) {
              tmpMotion.setFadeInTime(fadeTime);
            }
            fadeTime = this._modelSetting.getMotionFadeOutTimeValue(group, i);
            if (fadeTime >= 0) {
              tmpMotion.setFadeOutTime(fadeTime);
            }
            tmpMotion.setEffectIds(this._eyeBlinkIds, this._lipSyncIds);
            if (this._motions.getValue(name) != null) {
              ACubismMotion.delete(this._motions.getValue(name));
            }
            this._motions.setValue(name, tmpMotion);
            this._motionCount++;
            if (this._motionCount >= this._allMotionCount) {
              this._state = LoadStep.LoadTexture;
              this._motionManager.stopAllMotions();
              this._updating = false;
              this._initialized = true;
              this.createRenderer();
              this.setupTextures();
              this.getRenderer().startUp(this.gl);
            }
          } else {
            this._allMotionCount--;
          }
        });
      }
    }
    /**
     * すべてのモーションデータを解放する。
     */
    releaseMotions() {
      this._motions.clear();
    }
    /**
     * 全ての表情データを解放する。
     */
    releaseExpressions() {
      this._expressions.clear();
    }
    /**
     * モデルを描画する処理。モデルを描画する空間のView-Projection行列を渡す。
     */
    doDraw() {
      if (this._model == null)
        return;
      this.getRenderer().setRenderState(this.frameBuffer, this.viewport);
      this.getRenderer().drawModel();
    }
    /**
     * モデルを描画する処理。モデルを描画する空間のView-Projection行列を渡す。
     */
    draw(matrix) {
      if (this._model == null) {
        return;
      }
      if (this._state == LoadStep.CompleteSetup) {
        matrix.multiplyByMatrix(this._modelMatrix);
        this.getRenderer().setMvpMatrix(matrix);
        this.doDraw();
      }
    }
    hasMocConsistencyFromFile() {
      return __awaiter2(this, void 0, void 0, function* () {
        CSM_ASSERT(this._modelSetting.getModelFileName().localeCompare(``));
        if (this._modelSetting.getModelFileName() != "") {
          const modelFileName = this._modelSetting.getModelFileName();
          const response = yield fetch(`${this._modelHomeDir}${modelFileName}`);
          const arrayBuffer = yield response.arrayBuffer();
          this._consistency = CubismMoc.hasMocConsistency(arrayBuffer);
          if (!this._consistency) {
            CubismLogInfo("Inconsistent MOC3.");
          } else {
            CubismLogInfo("Consistent MOC3.");
          }
          return this._consistency;
        } else {
          LAppPal.printMessage("Model data does not exist.");
        }
      });
    }
    /**
     * コンストラクタ
     */
    constructor(canvas_gl, textureMgr, cvs, viewport, frameBuffer) {
      super();
      this.viewport = viewport;
      this.frameBuffer = frameBuffer;
      this._textureManager = textureMgr;
      this.gl = canvas_gl;
      this.canvas = cvs;
      this._modelSetting = null;
      this._modelHomeDir = null;
      this._userTimeSeconds = 0;
      this._eyeBlinkIds = new csmVector();
      this._lipSyncIds = new csmVector();
      this._motions = new csmMap();
      this._expressions = new csmMap();
      this._hitArea = new csmVector();
      this._userArea = new csmVector();
      this._idParamAngleX = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamAngleX);
      this._idParamAngleY = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamAngleY);
      this._idParamAngleZ = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamAngleZ);
      this._idParamEyeBallX = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamEyeBallX);
      this._idParamEyeBallY = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamEyeBallY);
      this._idParamBodyAngleX = CubismFramework.getIdManager().getId(CubismDefaultParameterId.ParamBodyAngleX);
      if (MOCConsistencyValidationEnable) {
        this._mocConsistency = true;
      }
      this._state = LoadStep.LoadAssets;
      this._expressionCount = 0;
      this._textureCount = 0;
      this._motionCount = 0;
      this._allMotionCount = 0;
      this._wavFileHandler = new LAppWavFileHandler();
      this._consistency = false;
    }
  };

  // src/Live2D/lapptexturemanager.js
  var LAppTextureManager = class {
    /**
     * コンストラクタ
     */
    constructor(canvas_gl) {
      this.gl = canvas_gl;
      this._textures = new csmVector();
    }
    /**
     * 解放する。
     */
    release() {
      for (let ite = this._textures.begin(); ite.notEqual(this._textures.end()); ite.preIncrement()) {
        this.gl.deleteTexture(ite.ptr().id);
      }
      this._textures = null;
    }
    /**
     * 画像読み込み
     *
     * @param fileName 読み込む画像ファイルパス名
     * @param usePremultiply Premult処理を有効にするか
     * @return 画像情報、読み込み失敗時はnullを返す
     */
    createTextureFromPngFile(fileName, usePremultiply, callback) {
      for (let ite = this._textures.begin(); ite.notEqual(this._textures.end()); ite.preIncrement()) {
        if (ite.ptr().fileName == fileName && ite.ptr().usePremultply == usePremultiply) {
          ite.ptr().img = new Image();
          ite.ptr().img.addEventListener("load", () => callback(ite.ptr()), {
            passive: true
          });
          ite.ptr().img.src = fileName;
          return;
        }
      }
      const img = new Image();
      img.addEventListener("load", () => {
        const tex = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        if (usePremultiply) {
          this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
        }
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, img);
        this.gl.generateMipmap(this.gl.TEXTURE_2D);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        const textureInfo = new TextureInfo();
        if (textureInfo != null) {
          textureInfo.fileName = fileName;
          textureInfo.width = img.width;
          textureInfo.height = img.height;
          textureInfo.id = tex;
          textureInfo.img = img;
          textureInfo.usePremultply = usePremultiply;
          this._textures.pushBack(textureInfo);
        }
        callback(textureInfo);
      }, { passive: true });
      img.src = fileName;
    }
    /**
     * 画像の解放
     *
     * 配列に存在する画像全てを解放する。
     */
    releaseTextures() {
      for (let i = 0; i < this._textures.getSize(); i++) {
        this._textures.set(i, null);
      }
      this._textures.clear();
    }
    /**
     * 画像の解放
     *
     * 指定したテクスチャの画像を解放する。
     * @param texture 解放するテクスチャ
     */
    releaseTextureByTexture(texture) {
      for (let i = 0; i < this._textures.getSize(); i++) {
        if (this._textures.at(i).id != texture) {
          continue;
        }
        this._textures.set(i, null);
        this._textures.remove(i);
        break;
      }
    }
    /**
     * 画像の解放
     *
     * 指定した名前の画像を解放する。
     * @param fileName 解放する画像ファイルパス名
     */
    releaseTextureByFilePath(fileName) {
      for (let i = 0; i < this._textures.getSize(); i++) {
        if (this._textures.at(i).fileName == fileName) {
          this._textures.set(i, null);
          this._textures.remove(i);
          break;
        }
      }
    }
  };
  var TextureInfo = class {
    constructor() {
      this.id = null;
      this.width = 0;
      this.height = 0;
    }
  };

  // src/Live2D/Live2D.js
  var _s_instance;
  var _Live2D = class _Live2D {
    static getInstance(canvas) {
      if (__privateGet(_Live2D, _s_instance) == null) {
        __privateSet(_Live2D, _s_instance, new _Live2D(canvas));
      } else {
        console.log("releasing old instance");
        __privateGet(_Live2D, _s_instance).release();
        __privateSet(_Live2D, _s_instance, new _Live2D(canvas));
      }
      console.log("instance created");
      return __privateGet(_Live2D, _s_instance);
    }
    constructor(canvas) {
      this._canvas = canvas;
      this._cubismOption = new Option();
      this._viewMatrix = new CubismViewMatrix();
      this.debugMode = false;
    }
    pjsToModern(pjs) {
      var oldCanvas = pjs.externals.canvas;
      var width = oldCanvas.width;
      var height = oldCanvas.height;
      this._pgraphics = pjs.createGraphics(width, height, 2);
      this._pjs = pjs;
      this._canvas = this._pgraphics.externals.canvas;
    }
    // get context
    _getCtx() {
      return this._LAppGlManager.gl;
    }
    initialize(x, y, width, height, modelDir, modelFile) {
      this._LAppGlManager = new LAppGlManager(this._canvas);
      this._gl = this._getCtx();
      if (!this._frameBuffer) {
        this._frameBuffer = this._gl.getParameter(this._gl.FRAMEBUFFER_BINDING);
      }
      this._textureManager = new LAppTextureManager(this._gl);
      this._gl.enable(this._gl.BLEND);
      this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
      this._initializeCubism();
      this._viewMatrix.setScreenRect(x, width, y, height);
      this._viewport = [x, y, width, height];
      this.loadModel(modelDir, modelFile);
      return true;
    }
    // initialize cubism
    _initializeCubism() {
      this._cubismOption.logFunction = LAppPal.printMessage;
      this._cubismOption.loggingLevel = CubismLoggingLevel;
      CubismFramework.startUp(this._cubismOption);
      CubismFramework.initialize();
      LAppPal.updateTime();
    }
    // create shader
    _createShader() {
      const vertexShaderId = this._gl.createShader(this._gl.VERTEX_SHADER);
      if (vertexShaderId == null) {
        LAppPal.printMessage("failed to create vertexShader");
        return null;
      }
      const vertexShader = "precision mediump float;attribute vec3 position;attribute vec2 uv;varying vec2 vuv;void main(void){   gl_Position = vec4(position, 1.0);   vuv = uv;}";
      this._gl.shaderSource(vertexShaderId, vertexShader);
      this._gl.compileShader(vertexShaderId);
      const fragmentShaderId = this._gl.createShader(this._gl.FRAGMENT_SHADER);
      if (fragmentShaderId == null) {
        LAppPal.printMessage("failed to create fragmentShader");
        return null;
      }
      const fragmentShader = "precision mediump float;varying vec2 vuv;uniform sampler2D texture;void main(void){   gl_FragColor = texture2D(texture, vuv);}";
      this._gl.shaderSource(fragmentShaderId, fragmentShader);
      this._gl.compileShader(fragmentShaderId);
      const programId = this._gl.createProgram();
      this._gl.attachShader(programId, vertexShaderId);
      this._gl.attachShader(programId, fragmentShaderId);
      this._gl.deleteShader(vertexShaderId);
      this._gl.deleteShader(fragmentShaderId);
      this._gl.linkProgram(programId);
      this._gl.useProgram(programId);
      return programId;
    }
    // release everything
    release() {
      this._textureManager.release();
      this._textureManager = null;
      this._model = null;
      CubismFramework.dispose();
    }
    // load model
    loadModel(modelDir, modelFile, callback = null) {
      if (this._model) {
        this._model.release();
        this._model = null;
      }
      this._model = new LAppModel(
        this._gl,
        this._textureManager,
        this.canvas,
        this._viewport,
        this._frameBuffer
      );
      this._model.loadAssets(modelDir, modelFile, callback);
    }
    _preRender() {
      this._gl.clearColor(0, 0, 0, 1);
      this._gl.enable(this._gl.DEPTH_TEST);
      this._gl.depthFunc(this._gl.LEQUAL);
      this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);
      this._gl.clearDepth(1);
      this._gl.enable(this._gl.BLEND);
      this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
    }
    // update + draw model
    updateModel() {
      if (!this._model) {
        return;
      }
      LAppPal.updateTime();
      const projection = new CubismMatrix44();
      const width = this._viewport[2];
      const height = this._viewport[3];
      if (this._model.getModel()) {
        if (this._model.getModel().getCanvasWidth() > 1 && width < height) {
          this._model.getModelMatrix().setWidth(2);
          projection.scale(1, width / height);
        } else {
          projection.scale(height / width, 1);
        }
        if (this._viewMatrix != null) {
          projection.multiplyByMatrix(this._viewMatrix);
        }
      }
      this._model.update();
      this._pgraphics.background(0, 0);
      this._pgraphics.beginDraw();
      this._model.draw(projection);
      this._pgraphics.endDraw();
      this._pjs.image(this._pgraphics, 0, 0);
    }
    // translate model (x, y) range of 0 to width/height of canvas
    // first translate canvas position to model position
    // note: the default model position is a the center of the canvas
    setModelCanvasPosition(x, y, width, height) {
      this._viewport = [x, y, width, height];
      this._viewMatrix.setScreenRect(x, width, y, height);
      if (this._model) {
        this._model.viewport = this._viewport;
      }
    }
    // set model position (x, y) range of -1.0 to 1.0
    setModelPosition(x, y) {
      if (this._model) {
        this._viewMatrix.translate(x, y);
      }
    }
    // set model scale
    setModelScale(scale) {
      if (this._model) {
        this._viewMatrix.scale(scale, scale);
      }
    }
    // start motion
    startMotion(group_name, id) {
      this._model.startMotion(group_name, id);
    }
    // end motion
    stopMotion() {
      this._model.endMotion();
    }
    // set expression
    setExpression(expression_name) {
      this._model.setExpression(expression_name);
    }
    // unset expression
    unsetExpression() {
      this._model.unsetExpression();
    }
    // set parameter
    setParameter(name, value, weight = 1) {
      this._model.getModel().setParameterValueById(name, value, weight);
    }
    // look at (x, y) range of -1.0 to 1.0
    lookAt(x, y) {
      this._model.setDragging(x, y);
    }
  };
  _s_instance = new WeakMap();
  __privateAdd(_Live2D, _s_instance, null);
  var Live2D = _Live2D;

  // src/P5Functions/Math.js
  function withMath(p, undef) {
    var internalRandomGenerator = function() {
      return Math.random();
    };
    p.abs = Math.abs;
    p.ceil = Math.ceil;
    p.exp = Math.exp;
    p.floor = Math.floor;
    p.log = Math.log;
    p.pow = Math.pow;
    p.round = Math.round;
    p.sqrt = Math.sqrt;
    p.acos = Math.acos;
    p.asin = Math.asin;
    p.atan = Math.atan;
    p.atan2 = Math.atan2;
    p.cos = Math.cos;
    p.sin = Math.sin;
    p.tan = Math.tan;
    p.constrain = function(aNumber, aMin, aMax) {
      return aNumber > aMax ? aMax : aNumber < aMin ? aMin : aNumber;
    };
    p.dist = function() {
      var dx, dy, dz;
      if (arguments.length === 4) {
        dx = arguments[0] - arguments[2];
        dy = arguments[1] - arguments[3];
        return Math.sqrt(dx * dx + dy * dy);
      }
      if (arguments.length === 6) {
        dx = arguments[0] - arguments[3];
        dy = arguments[1] - arguments[4];
        dz = arguments[2] - arguments[5];
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      }
    };
    p.lerp = function(value1, value2, amt) {
      return (value2 - value1) * amt + value1;
    };
    p.mag = function(a, b, c) {
      if (c) {
        return Math.sqrt(a * a + b * b + c * c);
      }
      return Math.sqrt(a * a + b * b);
    };
    p.map = function(value, istart, istop, ostart, ostop) {
      return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
    };
    p.max = function() {
      if (arguments.length === 2) {
        return arguments[0] < arguments[1] ? arguments[1] : arguments[0];
      }
      var numbers = arguments.length === 1 ? arguments[0] : arguments;
      if (!("length" in numbers && numbers.length > 0)) {
        throw "Non-empty array is expected";
      }
      var max = numbers[0], count = numbers.length;
      for (var i = 1; i < count; ++i) {
        if (max < numbers[i]) {
          max = numbers[i];
        }
      }
      return max;
    };
    p.min = function() {
      if (arguments.length === 2) {
        return arguments[0] < arguments[1] ? arguments[0] : arguments[1];
      }
      var numbers = arguments.length === 1 ? arguments[0] : arguments;
      if (!("length" in numbers && numbers.length > 0)) {
        throw "Non-empty array is expected";
      }
      var min = numbers[0], count = numbers.length;
      for (var i = 1; i < count; ++i) {
        if (min > numbers[i]) {
          min = numbers[i];
        }
      }
      return min;
    };
    p.norm = function(aNumber, low, high) {
      return (aNumber - low) / (high - low);
    };
    p.sq = function(aNumber) {
      return aNumber * aNumber;
    };
    p.degrees = function(aAngle) {
      return aAngle * 180 / Math.PI;
    };
    p.random = function(aMin, aMax) {
      if (arguments.length === 0) {
        aMax = 1;
        aMin = 0;
      } else if (arguments.length === 1) {
        aMax = aMin;
        aMin = 0;
      }
      if (aMin === aMax) {
        return aMin;
      }
      for (var i = 0; i < 100; i++) {
        var ir = internalRandomGenerator();
        var result = ir * (aMax - aMin) + aMin;
        if (result !== aMax) {
          return result;
        }
      }
      return aMin;
    };
    function Marsaglia(i1, i2) {
      var z = i1 || 362436069, w = i2 || 521288629;
      var intGenerator = function() {
        z = 36969 * (z & 65535) + (z >>> 16) & 4294967295;
        w = 18e3 * (w & 65535) + (w >>> 16) & 4294967295;
        return ((z & 65535) << 16 | w & 65535) & 4294967295;
      };
      this.doubleGenerator = function() {
        var i = intGenerator() / 4294967296;
        return i < 0 ? 1 + i : i;
      };
      this.intGenerator = intGenerator;
    }
    Marsaglia.createRandomized = function() {
      var now = /* @__PURE__ */ new Date();
      return new Marsaglia(now / 6e4 & 4294967295, now & 4294967295);
    };
    p.randomSeed = function(seed) {
      internalRandomGenerator = new Marsaglia(seed, (seed << 16) + (seed >> 16)).doubleGenerator;
      this.haveNextNextGaussian = false;
    };
    p.randomGaussian = function() {
      if (this.haveNextNextGaussian) {
        this.haveNextNextGaussian = false;
        return this.nextNextGaussian;
      }
      var v1, v2, s;
      do {
        v1 = 2 * internalRandomGenerator() - 1;
        v2 = 2 * internalRandomGenerator() - 1;
        s = v1 * v1 + v2 * v2;
      } while (s >= 1 || s === 0);
      var multiplier = Math.sqrt(-2 * Math.log(s) / s);
      this.nextNextGaussian = v2 * multiplier;
      this.haveNextNextGaussian = true;
      return v1 * multiplier;
    };
    function PerlinNoise(seed) {
      var rnd = seed !== undef ? new Marsaglia(seed, (seed << 16) + (seed >> 16)) : Marsaglia.createRandomized();
      var i, j;
      var perm = new Uint8Array(512);
      for (i = 0; i < 256; ++i) {
        perm[i] = i;
      }
      for (i = 0; i < 256; ++i) {
        var t2 = perm[j = rnd.intGenerator() & 255];
        perm[j] = perm[i];
        perm[i] = t2;
      }
      for (i = 0; i < 256; ++i) {
        perm[i + 256] = perm[i];
      }
      function grad3d(i2, x, y, z) {
        var h = i2 & 15;
        var u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;
        return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
      }
      function grad2d(i2, x, y) {
        var v = (i2 & 1) === 0 ? x : y;
        return (i2 & 2) === 0 ? -v : v;
      }
      function grad1d(i2, x) {
        return (i2 & 1) === 0 ? -x : x;
      }
      function lerp(t3, a, b) {
        return a + t3 * (b - a);
      }
      this.noise3d = function(x, y, z) {
        var X2 = Math.floor(x) & 255, Y2 = Math.floor(y) & 255, Z = Math.floor(z) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);
        var fx = (3 - 2 * x) * x * x, fy = (3 - 2 * y) * y * y, fz = (3 - 2 * z) * z * z;
        var p0 = perm[X2] + Y2, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z, p1 = perm[X2 + 1] + Y2, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;
        return lerp(
          fz,
          lerp(
            fy,
            lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x - 1, y, z)),
            lerp(fx, grad3d(perm[p01], x, y - 1, z), grad3d(perm[p11], x - 1, y - 1, z))
          ),
          lerp(
            fy,
            lerp(fx, grad3d(perm[p00 + 1], x, y, z - 1), grad3d(perm[p10 + 1], x - 1, y, z - 1)),
            lerp(fx, grad3d(perm[p01 + 1], x, y - 1, z - 1), grad3d(perm[p11 + 1], x - 1, y - 1, z - 1))
          )
        );
      };
      this.noise2d = function(x, y) {
        var X2 = Math.floor(x) & 255, Y2 = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        var fx = (3 - 2 * x) * x * x, fy = (3 - 2 * y) * y * y;
        var p0 = perm[X2] + Y2, p1 = perm[X2 + 1] + Y2;
        return lerp(
          fy,
          lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x - 1, y)),
          lerp(fx, grad2d(perm[p0 + 1], x, y - 1), grad2d(perm[p1 + 1], x - 1, y - 1))
        );
      };
      this.noise1d = function(x) {
        var X2 = Math.floor(x) & 255;
        x -= Math.floor(x);
        var fx = (3 - 2 * x) * x * x;
        return lerp(fx, grad1d(perm[X2], x), grad1d(perm[X2 + 1], x - 1));
      };
    }
    var noiseProfile = { generator: undef, octaves: 4, fallout: 0.5, seed: undef };
    p.noise = function(x, y, z) {
      if (noiseProfile.generator === undef) {
        noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
      }
      var generator = noiseProfile.generator;
      var effect = 1, k = 1, sum = 0;
      for (var i = 0; i < noiseProfile.octaves; ++i) {
        effect *= noiseProfile.fallout;
        switch (arguments.length) {
          case 1:
            sum += effect * (1 + generator.noise1d(k * x)) / 2;
            break;
          case 2:
            sum += effect * (1 + generator.noise2d(k * x, k * y)) / 2;
            break;
          case 3:
            sum += effect * (1 + generator.noise3d(k * x, k * y, k * z)) / 2;
            break;
        }
        k *= 2;
      }
      return sum;
    };
    p.noiseDetail = function(octaves, fallout) {
      noiseProfile.octaves = octaves;
      if (fallout !== undef) {
        noiseProfile.fallout = fallout;
      }
    };
    p.noiseSeed = function(seed) {
      noiseProfile.seed = seed;
      noiseProfile.generator = undef;
    };
  }

  // src/P5Functions/JavaProxyFunctions.js
  function withProxyFunctions(virtHashCode2, virtEquals2, undef) {
    return function withProxyFunctions2(p, removeFirstArgument) {
      p.__contains = function(subject, subStr) {
        if (typeof subject !== "string") {
          return subject.contains.apply(subject, removeFirstArgument(arguments));
        }
        return subject !== null && subStr !== null && typeof subStr === "string" && subject.indexOf(subStr) > -1;
      };
      p.__replaceAll = function(subject, regex, replacement) {
        if (typeof subject !== "string") {
          return subject.replaceAll.apply(subject, removeFirstArgument(arguments));
        }
        return subject.replace(new RegExp(regex, "g"), replacement);
      };
      p.__replaceFirst = function(subject, regex, replacement) {
        if (typeof subject !== "string") {
          return subject.replaceFirst.apply(subject, removeFirstArgument(arguments));
        }
        return subject.replace(new RegExp(regex, ""), replacement);
      };
      p.__replace = function(subject, what, replacement) {
        if (typeof subject !== "string") {
          return subject.replace.apply(subject, removeFirstArgument(arguments));
        }
        if (what instanceof RegExp) {
          return subject.replace(what, replacement);
        }
        if (typeof what !== "string") {
          what = what.toString();
        }
        if (what === "") {
          return subject;
        }
        var i = subject.indexOf(what);
        if (i < 0) {
          return subject;
        }
        var j = 0, result = "";
        do {
          result += subject.substring(j, i) + replacement;
          j = i + what.length;
        } while ((i = subject.indexOf(what, j)) >= 0);
        return result + subject.substring(j);
      };
      p.__equals = function(subject, other) {
        if (subject.equals instanceof Function) {
          return subject.equals.apply(subject, removeFirstArgument(arguments));
        }
        return virtEquals2(subject, other);
      };
      p.__equalsIgnoreCase = function(subject, other) {
        if (typeof subject !== "string") {
          return subject.equalsIgnoreCase.apply(subject, removeFirstArgument(arguments));
        }
        return subject.toLowerCase() === other.toLowerCase();
      };
      p.__toCharArray = function(subject) {
        if (typeof subject !== "string") {
          return subject.toCharArray.apply(subject, removeFirstArgument(arguments));
        }
        var chars = [];
        for (var i = 0, len = subject.length; i < len; ++i) {
          chars[i] = new Char_default(subject.charAt(i));
        }
        return chars;
      };
      p.__split = function(subject, regex, limit) {
        if (typeof subject !== "string") {
          return subject.split.apply(subject, removeFirstArgument(arguments));
        }
        var pattern = new RegExp(regex);
        if (limit === undef || limit < 1) {
          return subject.split(pattern);
        }
        var result = [], currSubject = subject, pos;
        while ((pos = currSubject.search(pattern)) !== -1 && result.length < limit - 1) {
          var match = pattern.exec(currSubject).toString();
          result.push(currSubject.substring(0, pos));
          currSubject = currSubject.substring(pos + match.length);
        }
        if (pos !== -1 || currSubject !== "") {
          result.push(currSubject);
        }
        return result;
      };
      p.__codePointAt = function(subject, idx) {
        var code = subject.charCodeAt(idx), hi, low;
        if (55296 <= code && code <= 56319) {
          hi = code;
          low = subject.charCodeAt(idx + 1);
          return (hi - 55296) * 1024 + (low - 56320) + 65536;
        }
        return code;
      };
      p.__matches = function(str, regexp) {
        return new RegExp(regexp).test(str);
      };
      p.__startsWith = function(subject, prefix, toffset) {
        if (typeof subject !== "string") {
          return subject.startsWith.apply(subject, removeFirstArgument(arguments));
        }
        toffset = toffset || 0;
        if (toffset < 0 || toffset > subject.length) {
          return false;
        }
        return prefix === "" || prefix === subject ? true : subject.indexOf(prefix) === toffset;
      };
      p.__endsWith = function(subject, suffix) {
        if (typeof subject !== "string") {
          return subject.endsWith.apply(subject, removeFirstArgument(arguments));
        }
        var suffixLen = suffix ? suffix.length : 0;
        return suffix === "" || suffix === subject ? true : subject.indexOf(suffix) === subject.length - suffixLen;
      };
      p.__hashCode = function(subject) {
        if (subject.hashCode instanceof Function) {
          return subject.hashCode.apply(subject, removeFirstArgument(arguments));
        }
        return virtHashCode2(subject);
      };
      p.__printStackTrace = function(subject) {
        p.println("Exception: " + subject.toString());
      };
    };
  }
  var JavaProxyFunctions_default = withProxyFunctions;

  // src/P5Functions/touchmouse.js
  function withTouch(p, curElement, attachEventHandler, detachEventHandlersByType, document2, PConstants3, undef) {
    var mouseTypes = ["mouseout", "mousemove", "mousedown", "mouseup", "DOMMouseScroll", "mousewheel", "touchstart"];
    function calculateOffset(curElement2, event) {
      var element = curElement2, offsetX = 0, offsetY = 0;
      p.pmouseX = p.mouseX;
      p.pmouseY = p.mouseY;
      if (element.offsetParent) {
        do {
          offsetX += element.offsetLeft;
          offsetY += element.offsetTop;
        } while (!!(element = element.offsetParent));
      }
      element = curElement2;
      do {
        offsetX -= element.scrollLeft || 0;
        offsetY -= element.scrollTop || 0;
      } while (!!(element = element.parentNode));
      var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;
      if (document2.defaultView && document2.defaultView.getComputedStyle) {
        stylePaddingLeft = parseInt(document2.defaultView.getComputedStyle(curElement2, null).paddingLeft, 10) || 0;
        stylePaddingTop = parseInt(document2.defaultView.getComputedStyle(curElement2, null).paddingTop, 10) || 0;
        styleBorderLeft = parseInt(document2.defaultView.getComputedStyle(curElement2, null).borderLeftWidth, 10) || 0;
        styleBorderTop = parseInt(document2.defaultView.getComputedStyle(curElement2, null).borderTopWidth, 10) || 0;
      }
      offsetX += stylePaddingLeft;
      offsetY += stylePaddingTop;
      offsetX += styleBorderLeft;
      offsetY += styleBorderTop;
      offsetX += window.pageXOffset;
      offsetY += window.pageYOffset;
      return { "X": offsetX, "Y": offsetY };
    }
    function updateMousePosition(curElement2, event) {
      var offset = calculateOffset(curElement2, event);
      p.mouseX = event.pageX - offset.X;
      p.mouseY = event.pageY - offset.Y;
    }
    function addTouchEventOffset(t2) {
      var offset = calculateOffset(t2.changedTouches[0].target, t2.changedTouches[0]), i;
      for (i = 0; i < t2.touches.length; i++) {
        var touch = t2.touches[i];
        touch.offsetX = touch.pageX - offset.X;
        touch.offsetY = touch.pageY - offset.Y;
      }
      for (i = 0; i < t2.targetTouches.length; i++) {
        var targetTouch = t2.targetTouches[i];
        targetTouch.offsetX = targetTouch.pageX - offset.X;
        targetTouch.offsetY = targetTouch.pageY - offset.Y;
      }
      for (i = 0; i < t2.changedTouches.length; i++) {
        var changedTouch = t2.changedTouches[i];
        changedTouch.offsetX = changedTouch.pageX - offset.X;
        changedTouch.offsetY = changedTouch.pageY - offset.Y;
      }
      return t2;
    }
    attachEventHandler(curElement, "touchstart", function(t2) {
      curElement.setAttribute("style", "-webkit-user-select: none");
      curElement.setAttribute("onclick", "void(0)");
      curElement.setAttribute("style", "-webkit-tap-highlight-color:rgba(0,0,0,0)");
      detachEventHandlersByType(curElement, mouseTypes);
      if (p.touchStart !== undef || p.touchMove !== undef || p.touchEnd !== undef || p.touchCancel !== undef) {
        attachEventHandler(curElement, "touchstart", function(t3) {
          if (p.touchStart !== undef) {
            t3 = addTouchEventOffset(t3);
            p.touchStart(t3);
          }
        });
        attachEventHandler(curElement, "touchmove", function(t3) {
          if (p.touchMove !== undef) {
            t3.preventDefault();
            t3 = addTouchEventOffset(t3);
            p.touchMove(t3);
          }
        });
        attachEventHandler(curElement, "touchend", function(t3) {
          if (p.touchEnd !== undef) {
            t3 = addTouchEventOffset(t3);
            p.touchEnd(t3);
          }
        });
        attachEventHandler(curElement, "touchcancel", function(t3) {
          if (p.touchCancel !== undef) {
            t3 = addTouchEventOffset(t3);
            p.touchCancel(t3);
          }
        });
      } else {
        attachEventHandler(curElement, "touchstart", function(e) {
          updateMousePosition(curElement, e.touches[0]);
          p.__mousePressed = true;
          p.mouseDragging = false;
          p.mouseButton = PConstants3.LEFT;
          if (typeof p.mousePressed === "function") {
            p.mousePressed();
          }
        });
        attachEventHandler(curElement, "touchmove", function(e) {
          e.preventDefault();
          updateMousePosition(curElement, e.touches[0]);
          if (typeof p.mouseMoved === "function" && !p.__mousePressed) {
            p.mouseMoved();
          }
          if (typeof p.mouseDragged === "function" && p.__mousePressed) {
            p.mouseDragged();
            p.mouseDragging = true;
          }
        });
        attachEventHandler(curElement, "touchend", function(e) {
          p.__mousePressed = false;
          if (typeof p.mouseClicked === "function" && !p.mouseDragging) {
            p.mouseClicked();
          }
          if (typeof p.mouseReleased === "function") {
            p.mouseReleased();
          }
        });
      }
    });
    (function() {
      var enabled = true, contextMenu = function(e) {
        e.preventDefault();
        e.stopPropagation();
      };
      p.disableContextMenu = function() {
        if (!enabled) {
          return;
        }
        attachEventHandler(curElement, "contextmenu", contextMenu);
        enabled = false;
      };
      p.enableContextMenu = function() {
        if (enabled) {
          return;
        }
        detachEventHandler({ elem: curElement, type: "contextmenu", fn: contextMenu });
        enabled = true;
      };
    })();
    attachEventHandler(curElement, "mousemove", function(e) {
      updateMousePosition(curElement, e);
      if (typeof p.mouseMoved === "function" && !p.__mousePressed) {
        p.mouseMoved();
      }
      if (typeof p.mouseDragged === "function" && p.__mousePressed) {
        p.mouseDragged();
        p.mouseDragging = true;
      }
    });
    attachEventHandler(curElement, "mouseout", function(e) {
      if (typeof p.mouseOut === "function") {
        p.mouseOut();
      }
    });
    attachEventHandler(curElement, "mouseover", function(e) {
      updateMousePosition(curElement, e);
      if (typeof p.mouseOver === "function") {
        p.mouseOver();
      }
    });
    curElement.onmousedown = function() {
      curElement.focus();
      return false;
    };
    attachEventHandler(curElement, "mousedown", function(e) {
      p.__mousePressed = true;
      p.mouseDragging = false;
      switch (e.which) {
        case 1:
          p.mouseButton = PConstants3.LEFT;
          break;
        case 2:
          p.mouseButton = PConstants3.CENTER;
          break;
        case 3:
          p.mouseButton = PConstants3.RIGHT;
          break;
      }
      if (typeof p.mousePressed === "function") {
        p.mousePressed();
      }
    });
    attachEventHandler(curElement, "mouseup", function(e) {
      p.__mousePressed = false;
      if (typeof p.mouseClicked === "function" && !p.mouseDragging) {
        p.mouseClicked();
      }
      if (typeof p.mouseReleased === "function") {
        p.mouseReleased();
      }
    });
    var mouseWheelHandler = function(e) {
      if (e.target !== curElement) return;
      var delta = 0;
      if (e.wheelDelta) {
        delta = e.wheelDelta / 120;
        if (window.opera) {
          delta = -delta;
        }
      } else if (e.detail) {
        delta = -e.detail / 3;
      }
      p.mouseScroll = delta;
      if (delta && typeof p.mouseScrolled === "function") {
        e.stopPropagation();
        e.preventDefault();
        p.mouseScrolled();
      }
    };
    attachEventHandler(document2, "DOMMouseScroll", mouseWheelHandler);
    attachEventHandler(document2, "mousewheel", mouseWheelHandler);
  }

  // src/index.js
  var source = {
    virtEquals,
    virtHashCode,
    ObjectIterator,
    PConstants: PConstants_default,
    ArrayList: ArrayList_default,
    HashMap: HashMap_default,
    PVector: PVector_default,
    PFont: PFont_default,
    Char: Char_default,
    XMLAttribute: XMLAttribute_default,
    XMLElement: XMLElement_default,
    PMatrix2D: PMatrix2D_default,
    PMatrix3D: PMatrix3D_default,
    PShape: PShape_default,
    colors: webcolors_default,
    PShapeSVG: PShapeSVG_default,
    CommonFunctions: commonFunctions,
    defaultScope: defaultScope_default,
    Processing: Processing_default,
    setupParser,
    finalize: finalizeProcessing,
    Live2D
  };
  var withProxyFunctionsFn = JavaProxyFunctions_default(source.virtHashCode, source.virtEquals);
  source.extend = {
    withMath,
    withProxyFunctions: withProxyFunctionsFn,
    withTouch,
    withCommonFunctions: source.CommonFunctions().withCommonFunctions
  };
  function buildProcessingJS(Browser2, testHarness) {
    var noop = function() {
    }, virtEquals2 = source.virtEquals, virtHashCode2 = source.virtHashCode, PConstants3 = source.PConstants, CommonFunctions = source.CommonFunctions, ObjectIterator2 = source.ObjectIterator, Char2 = source.Char, XMLAttribute = source.XMLAttribute(), ArrayList = source.ArrayList({
      virtHashCode: virtHashCode2,
      virtEquals: virtEquals2
    }), HashMap3 = source.HashMap({
      virtHashCode: virtHashCode2,
      virtEquals: virtEquals2
    }), PVector3 = source.PVector({
      PConstants: PConstants3
    }), PFont3 = source.PFont({
      Browser: Browser2,
      noop
    }), XMLElement = source.XMLElement({
      Browser: Browser2,
      XMLAttribute
    }), PMatrix2D2 = source.PMatrix2D({
      p: CommonFunctions
    }), PMatrix3D2 = source.PMatrix3D({
      p: CommonFunctions
    }), PShape = source.PShape({
      PConstants: PConstants3,
      PMatrix2D: PMatrix2D2,
      PMatrix3D: PMatrix3D2
    }), PShapeSVG2 = source.PShapeSVG({
      CommonFunctions,
      PConstants: PConstants3,
      PShape,
      XMLElement,
      colors: source.colors
    }), defaultScope2 = source.defaultScope({
      ArrayList,
      HashMap: HashMap3,
      PVector: PVector3,
      PFont: PFont3,
      PShapeSVG: PShapeSVG2,
      ObjectIterator: ObjectIterator2,
      PConstants: PConstants3,
      Char: Char2,
      XMLElement,
      XML: XMLElement,
      Live2D: source.Live2D
    }), Processing3 = source.Processing({
      defaultScope: defaultScope2,
      Browser: Browser2,
      extend: source.extend,
      noop
    });
    Processing3 = source.setupParser(Processing3, {
      Browser: Browser2,
      aFunctions: testHarness,
      defaultScope: defaultScope2
    });
    Processing3 = source.finalize(Processing3, {
      version: "1.6.6+live2d",
      isDomPresent: Browser2.isDomPresent,
      window: Browser2.window,
      document: Browser2.document,
      noop
    });
    window.PFont = PFont3;
    return Processing3;
  }
  var src_default = buildProcessingJS;

  // src/Live2D/live2dcubismcore.js
  var Live2DCubismCore2;
  (function(Live2DCubismCore3) {
    var _csm = (
      /** @class */
      function() {
        function _csm2() {
        }
        _csm2.getVersion = function() {
          return _em.ccall("csmGetVersion", "number", [], []);
        };
        _csm2.getLatestMocVersion = function() {
          return _em.ccall("csmGetLatestMocVersion", "number", [], []);
        };
        _csm2.getMocVersion = function(moc, mocSize) {
          return _em.ccall("csmGetMocVersion", "number", ["number", "number"], [moc, mocSize]);
        };
        _csm2.getSizeofModel = function(moc) {
          return _em.ccall("csmGetSizeofModel", "number", ["number"], [moc]);
        };
        _csm2.reviveMocInPlace = function(memory, mocSize) {
          return _em.ccall("csmReviveMocInPlace", "number", ["number", "number"], [memory, mocSize]);
        };
        _csm2.initializeModelInPlace = function(moc, memory, modelSize) {
          return _em.ccall("csmInitializeModelInPlace", "number", ["number", "number", "number"], [moc, memory, modelSize]);
        };
        _csm2.hasMocConsistency = function(memory, mocSize) {
          return _em.ccall("csmHasMocConsistency", "number", ["number", "number"], [memory, mocSize]);
        };
        _csm2.getParameterCount = function(model) {
          return _em.ccall("csmGetParameterCount", "number", ["number"], [model]);
        };
        _csm2.getParameterIds = function(model) {
          return _em.ccall("csmGetParameterIds", "number", ["number"], [model]);
        };
        _csm2.getParameterMinimumValues = function(model) {
          return _em.ccall("csmGetParameterMinimumValues", "number", ["number"], [model]);
        };
        _csm2.getParameterTypes = function(model) {
          return _em.ccall("csmGetParameterTypes", "number", ["number"], [model]);
        };
        _csm2.getParameterMaximumValues = function(model) {
          return _em.ccall("csmGetParameterMaximumValues", "number", ["number"], [model]);
        };
        _csm2.getParameterDefaultValues = function(model) {
          return _em.ccall("csmGetParameterDefaultValues", "number", ["number"], [model]);
        };
        _csm2.getParameterValues = function(model) {
          return _em.ccall("csmGetParameterValues", "number", ["number"], [model]);
        };
        _csm2.getParameterKeyCounts = function(model) {
          return _em.ccall("csmGetParameterKeyCounts", "number", ["number"], [model]);
        };
        _csm2.getParameterKeyValues = function(model) {
          return _em.ccall("csmGetParameterKeyValues", "number", ["number"], [model]);
        };
        _csm2.getPartCount = function(model) {
          return _em.ccall("csmGetPartCount", "number", ["number"], [model]);
        };
        _csm2.getPartIds = function(model) {
          return _em.ccall("csmGetPartIds", "number", ["number"], [model]);
        };
        _csm2.getPartOpacities = function(model) {
          return _em.ccall("csmGetPartOpacities", "number", ["number"], [model]);
        };
        _csm2.getPartParentPartIndices = function(model) {
          return _em.ccall("csmGetPartParentPartIndices", "number", ["number"], [model]);
        };
        _csm2.getDrawableCount = function(model) {
          return _em.ccall("csmGetDrawableCount", "number", ["number"], [model]);
        };
        _csm2.getDrawableIds = function(model) {
          return _em.ccall("csmGetDrawableIds", "number", ["number"], [model]);
        };
        _csm2.getDrawableConstantFlags = function(model) {
          return _em.ccall("csmGetDrawableConstantFlags", "number", ["number"], [model]);
        };
        _csm2.getDrawableDynamicFlags = function(model) {
          return _em.ccall("csmGetDrawableDynamicFlags", "number", ["number"], [model]);
        };
        _csm2.getDrawableTextureIndices = function(model) {
          return _em.ccall("csmGetDrawableTextureIndices", "number", ["number"], [model]);
        };
        _csm2.getDrawableDrawOrders = function(model) {
          return _em.ccall("csmGetDrawableDrawOrders", "number", ["number"], [model]);
        };
        _csm2.getDrawableRenderOrders = function(model) {
          return _em.ccall("csmGetDrawableRenderOrders", "number", ["number"], [model]);
        };
        _csm2.getDrawableOpacities = function(model) {
          return _em.ccall("csmGetDrawableOpacities", "number", ["number"], [model]);
        };
        _csm2.getDrawableMaskCounts = function(model) {
          return _em.ccall("csmGetDrawableMaskCounts", "number", ["number"], [model]);
        };
        _csm2.getDrawableMasks = function(model) {
          return _em.ccall("csmGetDrawableMasks", "number", ["number"], [model]);
        };
        _csm2.getDrawableVertexCounts = function(model) {
          return _em.ccall("csmGetDrawableVertexCounts", "number", ["number"], [model]);
        };
        _csm2.getDrawableVertexPositions = function(model) {
          return _em.ccall("csmGetDrawableVertexPositions", "number", ["number"], [model]);
        };
        _csm2.getDrawableVertexUvs = function(model) {
          return _em.ccall("csmGetDrawableVertexUvs", "number", ["number"], [model]);
        };
        _csm2.getDrawableIndexCounts = function(model) {
          return _em.ccall("csmGetDrawableIndexCounts", "number", ["number"], [model]);
        };
        _csm2.getDrawableIndices = function(model) {
          return _em.ccall("csmGetDrawableIndices", "number", ["number"], [model]);
        };
        _csm2.getDrawableMultiplyColors = function(model) {
          return _em.ccall("csmGetDrawableMultiplyColors", "number", ["number"], [model]);
        };
        _csm2.getDrawableScreenColors = function(model) {
          return _em.ccall("csmGetDrawableScreenColors", "number", ["number"], [model]);
        };
        _csm2.getDrawableParentPartIndices = function(model) {
          return _em.ccall("csmGetDrawableParentPartIndices", "number", ["number"], [model]);
        };
        _csm2.mallocMoc = function(mocSize) {
          return _em.ccall("csmMallocMoc", "number", ["number"], [mocSize]);
        };
        _csm2.mallocModelAndInitialize = function(moc) {
          return _em.ccall("csmMallocModelAndInitialize", "number", ["number"], [moc]);
        };
        _csm2.malloc = function(size) {
          return _em.ccall("csmMalloc", "number", ["number"], [size]);
        };
        _csm2.setLogFunction = function(handler) {
          _em.ccall("csmSetLogFunction", null, ["number"], [handler]);
        };
        _csm2.updateModel = function(model) {
          _em.ccall("csmUpdateModel", null, ["number"], [model]);
        };
        _csm2.readCanvasInfo = function(model, outSizeInPixels, outOriginInPixels, outPixelsPerUnit) {
          _em.ccall("csmReadCanvasInfo", null, ["number", "number", "number", "number"], [model, outSizeInPixels, outOriginInPixels, outPixelsPerUnit]);
        };
        _csm2.resetDrawableDynamicFlags = function(model) {
          _em.ccall("csmResetDrawableDynamicFlags", null, ["number"], [model]);
        };
        _csm2.free = function(memory) {
          _em.ccall("csmFree", null, ["number"], [memory]);
        };
        _csm2.initializeAmountOfMemory = function(size) {
          _em.ccall("csmInitializeAmountOfMemory", null, ["number"], [size]);
        };
        return _csm2;
      }()
    );
    Live2DCubismCore3.AlignofMoc = 64;
    Live2DCubismCore3.AlignofModel = 16;
    Live2DCubismCore3.MocVersion_Unknown = 0;
    Live2DCubismCore3.MocVersion_30 = 1;
    Live2DCubismCore3.MocVersion_33 = 2;
    Live2DCubismCore3.MocVersion_40 = 3;
    Live2DCubismCore3.MocVersion_42 = 4;
    Live2DCubismCore3.MocVersion_50 = 5;
    Live2DCubismCore3.ParameterType_Normal = 0;
    Live2DCubismCore3.ParameterType_BlendShape = 1;
    ;
    var Version = (
      /** @class */
      function() {
        function Version2() {
        }
        Version2.csmGetVersion = function() {
          return _csm.getVersion();
        };
        Version2.csmGetLatestMocVersion = function() {
          return _csm.getLatestMocVersion();
        };
        Version2.csmGetMocVersion = function(moc, mocBytes) {
          return _csm.getMocVersion(moc._ptr, mocBytes.byteLength);
        };
        return Version2;
      }()
    );
    Live2DCubismCore3.Version = Version;
    var Logging = (
      /** @class */
      function() {
        function Logging2() {
        }
        Logging2.csmSetLogFunction = function(handler) {
          Logging2.logFunction = handler;
          var pointer = _em.addFunction(Logging2.wrapLogFunction, "vi");
          _csm.setLogFunction(pointer);
        };
        Logging2.csmGetLogFunction = function() {
          return Logging2.logFunction;
        };
        Logging2.wrapLogFunction = function(messagePtr) {
          var messageStr = _em.UTF8ToString(messagePtr);
          Logging2.logFunction(messageStr);
        };
        return Logging2;
      }()
    );
    Live2DCubismCore3.Logging = Logging;
    var Moc2 = (
      /** @class */
      function() {
        function Moc3(mocBytes) {
          var memory = _csm.mallocMoc(mocBytes.byteLength);
          if (!memory) {
            return;
          }
          var destination = new Uint8Array(_em.HEAPU8.buffer, memory, mocBytes.byteLength);
          destination.set(new Uint8Array(mocBytes));
          this._ptr = _csm.reviveMocInPlace(memory, mocBytes.byteLength);
          if (!this._ptr) {
            _csm.free(memory);
          }
        }
        Moc3.prototype.hasMocConsistency = function(mocBytes) {
          var memory = _csm.mallocMoc(mocBytes.byteLength);
          if (!memory) {
            return;
          }
          var destination = new Uint8Array(_em.HEAPU8.buffer, memory, mocBytes.byteLength);
          destination.set(new Uint8Array(mocBytes));
          var hasConsistency = _csm.hasMocConsistency(memory, mocBytes.byteLength);
          _csm.free(memory);
          return hasConsistency;
        };
        Moc3.fromArrayBuffer = function(buffer) {
          if (!buffer) {
            return null;
          }
          var moc = new Moc3(buffer);
          return moc._ptr ? moc : null;
        };
        Moc3.prototype._release = function() {
          _csm.free(this._ptr);
          this._ptr = 0;
        };
        return Moc3;
      }()
    );
    Live2DCubismCore3.Moc = Moc2;
    var Model = (
      /** @class */
      function() {
        function Model2(moc) {
          this._ptr = _csm.mallocModelAndInitialize(moc._ptr);
          if (!this._ptr) {
            return;
          }
          this.parameters = new Parameters(this._ptr);
          this.parts = new Parts(this._ptr);
          this.drawables = new Drawables(this._ptr);
          this.canvasinfo = new CanvasInfo(this._ptr);
        }
        Model2.fromMoc = function(moc) {
          var model = new Model2(moc);
          return model._ptr ? model : null;
        };
        Model2.prototype.update = function() {
          _csm.updateModel(this._ptr);
        };
        Model2.prototype.release = function() {
          _csm.free(this._ptr);
          this._ptr = 0;
        };
        return Model2;
      }()
    );
    Live2DCubismCore3.Model = Model;
    var CanvasInfo = (
      /** @class */
      /* @__PURE__ */ function() {
        function CanvasInfo2(modelPtr) {
          if (!modelPtr) {
            return;
          }
          var _canvasSize_data = new Float32Array(2);
          var _canvasSize_nDataBytes = _canvasSize_data.length * _canvasSize_data.BYTES_PER_ELEMENT;
          var _canvasSize_dataPtr = _csm.malloc(_canvasSize_nDataBytes);
          var _canvasSize_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasSize_dataPtr, _canvasSize_nDataBytes);
          _canvasSize_dataHeap.set(new Uint8Array(_canvasSize_data.buffer));
          var _canvasOrigin_data = new Float32Array(2);
          var _canvasOrigin_nDataBytes = _canvasOrigin_data.length * _canvasOrigin_data.BYTES_PER_ELEMENT;
          var _canvasOrigin_dataPtr = _csm.malloc(_canvasOrigin_nDataBytes);
          var _canvasOrigin_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasOrigin_dataPtr, _canvasOrigin_nDataBytes);
          _canvasOrigin_dataHeap.set(new Uint8Array(_canvasOrigin_data.buffer));
          var _canvasPPU_data = new Float32Array(1);
          var _canvasPPU_nDataBytes = _canvasPPU_data.length * _canvasPPU_data.BYTES_PER_ELEMENT;
          var _canvasPPU_dataPtr = _csm.malloc(_canvasPPU_nDataBytes);
          var _canvasPPU_dataHeap = new Uint8Array(_em.HEAPU8.buffer, _canvasPPU_dataPtr, _canvasPPU_nDataBytes);
          _canvasPPU_dataHeap.set(new Uint8Array(_canvasPPU_data.buffer));
          _csm.readCanvasInfo(modelPtr, _canvasSize_dataHeap.byteOffset, _canvasOrigin_dataHeap.byteOffset, _canvasPPU_dataHeap.byteOffset);
          _canvasSize_data = new Float32Array(_canvasSize_dataHeap.buffer, _canvasSize_dataHeap.byteOffset, _canvasSize_dataHeap.length);
          _canvasOrigin_data = new Float32Array(_canvasOrigin_dataHeap.buffer, _canvasOrigin_dataHeap.byteOffset, _canvasOrigin_dataHeap.length);
          _canvasPPU_data = new Float32Array(_canvasPPU_dataHeap.buffer, _canvasPPU_dataHeap.byteOffset, _canvasPPU_dataHeap.length);
          this.CanvasWidth = _canvasSize_data[0];
          this.CanvasHeight = _canvasSize_data[1];
          this.CanvasOriginX = _canvasOrigin_data[0];
          this.CanvasOriginY = _canvasOrigin_data[1];
          this.PixelsPerUnit = _canvasPPU_data[0];
          _csm.free(_canvasSize_dataHeap.byteOffset);
          _csm.free(_canvasOrigin_dataHeap.byteOffset);
          _csm.free(_canvasPPU_dataHeap.byteOffset);
        }
        return CanvasInfo2;
      }()
    );
    Live2DCubismCore3.CanvasInfo = CanvasInfo;
    var Parameters = (
      /** @class */
      /* @__PURE__ */ function() {
        function Parameters2(modelPtr) {
          var length = 0;
          var length2 = null;
          this.count = _csm.getParameterCount(modelPtr);
          length = _csm.getParameterCount(modelPtr);
          this.ids = new Array(length);
          var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getParameterIds(modelPtr), length);
          for (var i = 0; i < _ids.length; i++) {
            this.ids[i] = _em.UTF8ToString(_ids[i]);
          }
          length = _csm.getParameterCount(modelPtr);
          this.minimumValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterMinimumValues(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.types = new Int32Array(_em.HEAP32.buffer, _csm.getParameterTypes(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.maximumValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterMaximumValues(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.defaultValues = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterDefaultValues(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.values = new Float32Array(_em.HEAPF32.buffer, _csm.getParameterValues(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          this.keyCounts = new Int32Array(_em.HEAP32.buffer, _csm.getParameterKeyCounts(modelPtr), length);
          length = _csm.getParameterCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getParameterKeyCounts(modelPtr), length);
          this.keyValues = new Array(length);
          var _keyValues = new Uint32Array(_em.HEAPU32.buffer, _csm.getParameterKeyValues(modelPtr), length);
          for (var i = 0; i < _keyValues.length; i++) {
            this.keyValues[i] = new Float32Array(_em.HEAPF32.buffer, _keyValues[i], length2[i]);
          }
        }
        return Parameters2;
      }()
    );
    Live2DCubismCore3.Parameters = Parameters;
    var Parts = (
      /** @class */
      /* @__PURE__ */ function() {
        function Parts2(modelPtr) {
          var length = 0;
          this.count = _csm.getPartCount(modelPtr);
          length = _csm.getPartCount(modelPtr);
          this.ids = new Array(length);
          var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getPartIds(modelPtr), length);
          for (var i = 0; i < _ids.length; i++) {
            this.ids[i] = _em.UTF8ToString(_ids[i]);
          }
          length = _csm.getPartCount(modelPtr);
          this.opacities = new Float32Array(_em.HEAPF32.buffer, _csm.getPartOpacities(modelPtr), length);
          length = _csm.getPartCount(modelPtr);
          this.parentIndices = new Int32Array(_em.HEAP32.buffer, _csm.getPartParentPartIndices(modelPtr), length);
        }
        return Parts2;
      }()
    );
    Live2DCubismCore3.Parts = Parts;
    var Drawables = (
      /** @class */
      function() {
        function Drawables2(modelPtr) {
          this._modelPtr = modelPtr;
          var length = 0;
          var length2 = null;
          this.count = _csm.getDrawableCount(modelPtr);
          length = _csm.getDrawableCount(modelPtr);
          this.ids = new Array(length);
          var _ids = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableIds(modelPtr), length);
          for (var i = 0; i < _ids.length; i++) {
            this.ids[i] = _em.UTF8ToString(_ids[i]);
          }
          length = _csm.getDrawableCount(modelPtr);
          this.constantFlags = new Uint8Array(_em.HEAPU8.buffer, _csm.getDrawableConstantFlags(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.dynamicFlags = new Uint8Array(_em.HEAPU8.buffer, _csm.getDrawableDynamicFlags(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.textureIndices = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableTextureIndices(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.drawOrders = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableDrawOrders(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.renderOrders = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableRenderOrders(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.opacities = new Float32Array(_em.HEAPF32.buffer, _csm.getDrawableOpacities(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.maskCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableMaskCounts(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.vertexCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.indexCounts = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableIndexCounts(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          this.multiplyColors = new Float32Array(_em.HEAPF32.buffer, _csm.getDrawableMultiplyColors(modelPtr), length * 4);
          length = _csm.getDrawableCount(modelPtr);
          this.screenColors = new Float32Array(_em.HEAPF32.buffer, _csm.getDrawableScreenColors(modelPtr), length * 4);
          length = _csm.getDrawableCount(modelPtr);
          this.parentPartIndices = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableParentPartIndices(modelPtr), length);
          length = _csm.getDrawableCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableMaskCounts(modelPtr), length);
          this.masks = new Array(length);
          var _masks = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableMasks(modelPtr), length);
          for (var i = 0; i < _masks.length; i++) {
            this.masks[i] = new Int32Array(_em.HEAP32.buffer, _masks[i], length2[i]);
          }
          length = _csm.getDrawableCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
          this.vertexPositions = new Array(length);
          var _vertexPositions = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableVertexPositions(modelPtr), length);
          for (var i = 0; i < _vertexPositions.length; i++) {
            this.vertexPositions[i] = new Float32Array(_em.HEAPF32.buffer, _vertexPositions[i], length2[i] * 2);
          }
          length = _csm.getDrawableCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableVertexCounts(modelPtr), length);
          this.vertexUvs = new Array(length);
          var _vertexUvs = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableVertexUvs(modelPtr), length);
          for (var i = 0; i < _vertexUvs.length; i++) {
            this.vertexUvs[i] = new Float32Array(_em.HEAPF32.buffer, _vertexUvs[i], length2[i] * 2);
          }
          length = _csm.getDrawableCount(modelPtr);
          length2 = new Int32Array(_em.HEAP32.buffer, _csm.getDrawableIndexCounts(modelPtr), length);
          this.indices = new Array(length);
          var _indices = new Uint32Array(_em.HEAPU32.buffer, _csm.getDrawableIndices(modelPtr), length);
          for (var i = 0; i < _indices.length; i++) {
            this.indices[i] = new Uint16Array(_em.HEAPU16.buffer, _indices[i], length2[i]);
          }
        }
        Drawables2.prototype.resetDynamicFlags = function() {
          _csm.resetDrawableDynamicFlags(this._modelPtr);
        };
        return Drawables2;
      }()
    );
    Live2DCubismCore3.Drawables = Drawables;
    var Utils = (
      /** @class */
      function() {
        function Utils2() {
        }
        Utils2.hasBlendAdditiveBit = function(bitfield) {
          return (bitfield & 1 << 0) == 1 << 0;
        };
        Utils2.hasBlendMultiplicativeBit = function(bitfield) {
          return (bitfield & 1 << 1) == 1 << 1;
        };
        Utils2.hasIsDoubleSidedBit = function(bitfield) {
          return (bitfield & 1 << 2) == 1 << 2;
        };
        Utils2.hasIsInvertedMaskBit = function(bitfield) {
          return (bitfield & 1 << 3) == 1 << 3;
        };
        Utils2.hasIsVisibleBit = function(bitfield) {
          return (bitfield & 1 << 0) == 1 << 0;
        };
        Utils2.hasVisibilityDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 1) == 1 << 1;
        };
        Utils2.hasOpacityDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 2) == 1 << 2;
        };
        Utils2.hasDrawOrderDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 3) == 1 << 3;
        };
        Utils2.hasRenderOrderDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 4) == 1 << 4;
        };
        Utils2.hasVertexPositionsDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 5) == 1 << 5;
        };
        Utils2.hasBlendColorDidChangeBit = function(bitfield) {
          return (bitfield & 1 << 6) == 1 << 6;
        };
        return Utils2;
      }()
    );
    Live2DCubismCore3.Utils = Utils;
    var Memory = (
      /** @class */
      function() {
        function Memory2() {
        }
        Memory2.initializeAmountOfMemory = function(size) {
          if (size > 16777216) {
            _csm.initializeAmountOfMemory(size);
          }
        };
        return Memory2;
      }()
    );
    Live2DCubismCore3.Memory = Memory;
    var _em_module = function() {
      var _scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0;
      return function(_em_module2) {
        _em_module2 = _em_module2 || {};
        var b, n, l2 = {};
        for (n in b = b || (void 0 !== _em_module2 ? _em_module2 : {})) b.hasOwnProperty(n) && (l2[n] = b[n]);
        var x, y, v, w, p = false, q = false, r = false, p = "object" == typeof window, q = "function" == typeof importScripts, r = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node && !p && !q, t2 = !p && !r && !q, u = "", D = (r ? (u = __dirname + "/", v = function(a, c) {
          var d = z(a);
          return d || (x = x || __require("fs"), a = (y = y || __require("path")).normalize(a), d = x.readFileSync(a)), c ? d : d.toString();
        }, w = function(a) {
          return assert((a = (a = v(a, true)).buffer ? a : new Uint8Array(a)).buffer), a;
        }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(a) {
          throw a;
        }), process.on("unhandledRejection", B), b.inspect = function() {
          return "[Emscripten Module object]";
        }) : t2 ? ("undefined" != typeof read && (v = function(a) {
          var c = z(a);
          return c ? C(c) : read(a);
        }), w = function(a) {
          var c;
          if (!(c = z(a))) {
            if ("function" == typeof readbuffer) return new Uint8Array(readbuffer(a));
            assert("object" == typeof (c = read(a, "binary")));
          }
          return c;
        }, "undefined" != typeof print && ((console = "undefined" == typeof console ? {} : console).log = print, console.warn = console.error = "undefined" != typeof printErr ? printErr : print)) : (p || q) && (q ? u = self.location.href : document.currentScript && (u = document.currentScript.src), u = 0 !== (u = _scriptDir ? _scriptDir : u).indexOf("blob:") ? u.substr(0, u.lastIndexOf("/") + 1) : "", v = function(a) {
          try {
            var c = new XMLHttpRequest();
            return c.open("GET", a, false), c.send(null), c.responseText;
          } catch (d) {
            if (a = z(a)) return C(a);
            throw d;
          }
        }, q) && (w = function(a) {
          try {
            var c = new XMLHttpRequest();
            return c.open("GET", a, false), c.responseType = "arraybuffer", c.send(null), new Uint8Array(c.response);
          } catch (d) {
            if (a = z(a)) return a;
            throw d;
          }
        }), b.print || console.log.bind(console)), E = b.printErr || console.warn.bind(console);
        for (n in l2) l2.hasOwnProperty(n) && (b[n] = l2[n]);
        function da() {
          return { exports: function(asmLibraryArg, wasmMemory, wasmTable) {
            var scratchBuffer = new ArrayBuffer(8), b2 = new Int32Array(scratchBuffer), c = new Float32Array(scratchBuffer), d = new Float64Array(scratchBuffer);
            function f(index, value) {
              b2[index] = value;
            }
            function g() {
              return d[0];
            }
            function h(value) {
              d[0] = value;
            }
            function j(value) {
              c[0] = value;
            }
            function k() {
              return c[0];
            }
            scratchBuffer = wasmMemory.buffer, U2 = new Uint8Array(scratchBuffer);
            var U2, global, buffer2, m, n2, o, p2, q2, r2, s, t3, u2, v2, w2, x2, y2, z2, A, C2, H2, I2, J2, K2, L2, M2, scratchBuffer = function(offset, s2) {
              var V2, W2;
              if ("undefined" == typeof Buffer) for (V2 = atob(s2), W2 = 0; W2 < V2.length; W2++) U2[offset + W2] = V2.charCodeAt(W2);
              else for (V2 = Buffer.from(s2, "base64"), W2 = 0; W2 < V2.length; W2++) U2[offset + W2] = V2[W2];
            };
            return scratchBuffer(1024, "QW4gZXJyb3Igb2NjdXJyZWQgaW4gdGhlIGludGVycG9sYXRpb24gZm9yIGJsZW5kIHNoYXBlcy4gQ29tYmluYXRpb25Db3VudCBpcyAlZC4ACgBbQ1NNXSBbRV1XYXJwRGVmb3JtZXI6OlRyYW5zZm9ybVRhcmdldCgpIGVycm9yLiBbJWRdIHAwMT0oJS40ZiAsICUuNGYpCgBbQ1NNXSBbRV1Jbml0aWFsaXplRGVmb3JtZXJzKCk6IFVua25vd24gRGVmb3JtZXIgVHlwZS4KAFtDU01dIFtFXWNzbUhhc01vY0NvbnNpc3RlbmN5OiBUaGlzIG1vYzMgc2l6ZSBpcyBpbnZhbGlkLgoAW0NTTV0gW0VdJXM6ICVzCgBbQ1NNXSBbV11Sb3RhdGlvbkRlZm9ybWVyOiBOb3QgZm91bmQgdHJhbnNmb3JtZWQgRGlyZWN0aW9uLgoAW0NTTV0gW0VdVXBkYXRlRGVmb3JtZXJIaWVyYXJjaHkoKTogVW5rbm93biBEZWZvcm1lciBUeXBlLgoAJXMKACAgAE1PQzMAImFkZHJlc3MiIGlzIG51bGwuACUwMlggAFtDU01dIFtFXWNzbUhhc01vY0NvbnNpc3RlbmN5OiBGaWxlVHlwZSBpcyBpbnZhbGlkLgoAImFkZHJlc3MiIGFsaWdubWVudCBpcyBpbnZhbGlkLgBbQ1NNXSBbRV1jc21IYXNNb2NDb25zaXN0ZW5jeTogVGhpcyBtb2MzIHZlciBpcyBpbnZhbGlkIFt2ZXI6JWRdLgoAInNpemUiIGlzIGludmFsaWQuAFtDU01dIFtFXWNzbUhhc01vY0NvbnNpc3RlbmN5OiBUaGUgQ29yZSB1bnN1cHBvcnQgbGF0ZXIgdGhhbiBtb2MzIHZlcjpbJWRdLiBUaGlzIG1vYzMgdmVyIGlzIFslZF0uCgAibW9kZWwiIGlzIGludmFsaWQuAFtDU01dIFtFXWNzbUhhc01vY0NvbnNpc3RlbmN5OiBIZWFkZXIgc2VjdGlvbiBpcyBpbnZhbGlkLgoAIm91dFNpemVJblBpeGVscyIgaXMgbnVsbC4AW0NTTV0gW0VdY3NtSGFzTW9jQ29uc2lzdGVuY3k6IERhdGEgc2VjdGlvbiBpcyBpbnZhbGlkLgoAIm91dE9yaWdpbkluUGl4ZWxzIiBpcyBudWxsLgBbQ1NNXSBbRV1jc21SZXZpdmVNb2NJblBsYWNlIGlzIGZhaWxlZC4gQ29ycnVwdGVkICBtb2MzIGZpbGUuCgAib3V0UGl4ZWxzUGVyVW5pdCIgaXMgbnVsbC4AW0NTTV0gW0VdY3NtUmV2aXZlTW9jSW5QbGFjZSBpcyBmYWlsZWQuIFRoZSBDb3JlIHVuc3VwcG9ydCBsYXRlciB0aGFuIG1vYzMgdmVyOlslZF0uIFRoaXMgbW9jMyB2ZXIgaXMgWyVkXS4KACJtb2MiIGlzIGludmFsaWQuAFtDU01dIFtFXWNzbUdldE1vY1ZlcnNpb24gaXMgZmFpbGVkLiBDb3JydXB0ZWQgbW9jMyBmaWxlLgoAInNpemUiIGlzIGludmFsaWQATGl2ZTJEIEN1YmlzbSBTREsgQ29yZSBWZXJzaW9uICVkLiVkLiVkAGNzbUdldE1vY1ZlcnNpb24AY3NtSGFzTW9jQ29uc2lzdGVuY3kAY3NtUmV2aXZlTW9jSW5QbGFjZQBjc21SZWFkQ2FudmFzSW5mbwBjc21HZXRTaXplb2ZNb2RlbABjc21Jbml0aWFsaXplTW9kZWxJblBsYWNlAGNzbVVwZGF0ZU1vZGVsAGNzbUdldFBhcmFtZXRlckNvdW50AGNzbUdldFBhcmFtZXRlcklkcwBjc21HZXRQYXJhbWV0ZXJUeXBlcwBjc21HZXRQYXJhbWV0ZXJNaW5pbXVtVmFsdWVzAGNzbUdldFBhcmFtZXRlck1heGltdW1WYWx1ZXMAY3NtR2V0UGFyYW1ldGVyRGVmYXVsdFZhbHVlcwBjc21HZXRQYXJhbWV0ZXJWYWx1ZXMAY3NtR2V0UGFydENvdW50AGNzbUdldFBhcnRJZHMAY3NtR2V0UGFydE9wYWNpdGllcwBjc21HZXRQYXJ0UGFyZW50UGFydEluZGljZXMAY3NtR2V0RHJhd2FibGVDb3VudABjc21HZXREcmF3YWJsZUlkcwBjc21HZXREcmF3YWJsZUNvbnN0YW50RmxhZ3MAY3NtR2V0RHJhd2FibGVEeW5hbWljRmxhZ3MAY3NtR2V0RHJhd2FibGVUZXh0dXJlSW5kaWNlcwBjc21HZXREcmF3YWJsZURyYXdPcmRlcnMAY3NtR2V0RHJhd2FibGVSZW5kZXJPcmRlcnMAY3NtR2V0RHJhd2FibGVPcGFjaXRpZXMAY3NtR2V0RHJhd2FibGVNYXNrQ291bnRzAGNzbUdldERyYXdhYmxlTWFza3MAY3NtR2V0RHJhd2FibGVWZXJ0ZXhDb3VudHMAY3NtR2V0RHJhd2FibGVWZXJ0ZXhQb3NpdGlvbnMAY3NtR2V0RHJhd2FibGVWZXJ0ZXhVdnMAY3NtR2V0RHJhd2FibGVJbmRleENvdW50cwBjc21HZXREcmF3YWJsZUluZGljZXMAY3NtR2V0RHJhd2FibGVNdWx0aXBseUNvbG9ycwBjc21HZXREcmF3YWJsZVNjcmVlbkNvbG9ycwBjc21HZXREcmF3YWJsZVBhcmVudFBhcnRJbmRpY2VzAGNzbVJlc2V0RHJhd2FibGVEeW5hbWljRmxhZ3MAY3NtR2V0UGFyYW1ldGVyS2V5Q291bnRzAGNzbUdldFBhcmFtZXRlcktleVZhbHVlcw=="), scratchBuffer(3228, "Cg=="), scratchBuffer(3267, "//////8="), scratchBuffer(3336, "LSsgICAwWDB4AChudWxsKQ=="), scratchBuffer(3360, "EQAKABEREQAAAAAFAAAAAAAACQAAAAAL"), scratchBuffer(3392, "EQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERER"), scratchBuffer(3441, "Cw=="), scratchBuffer(3450, "EQAKChEREQAKAAACAAkLAAAACQALAAAL"), scratchBuffer(3499, "DA=="), scratchBuffer(3511, "DAAAAAAMAAAAAAkMAAAAAAAMAAAM"), scratchBuffer(3557, "Dg=="), scratchBuffer(3569, "DQAAAAQNAAAAAAkOAAAAAAAOAAAO"), scratchBuffer(3615, "EA=="), scratchBuffer(3627, "DwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhIS"), scratchBuffer(3682, "EgAAABISEgAAAAAAAAk="), scratchBuffer(3731, "Cw=="), scratchBuffer(3743, "CgAAAAAKAAAAAAkLAAAAAAALAAAL"), scratchBuffer(3789, "DA=="), scratchBuffer(3801, "DAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGLTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgAuAAAAAKgaAAAAAAAAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGA"), scratchBuffer(6675, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNThj7T7aD0k/Xph7P9oPyT9pN6wxaCEiM7QPFDNoIaIz2w9JP9sPSb/kyxZA5MsWwAAAAAAAAACA2w9JQNsPScAAAIA/AADAPwAAAADcz9E1AAAAAADAFT8="), scratchBuffer(6824, "BQ=="), scratchBuffer(6836, "DQ=="), scratchBuffer(6860, "DgAAAA8AAABYHAAAAAQ="), scratchBuffer(6884, "AQ=="), scratchBuffer(6899, "Cv////8="), scratchBuffer(7156, "gCA="), global = { Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array, NaN: NaN, Infinity: 1 / 0, Math }, scratchBuffer = asmLibraryArg, buffer2 = wasmMemory.buffer, m = scratchBuffer.memory, n2 = wasmTable, o = new global.Int8Array(buffer2), p2 = new global.Int16Array(buffer2), q2 = new global.Int32Array(buffer2), r2 = new global.Uint8Array(buffer2), s = new global.Uint16Array(buffer2), t3 = new global.Uint32Array(buffer2), u2 = new global.Float32Array(buffer2), v2 = new global.Float64Array(buffer2), w2 = global.Math.imul, x2 = global.Math.fround, y2 = global.Math.abs, z2 = global.Math.clz32, A = global.Math.min, global.Math.max, C2 = global.Math.floor, global.Math.ceil, global.Math.sqrt, scratchBuffer.abort, global.NaN, H2 = global.Infinity, I2 = scratchBuffer.a, J2 = scratchBuffer.b, K2 = scratchBuffer.c, L2 = 5251744, M2 = 0, n2[1] = function(a, Ln, Mn, Nn, On) {
              a |= 0, Ln |= 0, Mn |= 0, Nn |= 0, On |= 0;
              var Wn, ko, lo, oo, qo, ro, so, to, uo, vo, wo, xo, yo, zo, Ao, Bo, Co, Do, Eo, Fo, Go, Ho, Io, po, Pn = 0, Qn = x2(0), Rn = x2(0), Sn = 0, Tn = x2(0), Un = x2(0), Vn = x2(0), Xn = x2(0), Yn = x2(0), Zn = x2(0), _n = x2(0), $n = x2(0), ao = x2(0), bo = x2(0), co = x2(0), eo = x2(0), fo = x2(0), go = x2(0), ho = x2(0), io = x2(0), jo = x2(0), mo = x2(0), no = x2(0), Jo = (x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), 0);
              if (L2 = po = L2 - 32 | 0, 1 <= (0 | On)) {
                for (Wn = q2[16 + (q2[a + 308 >> 2] + (Ln << 5) | 0) >> 2], Pn = q2[a + 60 >> 2] + w2(Wn, 24) | 0, Ln = (ko = q2[Pn + 8 >> 2]) + -1 | 0, xo = (qo = q2[Pn + 4 >> 2]) + -1 | 0, yo = uo = (Wn = q2[q2[a + 152 >> 2] + (Wn << 2) >> 2]) + (ko << 3) | 0, zo = vo = Wn + ((to = w2(qo, lo = ko + 1 | 0)) << 3) | 0, Ao = wo = Wn + (ko + to << 3) | 0, Io = q2[Pn + 12 >> 2], ro = x2(0 | qo), so = x2(0 | ko), a = 0; ; ) if (Vn = u2[(Pn = (oo = a << 3) + Mn | 0) + 4 >> 2], Rn = x2(Vn * ro), Xn = u2[Pn >> 2], Qn = x2(Xn * so), Pn = Vn >= x2(1), Rn = !(Vn < x2(0) ^ 1) || Pn | Xn >= x2(1) | Xn < x2(0) ? (Jo || (ao = u2[4 + Ao >> 2], Bo = u2[Wn + 4 >> 2], Yn = x2(ao - Bo), Co = u2[4 + yo >> 2], Do = u2[4 + zo >> 2], Zn = x2(Co - Do), bo = x2(x2(Yn - Zn) * x2(0.5)), Eo = u2[wo >> 2], Fo = u2[Wn >> 2], _n = x2(Eo - Fo), Go = u2[uo >> 2], Ho = u2[vo >> 2], $n = x2(Go - Ho), co = x2(x2(_n - $n) * x2(0.5)), Zn = x2(x2(Zn + Yn) * x2(0.5)), $n = x2(x2($n + _n) * x2(0.5)), Jo = 1, Yn = x2(x2(x2(x2(x2(Bo + Co) + Do) + ao) * x2(0.25)) - x2(Yn * x2(0.5))), _n = x2(x2(x2(x2(x2(Fo + Go) + Ho) + Eo) * x2(0.25)) - x2(_n * x2(0.5)))), Vn < x2(3) ^ 1 | Xn > x2(-2) ^ 1 | (Xn < x2(3) ^ 1 | Vn > x2(-2) ^ 1) ? (u2[Nn + oo >> 2] = x2(Vn * co) + x2(x2(Xn * $n) + _n), Qn = x2(Vn * bo), x2(x2(Xn * Zn) + Yn)) : (Xn <= x2(0) ? Vn <= x2(0) ? (Un = x2(x2(Vn + x2(2)) * x2(0.5)), Tn = x2(x2(Xn + x2(2)) * x2(0.5)), Qn = x2(bo + bo), mo = x2(Yn - Qn), Rn = x2(co + co), no = x2(_n - Rn), io = x2(Yn - x2(Zn + Zn)), eo = x2(io - Qn), jo = x2(_n - x2($n + $n)), fo = x2(jo - Rn), go = u2[Wn + 4 >> 2], ho = u2[Wn >> 2]) : Pn ? (Qn = x2(bo * x2(3)), Rn = x2(Yn - x2(Zn + Zn)), io = x2(Qn + Rn), eo = x2(co * x2(3)), fo = x2(_n - x2($n + $n)), jo = x2(eo + fo), Un = x2(x2(Vn + x2(-1)) * x2(0.5)), Tn = x2(x2(Xn + x2(2)) * x2(0.5)), go = x2(Qn + Yn), ho = x2(eo + _n), eo = x2(bo + Rn), fo = x2(co + fo), mo = u2[4 + zo >> 2], no = u2[vo >> 2]) : (Qn = x2(Yn - x2(Zn + Zn)), Pn = xo, Sn = x2(y2(Rn)) < x2(2147483648) ? ~~Rn : -2147483648, Un = x2(0 | (Pn = (0 | Sn) == (0 | qo) ? Pn : Sn)), Tn = x2(Un / ro), eo = x2(x2(Tn * bo) + Qn), ao = x2(Tn * co), Tn = x2(_n - x2($n + $n)), fo = x2(ao + Tn), Vn = x2(x2(0 | (Sn = Pn + 1 | 0)) / ro), io = x2(x2(Vn * bo) + Qn), jo = x2(x2(Vn * co) + Tn), Tn = x2(x2(Xn + x2(2)) * x2(0.5)), Un = x2(Rn - Un), Pn = Wn + (w2(Pn, lo) << 3) | 0, mo = u2[Pn + 4 >> 2], no = u2[Pn >> 2], Pn = Wn + (w2(Sn, lo) << 3) | 0, go = u2[Pn + 4 >> 2], ho = u2[Pn >> 2]) : Xn >= x2(1) ? Vn <= x2(0) ? (Un = x2(x2(Vn + x2(2)) * x2(0.5)), Tn = x2(x2(Xn + x2(-1)) * x2(0.5)), Qn = x2(bo + bo), eo = x2(x2(Zn + Yn) - Qn), Rn = x2(co + co), fo = x2(x2($n + _n) - Rn), go = x2(x2(Zn * x2(3)) + Yn), mo = x2(go - Qn), ho = x2(x2($n * x2(3)) + _n), no = x2(ho - Rn), io = u2[4 + yo >> 2], jo = u2[uo >> 2]) : Pn ? (Qn = x2(bo * x2(3)), io = x2(Qn + x2(Zn + Yn)), Rn = x2(co * x2(3)), jo = x2(Rn + x2($n + _n)), ao = Qn, Qn = x2(x2(Zn * x2(3)) + Yn), go = x2(ao + Qn), ao = Rn, Rn = x2(x2($n * x2(3)) + _n), ho = x2(ao + Rn), Un = x2(x2(Vn + x2(-1)) * x2(0.5)), Tn = x2(x2(Xn + x2(-1)) * x2(0.5)), mo = x2(bo + Qn), no = x2(co + Rn), eo = u2[4 + Ao >> 2], fo = u2[wo >> 2]) : (Qn = x2(x2(Zn * x2(3)) + Yn), Pn = xo, Sn = x2(y2(Rn)) < x2(2147483648) ? ~~Rn : -2147483648, Un = x2(0 | (Pn = (0 | Sn) == (0 | qo) ? Pn : Sn)), Tn = x2(Un / ro), mo = x2(x2(Tn * bo) + Qn), ao = x2(Tn * co), Tn = x2(x2($n * x2(3)) + _n), no = x2(ao + Tn), Vn = x2(x2(0 | (Sn = Pn + 1 | 0)) / ro), go = x2(x2(Vn * bo) + Qn), ho = x2(x2(Vn * co) + Tn), Tn = x2(x2(Xn + x2(-1)) * x2(0.5)), Un = x2(Rn - Un), Pn = Wn + (w2(Pn, lo) + ko << 3) | 0, eo = u2[Pn + 4 >> 2], fo = u2[Pn >> 2], Pn = Wn + (w2(Sn, lo) + ko << 3) | 0, io = u2[Pn + 4 >> 2], jo = u2[Pn >> 2]) : Vn <= x2(0) ? (Un = x2(x2(Vn + x2(2)) * x2(0.5)), Pn = Ln, Sn = x2(y2(Rn = Qn)) < x2(2147483648) ? ~~Qn : -2147483648, Qn = x2(0 | (Pn = (0 | Sn) == (0 | ko) ? Pn : Sn)), Tn = x2(Rn - Qn), Qn = x2(Qn / so), Rn = x2(bo + bo), eo = x2(x2(x2(Qn * Zn) + Yn) - Rn), ao = x2(x2(Qn * $n) + _n), Qn = x2(co + co), fo = x2(ao - Qn), Vn = x2(x2(0 | (Sn = Pn + 1 | 0)) / so), mo = x2(x2(x2(Vn * Zn) + Yn) - Rn), no = x2(x2(x2(Vn * $n) + _n) - Qn), io = u2[(Pn = Wn + (Pn << 3) | 0) + 4 >> 2], jo = u2[Pn >> 2], go = u2[(Pn = Wn + (Sn << 3) | 0) + 4 >> 2], ho = u2[Pn >> 2]) : Pn ? (ao = Rn = x2(bo * x2(3)), Pn = Ln, Sn = x2(y2(Qn)) < x2(2147483648) ? ~~Qn : -2147483648, Tn = x2(0 | (Pn = (0 | Sn) == (0 | ko) ? Pn : Sn)), Un = x2(Tn / so), io = x2(ao + x2(x2(Un * Zn) + Yn)), Xn = x2(co * x2(3)), jo = x2(Xn + x2(x2(Un * $n) + _n)), ao = Rn, Rn = x2(x2(0 | (Sn = Pn + 1 | 0)) / so), go = x2(ao + x2(x2(Rn * Zn) + Yn)), ho = x2(Xn + x2(x2(Rn * $n) + _n)), Un = x2(x2(Vn + x2(-1)) * x2(0.5)), Tn = x2(Qn - Tn), eo = u2[(Pn = Wn + (Pn + to << 3) | 0) + 4 >> 2], fo = u2[Pn >> 2], mo = u2[(Pn = Wn + (Sn + to << 3) | 0) + 4 >> 2], no = u2[Pn >> 2]) : (v2[16 + po >> 3] = Vn, q2[po >> 2] = a, v2[8 + po >> 3] = Xn, Y3(4, 1107, po)), x2(Tn + Un) <= x2(1) ? (u2[Nn + oo >> 2] = x2(fo + x2(x2(no - fo) * Tn)) + x2(x2(jo - fo) * Un), Qn = x2(eo + x2(x2(mo - eo) * Tn)), x2(x2(io - eo) * Un)) : (Qn = x2(x2(1) - Tn), Rn = x2(x2(1) - Un), u2[Nn + oo >> 2] = x2(ho + x2(x2(jo - ho) * Qn)) + x2(x2(no - ho) * Rn), Qn = x2(go + x2(x2(io - go) * Qn)), x2(x2(mo - go) * Rn)))) : (Pn = x2(y2(ao = Rn)) < x2(2147483648) ? ~~Rn : -2147483648, Un = x2(ao - x2(0 | Pn)), Sn = x2(y2(Rn = Qn)) < x2(2147483648) ? ~~Qn : -2147483648, Tn = x2(Rn - x2(0 | Sn)), Pn = Sn + w2(Pn, lo) | 0, Io ? (Qn = x2(x2(1) - Un), Rn = x2(x2(1) - Tn), Sn = Wn + (Pn << 3) | 0, Pn = Wn + (Pn + lo << 3) | 0, u2[Nn + oo >> 2] = x2(x2(x2(Qn * x2(Rn * u2[Sn >> 2])) + x2(Qn * x2(Tn * u2[Sn + 8 >> 2]))) + x2(Un * x2(Rn * u2[Pn >> 2]))) + x2(Un * x2(Tn * u2[Pn + 8 >> 2])), Qn = x2(x2(x2(Qn * x2(Rn * u2[Sn + 4 >> 2])) + x2(Qn * x2(Tn * u2[Sn + 12 >> 2]))) + x2(Un * x2(Rn * u2[Pn + 4 >> 2]))), x2(Un * x2(Tn * u2[Pn + 12 >> 2]))) : x2(Tn + Un) <= x2(1) ? (Qn = x2(x2(x2(1) - Tn) - Un), Sn = Wn + (Pn << 3) | 0, Pn = Wn + (Pn + lo << 3) | 0, u2[Nn + oo >> 2] = x2(x2(Qn * u2[Sn >> 2]) + x2(Tn * u2[Sn + 8 >> 2])) + x2(Un * u2[Pn >> 2]), Qn = x2(x2(Qn * u2[Sn + 4 >> 2]) + x2(Tn * u2[Sn + 12 >> 2])), x2(Un * u2[Pn + 4 >> 2])) : (Qn = x2(x2(Tn + x2(-1)) + Un), Sn = Wn + (Pn + lo << 3) | 0, Rn = x2(x2(1) - Tn), Vn = x2(x2(1) - Un), Pn = Wn + (Pn << 3) | 0, u2[Nn + oo >> 2] = x2(x2(Qn * u2[Sn + 8 >> 2]) + x2(Rn * u2[Sn >> 2])) + x2(Vn * u2[Pn + 8 >> 2]), Qn = x2(x2(Qn * u2[Sn + 12 >> 2]) + x2(Rn * u2[Sn + 4 >> 2])), x2(Vn * u2[Pn + 12 >> 2]))), u2[4 + (Nn + oo | 0) >> 2] = Qn + Rn, (0 | On) == (0 | (a = a + 1 | 0))) break;
              }
              L2 = 32 + po | 0;
            }, n2[2] = function(a, mh) {
              a |= 0, mh |= 0;
              var Dh = 0, Eh = 0, Fh = 0, Gh = 0, Hh = 0, Ih = x2(0), Jh = 0, Kh = 0, Mh = (x2(0), 0), Nh = 0, Gh = q2[a + 320 >> 2], Dh = q2[a + 316 >> 2], Hh = q2[a + 308 >> 2];
              -1 == (0 | (Eh = q2[(Fh = Hh + (mh << 5) | 0) + 8 >> 2])) ? (q2[(Nh = Dh) + (Dh = mh << 2) >> 2] = q2[q2[a + 148 >> 2] + (q2[Fh + 16 >> 2] << 2) >> 2], q2[Dh + Gh >> 2] = 1065353216) : (Jh = q2[Fh + 16 >> 2], Kh = q2[q2[a + 152 >> 2] + (Jh << 2) >> 2], n2[q2[24 + (Hh + (Eh << 5) | 0) >> 2]](a, Eh, Kh, Kh, q2[16 + (q2[a + 60 >> 2] + w2(Jh, 24) | 0) >> 2]), Ih = u2[q2[a + 148 >> 2] + (q2[Fh + 16 >> 2] << 2) >> 2], Fh = q2[Fh + 8 >> 2] << 2, u2[(Eh = mh << 2) + Dh >> 2] = Ih * u2[Fh + Dh >> 2], q2[Eh + Gh >> 2] = q2[Fh + Gh >> 2]), 4 <= r2[q2[a >> 2] + 4 | 0] && (Gh = mh << 2, Dh = q2[a + 308 >> 2] + (mh << 5) | 0, Eh = q2[Dh + 16 >> 2] << 2, Fh = q2[a + 328 >> 2], mh = q2[a + 324 >> 2], -1 == (0 | (Hh = q2[Dh + 8 >> 2])) ? (Hh = q2[a + 156 >> 2], q2[(Dh = Gh << 2) + mh >> 2] = q2[Hh + (Eh <<= 2) >> 2], q2[(Jh = 4 | Dh) + mh >> 2] = q2[(Kh = 4 | Eh) + Hh >> 2], q2[(Mh = 8 | Dh) + mh >> 2] = q2[Hh + (Nh = 8 | Eh) >> 2], q2[mh + ((Gh |= 3) << 2) >> 2] = 1065353216, a = q2[a + 160 >> 2], q2[Dh + Fh >> 2] = q2[a + Eh >> 2], q2[Fh + Jh >> 2] = q2[a + Kh >> 2], q2[Fh + Mh >> 2] = q2[a + Nh >> 2]) : (Eh = (Kh = Eh << 2) + q2[a + 156 >> 2] | 0, u2[(Dh = (Jh = Gh << 2) + mh | 0) >> 2] = u2[Eh >> 2] * u2[(Hh = (Mh = Hh << 4) + mh | 0) >> 2], u2[Dh + 4 >> 2] = u2[Eh + 4 >> 2] * u2[Hh + 4 >> 2], u2[Dh + 8 >> 2] = u2[Eh + 8 >> 2] * u2[Hh + 8 >> 2], q2[mh + ((Gh |= 3) << 2) >> 2] = 1065353216, a = Kh + q2[a + 160 >> 2] | 0, Nh = u2[a >> 2], Ih = u2[(Dh = Fh + Mh | 0) >> 2], u2[(mh = Fh + Jh | 0) >> 2] = x2(Nh + Ih) - x2(Nh * Ih), Nh = u2[a + 4 >> 2], Ih = u2[Dh + 4 >> 2], u2[mh + 4 >> 2] = x2(Nh + Ih) - x2(Nh * Ih), Nh = u2[a + 8 >> 2], Ih = u2[Dh + 8 >> 2], u2[mh + 8 >> 2] = x2(Nh + Ih) - x2(Nh * Ih)), q2[Fh + (Gh << 2) >> 2] = 1065353216);
            }, n2[3] = function(a, Sm, un, xn, yn) {
              a |= 0, Sm |= 0, un |= 0, xn |= 0, yn |= 0;
              var Dn, En, Fn, Hn, In, zn = 0, zn = (x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), x2(0), (Sm = q2[16 + (q2[a + 308 >> 2] + (Sm << 5) | 0) >> 2]) << 2), Bn = function(a2) {
                var El, Hl, Fl, Dl = x2(0), Gl = 0;
                L2 = Fl = L2 - 16 | 0, j(a2);
                a: if ((El = 2147483647 & (Gl = b2[0])) >>> 0 <= 1061752794) Dl = x2(1), El >>> 0 < 964689920 || (Dl = ba(+a2));
                else if (El >>> 0 <= 1081824209) Hl = +a2, Dl = 1075235812 <= El >>> 0 ? x2(-ba(((0 | Gl) < 0 ? 3.141592653589793 : -3.141592653589793) + Hl)) : aa((0 | Gl) <= -1 ? 1.5707963267948966 + Hl : 1.5707963267948966 - Hl);
                else if (El >>> 0 <= 1088565717) Dl = 1085271520 <= El >>> 0 ? ba(+a2 + ((0 | Gl) < 0 ? 6.283185307179586 : -6.283185307179586)) : aa((0 | Gl) <= -1 ? -4.71238898038469 - +a2 : +a2 - 4.71238898038469);
                else if (Dl = x2(a2 - a2), !(2139095040 <= El >>> 0)) if ((El = 3 & Da(a2, 8 + Fl | 0)) >>> 0 <= 2) {
                  b: switch (El - 1 | 0) {
                    default:
                      Dl = ba(v2[8 + Fl >> 3]);
                      break a;
                    case 0:
                      Dl = aa(-v2[8 + Fl >> 3]);
                      break a;
                    case 1:
                      break b;
                  }
                  Dl = x2(-ba(v2[8 + Fl >> 3]));
                } else Dl = aa(v2[8 + Fl >> 3]);
                return L2 = 16 + Fl | 0, a2 = Dl;
              }(An = x2(x2(x2(u2[4 + (q2[a + 168 >> 2] + w2(Sm, 12) | 0) >> 2] + u2[zn + q2[a + 284 >> 2] >> 2]) * x2(3.1415927410125732)) / x2(180))), Cn = u2[zn + q2[a + 272 >> 2] >> 2], Gn = q2[zn + q2[a + 292 >> 2] >> 2], An = function(a2) {
                var Vk, Al, Bl = 0, Cl = 0;
                L2 = Al = L2 - 16 | 0, j(a2);
                a: if ((Vk = 2147483647 & (Cl = b2[0])) >>> 0 <= 1061752794) Vk >>> 0 < 964689920 || (a2 = aa(+a2));
                else if (Vk >>> 0 <= 1081824209) Bl = +a2, a2 = Vk >>> 0 <= 1075235811 ? (0 | Cl) <= -1 ? x2(-ba(Bl + 1.5707963267948966)) : ba(Bl + -1.5707963267948966) : aa(-(((0 | Cl) < 0 ? 3.141592653589793 : -3.141592653589793) + Bl));
                else if (Vk >>> 0 <= 1088565717) Bl = +a2, a2 = Vk >>> 0 <= 1085271519 ? (0 | Cl) <= -1 ? ba(Bl + 4.71238898038469) : x2(-ba(Bl + -4.71238898038469)) : aa(((0 | Cl) < 0 ? 6.283185307179586 : -6.283185307179586) + Bl);
                else if (2139095040 <= Vk >>> 0) a2 = x2(a2 - a2);
                else if ((Vk = 3 & Da(a2, 8 + Al | 0)) >>> 0 <= 2) {
                  b: switch (Vk - 1 | 0) {
                    default:
                      a2 = aa(v2[8 + Al >> 3]);
                      break a;
                    case 0:
                      a2 = ba(v2[8 + Al >> 3]);
                      break a;
                    case 1:
                      break b;
                  }
                  a2 = aa(-v2[8 + Al >> 3]);
                } else a2 = x2(-ba(v2[8 + Al >> 3]));
                return L2 = 16 + Al | 0, a2;
              }(An);
              if ((Sm = 0) < (0 | yn)) {
                for (Bn = x2(Cn * Bn), En = x2(Gn ? -1 : 1), Hn = x2(Bn * En), Dn = q2[zn + q2[a + 288 >> 2] >> 2] ? x2(-1) : x2(1), In = x2(x2(Cn * An) * Dn), Bn = x2(Bn * Dn), Cn = x2(x2(Cn * x2(-An)) * En), An = u2[zn + q2[a + 280 >> 2] >> 2], En = u2[zn + q2[a + 276 >> 2] >> 2]; ; ) if (zn = (a = Sm << 3) + xn | 0, Dn = u2[(a = a + un | 0) >> 2], Fn = u2[a + 4 >> 2], u2[zn + 4 >> 2] = An + x2(x2(In * Dn) + x2(Hn * Fn)), u2[zn >> 2] = En + x2(x2(Bn * Dn) + x2(Cn * Fn)), (0 | yn) == (0 | (Sm = Sm + 1 | 0))) break;
              }
            }, n2[4] = function(a, mh) {
              a |= 0, mh |= 0;
              var yh, zh, Ah, Bh, Ch, nh, oh = 0, ph = 0, qh = 0, rh = x2(0), sh = 0, th = 0, uh = x2(0), vh = 0, wh = 0, xh = 0;
              if (x2(0), x2(0), x2(0), x2(0), L2 = nh = L2 + -64 | 0, vh = q2[a + 320 >> 2], wh = q2[a + 316 >> 2], ph = q2[a + 308 >> 2], -1 == (0 | (sh = q2[(qh = ph + (mh << 5) | 0) + 8 >> 2]))) oh = q2[qh + 16 >> 2] << 2, q2[(ph = mh << 2) + wh >> 2] = q2[oh + q2[a + 268 >> 2] >> 2], q2[ph + vh >> 2] = q2[oh + q2[a + 272 >> 2] >> 2];
              else {
                oh = q2[qh + 16 >> 2] << 2, xh = q2[oh + q2[a + 276 >> 2] >> 2], q2[24 + nh >> 2] = xh, oh = q2[oh + q2[a + 280 >> 2] >> 2], q2[28 + nh >> 2] = oh, q2[16 + nh >> 2] = 0, zh = 1 == q2[(th = ph + (sh << 5) | 0) + 12 >> 2] ? x2(-10) : x2(-0.10000000149011612), u2[20 + nh >> 2] = zh, q2[60 + nh >> 2] = oh, q2[56 + nh >> 2] = xh, n2[q2[th + 24 >> 2]](a, sh, 56 + nh | 0, 48 + nh | 0, 1), rh = x2(1), ph = 9;
                b: {
                  for (; ; ) {
                    if (oh = ph, uh = x2(rh * x2(0)), u2[32 + nh >> 2] = uh + u2[56 + nh >> 2], yh = x2(zh * rh), u2[36 + nh >> 2] = yh + u2[60 + nh >> 2], n2[q2[th + 24 >> 2]](a, sh, 32 + nh | 0, 40 + nh | 0, 1), Ah = x2(u2[44 + nh >> 2] - u2[52 + nh >> 2]), u2[44 + nh >> 2] = Ah, Bh = x2(u2[40 + nh >> 2] - u2[48 + nh >> 2]), u2[40 + nh >> 2] = Bh, Ah != x2(0) || Bh != x2(0)) {
                      ph = q2[44 + nh >> 2], q2[8 + nh >> 2] = q2[40 + nh >> 2], q2[12 + nh >> 2] = ph;
                      break b;
                    }
                    if (u2[32 + nh >> 2] = u2[56 + nh >> 2] - uh, u2[36 + nh >> 2] = u2[60 + nh >> 2] - yh, n2[q2[th + 24 >> 2]](a, sh, 32 + nh | 0, 40 + nh | 0, 1), uh = x2(u2[40 + nh >> 2] - u2[48 + nh >> 2]), u2[40 + nh >> 2] = uh, yh = x2(u2[44 + nh >> 2] - u2[52 + nh >> 2]), (u2[44 + nh >> 2] = yh) != x2(0) || uh != x2(0)) {
                      u2[12 + nh >> 2] = -yh, u2[8 + nh >> 2] = -uh;
                      break b;
                    }
                    if (ph = oh + -1 | 0, rh = x2(rh * x2(0.10000000149011612)), !oh) break;
                  }
                  Y3(3, 1311, 0);
                }
                rh = function(a2, ji) {
                  var ki = x2(0);
                  if ((ki = x2(Ba2(u2[a2 + 4 >> 2], u2[a2 >> 2]) - Ba2(u2[ji + 4 >> 2], u2[ji >> 2]))) < x2(-3.1415927410125732)) {
                    for (; ; ) if (!((ki = x2(ki + x2(6.2831854820251465))) < x2(-3.1415927410125732))) break;
                  }
                  if (ki > x2(3.1415927410125732)) {
                    for (; ; ) if (!((ki = x2(ki + x2(-6.2831854820251465))) > x2(3.1415927410125732))) break;
                  }
                  return ki;
                }(16 + nh | 0, 8 + nh | 0), n2[q2[th + 24 >> 2]](a, q2[qh + 8 >> 2], 24 + nh | 0, 24 + nh | 0, 1), ph = q2[qh + 16 >> 2] << 2, q2[ph + q2[a + 276 >> 2] >> 2] = q2[24 + nh >> 2], q2[ph + q2[a + 280 >> 2] >> 2] = q2[28 + nh >> 2], oh = ph + q2[a + 284 >> 2] | 0, u2[oh >> 2] = u2[oh >> 2] + x2(x2(rh * x2(-180)) / x2(3.1415927410125732)), qh = q2[qh + 8 >> 2] << 2, u2[(oh = mh << 2) + wh >> 2] = u2[ph + q2[a + 268 >> 2] >> 2] * u2[qh + wh >> 2], ph = ph + q2[a + 272 >> 2] | 0, rh = x2(u2[ph >> 2] * u2[qh + vh >> 2]), u2[oh + vh >> 2] = rh, u2[ph >> 2] = rh;
              }
              4 <= r2[q2[a >> 2] + 4 | 0] && (oh = mh << 2, qh = q2[a + 308 >> 2] + (mh << 5) | 0, sh = q2[qh + 16 >> 2] << 2, ph = q2[a + 328 >> 2], mh = q2[a + 324 >> 2], -1 == (0 | (th = q2[qh + 8 >> 2])) ? (th = q2[a + 296 >> 2], q2[(qh = oh << 2) + mh >> 2] = q2[th + (sh <<= 2) >> 2], q2[(vh = 4 | qh) + mh >> 2] = q2[(wh = 4 | sh) + th >> 2], q2[(xh = 8 | qh) + mh >> 2] = q2[th + (Ch = 8 | sh) >> 2], q2[mh + ((oh |= 3) << 2) >> 2] = 1065353216, a = q2[a + 300 >> 2], q2[ph + qh >> 2] = q2[a + sh >> 2], q2[ph + vh >> 2] = q2[a + wh >> 2], q2[ph + xh >> 2] = q2[a + Ch >> 2]) : (sh = (wh = sh << 2) + q2[a + 296 >> 2] | 0, u2[(qh = (vh = oh << 2) + mh | 0) >> 2] = u2[sh >> 2] * u2[(th = (xh = th << 4) + mh | 0) >> 2], u2[qh + 4 >> 2] = u2[sh + 4 >> 2] * u2[th + 4 >> 2], u2[qh + 8 >> 2] = u2[sh + 8 >> 2] * u2[th + 8 >> 2], q2[mh + ((oh |= 3) << 2) >> 2] = 1065353216, a = wh + q2[a + 300 >> 2] | 0, rh = u2[a >> 2], uh = u2[(qh = ph + xh | 0) >> 2], u2[(mh = ph + vh | 0) >> 2] = x2(rh + uh) - x2(rh * uh), rh = u2[a + 4 >> 2], uh = u2[qh + 4 >> 2], u2[mh + 4 >> 2] = x2(rh + uh) - x2(rh * uh), rh = u2[a + 8 >> 2], uh = u2[qh + 8 >> 2], u2[mh + 8 >> 2] = x2(rh + uh) - x2(rh * uh)), q2[ph + (oh << 2) >> 2] = 1065353216), L2 = nh + 64 | 0;
            }, n2[5] = function(a, Vk) {
              return a |= 0, Vk |= 0, x2(0), x2(0), 0 | ((a = u2[a >> 2]) < (Vk = u2[Vk >> 2]) ? -1 : Vk < a);
            }, n2[6] = function(a, vj, xj, yj) {
              a |= 0, vj |= 0, xj |= 0, yj |= 0;
              var Vj = 0, Wj = 0, Xj = x2(0), Yj = 0, Zj = 0, _j = 0, $j = 0, ak = 0;
              if (1 <= (0 | (Yj = q2[a + 8 >> 2]))) {
                for (_j = q2[a + 12 >> 2], Zj = q2[a + 20 >> 2]; ; ) if (u2[(Wj = Vj << 2) + _j >> 2] = u2[vj + Wj >> 2] * u2[Wj + Zj >> 2], !((0 | (Vj = Vj + 1 | 0)) < (0 | Yj))) break;
              }
              if (!((0 | (Yj = q2[a >> 2])) < 1)) if (_j = q2[a + 4 >> 2], yj) for (Wj = vj = 0; ; ) {
                if (q2[yj >> 2]) {
                  if ((0 | (Vj = q2[(Zj = vj << 2) + q2[a + 16 >> 2] >> 2])) < 1) Xj = x2(0);
                  else for ($j = Vj + Wj | 0, ak = q2[a + 12 >> 2], Xj = x2(0), Vj = Wj; ; ) if (Xj = x2(Xj + u2[ak + (Vj << 2) >> 2]), !((0 | (Vj = Vj + 1 | 0)) < (0 | $j))) break;
                  u2[xj + Zj >> 2] = Xj;
                }
                if (yj = yj + 4 | 0, Wj = q2[_j + (vj << 2) >> 2] + Wj | 0, !((0 | (vj = vj + 1 | 0)) < (0 | Yj))) break;
              }
              else for (Zj = q2[a + 16 >> 2], vj = yj = 0; ; ) {
                if ((0 | (Vj = q2[(Wj = yj << 2) + Zj >> 2])) <= 0) Xj = x2(0);
                else for ($j = vj + Vj | 0, ak = q2[a + 12 >> 2], Xj = x2(0), Vj = vj; ; ) if (Xj = x2(Xj + u2[ak + (Vj << 2) >> 2]), !((0 | (Vj = Vj + 1 | 0)) < (0 | $j))) break;
                if (u2[xj + Wj >> 2] = Xj, vj = q2[Wj + _j >> 2] + vj | 0, !((0 | (yj = yj + 1 | 0)) < (0 | Yj))) break;
              }
            }, n2[7] = function(a, vj, xj, yj) {
              a |= 0, vj |= 0, xj |= 0, yj |= 0;
              var zj = 0, Aj = x2(0), Qj = 0, Rj = 0, Sj = 0, Tj = 0, Uj = 0;
              if (1 <= (0 | (Tj = q2[a + 8 >> 2]))) {
                for (Rj = q2[a + 12 >> 2], Sj = q2[a + 20 >> 2]; ; ) if (u2[(Qj = zj << 2) + Rj >> 2] = u2[vj + Qj >> 2] * u2[Qj + Sj >> 2], !((0 | (zj = zj + 1 | 0)) < (0 | Tj))) break;
              }
              if (!((0 | (zj = q2[a >> 2])) < 1)) if (Tj = q2[a + 4 >> 2], yj) for (Qj = vj = 0; ; ) {
                if (q2[yj >> 2]) {
                  if ((0 | (zj = q2[(Rj = vj << 2) + q2[a + 16 >> 2] >> 2])) < 1) Aj = x2(0);
                  else for (Sj = zj + Qj | 0, Uj = q2[a + 12 >> 2], Aj = x2(0), zj = Qj; ; ) if (Aj = x2(Aj + u2[Uj + (zj << 2) >> 2]), !((0 | (zj = zj + 1 | 0)) < (0 | Sj))) break;
                  zj = xj + Rj | 0, Aj = x2(Aj + x2(0.0010000000474974513)), Rj = x2(y2(Aj)) < x2(2147483648) ? ~~Aj : -2147483648, q2[zj >> 2] = Rj, zj = q2[a >> 2];
                }
                if (yj = yj + 4 | 0, Qj = q2[Tj + (vj << 2) >> 2] + Qj | 0, !((0 | (vj = vj + 1 | 0)) < (0 | zj))) break;
              }
              else for (Rj = q2[a + 16 >> 2], vj = yj = 0; ; ) {
                if ((0 | (zj = q2[(Qj = yj << 2) + Rj >> 2])) <= 0) Aj = x2(0);
                else for (Sj = vj + zj | 0, Uj = q2[a + 12 >> 2], Aj = x2(0), zj = vj; ; ) if (Aj = x2(Aj + u2[Uj + (zj << 2) >> 2]), !((0 | (zj = zj + 1 | 0)) < (0 | Sj))) break;
                if (zj = xj + Qj | 0, Aj = x2(Aj + x2(0.0010000000474974513)), Sj = x2(y2(Aj)) < x2(2147483648) ? ~~Aj : -2147483648, q2[zj >> 2] = Sj, vj = q2[Qj + Tj >> 2] + vj | 0, !((0 | (yj = yj + 1 | 0)) < q2[a >> 2])) break;
              }
            }, n2[8] = function(a, vj, xj, yj, zj, Aj) {
              a |= 0, vj |= 0, xj |= 0, yj |= 0, zj |= 0, Aj |= 0;
              var Oj, Pj, Bj = 0, Cj = 0, Dj = 0, Ej = 0, Fj = 0, Gj = 0, Hj = 0, Ij = 0, Kj = 0, Lj = 0, Mj = x2(0), Nj = 0, Jj = q2[a >> 2];
              if (!((0 | Jj) < 1)) if (Oj = zj << 2, Pj = q2[a + 4 >> 2], Aj) for (; ; ) {
                if (q2[Aj >> 2] && (Dj = q2[(Bj = Ej << 2) + q2[a + 16 >> 2] >> 2], Hj = q2[xj + Bj >> 2], Cj = q2[yj + Bj >> 2], (Bj = (0 | (Ij = w2(Cj, zj))) < 1) || ca2(Hj, 0, w2(Cj, Oj)), !(Bj | (0 | Dj) < 1))) for (Kj = Dj + Gj | 0, Lj = q2[a + 20 >> 2], Bj = Gj; ; ) {
                  for (Mj = u2[(Cj = Bj << 2) + Lj >> 2], Nj = q2[vj + Cj >> 2], Fj = 0; ; ) if (u2[(Cj = (Dj = Fj << 2) + Hj | 0) >> 2] = u2[Cj >> 2] + x2(Mj * u2[Dj + Nj >> 2]), (0 | Ij) == (0 | (Fj = Fj + 1 | 0))) break;
                  if (!((0 | (Bj = Bj + 1 | 0)) < (0 | Kj))) break;
                }
                if (Aj = Aj + 4 | 0, Gj = q2[(Ej << 2) + Pj >> 2] + Gj | 0, !((0 | (Ej = Ej + 1 | 0)) < (0 | Jj))) break;
              }
              else for (Aj = 0; ; ) {
                if (Dj = q2[(Ej = Aj << 2) + q2[a + 16 >> 2] >> 2], Hj = q2[xj + Ej >> 2], Cj = q2[yj + Ej >> 2], (Bj = (0 | (Ij = w2(Cj, zj))) < 1) || ca2(Hj, 0, w2(Cj, Oj)), !(Bj | (0 | Dj) <= 0)) for (Kj = Dj + Gj | 0, Lj = q2[a + 20 >> 2], Bj = Gj; ; ) {
                  for (Mj = u2[(Cj = Bj << 2) + Lj >> 2], Nj = q2[vj + Cj >> 2], Fj = 0; ; ) if (u2[(Cj = (Dj = Fj << 2) + Hj | 0) >> 2] = u2[Cj >> 2] + x2(Mj * u2[Dj + Nj >> 2]), (0 | Ij) == (0 | (Fj = Fj + 1 | 0))) break;
                  if (!((0 | (Bj = Bj + 1 | 0)) < (0 | Kj))) break;
                }
                if (Gj = q2[Ej + Pj >> 2] + Gj | 0, !((0 | (Aj = Aj + 1 | 0)) < (0 | Jj))) break;
              }
            }, n2[9] = function(a) {
              a |= 0;
              var Me, Ne, Oe, Ie = 0, Je = 0, Ke = 0, Le = 0;
              if (!(q2[a + 648 >> 2] || (0 | (Ie = q2[a + 332 >> 2])) < 1)) for (Ne = (Je = q2[a + 336 >> 2]) + w2(Ie, 20) | 0, Ie = q2[a + 424 >> 2], Le = q2[a + 444 >> 2]; ; ) {
                if (q2[Ie >> 2] && !((0 | (Ke = q2[Je + 16 >> 2])) < (a = 1))) {
                  for (Ke <<= 1, Oe = q2[Le >> 2]; ; ) if (u2[(Me = (a << 2) + Oe | 0) >> 2] = -u2[Me >> 2], !((0 | (a = a + 2 | 0)) < (0 | Ke))) break;
                }
                if (Le = Le + 4 | 0, Ie = Ie + 4 | 0, !((Je = Je + 20 | 0) >>> 0 < Ne >>> 0)) break;
              }
            }, n2[10] = function(a, Sm, un) {
              var wn;
              return $(wn = q2[(a |= 0) + 20 >> 2], Sm |= 0, Sm = (un |= 0) >>> 0 < (Sm = q2[a + 16 >> 2] - wn | 0) >>> 0 ? un : Sm), q2[a + 20 >> 2] = Sm + q2[a + 20 >> 2], 0 | un;
            }, n2[11] = function(a, Il, Rm, Sm, Tm, Um) {
              a |= 0, Il = +Il, Rm |= 0, Sm |= 0, Tm |= 0, Um |= 0;
              var fn, qn, Zm, Vm = 0, Wm = 0, Xm = 0, Ym = 0, _m = 0, $m = 0, an = 0, bn = 0, cn = 0, dn = 0, en = 0, gn = 0, hn = 0, jn = 0, kn = 0, mn = 0;
              if (q2[44 + (L2 = Zm = L2 - 560 | 0) >> 2] = 0, h(+Il), Vm = 0 | b2[1], qn = 4294967295 < b2[0] >>> 0 ? 0 : 1, kn = (0 | Vm) < -1 || ((0 | Vm) <= -1 ? qn : 0) ? (h(+(Il = -Il)), Vm = 0 | b2[1], b2[0], jn = 1, 3840) : 2048 & Tm ? (jn = 1, 3843) : (jn = 1 & Tm) ? 3846 : 3841, 2146435072 == (2146435072 & Vm)) _(a, 32, Rm, $m = jn + 3 | 0, -65537 & Tm), Z2(a, kn, jn), Sm = Um >>> 5 & 1, Z2(a, Il != Il ? Sm ? 3867 : 3871 : Sm ? 3859 : 3863, 3);
              else if (Il = function Ja(a2, ic) {
                var kc, lc, jc = 0;
                if (h(+a2), jc = 0 | b2[1], kc = 0 | b2[0], 2047 != (0 | (jc = (lc = jc) >>> 20 & 2047))) {
                  if (!jc) return jc = ic, ic = 0 == a2 ? 0 : (a2 = Ja(18446744073709552e3 * a2, ic), q2[ic >> 2] + -64 | 0), q2[jc >> 2] = ic, a2;
                  q2[ic >> 2] = jc + -1022, f(0, 0 | kc), f(1, -2146435073 & lc | 1071644672), a2 = +g();
                }
                return a2;
              }(Il, 44 + Zm | 0), 0 != (Il += Il) && (q2[44 + Zm >> 2] = q2[44 + Zm >> 2] + -1), fn = 16 + Zm | 0, 97 == (0 | (qn = 32 | Um))) {
                if (en = (dn = 32 & Um) ? kn + 9 | 0 : kn, !(11 < Sm >>> 0) && (Vm = 12 - Sm | 0)) {
                  for (gn = 8; ; ) if (gn *= 16, !(Vm = Vm + -1 | 0)) break;
                  Il = 45 == r2[0 | en] ? -(gn + (-Il - gn)) : Il + gn - gn;
                }
                for ((0 | fn) == (0 | (Vm = ga((Xm = (Vm = q2[44 + Zm >> 2]) >> 31) ^ Vm + Xm, 0, fn))) && (o[15 + Zm | 0] = 48, Vm = 15 + Zm | 0), _m = 2 | jn, Xm = q2[44 + Zm >> 2], o[0 | (cn = Vm + -2 | 0)] = Um + 15, o[Vm + -1 | 0] = (0 | Xm) < 0 ? 45 : 43, Vm = 8 & Tm, Wm = 16 + Zm | 0; ; ) if (Um = Wm, bn = dn, Xm = y2(Il) < 2147483648 ? ~~Il : -2147483648, o[0 | Wm] = bn | r2[Xm + 3824 | 0], 1 != ((Wm = Um + 1 | 0) - (16 + Zm | 0) | 0) | (0 == (Il = 16 * (Il - (0 | Xm))) ? !(Vm | 0 < (0 | Sm)) : 0) || (o[Um + 1 | 0] = 46, Wm = Um + 2 | 0), 0 == Il) break;
                _(a, 32, Rm, $m = (Um = !Sm | (0 | Sm) <= ((Wm - Zm | 0) - 18 | 0) ? ((fn - (16 + Zm | 0) | 0) - cn | 0) + Wm | 0 : 2 + ((Sm + fn | 0) - cn | 0) | 0) + _m | 0, Tm), Z2(a, en, _m), _(a, 48, Rm, $m, 65536 ^ Tm), Z2(a, 16 + Zm | 0, Sm = Wm - (16 + Zm | 0) | 0), _(a, 48, Um - ((Vm = Sm) + (Sm = fn - cn | 0) | 0) | 0, 0, 0), Z2(a, cn, Sm);
              } else {
                for (Vm = (0 | Sm) < 0, 0 == Il ? Ym = q2[44 + Zm >> 2] : (Ym = q2[44 + Zm >> 2] + -28 | 0, q2[44 + Zm >> 2] = Ym, Il *= 268435456), an = Vm ? 6 : Sm, Xm = dn = (0 | Ym) < 0 ? 48 + Zm | 0 : 336 + Zm | 0; ; ) if (Xm = (Sm = Xm) + 4 | 0, 0 == (Il = 1e9 * (Il - ((q2[Sm >> 2] = Vm = Il < 4294967296 & 0 <= Il ? ~~Il >>> 0 : 0) >>> 0)))) break;
                if ((0 | Ym) < 1) Vm = Xm, Wm = dn;
                else for (Wm = dn; ; ) {
                  if (cn = (0 | Ym) < 29 ? Ym : 29, !((Vm = Xm + -4 | 0) >>> 0 < Wm >>> 0)) {
                    for (Sm = cn, bn = 0; ; ) if (mn = bn, bn = q2[(en = Vm) >> 2], _m = 31 & Sm, _m = 32 <= (63 & Sm) >>> ($m = 0) ? (Ym = bn << _m, 0) : (Ym = (1 << _m) - 1 & bn >>> 32 - _m, bn << _m), $m = Ym + $m | 0, $m = (bn = mn + _m | 0) >>> 0 < _m >>> 0 ? $m + 1 | 0 : $m, mn = en, en = ad(bn = bd(_m = bn, $m, 1e9), M2, 1e9), q2[mn >> 2] = _m - en, !(Wm >>> 0 <= (Vm = Vm + -4 | 0) >>> 0)) break;
                    (Sm = bn) && (q2[(Wm = Wm + -4 | 0) >> 2] = Sm);
                  }
                  for (; ; ) if (!(Wm >>> 0 < (Vm = Xm) >>> 0) || q2[(Xm = Vm + -4 | 0) >> 2]) break;
                  if (Ym = q2[44 + Zm >> 2] - cn | 0, Xm = Vm, !(0 < (0 | (q2[44 + Zm >> 2] = Ym)))) break;
                }
                if ((0 | Ym) <= -1) for (hn = 1 + ((an + 25 | 0) / 9 | 0) | 0, cn = 102 == (0 | qn); ; ) {
                  if (bn = (0 | Ym) < -9 ? 9 : 0 - Ym | 0, Vm >>> 0 <= Wm >>> 0) Wm = q2[Wm >> 2] ? Wm : Wm + 4 | 0;
                  else {
                    for (en = 1e9 >>> bn, _m = -1 << bn ^ -1, Ym = 0, Xm = Wm; ; ) if (Sm = q2[Xm >> 2], q2[Xm >> 2] = (Sm >>> bn) + Ym, Ym = w2(en, Sm & _m), !((Xm = Xm + 4 | 0) >>> 0 < Vm >>> 0)) break;
                    Wm = q2[Wm >> 2] ? Wm : Wm + 4 | 0, Ym && (q2[Vm >> 2] = Ym, Vm = Vm + 4 | 0);
                  }
                  if (Ym = bn + q2[44 + Zm >> 2] | 0, Vm = (0 | hn) < Vm - (Sm = cn ? dn : Wm) >> 2 ? Sm + (hn << 2) | 0 : Vm, !((0 | (q2[44 + Zm >> 2] = Ym)) < 0)) break;
                }
                if (!(Vm >>> (Xm = 0) <= Wm >>> 0 || (Xm = w2(dn - Wm >> 2, 9), (Sm = q2[Wm >> 2]) >>> 0 < (Ym = 10)))) {
                  for (; ; ) if (Xm = Xm + 1 | 0, !((Ym = w2(Ym, 10)) >>> 0 <= Sm >>> 0)) break;
                }
                if ((0 | (Sm = (an - (102 == (0 | qn) ? 0 : Xm) | 0) - (103 == (0 | qn) & 0 != (0 | an)) | 0)) < (w2(Vm - dn >> 2, 9) + -9 | 0)) {
                  if ($m = (dn + ((Sm = (0 | (_m = Sm + 9216 | 0)) / 9 | 0) << 2) | 0) - 4092 | 0, Ym = 10, (0 | (Sm = 1 + (_m - w2(Sm, 9) | 0) | 0)) <= 8) {
                    for (; ; ) if (Ym = w2(Ym, 10), 9 == (0 | (Sm = Sm + 1 | 0))) break;
                  }
                  if (hn = $m + 4 | 0, ((cn = (en = q2[$m >> 2]) - w2(Ym, _m = (en >>> 0) / (Ym >>> 0) | 0) | 0) || (0 | hn) != (0 | Vm)) && (gn = cn >>> 0 < (Sm = Ym >>> 1) >>> 0 ? 0.5 : (0 | Vm) == (0 | hn) && (0 | Sm) == (0 | cn) ? 1 : 1.5, Il = 1 & _m ? 9007199254740994 : 9007199254740992, !jn | 45 != r2[0 | kn] || (gn = -gn, Il = -Il), q2[$m >> 2] = Sm = en - cn | 0, Il + gn != Il)) {
                    if (1e9 <= (q2[$m >> 2] = Sm = Sm + Ym | 0) >>> 0) {
                      for (; ; ) if (($m = $m + -4 | (q2[$m >> 2] = 0)) >>> 0 < Wm >>> 0 && (q2[(Wm = Wm + -4 | 0) >> 2] = 0), Sm = q2[$m >> 2] + 1 | 0, !(999999999 < (q2[$m >> 2] = Sm) >>> 0)) break;
                    }
                    if (Xm = w2(dn - Wm >> 2, 9), !((Sm = q2[Wm >> 2]) >>> 0 < (Ym = 10))) {
                      for (; ; ) if (Xm = Xm + 1 | 0, !((Ym = w2(Ym, 10)) >>> 0 <= Sm >>> 0)) break;
                    }
                  }
                  Vm = (Sm = $m + 4 | 0) >>> 0 < Vm >>> 0 ? Sm : Vm;
                }
                j: {
                  for (; ; ) {
                    if ((cn = Vm) >>> (en = 0) <= Wm >>> 0) break j;
                    if (q2[(Vm = cn + -4 | 0) >> 2]) break;
                  }
                  en = 1;
                }
                if (103 != (0 | qn)) _m = 8 & Tm;
                else if (an = ((Sm = (0 | Xm) < (0 | (Vm = an || 1)) & -5 < (0 | Xm)) ? -1 ^ Xm : -1) + Vm | 0, Um = (Sm ? -1 : -2) + Um | 0, !(_m = 8 & Tm)) {
                  if (Vm = 9, en && (_m = q2[cn + -4 >> 2]) && !((_m >>> (Vm = 0)) % (Sm = 10))) {
                    for (; ; ) if (Vm = Vm + 1 | 0, (_m >>> 0) % ((Sm = w2(Sm, 10)) >>> 0)) break;
                  }
                  Sm = w2(cn - dn >> 2, 9) + -9 | 0, an = 102 == (32 | Um) ? ((_m = 0) | an) < (0 | (Sm = 0 < (0 | (Sm = Sm - Vm | 0)) ? Sm : 0)) ? an : Sm : ((_m = 0) | an) < (0 | (Sm = 0 < (0 | (Sm = (Sm + Xm | 0) - Vm | 0)) ? Sm : 0)) ? an : Sm;
                }
                if ($m = 0 != (0 | (Ym = an | _m)), Sm = a, mn = Rm, Vm = 0 < (0 | Xm) ? Xm : 0, 102 != (0 | (bn = 32 | Um))) {
                  if ((fn - (Vm = ga((Vm = Xm >> 31) + Xm ^ Vm, 0, fn)) | 0) <= 1) {
                    for (; ; ) if (o[0 | (Vm = Vm + -1 | 0)] = 48, !((fn - Vm | 0) < 2)) break;
                  }
                  o[0 | (hn = Vm + -2 | 0)] = Um, o[Vm + -1 | 0] = (0 | Xm) < 0 ? 45 : 43, Vm = fn - hn | 0;
                }
                if (_(Sm, 32, mn, $m = 1 + (Vm + ($m + (an + jn | 0) | 0) | 0) | 0, Tm), Z2(a, kn, jn), _(a, 48, Rm, $m, 65536 ^ Tm), 102 == (0 | bn)) {
                  for (Sm = 16 + Zm | 8, Xm = 16 + Zm | 9, Wm = Um = dn >>> 0 < Wm >>> 0 ? dn : Wm; ; ) {
                    if (Vm = ga(q2[Wm >> 2], 0, Xm), (0 | Um) != (0 | Wm)) {
                      if (!(Vm >>> 0 <= 16 + Zm >>> 0)) {
                        for (; ; ) if (o[0 | (Vm = Vm + -1 | 0)] = 48, !(16 + Zm >>> 0 < Vm >>> 0)) break;
                      }
                    } else (0 | Vm) == (0 | Xm) && (o[24 + Zm | 0] = 48, Vm = Sm);
                    if (Z2(a, Vm, Xm - Vm | 0), !((Wm = Wm + 4 | 0) >>> 0 <= dn >>> 0)) break;
                  }
                  Ym && Z2(a, 3875, 1);
                  p: if (!((0 | an) < 1 | cn >>> 0 <= Wm >>> 0)) for (; ; ) {
                    if (16 + Zm >>> 0 < (Vm = ga(q2[Wm >> 2], 0, Xm)) >>> 0) {
                      for (; ; ) if (o[0 | (Vm = Vm + -1 | 0)] = 48, !(16 + Zm >>> 0 < Vm >>> 0)) break;
                    }
                    if (Z2(a, Vm, (0 | an) < 9 ? an : 9), an = an + -9 | 0, cn >>> 0 <= (Wm = Wm + 4 | 0) >>> 0) break p;
                    if (!(0 < (0 | an))) break;
                  }
                  _(a, 48, an + 9 | 0, 9, 0);
                } else {
                  q: if (!((0 | an) < 0)) for (Um = en ? cn : Wm + 4 | 0, Sm = 16 + Zm | 8, dn = 16 + Zm | 9, Xm = Wm; ; ) {
                    if ((0 | dn) == (0 | (Vm = ga(q2[Xm >> 2], 0, dn))) && (o[24 + Zm | 0] = 48, Vm = Sm), (0 | Wm) != (0 | Xm)) {
                      if (!(Vm >>> 0 <= 16 + Zm >>> 0)) {
                        for (; ; ) if (o[0 | (Vm = Vm + -1 | 0)] = 48, !(16 + Zm >>> 0 < Vm >>> 0)) break;
                      }
                    } else Z2(a, Vm, 1), Vm = Vm + 1 | 0, (0 | an) < 1 && !_m || Z2(a, 3875, 1);
                    if (Z2(a, bn = Vm, (0 | (Vm = dn - Vm | 0)) < (0 | an) ? Vm : an), an = an - Vm | 0, Um >>> 0 <= (Xm = Xm + 4 | 0) >>> 0) break q;
                    if (!(-1 < (0 | an))) break;
                  }
                  _(a, 48, an + 18 | 0, 18, 0), Z2(a, hn, fn - hn | 0);
                }
              }
              return _(a, 32, Rm, $m, 8192 ^ Tm), L2 = 560 + Zm | 0, 0 | ((0 | $m) < (0 | Rm) ? Rm : $m);
            }, n2[12] = function(a, Il) {
              a |= 0;
              var tm = 0, tm = Il |= 0;
              Il = q2[Il >> 2] + 15 & -16, q2[tm >> 2] = Il + 16, tm = a, a = Cc(q2[Il >> 2], q2[Il + 4 >> 2], q2[Il + 8 >> 2], q2[Il + 12 >> 2]), v2[tm >> 3] = a;
            }, n2[13] = function(a) {
              return 0;
            }, n2[14] = function(a, Il, tm) {
              Il |= 0, tm |= 0;
              var Om, Cm, Bm = 0, Lm = 0, Mm = 0, Nm = 0;
              for (L2 = Cm = L2 - 32 | 0, Bm = q2[(a |= 0) + 28 >> 2], q2[16 + Cm >> 2] = Bm, Mm = q2[a + 20 >> 2], q2[28 + Cm >> 2] = tm, q2[24 + Cm >> 2] = Il, Mm = (q2[20 + Cm >> 2] = Il = Mm - Bm | 0) + tm | 0, Nm = 2, Il = 16 + Cm | 0; ; ) {
                a: {
                  if ((Lm = (Bm = 0) | K2(q2[a + 60 >> 2], 0 | Il, 0 | Nm, 12 + Cm | 0)) && (q2[2086] = Lm, Bm = -1), (0 | (Bm = Bm ? q2[12 + Cm >> 2] = -1 : q2[12 + Cm >> 2])) == (0 | Mm)) Il = q2[a + 44 >> 2], q2[a + 28 >> 2] = Il, q2[a + 20 >> 2] = Il, q2[a + 16 >> 2] = Il + q2[a + 48 >> 2], a = tm;
                  else {
                    if (-1 < (0 | Bm)) break a;
                    q2[a + 28 >> 2] = 0, q2[a + 16 >> 2] = 0, q2[a + 20 >> 2] = 0, q2[a >> 2] = 32 | q2[a >> 2], 2 != ((a = 0) | Nm) && (a = tm - q2[Il + 4 >> 2] | 0);
                  }
                  return L2 = 32 + Cm | 0, 0 | a;
                }
                Lm = q2[Il + 4 >> 2], q2[(Il = (Om = Lm >>> 0 < Bm >>> 0) ? Il + 8 | 0 : Il) >> 2] = (Lm = Bm - (Om ? Lm : 0) | 0) + q2[Il >> 2], q2[Il + 4 >> 2] = q2[Il + 4 >> 2] - Lm, Mm = Mm - Bm | 0, Nm = Nm - Om | 0;
              }
            }, n2[15] = function(a, Il, tm, Bm) {
              return M2 = 0;
            }, { d: function() {
            }, e: function() {
              return 83886080;
            }, f: function() {
              return 5;
            }, g: function(a, vj) {
              return vj |= 0, L2 = vj = L2 - 16 | 0, a = (a |= 0) ? sa(a) ? (Y3(4, 2150, 0), 0) : r2[a + 4 | 0] : (q2[vj + 4 >> 2] = 1444, q2[vj >> 2] = 2267, Y3(4, 1294, vj), 0), L2 = vj + 16 | 0, 0 | a;
            }, h: function(a, vj) {
              var wj;
              return vj |= 0, L2 = wj = L2 - 48 | 0, a = (a |= 0) ? (a + 63 & -64) != (0 | a) ? (q2[36 + wj >> 2] = 1522, q2[32 + wj >> 2] = 2284, Y3(4, 1294, 32 + wj | 0), 0) : (vj + 63 & -64) == (0 | vj) && vj ? function(a2, Vk) {
                var Wk = 0, Xk = 0, Yk = 0, Zk = 0, _k = 0, $k = 0, al = 0, bl = 0, cl = 0, dl = 0, el = 0, fl = 0, gl = 0, hl = 0, il = 0, jl = 0, kl = 0, ll = 0, ml = 0, nl = 0, ol = 0, pl = 0;
                L2 = _k = (pl = Xk = L2) - 704 & -64;
                a: if (Vk >>> 0 <= 1343) Y3(4, 1235, 0);
                else if (sa(a2)) Y3(4, 1469, 0);
                else if (Xk = r2[0 | (nl = a2 + 4 | 0)]) {
                  if (!(6 <= Xk >>> 0)) {
                    (jl = 1 == (0 | !r2[a2 + 5 | 0])) || (da2(nl, 1), X3(a2 - -64 | 0, 4, 160)), ca2(_k - -64 | 0, 0, 640), na2(a2, _k - -64 | 0), Xk = a2 + Vk | 0, Vk = q2[_k + 64 >> 2];
                    b: {
                      c: {
                        d: {
                          if (5 <= (il = r2[a2 + 4 | 0]) >>> 0) {
                            if (Vk >>> 0 < a2 >>> 0 | Xk >>> 0 < Vk >>> 0) break c;
                            if ((Zk = Vk + 256 | 0) >>> 0 < a2 >>> 0) break c;
                            if (Zk >>> 0 <= Xk >>> 0) break d;
                            break c;
                          }
                          if (Vk >>> 0 < a2 >>> 0 | Xk >>> 0 < Vk >>> 0) break c;
                          if ((Zk = Vk + 128 | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0) break c;
                        }
                        if (!((Yk = q2[_k + 68 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Zk >>> 0) && !((Yk = Yk - -64 | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (dl = q2[Vk >> 2])) < 0 || (Zk = q2[_k + 72 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = (Wk = Zk) + (Zk = dl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (al = q2[_k + 76 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < al >>> 0 | al >>> 0 < Yk >>> 0 || (Wk = (dl << 6) + al | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 80 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 84 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 88 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 92 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 96 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 100 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 4 >> 2])) < 0 || (Zk = q2[_k + 104 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || ($k = (Yk = Zk) + (Zk = Wk << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Yk = q2[_k + 108 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < $k >>> 0 || (Wk = Yk + (Wk << 6) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 112 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 116 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 120 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 124 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 128 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 132 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 136 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 8 >> 2])) < 0 || (Zk = q2[_k + 140 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = (el = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 144 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 148 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 156 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 160 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 164 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 12 >> 2])) < 0 || (Zk = q2[_k + 172 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = (fl = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 176 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + fl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 180 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + fl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 188 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Wk = Zk + fl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (0 | (Yk = q2[Vk + 16 >> 2])) < 0 || (Zk = q2[_k + 192 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || ($k = (Wk = Zk) + (Zk = Yk << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 196 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 200 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 204 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 208 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + (Yk << 6) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 212 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 216 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 220 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 228 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 232 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 236 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 240 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 244 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 248 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || (Wk = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 252 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 256 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 260 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 264 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 268 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Yk = q2[_k + 272 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (0 | ($k = q2[Vk + 20 >> 2])) < 0 || (Yk = q2[_k + 276 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0 || (gl = (Wk = Yk) + (Yk = $k << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 280 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || ($k = Wk + ($k << 6) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 284 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 288 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 292 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 296 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 300 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 308 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 312 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (0 | (gl = q2[Vk + 24 >> 2])) < 0 || (Wk = q2[_k + 336 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + (gl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (0 | (gl = q2[Vk + 28 >> 2])) < 0 || (Wk = q2[_k + 340 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = (ll = gl << 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (Wk = q2[_k + 344 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || ($k = Wk + ll | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < $k >>> 0 || (0 | (gl = q2[Vk + 32 >> 2])) < 0 || (Wk = q2[_k + 356 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < $k >>> 0 || (gl = ($k = gl << 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 360 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 364 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 368 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 372 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 376 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (Wk = q2[_k + 380 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (gl = Wk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < gl >>> 0 || (0 | (bl = q2[Vk + 36 >> 2])) < 0 || (Wk = q2[_k + 392 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < gl >>> 0 || (bl = (gl = bl << 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 396 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + gl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 400 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + gl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 40 >> 2])) < 0 || (Wk = q2[_k + 412 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 44 >> 2])) < 0 || (Wk = q2[_k + 424 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 48 >> 2])) < 0 || (Wk = q2[_k + 428 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = (cl <<= 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 432 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + cl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 52 >> 2])) < 0 || (Wk = q2[_k + 416 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = (cl <<= 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 420 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + cl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 56 >> 2])) < 0 || (Wk = q2[_k + 552 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 60 >> 2])) < 0 || (Wk = q2[_k + 556 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 64 >> 2])) < 0 || (Wk = q2[_k + 560 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 1) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 68 >> 2])) < 0 || (Wk = q2[_k + 564 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 72 >> 2])) < 0 || (Wk = q2[_k + 568 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (cl = (bl = Wk) + (Wk = cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 572 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 576 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 580 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 584 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (bl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 76 >> 2])) < 0 || (Wk = q2[_k + 588 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (cl = (bl = cl << 2) + Wk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (Wk = q2[_k + 592 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (Wk = q2[_k + 596 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < cl >>> 0 || (bl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 80 >> 2])) < 0 || (Wk = q2[_k + 600 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (hl = (bl = Wk) + (Wk = cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < hl >>> 0 || (bl = q2[_k + 604 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < hl >>> 0 || (cl = bl + (cl << 6) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 608 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 612 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 616 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 620 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 624 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 628 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (cl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < cl >>> 0 || (bl = q2[_k + 632 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < cl >>> 0 || (bl = Wk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 84 >> 2])) < 0 || (Wk = q2[_k + 636 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (Wk = q2[_k + 640 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (bl = Wk + (cl << 1) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 || (0 | (cl = q2[Vk + 88 >> 2])) < 0 || (Wk = q2[_k + 644 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0 || (Wk = Wk + (cl << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0)) {
                          if (!(il >>> 0 < 2)) {
                            if ((bl = q2[_k + 168 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < Wk >>> 0) break c;
                            if ((Wk = bl + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                            if (!(il >>> 0 < 4)) {
                              if ((bl = q2[_k + 324 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0 | bl >>> 0 < Wk >>> 0) break c;
                              if ((bl = Yk + bl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0) break c;
                              if ((Wk = q2[_k + 328 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0) break c;
                              if ((bl = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0) break c;
                              if ((Wk = q2[_k + 332 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0) break c;
                              if ((bl = Wk + Yk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < bl >>> 0) break c;
                              if ((Wk = q2[_k + 152 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < bl >>> 0) break c;
                              if ((el = Wk + el | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Wk = q2[_k + 184 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < el >>> 0) break c;
                              if ((el = Wk + fl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Wk = q2[_k + 224 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 | Wk >>> 0 < el >>> 0) break c;
                              if ((Wk = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((0 | (el = q2[Vk + 92 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 648 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((el = (Wk = el << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Zk = q2[_k + 652 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < el >>> 0) break c;
                              if ((el = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Zk = q2[_k + 656 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < el >>> 0) break c;
                              if ((Wk = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((0 | (el = q2[Vk + 96 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 660 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((el = (Wk = el << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Zk = q2[_k + 664 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < el >>> 0) break c;
                              if ((el = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < el >>> 0) break c;
                              if ((Zk = q2[_k + 668 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < el >>> 0) break c;
                              if ((Wk = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 304 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 316 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 320 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 100 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 436 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 440 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 444 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 104 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 448 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Zk) + (Zk = Wk << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = q2[_k + 452 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = q2[_k + 456 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = q2[_k + 460 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = q2[_k + 464 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 | Yk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 108 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 480 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 484 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 488 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 112 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 504 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 508 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 512 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 116 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 528 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Yk = Zk + (Wk << 2) | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 120 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 532 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 536 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                              if ((Zk = q2[_k + 540 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0) break c;
                              if ((Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((0 | (Wk = q2[Vk + 124 >> 2])) < 0) break c;
                              if ((Zk = q2[_k + 544 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Yk = (Wk <<= 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0) break c;
                              if ((Zk = q2[_k + 548 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0) break c;
                              if ((Wk = Wk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0) break c;
                            }
                          }
                          if (il >>> 0 < 5) break b;
                          if (!((Zk = q2[_k + 348 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Yk = Zk + ll | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 352 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + ll | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 384 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 388 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + $k | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 404 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + gl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (Zk = q2[_k + 408 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Yk = Zk + gl | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 128 >> 2])) < 0 || (Zk = q2[_k + 468 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 472 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 476 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 132 >> 2])) < 0 || (Zk = q2[_k + 492 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 496 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 500 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Yk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Yk >>> 0 || (0 | (Wk = q2[Vk + 136 >> 2])) < 0 || (Zk = q2[_k + 516 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Yk >>> 0 || (Wk = (Yk = Wk << 2) + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 520 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Wk = Yk + Zk | 0) >>> 0 < a2 >>> 0 | Xk >>> 0 < Wk >>> 0 || (Zk = q2[_k + 524 >> 2]) >>> 0 < a2 >>> 0 | Xk >>> 0 < Zk >>> 0 | Zk >>> 0 < Wk >>> 0 || (Zk = Yk + Zk | 0) >>> 0 < a2 >>> 0 || !(Zk >>> 0 <= Xk >>> 0))) break b;
                        }
                      }
                      Y3(4, 1760, 0), da2(nl, 1), X3(a2 - -64 | 0, 4, 160);
                      break a;
                    }
                    jl || (ya2(a2), o[a2 + 5 | 0] = 0, Vk = q2[_k + 64 >> 2], dl = q2[Vk >> 2], al = q2[_k + 76 >> 2], il = r2[a2 + 4 | 0]);
                    f: {
                      if ((a2 = 0) < (0 | dl)) {
                        for (; ; ) {
                          if (63 < ia2((a2 << 6) + al | 0) >>> 0) break f;
                          if ((0 | dl) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        if (Wk = Vk + 48 | 0, (Xk = 0) < (0 | (a2 = q2[Vk >> 2]))) {
                          for (Zk = q2[Vk + 48 >> 2], Yk = q2[_k + 80 >> 2]; ; ) {
                            if ((0 | (al = q2[Yk + (Xk << 2) >> 2])) < 0 | (0 | Zk) <= (0 | al)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (gl = Vk + 24 | 0, Zk = q2[Vk + 24 >> 2], $k = q2[_k + 88 >> 2], dl = q2[_k + 84 >> 2], Xk = 0; ; ) {
                            if (Yk = q2[(al = Xk << 2) + $k >> 2]) {
                              if ((0 | Yk) < 0 | (0 | Zk) < (0 | Yk)) break f;
                              if ((0 | (al = q2[al + dl >> 2])) < 0 | (0 | Zk) <= (0 | al)) break f;
                              if ((Yk = Yk + al | 0) >>> 31 | (0 | Zk) < (0 | Yk)) break f;
                            }
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 92 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 96 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 100 >> 2]; ; ) {
                            if ((0 | (Yk = q2[Zk + (Xk << 2) >> 2])) < -1 | (0 | a2) <= (0 | Yk)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                        } else gl = Vk + 24 | 0;
                      } else gl = Vk + 24 | 0, Wk = Vk + 48 | 0;
                      if ((a2 = 0) < (0 | (Xk = q2[Vk + 4 >> 2]))) {
                        for (Zk = q2[_k + 108 >> 2]; ; ) {
                          if (63 < ia2(Zk + (a2 << 6) | 0) >>> 0) break f;
                          if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        if (Zk = q2[Vk + 48 >> 2], $k = Zk + -1 | 0, !(((Xk = 0) | (a2 = q2[Vk + 4 >> 2])) <= 0)) {
                          for (Yk = q2[_k + 112 >> 2]; ; ) {
                            if ((0 | (al = q2[Yk + (Xk << 2) >> 2])) < 0 | (0 | Zk) <= (0 | al)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 116 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 120 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Zk = q2[Vk >> 2], Xk = 0, Yk = q2[_k + 124 >> 2]; ; ) {
                            if ((0 | (al = q2[Yk + (Xk << 2) >> 2])) < -1 | (0 | Zk) <= (0 | al)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 128 >> 2]; ; ) {
                            if ((0 | (Yk = q2[Zk + (Xk << 2) >> 2])) < -1 | (0 | a2) <= (0 | Yk)) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Xk = 0, Zk = q2[_k + 132 >> 2]; ; ) {
                            if (1 < t3[Zk + (Xk << 2) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          for (Yk = Vk + 8 | 0, al = Vk + 12 | 0, dl = q2[_k + 136 >> 2], Xk = 0; ; ) {
                            if (1 < (fl = q2[(el = Xk << 2) + Zk >> 2]) >>> 0) break f;
                            if ((0 | (el = q2[dl + el >> 2])) < 0 | (0 | el) >= q2[(fl - 1 | 0 ? Yk : al) >> 2]) break f;
                            if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                        }
                      } else $k = q2[Wk >> 2] + -1 | 0;
                      if ((a2 = 0) < (0 | (Xk = q2[Vk + 8 >> 2]))) {
                        for (Zk = q2[_k + 140 >> 2]; ; ) {
                          if ((0 | (Yk = q2[Zk + (a2 << 2) >> 2])) < 0 | (0 | $k) < (0 | Yk)) break f;
                          if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        for (ll = Vk + 28 | 0, Zk = q2[Vk + 28 >> 2], dl = q2[_k + 148 >> 2], el = q2[_k + 144 >> 2], a2 = 0; ; ) {
                          if (Yk = q2[(al = a2 << 2) + dl >> 2]) {
                            if ((0 | Yk) < 0 | (0 | Zk) < (0 | Yk)) break f;
                            if ((0 | (al = q2[al + el >> 2])) < 0 | (0 | Zk) <= (0 | al)) break f;
                            if ((Yk = Yk + al | 0) >>> 31 | (0 | Zk) < (0 | Yk)) break f;
                          }
                          if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        for (a2 = 0, Yk = q2[_k + 156 >> 2], al = q2[_k + 164 >> 2], dl = q2[_k + 160 >> 2]; ; ) {
                          if ((0 | (el = q2[(Zk = a2 << 2) + dl >> 2])) < 1) break f;
                          if ((0 | (fl = q2[Zk + al >> 2])) < 1) break f;
                          if ((0 | (Zk = q2[Yk + Zk >> 2])) < 1 | (0 | Zk) != (0 | w2(fl + 1 | 0, el + 1 | 0))) break f;
                          if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                      } else ll = Vk + 28 | 0;
                      if ((a2 = 0) < (0 | (Yk = q2[Vk + 12 >> 2]))) {
                        for (Xk = q2[_k + 172 >> 2]; ; ) {
                          if ((0 | (Zk = q2[Xk + (a2 << 2) >> 2])) < 0 | (0 | $k) < (0 | Zk)) break f;
                          if ((0 | Yk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        for (bl = Vk + 32 | 0, Xk = q2[Vk + 32 >> 2], $k = q2[_k + 180 >> 2], dl = q2[_k + 176 >> 2], a2 = 0; ; ) {
                          if (Zk = q2[(al = a2 << 2) + $k >> 2]) {
                            if ((0 | Zk) < 0 | (0 | Xk) < (0 | Zk)) break f;
                            if ((0 | (al = q2[al + dl >> 2])) < 0 | (0 | Xk) <= (0 | al)) break f;
                            if ((Zk = Zk + al | 0) >>> 31 | (0 | Xk) < (0 | Zk)) break f;
                          }
                          if ((0 | Yk) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                      } else bl = Vk + 32 | 0;
                      Zk = Vk + 16 | 0, a2 = 0;
                      m: {
                        n: {
                          if (!((0 | (Xk = q2[Vk + 16 >> 2])) <= 0)) {
                            for (Yk = q2[_k + 208 >> 2]; ; ) {
                              if (63 < ia2(Yk + (a2 << 6) | 0) >>> 0) break f;
                              if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            if (!(((Xk = 0) | (a2 = q2[Zk >> 2])) <= 0)) {
                              for (Yk = q2[Wk >> 2], al = q2[_k + 212 >> 2]; ; ) {
                                if ((0 | ($k = q2[al + (Xk << 2) >> 2])) < 0 | (0 | Yk) <= (0 | $k)) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (nl = Vk + 36 | 0, Yk = q2[Vk + 36 >> 2], dl = q2[_k + 220 >> 2], el = q2[_k + 216 >> 2], Xk = 0; ; ) {
                                if (al = q2[($k = Xk << 2) + dl >> 2]) {
                                  if ((0 | al) < 0 | (0 | Yk) < (0 | al)) break f;
                                  if ((0 | ($k = q2[$k + el >> 2])) < 0 | (0 | Yk) <= (0 | $k)) break f;
                                  if ((al = al + $k | 0) >>> 31 | (0 | Yk) < (0 | al)) break f;
                                }
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Xk = 0, Yk = q2[_k + 228 >> 2]; ; ) {
                                if (1 < t3[Yk + (Xk << 2) >> 2]) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Xk = 0, Yk = q2[_k + 232 >> 2]; ; ) {
                                if (1 < t3[Yk + (Xk << 2) >> 2]) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Yk = q2[Vk >> 2], Xk = 0, al = q2[_k + 236 >> 2]; ; ) {
                                if ((0 | ($k = q2[al + (Xk << 2) >> 2])) < -1 | (0 | Yk) <= (0 | $k)) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Yk = q2[Vk + 4 >> 2], Xk = 0, al = q2[_k + 240 >> 2]; ; ) {
                                if ((0 | ($k = q2[al + (Xk << 2) >> 2])) < -1 | (0 | Yk) <= (0 | $k)) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              for (Yk = q2[_k + 244 >> 2], Xk = 0; ; ) {
                                if (q2[Yk + (Xk << 2) >> 2] < 0) break f;
                                if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                              }
                              break n;
                            }
                          }
                          al = Vk + 68 | 0, nl = Vk + 36 | 0;
                          break m;
                        }
                        for (Yk = q2[_k + 252 >> 2], Xk = 0; ; ) {
                          if (q2[Yk + (Xk << 2) >> 2] < 0) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (al = q2[Vk + 60 >> 2], Xk = 0, $k = q2[_k + 256 >> 2]; ; ) {
                          if ((dl = q2[(dl = Xk << 2) + $k >> 2] + (q2[Yk + dl >> 2] << 1) | 0) >>> 31 | (0 | al) < (0 | dl)) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (Yk = q2[Vk + 64 >> 2], dl = q2[_k + 264 >> 2], el = q2[_k + 260 >> 2], Xk = 0; ; ) {
                          if (al = q2[($k = Xk << 2) + dl >> 2]) {
                            if ((0 | al) < 0 | (0 | Yk) < (0 | al)) break f;
                            if ((0 | ($k = q2[$k + el >> 2])) < 0 | (0 | Yk) <= (0 | $k)) break f;
                            if ((al = al + $k | 0) >>> 31 | (0 | Yk) < (0 | al)) break f;
                          }
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (al = Vk + 68 | 0, Yk = q2[Vk + 68 >> 2], el = q2[_k + 272 >> 2], fl = q2[_k + 268 >> 2], Xk = 0; ; ) {
                          if ($k = q2[(dl = Xk << 2) + el >> 2]) {
                            if ((0 | $k) < 0 | (0 | Yk) < (0 | $k)) break f;
                            if ((0 | (dl = q2[dl + fl >> 2])) < 0 | (0 | Yk) <= (0 | dl)) break f;
                            if (($k = $k + dl | 0) >>> 31 | (0 | Yk) < (0 | $k)) break f;
                          }
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                      }
                      a2 = 0;
                      p: {
                        q: {
                          if (!((0 | (Xk = q2[Vk + 20 >> 2])) <= 0)) {
                            for (Yk = q2[_k + 280 >> 2]; ; ) {
                              if (63 < ia2(Yk + (a2 << 6) | 0) >>> 0) break f;
                              if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            if (!(((a2 = 0) | (Xk = q2[Vk + 20 >> 2])) <= 0)) {
                              for (Yk = q2[_k + 296 >> 2]; ; ) {
                                if (1 < t3[Yk + (a2 << 2) >> 2]) break f;
                                if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (Yk = q2[_k + 300 >> 2], a2 = 0; ; ) {
                                if (q2[Yk + (a2 << 2) >> 2] < 0) break f;
                                if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              break q;
                            }
                          }
                          a2 = q2[Vk + 52 >> 2];
                          break p;
                        }
                        for (a2 = q2[Vk + 52 >> 2], el = q2[_k + 312 >> 2], fl = q2[_k + 308 >> 2], $k = 0; ; ) {
                          if (Yk = q2[(dl = $k << 2) + el >> 2]) {
                            if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                            if ((0 | (dl = q2[dl + fl >> 2])) < 0 | (0 | a2) <= (0 | dl)) break f;
                            if ((Yk = Yk + dl | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                          }
                          if ((0 | Xk) == (0 | ($k = $k + 1 | 0))) break;
                        }
                      }
                      if (Xk = 0, Yk = q2[Vk + 40 >> 2], 0 < (0 | ($k = q2[Vk + 8 >> 2]))) for (dl = q2[_k + 344 >> 2], el = q2[_k + 156 >> 2]; ; ) {
                        if ((fl = q2[(fl = Xk << 2) + dl >> 2] + (q2[el + fl >> 2] << 1) | 0) >>> 31 | (0 | Yk) < (0 | fl)) break f;
                        if ((0 | $k) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if ((Xk = 0) < (0 | ($k = q2[bl >> 2]))) {
                        for (dl = q2[_k + 376 >> 2]; ; ) {
                          if (1 < t3[dl + (Xk << 2) >> 2]) break f;
                          if ((0 | $k) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (Xk = 0, dl = q2[_k + 380 >> 2]; ; ) {
                          if (1 < t3[dl + (Xk << 2) >> 2]) break f;
                          if ((0 | $k) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                      }
                      if ((Xk = 0) < (0 | ($k = q2[Zk >> 2]))) for (dl = q2[_k + 400 >> 2], el = q2[_k + 252 >> 2]; ; ) {
                        if ((fl = q2[(fl = Xk << 2) + dl >> 2] + (q2[el + fl >> 2] << 1) | 0) >>> 31 | (0 | Yk) < (0 | fl)) break f;
                        if ((0 | $k) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if ((Xk = 0) < (0 | (Yk = q2[Vk + 44 >> 2]))) for (dl = q2[_k + 424 >> 2]; ; ) {
                        if ((0 | (el = q2[dl + (Xk << 2) >> 2])) < 0 | (0 | a2) <= (0 | el)) break f;
                        if ((0 | Yk) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if (1 <= (0 | (el = q2[Wk >> 2]))) for (Xk = 0, fl = q2[_k + 432 >> 2], cl = q2[_k + 428 >> 2]; ; ) {
                        if (Wk = q2[(dl = Xk << 2) + fl >> 2]) {
                          if ((0 | Wk) < 0 | (0 | Yk) < (0 | Wk)) break f;
                          if ((0 | (dl = q2[cl + dl >> 2])) < 0 | (0 | Yk) <= (0 | dl)) break f;
                          if ((Wk = Wk + dl | 0) >>> 31 | (0 | Yk) < (0 | Wk)) break f;
                        }
                        if ((0 | el) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if (1 <= (0 | a2)) for (Yk = q2[Vk + 56 >> 2], Xk = 0, el = q2[_k + 420 >> 2], fl = q2[_k + 416 >> 2]; ; ) {
                        if (Wk = q2[(dl = Xk << 2) + el >> 2]) {
                          if ((0 | Wk) < 0 | (0 | Yk) < (0 | Wk)) break f;
                          if ((0 | (dl = q2[dl + fl >> 2])) < 0 | (0 | Yk) <= (0 | dl)) break f;
                          if ((Wk = Wk + dl | 0) >>> 31 | (0 | Yk) < (0 | Wk)) break f;
                        }
                        if ((0 | (Xk = Xk + 1 | 0)) == (0 | a2)) break;
                      }
                      if ((a2 = 0) < (0 | (Xk = q2[al >> 2]))) for (Yk = q2[_k + 564 >> 2]; ; ) {
                        if ((0 | (al = q2[Yk + (a2 << 2) >> 2])) < -1 | (0 | $k) <= (0 | al)) break f;
                        if ((0 | Xk) == (0 | (a2 = a2 + 1 | 0))) break;
                      }
                      if (a2 = q2[Vk + 76 >> 2], 1 <= (0 | (al = q2[Vk + 72 >> 2]))) for (Xk = 0, $k = q2[_k + 572 >> 2], dl = q2[_k + 568 >> 2]; ; ) {
                        if (Yk = q2[(Wk = Xk << 2) + $k >> 2]) {
                          if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                          if ((0 | (Wk = q2[Wk + dl >> 2])) < 0 | (0 | a2) <= (0 | Wk)) break f;
                          if ((Yk = Wk + Yk | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                        }
                        if ((0 | al) == (0 | (Xk = Xk + 1 | 0))) break;
                      }
                      if ((Xk = 0) < (0 | a2)) {
                        for (Yk = q2[_k + 588 >> 2]; ; ) {
                          if (1 < t3[Yk + (Xk << 2) >> 2]) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (Wk = q2[_k + 592 >> 2], Xk = 0; ; ) {
                          if (1 < (dl = q2[($k = Xk << 2) + Yk >> 2]) >>> 0) break f;
                          if ((0 | ($k = q2[Wk + $k >> 2])) < 0 | (0 | $k) >= q2[(dl - 1 | 0 ? Zk : Vk) >> 2]) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                        for (Xk = 0, Yk = q2[_k + 596 >> 2]; ; ) {
                          if ((0 | (Wk = q2[Yk + (Xk << 2) >> 2])) < -1 | (0 | al) <= (0 | Wk)) break f;
                          if ((0 | a2) == (0 | (Xk = Xk + 1 | 0))) break;
                        }
                      }
                      a2 = 0;
                      s: {
                        if (!((0 | ($k = q2[Vk + 80 >> 2])) <= 0)) {
                          for (Xk = q2[_k + 604 >> 2]; ; ) {
                            if (63 < ia2(Xk + (a2 << 6) | 0) >>> 0) break f;
                            if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                          }
                          if (!(((a2 = 0) | ($k = q2[Vk + 80 >> 2])) <= 0)) {
                            for (Xk = q2[Vk + 48 >> 2], Yk = q2[_k + 608 >> 2]; ; ) {
                              if ((0 | (al = q2[Yk + (a2 << 2) >> 2])) < 0 | (0 | Xk) <= (0 | al)) break f;
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (el = q2[Vk + 88 >> 2], al = q2[_k + 616 >> 2], Wk = q2[_k + 612 >> 2], a2 = 0; ; ) {
                              if (Xk = q2[(Yk = a2 << 2) + al >> 2]) {
                                if ((0 | Xk) < 0 | (0 | el) < (0 | Xk)) break f;
                                if ((0 | (Yk = q2[Wk + Yk >> 2])) < 0 | (0 | el) <= (0 | Yk)) break f;
                                if ((Xk = Xk + Yk | 0) >>> 31 | (0 | el) < (0 | Xk)) break f;
                              }
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (Zk = q2[Zk >> 2], al = q2[_k + 620 >> 2], a2 = 0; ; ) {
                              if ((0 | (Xk = q2[al + (a2 << 2) >> 2])) < 0 | (0 | Zk) <= (0 | Xk)) break f;
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (Wk = q2[_k + 624 >> 2], a2 = 0; ; ) {
                              if ((0 | (Xk = q2[Wk + (a2 << 2) >> 2])) < 0 | (0 | Zk) <= (0 | Xk)) break f;
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (Xk = q2[Vk + 84 >> 2], dl = q2[_k + 632 >> 2], fl = q2[_k + 628 >> 2], a2 = 0; ; ) {
                              if (Yk = q2[(cl = a2 << 2) + dl >> 2]) {
                                if ((0 | Yk) < 0 | (0 | Xk) < (0 | Yk)) break f;
                                if ((0 | (cl = q2[cl + fl >> 2])) < 0 | (0 | Xk) <= (0 | cl)) break f;
                                if ((Yk = Yk + cl | 0) >>> 31 | (0 | Xk) < (0 | Yk)) break f;
                              }
                              if ((0 | $k) == (0 | (a2 = a2 + 1 | 0))) break;
                            }
                            for (hl = q2[_k + 640 >> 2], Xk = q2[_k + 252 >> 2], Yk = 0; ; ) {
                              if (0 < (0 | (jl = q2[(a2 = Yk << 2) + dl >> 2]))) for (cl = hl + (q2[a2 + fl >> 2] << 1) | 0, ol = q2[Xk + (q2[a2 + Wk >> 2] << 2) >> 2], kl = q2[Xk + (q2[a2 + al >> 2] << 2) >> 2], a2 = 0; ; ) {
                                if ((0 | ol) <= s[cl + (2 | (ml = a2 << 1)) >> 1] | (0 | kl) <= s[cl + ml >> 1]) break f;
                                if (!((0 | (a2 = a2 + 2 | 0)) < (0 | jl))) break;
                              }
                              if ((0 | $k) == (0 | (Yk = Yk + 1 | 0))) break;
                            }
                            break s;
                          }
                        }
                        Zk = q2[Vk + 16 >> 2], el = q2[Vk + 88 >> 2];
                      }
                      if (!((255 & il) >>> 0 < 2)) {
                        if ((a2 = 0) < (0 | (dl = q2[Vk + 8 >> 2]))) for (Xk = q2[_k + 168 >> 2]; ; ) {
                          if (1 < t3[Xk + (a2 << 2) >> 2]) break f;
                          if ((0 | dl) == (0 | (a2 = a2 + 1 | 0))) break;
                        }
                        if (!((255 & il) >>> 0 < 4)) {
                          if (al = q2[Vk + 56 >> 2], 1 <= (0 | (fl = q2[Vk + 20 >> 2]))) for (Wk = q2[_k + 332 >> 2], cl = q2[_k + 328 >> 2], a2 = 0; ; ) {
                            if (Xk = q2[(Yk = a2 << 2) + Wk >> 2]) {
                              if ((0 | Xk) < 0 | (0 | al) < (0 | Xk)) break f;
                              if ((0 | (Yk = q2[Yk + cl >> 2])) < 0 | (0 | al) <= (0 | Yk)) break f;
                              if ((Xk = Xk + Yk | 0) >>> 31 | (0 | al) < (0 | Xk)) break f;
                            }
                            if ((0 | fl) == (0 | (a2 = a2 + 1 | 0))) break;
                          }
                          if ((0 | (a2 = q2[Vk + 92 >> 2])) != q2[Vk + 96 >> 2]) break f;
                          if (1 <= (0 | dl)) for (cl = q2[_k + 152 >> 2], Xk = 0, hl = q2[_k + 148 >> 2]; ; ) {
                            if (Yk = q2[(Wk = Xk << 2) + hl >> 2]) {
                              if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                              if ((0 | (Wk = q2[Wk + cl >> 2])) < 0 | (0 | a2) <= (0 | Wk)) break f;
                              if ((Yk = Wk + Yk | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                            }
                            if ((0 | dl) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          if (1 <= (0 | (ol = q2[Vk + 12 >> 2]))) for (cl = q2[_k + 184 >> 2], Xk = 0, hl = q2[_k + 180 >> 2]; ; ) {
                            if (Yk = q2[(Wk = Xk << 2) + hl >> 2]) {
                              if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                              if ((0 | (Wk = q2[Wk + cl >> 2])) < 0 | (0 | a2) <= (0 | Wk)) break f;
                              if ((Yk = Wk + Yk | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                            }
                            if ((0 | ol) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          if (1 <= (0 | Zk)) for (cl = q2[_k + 224 >> 2], Xk = 0, hl = q2[_k + 220 >> 2]; ; ) {
                            if (Yk = q2[(Wk = Xk << 2) + hl >> 2]) {
                              if ((0 | Yk) < 0 | (0 | a2) < (0 | Yk)) break f;
                              if ((0 | (Wk = q2[Wk + cl >> 2])) < 0 | (0 | a2) <= (0 | Wk)) break f;
                              if ((Yk = Wk + Yk | 0) >>> 31 | (0 | a2) < (0 | Yk)) break f;
                            }
                            if ((0 | Zk) == (0 | (Xk = Xk + 1 | 0))) break;
                          }
                          if ((Xk = 0) < (0 | fl)) {
                            for (Yk = q2[_k + 304 >> 2]; ; ) {
                              if (1 < t3[Yk + (Xk << 2) >> 2]) break f;
                              if ((0 | fl) == (0 | (Xk = Xk + 1 | 0))) break;
                            }
                            for (Yk = q2[Vk + 100 >> 2], hl = q2[_k + 320 >> 2], jl = q2[_k + 316 >> 2], Xk = 0; ; ) {
                              if (Wk = q2[(cl = Xk << 2) + hl >> 2]) {
                                if ((0 | Wk) < 0 | (0 | Yk) < (0 | Wk)) break f;
                                if ((0 | (cl = q2[cl + jl >> 2])) < 0 | (0 | Yk) <= (0 | cl)) break f;
                                if ((Wk = Wk + cl | 0) >>> 31 | (0 | Yk) < (0 | Wk)) break f;
                              }
                              if ((0 | fl) == (0 | (Xk = Xk + 1 | 0))) break;
                            }
                          } else Yk = q2[Vk + 100 >> 2];
                          if (1 <= (0 | Yk)) {
                            for (cl = q2[_k + 440 >> 2], Xk = 0, jl = q2[_k + 436 >> 2]; ; ) {
                              if (Wk = q2[(hl = Xk << 2) + cl >> 2]) {
                                if ((0 | Wk) < 0 | (0 | al) < (0 | Wk)) break f;
                                if ((0 | (hl = q2[hl + jl >> 2])) < 0 | (0 | al) <= (0 | hl)) break f;
                                if ((Wk = Wk + hl | 0) >>> 31 | (0 | al) < (0 | Wk)) break f;
                              }
                              if ((0 | Yk) == (0 | (Xk = Xk + 1 | 0))) break;
                            }
                            for (al = q2[_k + 444 >> 2], Xk = 0; ; ) {
                              if ((0 | (hl = q2[(Wk = Xk << 2) + al >> 2])) < 0 | (0 | hl) >= q2[Wk + cl >> 2]) break f;
                              if ((0 | Yk) == (0 | (Xk = Xk + 1 | 0))) break;
                            }
                          }
                          if ((al = 0) < (0 | (Xk = q2[Vk + 104 >> 2]))) {
                            for (Wk = q2[_k + 448 >> 2]; ; ) {
                              if ((0 | (cl = q2[Wk + (al << 2) >> 2])) < 0 | (0 | Yk) <= (0 | cl)) break f;
                              if ((0 | Xk) == (0 | (al = al + 1 | 0))) break;
                            }
                            for (Wk = q2[Vk + 116 >> 2], hl = q2[_k + 464 >> 2], jl = q2[_k + 460 >> 2], Yk = 0; ; ) {
                              if (al = q2[(cl = Yk << 2) + hl >> 2]) {
                                if ((0 | al) < 0 | (0 | Wk) < (0 | al)) break f;
                                if ((0 | (cl = q2[cl + jl >> 2])) < 0 | (0 | Wk) <= (0 | cl)) break f;
                                if ((al = al + cl | 0) >>> 31 | (0 | Wk) < (0 | al)) break f;
                              }
                              if ((0 | Xk) == (0 | (Yk = Yk + 1 | 0))) break;
                            }
                          } else Wk = q2[Vk + 116 >> 2];
                          if ((Yk = 0) < (0 | (cl = q2[Vk + 108 >> 2]))) {
                            for (al = q2[_k + 480 >> 2]; ; ) {
                              if ((0 | (hl = q2[al + (Yk << 2) >> 2])) < 0 | (0 | dl) <= (0 | hl)) break f;
                              if ((0 | cl) == (0 | (Yk = Yk + 1 | 0))) break;
                            }
                            for (hl = q2[_k + 488 >> 2], kl = q2[_k + 484 >> 2], Yk = 0; ; ) {
                              if (al = q2[(dl = Yk << 2) + hl >> 2]) {
                                if ((0 | al) < 0 | (0 | Xk) < (0 | al)) break f;
                                if ((0 | (dl = q2[dl + kl >> 2])) < 0 | (0 | Xk) <= (0 | dl)) break f;
                                if ((al = al + dl | 0) >>> 31 | (0 | Xk) < (0 | al)) break f;
                              }
                              if ((0 | cl) == (0 | (Yk = Yk + 1 | 0))) break;
                            }
                            for (hl = q2[ll >> 2], Yk = q2[_k + 456 >> 2], dl = q2[_k + 452 >> 2], al = 0; ; ) {
                              if (ml = q2[kl + (al << 2) >> 2] << 2, jl = q2[ml + Yk >> 2]) {
                                if ((0 | jl) < 0 | (0 | hl) < (0 | jl)) break f;
                                if ((0 | (ml = q2[dl + ml >> 2])) < 0 | (0 | hl) <= (0 | ml)) break f;
                                if ((0 | (jl = jl + ml | 0)) < 0 | (0 | hl) < (0 | jl)) break f;
                              }
                              if ((0 | cl) == (0 | (al = al + 1 | 0))) break;
                            }
                          } else Yk = q2[_k + 456 >> 2], dl = q2[_k + 452 >> 2];
                          if ((al = 0) < (0 | (cl = q2[Vk + 112 >> 2]))) {
                            for (hl = q2[_k + 504 >> 2]; ; ) {
                              if ((0 | (jl = q2[hl + (al << 2) >> 2])) < 0 | (0 | Zk) <= (0 | jl)) break f;
                              if ((0 | cl) == (0 | (al = al + 1 | 0))) break;
                            }
                            for (kl = q2[_k + 512 >> 2], jl = q2[_k + 508 >> 2], Zk = 0; ; ) {
                              if (al = q2[(hl = Zk << 2) + kl >> 2]) {
                                if ((0 | al) < 0 | (0 | Xk) < (0 | al)) break f;
                                if ((0 | (hl = q2[hl + jl >> 2])) < 0 | (0 | Xk) <= (0 | hl)) break f;
                                if ((al = al + hl | 0) >>> 31 | (0 | Xk) < (0 | al)) break f;
                              }
                              if ((0 | cl) == (0 | (Zk = Zk + 1 | 0))) break;
                            }
                            for (al = q2[nl >> 2], Zk = 0; ; ) {
                              if (kl = q2[jl + (Zk << 2) >> 2] << 2, hl = q2[kl + Yk >> 2]) {
                                if ((0 | hl) < 0 | (0 | al) < (0 | hl)) break f;
                                if ((0 | (kl = q2[dl + kl >> 2])) < 0 | (0 | al) <= (0 | kl)) break f;
                                if ((0 | (hl = hl + kl | 0)) < 0 | (0 | al) < (0 | hl)) break f;
                              }
                              if ((0 | cl) == (0 | (Zk = Zk + 1 | 0))) break;
                            }
                          }
                          if (Zk = 0, al = q2[Vk + 120 >> 2], 0 < (0 | Wk)) for (cl = q2[_k + 528 >> 2]; ; ) {
                            if ((0 | (hl = q2[cl + (Zk << 2) >> 2])) < 0 | (0 | al) <= (0 | hl)) break f;
                            if ((0 | (Zk = Zk + 1 | 0)) == (0 | Wk)) break;
                          }
                          if ((Zk = 0) < (0 | al)) {
                            for (Wk = q2[_k + 532 >> 2]; ; ) {
                              if ((0 | (cl = q2[Wk + (Zk << 2) >> 2])) < -1 | (0 | fl) <= (0 | cl)) break f;
                              if ((0 | al) == (0 | (Zk = Zk + 1 | 0))) break;
                            }
                            for (Wk = q2[Vk + 124 >> 2], hl = q2[_k + 540 >> 2], jl = q2[_k + 536 >> 2], Zk = 0; ; ) {
                              if (fl = q2[(cl = Zk << 2) + hl >> 2]) {
                                if ((0 | fl) < 0 | (0 | Wk) < (0 | fl)) break f;
                                if ((0 | (cl = q2[cl + jl >> 2])) < 0 | (0 | Wk) <= (0 | cl)) break f;
                                if ((fl = cl + fl | 0) >>> 31 | (0 | Wk) < (0 | fl)) break f;
                              }
                              if ((0 | al) == (0 | (Zk = Zk + 1 | 0))) break;
                            }
                          }
                          if (!((255 & il) >>> 0 < 5)) {
                            if ((Zk = 0) < (0 | (il = q2[ll >> 2]))) {
                              for (al = q2[_k + 348 >> 2]; ; ) {
                                if ((0 | (Wk = q2[al + (Zk << 2) >> 2])) < 0 | (0 | a2) < (0 | Wk)) break f;
                                if ((0 | il) == (0 | (Zk = Zk + 1 | 0))) break;
                              }
                              for (al = q2[_k + 352 >> 2], Zk = 0; ; ) {
                                if ((0 | (Wk = q2[al + (Zk << 2) >> 2])) < 0 | (0 | a2) < (0 | Wk)) break f;
                                if ((0 | il) == (0 | (Zk = Zk + 1 | 0))) break;
                              }
                            }
                            if ((il = 0) < (0 | (Zk = q2[bl >> 2]))) {
                              for (al = q2[_k + 384 >> 2]; ; ) {
                                if ((0 | (Wk = q2[al + (il << 2) >> 2])) < 0 | (0 | a2) < (0 | Wk)) break f;
                                if ((0 | Zk) == (0 | (il = il + 1 | 0))) break;
                              }
                              for (al = q2[_k + 388 >> 2], il = 0; ; ) {
                                if ((0 | (Wk = q2[al + (il << 2) >> 2])) < 0 | (0 | a2) < (0 | Wk)) break f;
                                if ((0 | Zk) == (0 | (il = il + 1 | 0))) break;
                              }
                            }
                            if ((il = 0) < (0 | (al = q2[nl >> 2]))) {
                              for (Wk = q2[_k + 404 >> 2]; ; ) {
                                if ((0 | (fl = q2[Wk + (il << 2) >> 2])) < 0 | (0 | a2) < (0 | fl)) break f;
                                if ((0 | al) == (0 | (il = il + 1 | 0))) break;
                              }
                              for (Wk = q2[_k + 408 >> 2], il = 0; ; ) {
                                if ((0 | (fl = q2[Wk + (il << 2) >> 2])) < 0 | (0 | a2) < (0 | fl)) break f;
                                if ((0 | al) == (0 | (il = il + 1 | 0))) break;
                              }
                            }
                            if ((a2 = 0) < (0 | (il = q2[Vk + 128 >> 2]))) {
                              for (al = q2[Vk >> 2], Wk = q2[_k + 468 >> 2]; ; ) {
                                if ((0 | (fl = q2[Wk + (a2 << 2) >> 2])) < 0 | (0 | al) <= (0 | fl)) break f;
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (ll = q2[_k + 476 >> 2], fl = q2[_k + 472 >> 2], a2 = 0; ; ) {
                                if (al = q2[(Wk = a2 << 2) + ll >> 2]) {
                                  if ((0 | al) < 0 | (0 | Xk) < (0 | al)) break f;
                                  if ((0 | (Wk = q2[Wk + fl >> 2])) < 0 | (0 | Xk) <= (0 | Wk)) break f;
                                  if ((al = Wk + al | 0) >>> 31 | (0 | Xk) < (0 | al)) break f;
                                }
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (al = q2[gl >> 2], a2 = 0; ; ) {
                                if (gl = q2[fl + (a2 << 2) >> 2] << 2, Wk = q2[gl + Yk >> 2]) {
                                  if ((0 | Wk) < 0 | (0 | al) < (0 | Wk)) break f;
                                  if ((0 | (gl = q2[dl + gl >> 2])) < 0 | (0 | al) <= (0 | gl)) break f;
                                  if ((0 | (Wk = Wk + gl | 0)) < 0 | (0 | al) < (0 | Wk)) break f;
                                }
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                            }
                            if ((a2 = 0) < (0 | (il = q2[Vk + 132 >> 2]))) {
                              for (al = q2[_k + 492 >> 2]; ; ) {
                                if ((0 | (Wk = q2[al + (a2 << 2) >> 2])) < 0 | (0 | ol) <= (0 | Wk)) break f;
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (gl = q2[_k + 500 >> 2], Wk = q2[_k + 496 >> 2], a2 = 0; ; ) {
                                if (al = q2[(fl = a2 << 2) + gl >> 2]) {
                                  if ((0 | al) < 0 | (0 | Xk) < (0 | al)) break f;
                                  if ((0 | (fl = q2[Wk + fl >> 2])) < 0 | (0 | Xk) <= (0 | fl)) break f;
                                  if ((al = al + fl | 0) >>> 31 | (0 | Xk) < (0 | al)) break f;
                                }
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (a2 = 0; ; ) {
                                if (fl = q2[Wk + (a2 << 2) >> 2] << 2, al = q2[fl + Yk >> 2]) {
                                  if ((0 | al) < 0 | (0 | Zk) < (0 | al)) break f;
                                  if ((0 | (fl = q2[dl + fl >> 2])) < 0 | (0 | Zk) <= (0 | fl)) break f;
                                  if ((0 | (al = al + fl | 0)) < 0 | (0 | Zk) < (0 | al)) break f;
                                }
                                if ((0 | il) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                            }
                            if (!(((a2 = 0) | (Vk = q2[Vk + 136 >> 2])) <= 0)) {
                              for (Zk = q2[_k + 516 >> 2]; ; ) {
                                if ((0 | (il = q2[Zk + (a2 << 2) >> 2])) < 0 | (0 | $k) <= (0 | il)) break f;
                                if ((0 | Vk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (al = q2[_k + 524 >> 2], Zk = q2[_k + 520 >> 2], a2 = 0; ; ) {
                                if (_k = q2[(il = a2 << 2) + al >> 2]) {
                                  if ((0 | _k) < 0 | (0 | Xk) < (0 | _k)) break f;
                                  if ((0 | (il = q2[Zk + il >> 2])) < 0 | (0 | Xk) <= (0 | il)) break f;
                                  if ((_k = _k + il | 0) >>> 31 | (0 | Xk) < (0 | _k)) break f;
                                }
                                if ((0 | Vk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                              for (a2 = 0; ; ) {
                                if (_k = q2[Zk + (a2 << 2) >> 2] << 2, Xk = q2[_k + Yk >> 2]) {
                                  if ((0 | Xk) < 0 | (0 | el) < (0 | Xk)) break f;
                                  if ((0 | (_k = q2[_k + dl >> 2])) < 0 | (0 | el) <= (0 | _k)) break f;
                                  if ((0 | (Xk = Xk + _k | 0)) < 0 | (0 | el) < (0 | Xk)) break f;
                                }
                                if ((0 | Vk) == (0 | (a2 = a2 + 1 | 0))) break;
                              }
                            }
                          }
                        }
                      }
                      return L2 = pl, 1;
                    }
                    return Y3(4, 1846, 0), L2 = pl, 0;
                  }
                  q2[_k + 52 >> 2] = Xk, q2[_k + 48 >> 2] = 5, Y3(4, 1640, _k + 48 | 0);
                } else q2[_k + 32 >> 2] = Xk, Y3(4, 1554, _k + 32 | 0);
                return L2 = pl, 0;
              }(a, vj) : (q2[20 + wj >> 2] = 1621, q2[16 + wj >> 2] = 2284, Y3(4, 1294, 16 + wj | 0), 0) : (q2[4 + wj >> 2] = 1444, q2[wj >> 2] = 2284, Y3(4, 1294, wj), 0), L2 = 48 + wj | 0, 0 | a;
            }, i: function(a) {
              q2[1805] = a |= 0;
            }, j: function(a, ej) {
              var fj;
              return ej |= 0, L2 = fj = L2 - 48 | 0, a = (a |= 0) ? (a + 63 & -64) != (0 | a) ? (q2[36 + fj >> 2] = 1522, q2[32 + fj >> 2] = 2305, Y3(4, 1294, 32 + fj | 0), 0) : (ej + 63 & -64) == (0 | ej) && ej ? function(a2) {
                var Kk = 0, Lk = 0, Mk = 0, Nk = 0, Ok = 0, Pk = 0, Qk = 0, Rk = 0, Sk = 0, Tk = 0, Uk = 0;
                q2[24 + (L2 = Qk = L2 - 32 | 0) >> 2] = 0, q2[16 + Qk >> 2] = 5, q2[20 + Qk >> 2] = 0, function(a3) {
                  var Uh;
                  Ka(16 + (L2 = Uh = L2 - 272 | 0) | 0, 2227, q2[12 + Uh >> 2] = a3), Sa(16 + Uh | 0), L2 = 272 + Uh | 0;
                }(16 + Qk | 0);
                a: {
                  if (sa(a2)) Y3(4, 1932, 0);
                  else {
                    if (!(6 <= (Mk = r2[a2 + 4 | 0]) >>> 0)) {
                      if (1 != (0 | !r2[a2 + 5 | 0]) ? (da2(a2 + 4 | 0, 1), X3(a2 - -64 | 0, 4, 160), o[a2 + 5 | 0] = 0, na2(a2, a2 + 704 | 0), ya2(a2)) : na2(a2, a2 + 704 | 0), r2[7224] || (q2[1807] = 6, o[7224] = 1, q2[1808] = 7, q2[1809] = 8, q2[1810] = 9), Lk = q2[a2 + 704 >> 2], 1 <= (0 | (Mk = q2[Lk + 16 >> 2]))) {
                        for (Nk = q2[a2 + 912 >> 2], Sk = Nk + (Mk << 2) | 0, Ok = q2[a2 + 908 >> 2]; ; ) {
                          Rk = q2[a2 + 1204 >> 2] + (q2[Ok >> 2] << 2) | 0, Lk = 0, Mk = q2[Nk >> 2], Kk = Mk + -1 | 0;
                          d: if (!((0 | Kk) < 1)) e: for (; ; ) {
                            for (; ; ) {
                              if (q2[(Pk = Rk + (Lk << 2) | 0) >> 2] <= -1) {
                                if (!function(a3, Vk, ql) {
                                  var rl = 0, sl = 0;
                                  a: if ((0 | a3) != (0 | Vk)) {
                                    if (!(a3 >>> 0 < Vk + ql >>> 0 && Vk >>> 0 < (sl = a3 + ql | 0) >>> 0)) return $(a3, Vk, ql);
                                    if (rl = 3 & (a3 ^ Vk), a3 >>> 0 < Vk >>> 0) {
                                      if (!rl) {
                                        if (3 & a3) for (; ; ) {
                                          if (!ql) break a;
                                          if (o[0 | a3] = r2[0 | Vk], Vk = Vk + 1 | 0, ql = ql + -1 | 0, !(3 & (a3 = a3 + 1 | 0))) break;
                                        }
                                        if (!(ql >>> 0 <= 3)) {
                                          for (rl = ql; ; ) if (q2[a3 >> 2] = q2[Vk >> 2], Vk = Vk + 4 | 0, a3 = a3 + 4 | 0, !(3 < (rl = rl + -4 | 0) >>> 0)) break;
                                          ql &= 3;
                                        }
                                      }
                                      if (ql) {
                                        for (; ; ) if (o[0 | a3] = r2[0 | Vk], a3 = a3 + 1 | 0, Vk = Vk + 1 | 0, !(ql = ql + -1 | 0)) break;
                                      }
                                    } else {
                                      if (!rl) {
                                        if (3 & sl) for (; ; ) {
                                          if (!ql) break a;
                                          if (o[0 | (rl = (ql = ql + -1 | 0) + a3 | 0)] = r2[Vk + ql | 0], !(3 & rl)) break;
                                        }
                                        if (!(ql >>> 0 <= 3)) {
                                          for (; ; ) if (q2[(ql = ql + -4 | 0) + a3 >> 2] = q2[Vk + ql >> 2], !(3 < ql >>> 0)) break;
                                        }
                                      }
                                      if (ql) {
                                        for (; ; ) if (o[(ql = ql + -1 | 0) + a3 | 0] = r2[Vk + ql | 0], !ql) break;
                                      }
                                    }
                                  }
                                }(Pk, Pk + 4 | 0, (-1 ^ Lk) + Mk << 2), (0 | Lk) < (0 | (Kk = (Mk = Kk) + -1 | 0))) continue e;
                                break d;
                              }
                              if (!((0 | (Lk = Lk + 1 | 0)) < (0 | Kk))) break;
                            }
                            break;
                          }
                          if (Lk = Nk, 0 < (0 | Mk) && (Mk = q2[Rk + (Kk << 2) >> 2] < 0 ? Kk : Mk), q2[Lk >> 2] = Mk, Ok = Ok + 4 | 0, !((Nk = Nk + 4 | 0) >>> 0 < Sk >>> 0)) break;
                        }
                        Lk = q2[a2 + 704 >> 2];
                      }
                      if (1 <= q2[Lk >> 2]) {
                        for (Kk = 0; ; ) if (q2[q2[a2 + 712 >> 2] + (Kk << 2) >> 2] = q2[a2 + 716 >> 2] + (Kk << 6), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk >> 2])) break;
                      }
                      if (1 <= q2[Lk + 4 >> 2]) {
                        for (Kk = 0; ; ) if (q2[q2[a2 + 744 >> 2] + (Kk << 2) >> 2] = q2[a2 + 748 >> 2] + (Kk << 6), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk + 4 >> 2])) break;
                      }
                      if (1 <= q2[Lk + 16 >> 2]) {
                        for (Kk = 0; ; ) if (q2[(Mk = Kk << 2) + q2[a2 + 832 >> 2] >> 2] = q2[a2 + 848 >> 2] + (Kk << 6), q2[Mk + q2[a2 + 836 >> 2] >> 2] = q2[a2 + 1196 >> 2] + (q2[Mk + q2[a2 + 896 >> 2] >> 2] << 2), q2[Mk + q2[a2 + 840 >> 2] >> 2] = q2[a2 + 1200 >> 2] + (q2[Mk + q2[a2 + 900 >> 2] >> 2] << 1), q2[Mk + q2[a2 + 844 >> 2] >> 2] = q2[a2 + 1204 >> 2] + (q2[Mk + q2[a2 + 908 >> 2] >> 2] << 2), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk + 16 >> 2])) break;
                      }
                      if (1 <= q2[Lk + 20 >> 2]) {
                        for (Kk = 0; ; ) if (q2[q2[a2 + 916 >> 2] + (Kk << 2) >> 2] = q2[a2 + 920 >> 2] + (Kk << 6), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk + 20 >> 2])) break;
                      }
                      if (1 <= q2[Lk + 80 >> 2]) {
                        for (Kk = 0; ; ) if (q2[q2[a2 + 1240 >> 2] + (Kk << 2) >> 2] = q2[a2 + 1244 >> 2] + (Kk << 6), Kk = Kk + 1 | 0, Lk = q2[a2 + 704 >> 2], !((0 | Kk) < q2[Lk + 80 >> 2])) break;
                      }
                      if (1 & o[q2[a2 + 708 >> 2] + 20 | 0]) break a;
                      if ((0 | (Nk = q2[Lk + 16 >> 2])) < 1) break a;
                      for (Kk = q2[a2 + 904 >> 2], Rk = q2[a2 + 900 >> 2], Pk = q2[a2 + 1200 >> 2], Ok = 0; ; ) {
                        if (0 < (0 | (Sk = q2[(Mk = Ok << 2) + Kk >> 2] + -1 | 0))) {
                          for (Tk = Pk + (q2[Mk + Rk >> 2] << 1) | 0, Lk = 0; ; ) if (Uk = s[(Mk = Tk + (Lk << 1) | 0) >> 1], p2[Mk >> 1] = s[Mk + 4 >> 1], p2[Mk + 4 >> 1] = Uk, !((0 | (Lk = Lk + 3 | 0)) < (0 | Sk))) break;
                        }
                        if ((0 | Nk) == (0 | (Ok = Ok + 1 | 0))) break;
                      }
                      for (Mk = q2[a2 + 892 >> 2], Ok = q2[a2 + 896 >> 2], Rk = q2[a2 + 1196 >> 2], Kk = 0; ; ) {
                        if (1 <= (0 | (Pk = q2[(Lk = Kk << 2) + Mk >> 2]))) {
                          for (Lk = Rk + (q2[Lk + Ok >> 2] << 2) | 0, Pk = Lk + (Pk << 3) | 0, Lk = Lk + 4 | 0; ; ) if (u2[Lk >> 2] = x2(1) - u2[Lk >> 2], !((Lk = Lk + 8 | 0) >>> 0 < Pk >>> 0)) break;
                        }
                        if ((0 | Nk) == (0 | (Kk = Kk + 1 | 0))) break;
                      }
                      break a;
                    }
                    q2[4 + Qk >> 2] = Mk, q2[Qk >> 2] = 5, Y3(4, 2023, Qk);
                  }
                  a2 = 0;
                }
                return L2 = 32 + Qk | 0, a2;
              }(a) : (q2[20 + fj >> 2] = 1621, q2[16 + fj >> 2] = 2305, Y3(4, 1294, 16 + fj | 0), 0) : (q2[4 + fj >> 2] = 1444, q2[fj >> 2] = 2305, Y3(4, 1294, fj), 0), L2 = 48 + fj | 0, 0 | a;
            }, k: function(a, ej, fj, gj) {
              var hj;
              ej |= 0, fj |= 0, gj |= 0, L2 = hj = L2 + -64 | 0, (a |= 0) ? ej ? fj ? gj ? (a = q2[q2[a >> 2] + 708 >> 2], q2[ej >> 2] = q2[a + 12 >> 2], q2[ej + 4 >> 2] = q2[a + 16 >> 2], q2[fj >> 2] = q2[a + 4 >> 2], q2[fj + 4 >> 2] = q2[a + 8 >> 2], q2[gj >> 2] = q2[a >> 2]) : (q2[52 + hj >> 2] = 1995, q2[48 + hj >> 2] = 2325, Y3(4, 1294, 48 + hj | 0)) : (q2[36 + hj >> 2] = 1903, q2[32 + hj >> 2] = 2325, Y3(4, 1294, 32 + hj | 0)) : (q2[20 + hj >> 2] = 1819, q2[16 + hj >> 2] = 2325, Y3(4, 1294, 16 + hj | 0)) : (q2[4 + hj >> 2] = 1740, q2[hj >> 2] = 2325, Y3(4, 1294, hj)), L2 = hj + 64 | 0;
            }, l: xa2, m: wa2, n: function(a) {
              var dj;
              L2 = dj = L2 - 16 | 0, (a |= 0) ? ua(a) : (q2[4 + dj >> 2] = 1740, q2[dj >> 2] = 2387, Y3(4, 1294, dj)), L2 = 16 + dj | 0;
            }, o: function(a) {
              var cj;
              return L2 = cj = L2 - 16 | 0, a = (a |= 0) ? q2[a + 540 >> 2] : (q2[4 + cj >> 2] = 1740, q2[cj >> 2] = 2402, Y3(4, 1294, cj), -1), L2 = 16 + cj | 0, 0 | a;
            }, p: function(a) {
              var bj;
              return L2 = bj = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 916 >> 2] : (q2[4 + bj >> 2] = 1740, q2[bj >> 2] = 2423, Y3(4, 1294, bj), 0), L2 = 16 + bj | 0, 0 | a;
            }, q: function(a) {
              var aj;
              return L2 = aj = L2 - 16 | 0, a = (a |= 0) ? q2[a + 548 >> 2] : (q2[4 + aj >> 2] = 1740, q2[aj >> 2] = 2442, Y3(4, 1294, aj), 0), L2 = 16 + aj | 0, 0 | a;
            }, r: function(a) {
              var $i;
              return L2 = $i = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 928 >> 2] : (q2[4 + $i >> 2] = 1740, q2[$i >> 2] = 2463, Y3(4, 1294, $i), 0), L2 = 16 + $i | 0, 0 | a;
            }, s: function(a) {
              var _i;
              return L2 = _i = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 924 >> 2] : (q2[4 + _i >> 2] = 1740, q2[_i >> 2] = 2492, Y3(4, 1294, _i), 0), L2 = 16 + _i | 0, 0 | a;
            }, t: function(a) {
              var Zi;
              return L2 = Zi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 932 >> 2] : (q2[4 + Zi >> 2] = 1740, q2[Zi >> 2] = 2521, Y3(4, 1294, Zi), 0), L2 = 16 + Zi | 0, 0 | a;
            }, u: function(a) {
              var Yi;
              return L2 = Yi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 552 >> 2] : (q2[4 + Yi >> 2] = 1740, q2[Yi >> 2] = 2550, Y3(4, 1294, Yi), 0), L2 = 16 + Yi | 0, 0 | a;
            }, v: function(a) {
              var Xi;
              return L2 = Xi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 4 >> 2] : (q2[4 + Xi >> 2] = 1740, q2[Xi >> 2] = 2572, Y3(4, 1294, Xi), -1), L2 = 16 + Xi | 0, 0 | a;
            }, w: function(a) {
              var Wi;
              return L2 = Wi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 712 >> 2] : (q2[4 + Wi >> 2] = 1740, q2[Wi >> 2] = 2588, Y3(4, 1294, Wi), 0), L2 = 16 + Wi | 0, 0 | a;
            }, x: function(a) {
              var Vi;
              return L2 = Vi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 52 >> 2] : (q2[4 + Vi >> 2] = 1740, q2[Vi >> 2] = 2602, Y3(4, 1294, Vi), 0), L2 = 16 + Vi | 0, 0 | a;
            }, y: function(a) {
              var Ui;
              return L2 = Ui = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 740 >> 2] : (q2[4 + Ui >> 2] = 1740, q2[Ui >> 2] = 2622, Y3(4, 1294, Ui), 0), L2 = 16 + Ui | 0, 0 | a;
            }, z: function(a) {
              var Ti;
              return L2 = Ti = L2 - 16 | 0, a = (a |= 0) ? q2[a + 332 >> 2] : (q2[4 + Ti >> 2] = 1740, q2[Ti >> 2] = 2650, Y3(4, 1294, Ti), -1), L2 = 16 + Ti | 0, 0 | a;
            }, A: function(a) {
              var Si;
              return L2 = Si = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 832 >> 2] : (q2[4 + Si >> 2] = 1740, q2[Si >> 2] = 2670, Y3(4, 1294, Si), 0), L2 = 16 + Si | 0, 0 | a;
            }, B: function(a) {
              var Ri;
              return L2 = Ri = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 888 >> 2] : (q2[4 + Ri >> 2] = 1740, q2[Ri >> 2] = 2688, Y3(4, 1294, Ri), 0), L2 = 16 + Ri | 0, 0 | a;
            }, C: function(a) {
              var Qi;
              return L2 = Qi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 432 >> 2] : (q2[4 + Qi >> 2] = 1740, q2[Qi >> 2] = 2716, Y3(4, 1294, Qi), 0), L2 = 16 + Qi | 0, 0 | a;
            }, D: function(a) {
              var Pi;
              return L2 = Pi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 884 >> 2] : (q2[4 + Pi >> 2] = 1740, q2[Pi >> 2] = 2743, Y3(4, 1294, Pi), 0), L2 = 16 + Pi | 0, 0 | a;
            }, E: function(a) {
              var Oi;
              return L2 = Oi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 440 >> 2] : (q2[4 + Oi >> 2] = 1740, q2[Oi >> 2] = 2772, Y3(4, 1294, Oi), 0), L2 = 16 + Oi | 0, 0 | a;
            }, F: function(a) {
              var Ni;
              return L2 = Ni = L2 - 16 | 0, a = (a |= 0) ? q2[a + 436 >> 2] : (q2[4 + Ni >> 2] = 1740, q2[Ni >> 2] = 2797, Y3(4, 1294, Ni), 0), L2 = 16 + Ni | 0, 0 | a;
            }, G: function(a) {
              var Mi;
              return L2 = Mi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 448 >> 2] : (q2[4 + Mi >> 2] = 1740, q2[Mi >> 2] = 2824, Y3(4, 1294, Mi), 0), L2 = 16 + Mi | 0, 0 | a;
            }, H: function(a) {
              var Li;
              return L2 = Li = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 912 >> 2] : (q2[4 + Li >> 2] = 1740, q2[Li >> 2] = 2848, Y3(4, 1294, Li), 0), L2 = 16 + Li | 0, 0 | a;
            }, I: function(a) {
              var Ki;
              return L2 = Ki = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 844 >> 2] : (q2[4 + Ki >> 2] = 1740, q2[Ki >> 2] = 2873, Y3(4, 1294, Ki), 0), L2 = 16 + Ki | 0, 0 | a;
            }, J: function(a) {
              var Ji;
              return L2 = Ji = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 892 >> 2] : (q2[4 + Ji >> 2] = 1740, q2[Ji >> 2] = 2893, Y3(4, 1294, Ji), 0), L2 = 16 + Ji | 0, 0 | a;
            }, K: function(a) {
              var Ii;
              return L2 = Ii = L2 - 16 | 0, a = (a |= 0) ? q2[a + 444 >> 2] : (q2[4 + Ii >> 2] = 1740, q2[Ii >> 2] = 2920, Y3(4, 1294, Ii), 0), L2 = 16 + Ii | 0, 0 | a;
            }, L: function(a) {
              var Hi;
              return L2 = Hi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 836 >> 2] : (q2[4 + Hi >> 2] = 1740, q2[Hi >> 2] = 2950, Y3(4, 1294, Hi), 0), L2 = 16 + Hi | 0, 0 | a;
            }, M: function(a) {
              var ri;
              return L2 = ri = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 904 >> 2] : (q2[4 + ri >> 2] = 1740, q2[ri >> 2] = 2974, Y3(4, 1294, ri), 0), L2 = 16 + ri | 0, 0 | a;
            }, N: function(a) {
              var qi;
              return L2 = qi = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 840 >> 2] : (q2[4 + qi >> 2] = 1740, q2[qi >> 2] = 3e3, Y3(4, 1294, qi), 0), L2 = 16 + qi | 0, 0 | a;
            }, O: function(a) {
              var pi;
              return L2 = pi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 452 >> 2] : (q2[4 + pi >> 2] = 1740, q2[pi >> 2] = 3022, Y3(4, 1294, pi), 0), L2 = 16 + pi | 0, 0 | a;
            }, P: function(a) {
              var oi;
              return L2 = oi = L2 - 16 | 0, a = (a |= 0) ? q2[a + 456 >> 2] : (q2[4 + oi >> 2] = 1740, q2[oi >> 2] = 3051, Y3(4, 1294, oi), 0), L2 = 16 + oi | 0, 0 | a;
            }, Q: function(a) {
              var ni;
              return L2 = ni = L2 - 16 | 0, a = (a |= 0) ? q2[q2[a >> 2] + 876 >> 2] : (q2[4 + ni >> 2] = 1740, q2[ni >> 2] = 3078, Y3(4, 1294, ni), 0), L2 = 16 + ni | 0, 0 | a;
            }, R: function(a) {
              var mi;
              L2 = mi = L2 - 16 | 0, (a |= 0) ? q2[a + 428 >> 2] = 1 : (q2[4 + mi >> 2] = 1740, q2[mi >> 2] = 3110, Y3(4, 1294, mi)), L2 = 16 + mi | 0;
            }, S: function(a) {
              var li;
              return L2 = li = L2 - 16 | 0, a = (a |= 0) ? q2[a + 640 >> 2] : (q2[4 + li >> 2] = 1740, q2[li >> 2] = 3139, Y3(4, 1294, li), 0), L2 = 16 + li | 0, 0 | a;
            }, T: function(a) {
              var ji;
              return L2 = ji = L2 - 16 | 0, a = (a |= 0) ? q2[a + 636 >> 2] : (q2[4 + ji >> 2] = 1740, q2[ji >> 2] = 3164, Y3(4, 1294, ji), 0), L2 = 16 + ji | 0, 0 | a;
            }, U: function(a) {
              var Fc;
              return oa2(12 + (L2 = Fc = L2 - 16 | 0) | 0, 64, a |= 0), L2 = 16 + Fc | 0, q2[12 + Fc >> 2];
            }, V: function(a) {
              var Ec, Cc2, Dc = 0;
              return L2 = Cc2 = L2 - 16 | 0, !(a |= 0) || oa2(12 + Cc2 | 0, 16, Ec = xa2(a)) || (Dc = wa2(a, q2[12 + Cc2 >> 2], Ec)) || (pa2(q2[12 + Cc2 >> 2]), Dc = 0), L2 = 16 + Cc2 | 0, 0 | Dc;
            }, W: function(a) {
              return 0 | qa(a |= 0);
            }, X: function(a) {
              pa2(a |= 0);
            }, Y: function(a) {
              var Sm;
              oa2(12 + (L2 = Sm = L2 - 16 | 0) | 0, 64, a |= 0), pa2(q2[12 + Sm >> 2]), L2 = 16 + Sm | 0;
            }, Z: function() {
              return 0 | L2;
            }, _: function(a) {
              return 0 | (L2 = a = L2 - (a |= 0) & -16);
            }, $: function(a) {
              L2 = a |= 0;
            }, aa: function(a) {
              return 0 | function(pagesToAdd) {
                pagesToAdd |= 0;
                var P2 = 0 | N2(), pagesToAdd = P2 + pagesToAdd | 0;
                {
                  var S;
                  P2 < pagesToAdd && pagesToAdd < 65536 && (pagesToAdd = new ArrayBuffer(w2(pagesToAdd, 65536)), (S = new global.Int8Array(pagesToAdd)).set(o), o = S, o = new global.Int8Array(pagesToAdd), p2 = new global.Int16Array(pagesToAdd), q2 = new global.Int32Array(pagesToAdd), r2 = new global.Uint8Array(pagesToAdd), s = new global.Uint16Array(pagesToAdd), t3 = new global.Uint32Array(pagesToAdd), u2 = new global.Float32Array(pagesToAdd), v2 = new global.Float64Array(pagesToAdd), buffer2 = pagesToAdd, m.buffer = pagesToAdd);
                }
                return P2;
              }(0 | (a |= 0));
            }, ba: function(a, Vk) {
              n2[a |= 0](Vk |= 0);
            } };
            function X3(a, b3, c2) {
              var e, f2, d2 = 0;
              if (c2) for (; ; ) {
                if (c2 = c2 + -1 | 0, a >>> 0 < (d2 = (e = a + b3 | 0) - 1 | 0) >>> 0) {
                  for (; ; ) if (f2 = r2[0 | a], o[0 | a] = r2[0 | d2], o[0 | d2] = f2, !((a = a + 1 | 0) >>> 0 < (d2 = d2 + -1 | 0) >>> 0)) break;
                }
                if (a = e, !c2) break;
              }
            }
            function Y3(a, b3, c2) {
              var g2;
              L2 = g2 = L2 - 272 | 0, t3[1804] > a >>> 0 || (a = q2[1805]) && (Ka(16 + g2 | 0, b3, q2[12 + g2 >> 2] = c2), n2[a](16 + g2 | 0)), L2 = 272 + g2 | 0;
            }
            function Z2(a, b3, c2) {
              32 & r2[0 | a] || !function(a2, Rm, Sm) {
                var Tm = 0, Um = 0, tn = 0;
                a: {
                  if (!(Tm = q2[Sm + 16 >> 2])) {
                    if (function(a3) {
                      var Rm2 = 0;
                      if (Rm2 = r2[a3 + 74 | 0], o[a3 + 74 | 0] = Rm2 + -1 | Rm2, 8 & (Rm2 = q2[a3 >> 2])) return q2[a3 >> 2] = 32 | Rm2, 1;
                      return q2[a3 + 4 >> 2] = 0, q2[a3 + 8 >> 2] = 0, Rm2 = q2[a3 + 44 >> 2], q2[a3 + 28 >> 2] = Rm2, q2[a3 + 20 >> 2] = Rm2, q2[a3 + 16 >> 2] = Rm2 + q2[a3 + 48 >> 2], 0;
                    }(Sm)) break a;
                    Tm = q2[Sm + 16 >> 2];
                  }
                  if (tn = q2[Sm + 20 >> 2], Tm - tn >>> 0 < Rm >>> 0) return n2[q2[Sm + 36 >> 2]](Sm, a2, Rm);
                  b: if (!(o[Sm + 75 | 0] < 0)) {
                    for (Tm = Rm; ; ) {
                      if (!(Um = Tm)) break b;
                      if (10 == r2[(Tm = Um + -1 | 0) + a2 | 0]) break;
                    }
                    if (n2[q2[Sm + 36 >> 2]](Sm, a2, Um) >>> 0 < Um >>> 0) break a;
                    Rm = Rm - Um | 0, a2 = a2 + Um | 0, tn = q2[Sm + 20 >> 2];
                  }
                  $(tn, a2, Rm), q2[Sm + 20 >> 2] = q2[Sm + 20 >> 2] + Rm;
                }
              }(b3, c2, a);
            }
            function _(a, b3, c2, h2, i) {
              var k2, l3, j2;
              if (L2 = j2 = L2 - 256 | 0, !(73728 & i | (0 | c2) <= (0 | h2))) {
                if (ca2(j2, b3, (k2 = (i = c2 - h2 | 0) >>> 0 < 256) ? i : 256), b3 = a, l3 = j2, !k2) {
                  for (c2 = c2 - h2 | 0; ; ) if (Z2(a, j2, 256), !(255 < (i = i + -256 | 0) >>> 0)) break;
                  i = 255 & c2;
                }
                Z2(b3, l3, i);
              }
              L2 = 256 + j2 | 0;
            }
            function $(a, b3, c2) {
              var h2, i = 0;
              if (8192 <= c2 >>> 0) I2(0 | a, 0 | b3, 0 | c2);
              else {
                if (h2 = a + c2 | 0, 3 & (a ^ b3)) {
                  if (h2 >>> 0 < 4) c2 = a;
                  else if ((i = h2 - 4 | 0) >>> 0 < a >>> 0) c2 = a;
                  else for (c2 = a; ; ) if (o[0 | c2] = r2[0 | b3], o[c2 + 1 | 0] = r2[b3 + 1 | 0], o[c2 + 2 | 0] = r2[b3 + 2 | 0], o[c2 + 3 | 0] = r2[b3 + 3 | 0], b3 = b3 + 4 | 0, !((c2 = c2 + 4 | 0) >>> 0 <= i >>> 0)) break;
                } else {
                  b: if ((0 | c2) < 1) c2 = a;
                  else if (3 & a) for (c2 = a; ; ) {
                    if (o[0 | c2] = r2[0 | b3], b3 = b3 + 1 | 0, h2 >>> 0 <= (c2 = c2 + 1 | 0) >>> 0) break b;
                    if (!(3 & c2)) break;
                  }
                  else c2 = a;
                  if (!((a = -4 & h2) >>> 0 < 64 || (i = a + -64 | 0) >>> 0 < c2 >>> 0)) {
                    for (; ; ) if (q2[c2 >> 2] = q2[b3 >> 2], q2[c2 + 4 >> 2] = q2[b3 + 4 >> 2], q2[c2 + 8 >> 2] = q2[b3 + 8 >> 2], q2[c2 + 12 >> 2] = q2[b3 + 12 >> 2], q2[c2 + 16 >> 2] = q2[b3 + 16 >> 2], q2[c2 + 20 >> 2] = q2[b3 + 20 >> 2], q2[c2 + 24 >> 2] = q2[b3 + 24 >> 2], q2[c2 + 28 >> 2] = q2[b3 + 28 >> 2], q2[c2 + 32 >> 2] = q2[b3 + 32 >> 2], q2[c2 + 36 >> 2] = q2[b3 + 36 >> 2], q2[c2 + 40 >> 2] = q2[b3 + 40 >> 2], q2[c2 + 44 >> 2] = q2[b3 + 44 >> 2], q2[c2 + 48 >> 2] = q2[b3 + 48 >> 2], q2[c2 + 52 >> 2] = q2[b3 + 52 >> 2], q2[c2 + 56 >> 2] = q2[b3 + 56 >> 2], q2[c2 + 60 >> 2] = q2[b3 + 60 >> 2], b3 = b3 - -64 | 0, !((c2 = c2 - -64 | 0) >>> 0 <= i >>> 0)) break;
                  }
                  if (!(a >>> 0 <= c2 >>> 0)) {
                    for (; ; ) if (q2[c2 >> 2] = q2[b3 >> 2], b3 = b3 + 4 | 0, !((c2 = c2 + 4 | 0) >>> 0 < a >>> 0)) break;
                  }
                }
                if (c2 >>> 0 < h2 >>> 0) {
                  for (; ; ) if (o[0 | c2] = r2[0 | b3], b3 = b3 + 1 | 0, (0 | h2) == (0 | (c2 = c2 + 1 | 0))) break;
                }
              }
            }
            function aa(a) {
              var b3, c2;
              return x2((b3 = a * a) * b3 * (c2 = b3 * a) * (2718311493989822e-21 * b3 - 19839334836096632e-20) + (c2 * (0.008333329385889463 * b3 - 0.16666666641626524) + a));
            }
            function ba(a) {
              var m2;
              return x2(-0.499999997251031 * (a *= a) + 1 + 0.04166662332373906 * (m2 = a * a) + a * m2 * (2439044879627741e-20 * a - 0.001388676377460993));
            }
            function ca2(a, n3, p3) {
              var r3, s2, t4, u3;
              if (p3 && (o[(r3 = a + p3 | 0) - 1 | 0] = n3, o[0 | a] = n3, !(p3 >>> 0 < 3 || (o[r3 - 2 | 0] = n3, o[a + 1 | 0] = n3, o[r3 - 3 | 0] = n3, o[a + 2 | 0] = n3, p3 >>> 0 < 7) || (o[r3 - 4 | 0] = n3, o[a + 3 | 0] = n3, p3 >>> 0 < 9) || (s2 = (r3 = 0 - a & 3) + a | 0, n3 = w2(255 & n3, 16843009), q2[s2 >> 2] = n3, q2[(r3 = (p3 = p3 - r3 & -4) + s2 | 0) - 4 >> 2] = n3, p3 >>> 0 < 9) || (q2[8 + s2 >> 2] = n3, q2[4 + s2 >> 2] = n3, q2[r3 - 8 >> 2] = n3, q2[r3 - 12 >> 2] = n3, p3 >>> 0 < 25) || (q2[24 + s2 >> 2] = n3, q2[20 + s2 >> 2] = n3, q2[16 + s2 >> 2] = n3, q2[12 + s2 >> 2] = n3, q2[r3 - 16 >> 2] = n3, q2[r3 - 20 >> 2] = n3, q2[r3 - 24 >> 2] = n3, q2[r3 - 28 >> 2] = n3, (p3 = p3 - (u3 = 4 & s2 | 24) | 0) >>> 0 < 32)))) {
                for (t4 = r3 = n3, n3 = s2 + u3 | 0; ; ) if (q2[n3 + 24 >> 2] = t4, q2[n3 + 28 >> 2] = r3, q2[n3 + 16 >> 2] = t4, q2[n3 + 20 >> 2] = r3, q2[n3 + 8 >> 2] = t4, q2[n3 + 12 >> 2] = r3, q2[n3 >> 2] = t4, q2[n3 + 4 >> 2] = r3, n3 = n3 + 32 | 0, !(31 < (p3 = p3 + -32 | 0) >>> 0)) break;
              }
              return a;
            }
            function da2(a, n3) {
              var p3;
              if (a >>> 0 < (n3 = (a + n3 | 0) - 1 | 0) >>> 0) {
                for (; ; ) if (p3 = r2[0 | a], o[0 | a] = r2[0 | n3], o[0 | n3] = p3, !((a = a + 1 | 0) >>> 0 < (n3 = n3 + -1 | 0) >>> 0)) break;
              }
            }
            function ea(a) {
              var n3 = 0, o2 = N2();
              return (a = (n3 = q2[2216]) + a | 0) >>> 0 <= o2 << 16 >>> 0 || J2(0 | a) ? (q2[2216] = a, n3) : (q2[2086] = 48, -1);
            }
            function fa(a, v3, y3, z3, B2, C3, D2) {
              var H3, I3, K3, N3, Q2, R, S, O2, P2, J3, E2 = 0, F2 = x2(0), G2 = x2(0), M3 = x2(0);
              x2(0), x2(0), x2(0), x2(0);
              if (L2 = J3 = L2 - 16 | 0, 1 <= (0 | a)) for (R = w2(a, 12) + v3 | 0; ; ) {
                if (1 <= (0 | (I3 = q2[v3 + 4 >> 2]))) {
                  for (S = (a = q2[v3 + 8 >> 2]) + w2(I3, 48) | 0, I3 = (H3 = q2[v3 >> 2] << 4) + D2 | 0, K3 = (8 | H3) + D2 | 0, H3 = (4 | H3) + D2 | 0; ; ) if ((E2 = q2[a + 8 >> 2]) && ((O2 = E2 + -1 | 0) >>> 0 <= 1 ? (P2 = (q2[a + 4 >> 2] << 2) + y3 | 0, E2 = q2[P2 + (q2[a + 12 >> 2] << 2) >> 2] << 2, F2 = u2[E2 + C3 >> 2], Q2 = u2[B2 + E2 >> 2], G2 = u2[z3 + E2 >> 2], O2 - 1 ? (M3 = G2, G2 = u2[a + 20 >> 2], u2[I3 >> 2] = u2[I3 >> 2] + x2(u2[a + 44 >> 2] * x2(M3 * G2)), u2[H3 >> 2] = u2[H3 >> 2] + x2(x2(Q2 * G2) * u2[a + 44 >> 2]), u2[K3 >> 2] = u2[K3 >> 2] + x2(x2(F2 * G2) * u2[a + 44 >> 2])) : (E2 = q2[(q2[a + 16 >> 2] << 2) + P2 >> 2] << 2, O2 = u2[E2 + C3 >> 2], P2 = u2[B2 + E2 >> 2], M3 = G2, G2 = u2[a + 20 >> 2], N3 = u2[a + 24 >> 2], u2[I3 >> 2] = u2[I3 >> 2] + x2(u2[a + 44 >> 2] * x2(x2(M3 * G2) + x2(u2[z3 + E2 >> 2] * N3))), u2[H3 >> 2] = u2[H3 >> 2] + x2(x2(x2(Q2 * G2) + x2(P2 * N3)) * u2[a + 44 >> 2]), u2[K3 >> 2] = u2[K3 >> 2] + x2(x2(x2(F2 * G2) + x2(O2 * N3)) * u2[a + 44 >> 2]))) : (q2[J3 >> 2] = E2, Y3(4, 1024, J3))), !((a = a + 48 | 0) >>> 0 < S >>> 0)) break;
                }
                if (a = (q2[v3 >> 2] << 4) + D2 | 0, F2 = u2[a >> 2], u2[a >> 2] = F2 < x2(0) ? x2(0) : x2(A(F2, x2(1))), F2 = u2[a + 4 >> 2], u2[a + 4 >> 2] = F2 < x2(0) ? x2(0) : x2(A(F2, x2(1))), F2 = u2[a + 8 >> 2], u2[a + 8 >> 2] = F2 < x2(0) ? x2(0) : x2(A(F2, x2(1))), !((v3 = v3 + 12 | 0) >>> 0 < R >>> 0)) break;
              }
              L2 = 16 + J3 | 0;
            }
            function ga(a, q3, v3) {
              var y3, x3 = 0, z3 = 0;
              if (1 == (0 | q3) & a >>> 0 < 0 | q3 >>> 0 < 1) x3 = a;
              else for (; ; ) if (y3 = ad(x3 = bd(a, q3, 10), z3 = M2, 10), o[0 | (v3 = v3 + -1 | 0)] = a - y3 | 48, y3 = 9 == (0 | q3) & 4294967295 < a >>> 0 | 9 < q3 >>> 0, a = x3, q3 = z3, !y3) break;
              if (x3) {
                for (; ; ) if (o[0 | (v3 = v3 + -1 | 0)] = x3 - w2(a = (x3 >>> 0) / 10 | 0, 10) | 48, q3 = 9 < x3 >>> 0, x3 = a, !q3) break;
              }
              return v3;
            }
            function ha2(a) {
              return a + -48 >>> 0 < 10;
            }
            function ia2(a) {
              var q3;
              return (q3 = La(a, 64)) ? q3 - a | 0 : 64;
            }
            function ja2(a, v3) {
              var w3 = 0;
              return 1024 <= (0 | v3) ? (a *= 898846567431158e293, v3 = (0 | (w3 = v3 + -1023 | 0)) < 1024 ? w3 : (a *= 898846567431158e293, ((0 | v3) < 3069 ? v3 : 3069) + -2046 | 0)) : -1023 < (0 | v3) || (a *= 22250738585072014e-324, v3 = -1023 < (0 | (w3 = v3 + 1022 | 0)) ? w3 : (a *= 22250738585072014e-324, (-3066 < (0 | v3) ? v3 : -3066) + 2044 | 0)), f(0, 0), f(1, v3 + 1023 << 20), a * +g();
            }
            function ka2(a, v3) {
              var A2 = 0, B2 = 0, C3 = a, B2 = v3 >>> 0 <= 31 ? (A2 = q2[a + 4 >> 2], q2[a >> 2]) : (A2 = q2[a >> 2], q2[a + 4 >> 2] = A2, v3 = v3 + -32 | (q2[a >> 2] = 0), 0);
              q2[C3 >> 2] = B2 << v3, q2[a + 4 >> 2] = A2 << v3 | B2 >>> 32 - v3;
            }
            function la2(a, v3, D2, V2, W2) {
              var X4, Y4 = 0, Z3 = 0, _2 = 0;
              L2 = X4 = L2 - 240 | 0, Y4 = q2[v3 >> 2], q2[232 + X4 >> 2] = Y4, v3 = q2[v3 + 4 >> 2], q2[X4 >> 2] = a, q2[236 + X4 >> 2] = v3, Z3 = 1;
              a: {
                b: {
                  c: {
                    if ((v3 || 1 != (0 | Y4)) && (Y4 = a - q2[(D2 << 2) + W2 >> 2] | 0, !((0 | n2[5](Y4, a)) < 1))) {
                      for (_2 = !V2; ; ) {
                        e: {
                          if (v3 = Y4, !(!_2 | (0 | D2) < 2)) {
                            if (V2 = q2[((D2 << 2) + W2 | 0) - 8 >> 2], -1 < (0 | n2[5](Y4 = a + -4 | 0, v3))) break e;
                            if (-1 < (0 | n2[5](Y4 - V2 | 0, v3))) break e;
                          }
                          if (q2[(Z3 << 2) + X4 >> 2] = v3, Z3 = Z3 + 1 | 0, ma2(232 + X4 | 0, a = Oa(232 + X4 | 0)), D2 = a + D2 | 0, !q2[236 + X4 >> 2] && 1 == q2[232 + X4 >> 2]) break b;
                          if (_2 = 1, Y4 = (a = v3) - q2[(D2 << 2) + W2 >> 2] | (V2 = 0), 0 < (0 | n2[5](Y4, q2[X4 >> 2]))) continue;
                          break c;
                        }
                        break;
                      }
                      v3 = a;
                      break b;
                    }
                    v3 = a;
                  }
                  if (V2) break a;
                }
                Na(X4, Z3), ta2(v3, D2, W2);
              }
              L2 = 240 + X4 | 0;
            }
            function ma2(a, v3) {
              var D2 = 0, L3 = 0, V2 = a, L3 = v3 >>> 0 <= 31 ? (D2 = q2[a >> 2], q2[a + 4 >> 2]) : (D2 = q2[a + 4 >> 2], q2[a + 4 >> 2] = 0, q2[a >> 2] = D2, v3 = v3 + -32 | 0, 0);
              q2[V2 + 4 >> 2] = L3 >>> v3, q2[a >> 2] = L3 << 32 - v3 | D2 >>> v3;
            }
            function na2(a, v3) {
              var W2 = r2[a + 4 | 0];
              q2[v3 >> 2] = q2[a + 64 >> 2] + a, q2[v3 + 4 >> 2] = q2[a + 68 >> 2] + a, q2[v3 + 8 >> 2] = q2[a + 72 >> 2] + a, q2[v3 + 12 >> 2] = q2[a + 76 >> 2] + a, q2[v3 + 16 >> 2] = q2[a + 80 >> 2] + a, q2[v3 + 20 >> 2] = q2[a + 84 >> 2] + a, q2[v3 + 24 >> 2] = q2[a + 88 >> 2] + a, q2[v3 + 28 >> 2] = q2[a + 92 >> 2] + a, q2[v3 + 32 >> 2] = q2[a + 96 >> 2] + a, q2[v3 + 36 >> 2] = q2[a + 100 >> 2] + a, q2[v3 + 40 >> 2] = q2[a + 104 >> 2] + a, q2[v3 + 44 >> 2] = q2[a + 108 >> 2] + a, q2[v3 + 48 >> 2] = q2[a + 112 >> 2] + a, q2[v3 + 52 >> 2] = q2[a + 116 >> 2] + a, q2[v3 + 56 >> 2] = q2[a + 120 >> 2] + a, q2[v3 + 60 >> 2] = q2[a + 124 >> 2] + a, q2[v3 - -64 >> 2] = q2[a + 128 >> 2] + a, q2[v3 + 68 >> 2] = q2[a + 132 >> 2] + a, q2[v3 + 72 >> 2] = q2[a + 136 >> 2] + a, q2[v3 + 76 >> 2] = q2[a + 140 >> 2] + a, q2[v3 + 80 >> 2] = q2[a + 144 >> 2] + a, q2[v3 + 84 >> 2] = q2[a + 148 >> 2] + a, q2[v3 + 92 >> 2] = q2[a + 152 >> 2] + a, q2[v3 + 96 >> 2] = q2[a + 156 >> 2] + a, q2[v3 + 100 >> 2] = q2[a + 160 >> 2] + a, q2[v3 + 108 >> 2] = q2[a + 164 >> 2] + a, q2[v3 + 112 >> 2] = q2[a + 168 >> 2] + a, q2[v3 + 116 >> 2] = q2[a + 172 >> 2] + a, q2[v3 + 124 >> 2] = q2[a + 176 >> 2] + a, q2[v3 + 128 >> 2] = q2[a + 180 >> 2] + a, q2[v3 + 132 >> 2] = q2[a + 184 >> 2] + a, q2[v3 + 136 >> 2] = q2[a + 188 >> 2] + a, q2[v3 + 140 >> 2] = q2[a + 192 >> 2] + a, q2[v3 + 144 >> 2] = q2[a + 196 >> 2] + a, q2[v3 + 148 >> 2] = q2[a + 200 >> 2] + a, q2[v3 + 152 >> 2] = q2[a + 204 >> 2] + a, q2[v3 + 156 >> 2] = q2[a + 208 >> 2] + a, q2[v3 + 164 >> 2] = q2[a + 212 >> 2] + a, q2[v3 + 168 >> 2] = q2[a + 216 >> 2] + a, q2[v3 + 172 >> 2] = q2[a + 220 >> 2] + a, q2[v3 + 176 >> 2] = q2[a + 224 >> 2] + a, q2[v3 + 180 >> 2] = q2[a + 228 >> 2] + a, q2[v3 + 184 >> 2] = q2[a + 232 >> 2] + a, q2[v3 + 188 >> 2] = q2[a + 236 >> 2] + a, q2[v3 + 192 >> 2] = q2[a + 240 >> 2] + a, q2[v3 + 196 >> 2] = q2[a + 244 >> 2] + a, q2[v3 + 200 >> 2] = q2[a + 248 >> 2] + a, q2[v3 + 204 >> 2] = q2[a + 252 >> 2] + a, q2[v3 + 208 >> 2] = q2[a + 256 >> 2] + a, q2[v3 + 212 >> 2] = q2[a + 260 >> 2] + a, q2[v3 + 216 >> 2] = q2[a + 264 >> 2] + a, q2[v3 + 220 >> 2] = q2[a + 268 >> 2] + a, q2[v3 + 224 >> 2] = q2[a + 272 >> 2] + a, q2[v3 + 228 >> 2] = q2[a + 276 >> 2] + a, q2[v3 + 232 >> 2] = q2[a + 280 >> 2] + a, q2[v3 + 236 >> 2] = q2[a + 284 >> 2] + a, q2[v3 + 244 >> 2] = q2[a + 288 >> 2] + a, q2[v3 + 248 >> 2] = q2[a + 292 >> 2] + a, q2[v3 + 272 >> 2] = q2[a + 296 >> 2] + a, q2[v3 + 276 >> 2] = q2[a + 300 >> 2] + a, q2[v3 + 280 >> 2] = q2[a + 304 >> 2] + a, q2[v3 + 292 >> 2] = q2[a + 308 >> 2] + a, q2[v3 + 296 >> 2] = q2[a + 312 >> 2] + a, q2[v3 + 300 >> 2] = q2[a + 316 >> 2] + a, q2[v3 + 304 >> 2] = q2[a + 320 >> 2] + a, q2[v3 + 308 >> 2] = q2[a + 324 >> 2] + a, q2[v3 + 312 >> 2] = q2[a + 328 >> 2] + a, q2[v3 + 316 >> 2] = q2[a + 332 >> 2] + a, q2[v3 + 328 >> 2] = q2[a + 336 >> 2] + a, q2[v3 + 332 >> 2] = q2[a + 340 >> 2] + a, q2[v3 + 336 >> 2] = q2[a + 344 >> 2] + a, q2[v3 + 348 >> 2] = q2[a + 348 >> 2] + a, q2[v3 + 360 >> 2] = q2[a + 352 >> 2] + a, q2[v3 + 364 >> 2] = q2[a + 356 >> 2] + a, q2[v3 + 368 >> 2] = q2[a + 360 >> 2] + a, q2[v3 + 352 >> 2] = q2[a + 364 >> 2] + a, q2[v3 + 356 >> 2] = q2[a + 368 >> 2] + a, q2[v3 + 488 >> 2] = q2[a + 372 >> 2] + a, q2[v3 + 492 >> 2] = q2[a + 376 >> 2] + a, q2[v3 + 496 >> 2] = q2[a + 380 >> 2] + a, q2[v3 + 500 >> 2] = q2[a + 384 >> 2] + a, q2[v3 + 504 >> 2] = q2[a + 388 >> 2] + a, q2[v3 + 508 >> 2] = q2[a + 392 >> 2] + a, q2[v3 + 512 >> 2] = q2[a + 396 >> 2] + a, q2[v3 + 516 >> 2] = q2[a + 400 >> 2] + a, q2[v3 + 520 >> 2] = q2[a + 404 >> 2] + a, q2[v3 + 524 >> 2] = q2[a + 408 >> 2] + a, q2[v3 + 528 >> 2] = q2[a + 412 >> 2] + a, q2[v3 + 532 >> 2] = q2[a + 416 >> 2] + a, q2[v3 + 536 >> 2] = q2[a + 420 >> 2] + a, q2[v3 + 540 >> 2] = q2[a + 424 >> 2] + a, q2[v3 + 544 >> 2] = q2[a + 428 >> 2] + a, q2[v3 + 548 >> 2] = q2[a + 432 >> 2] + a, q2[v3 + 552 >> 2] = q2[a + 436 >> 2] + a, q2[v3 + 556 >> 2] = q2[a + 440 >> 2] + a, q2[v3 + 560 >> 2] = q2[a + 444 >> 2] + a, q2[v3 + 564 >> 2] = q2[a + 448 >> 2] + a, q2[v3 + 568 >> 2] = q2[a + 452 >> 2] + a, q2[v3 + 572 >> 2] = q2[a + 456 >> 2] + a, q2[v3 + 576 >> 2] = q2[a + 460 >> 2] + a, q2[v3 + 580 >> 2] = q2[a + 464 >> 2] + a, W2 >>> 0 < 2 || (q2[v3 + 104 >> 2] = q2[a + 468 >> 2] + a, W2 >>> 0 < 4) || (q2[v3 + 260 >> 2] = q2[a + 472 >> 2] + a, q2[v3 + 264 >> 2] = q2[a + 476 >> 2] + a, q2[v3 + 268 >> 2] = q2[a + 480 >> 2] + a, q2[v3 + 88 >> 2] = q2[a + 484 >> 2] + a, q2[v3 + 120 >> 2] = q2[a + 488 >> 2] + a, q2[v3 + 160 >> 2] = q2[a + 492 >> 2] + a, q2[v3 + 584 >> 2] = q2[a + 496 >> 2] + a, q2[v3 + 588 >> 2] = q2[a + 500 >> 2] + a, q2[v3 + 592 >> 2] = q2[a + 504 >> 2] + a, q2[v3 + 596 >> 2] = q2[a + 508 >> 2] + a, q2[v3 + 600 >> 2] = q2[a + 512 >> 2] + a, q2[v3 + 604 >> 2] = q2[a + 516 >> 2] + a, q2[v3 + 240 >> 2] = q2[a + 520 >> 2] + a, q2[v3 + 252 >> 2] = q2[a + 524 >> 2] + a, q2[v3 + 256 >> 2] = q2[a + 528 >> 2] + a, q2[v3 + 372 >> 2] = q2[a + 532 >> 2] + a, q2[v3 + 376 >> 2] = q2[a + 536 >> 2] + a, q2[v3 + 380 >> 2] = q2[a + 540 >> 2] + a, q2[v3 + 384 >> 2] = q2[a + 544 >> 2] + a, q2[v3 + 388 >> 2] = q2[a + 548 >> 2] + a, q2[v3 + 392 >> 2] = q2[a + 552 >> 2] + a, q2[v3 + 396 >> 2] = q2[a + 556 >> 2] + a, q2[v3 + 400 >> 2] = q2[a + 560 >> 2] + a, q2[v3 + 416 >> 2] = q2[a + 564 >> 2] + a, q2[v3 + 420 >> 2] = q2[a + 568 >> 2] + a, q2[v3 + 424 >> 2] = q2[a + 572 >> 2] + a, q2[v3 + 440 >> 2] = q2[a + 576 >> 2] + a, q2[v3 + 444 >> 2] = q2[a + 580 >> 2] + a, q2[v3 + 448 >> 2] = q2[a + 584 >> 2] + a, q2[v3 + 464 >> 2] = q2[a + 588 >> 2] + a, q2[v3 + 468 >> 2] = q2[a + 592 >> 2] + a, q2[v3 + 472 >> 2] = q2[a + 596 >> 2] + a, q2[v3 + 476 >> 2] = q2[a + 600 >> 2] + a, q2[v3 + 480 >> 2] = q2[a + 604 >> 2] + a, q2[v3 + 484 >> 2] = q2[a + 608 >> 2] + a, 4 != (0 | W2) && (q2[v3 + 284 >> 2] = q2[a + 612 >> 2] + a, q2[v3 + 288 >> 2] = q2[a + 616 >> 2] + a, q2[v3 + 320 >> 2] = q2[a + 620 >> 2] + a, q2[v3 + 324 >> 2] = q2[a + 624 >> 2] + a, q2[v3 + 340 >> 2] = q2[a + 628 >> 2] + a, q2[v3 + 344 >> 2] = q2[a + 632 >> 2] + a, q2[v3 + 404 >> 2] = q2[a + 636 >> 2] + a, q2[v3 + 408 >> 2] = q2[a + 640 >> 2] + a, q2[v3 + 412 >> 2] = q2[a + 644 >> 2] + a, q2[v3 + 428 >> 2] = q2[a + 648 >> 2] + a, q2[v3 + 432 >> 2] = q2[a + 652 >> 2] + a, q2[v3 + 436 >> 2] = q2[a + 656 >> 2] + a, q2[v3 + 452 >> 2] = q2[a + 660 >> 2] + a, q2[v3 + 456 >> 2] = q2[a + 664 >> 2] + a, q2[v3 + 460 >> 2] = q2[a + 668 >> 2] + a));
            }
            function oa2(a, v3, $2) {
              var aa2 = 0;
              a: {
                if (8 == (0 | v3)) v3 = qa($2);
                else {
                  if (aa2 = 28, 3 & v3 | 1 != (0 | function(a2) {
                    var $o = 0, ap = 0;
                    for (; ; ) {
                      if (ap = $o, !a2) break;
                      a2 &= a2 - 1, $o = $o + 1 | 0;
                    }
                    return ap;
                  }(v3 >>> 2))) break a;
                  if (aa2 = 48, -64 - v3 >>> 0 < $2 >>> 0) break a;
                  v3 = function(a2, Vk) {
                    var ql = 0, tl = 0, ul = 0, vl = 0, wl = 0;
                    if ((tl = a2 >>> 0 > (ql = 16) ? a2 : 16) + -1 & tl) {
                      for (; ; ) if (ql = (a2 = ql) << 1, !(a2 >>> 0 < tl >>> 0)) break;
                    } else a2 = tl;
                    if (-64 - a2 >>> 0 <= Vk >>> 0) return q2[2086] = 48, 0;
                    if (!(ql = qa(12 + ((tl = Vk >>> 0 < 11 ? 16 : Vk + 11 & -8) + a2 | 0) | 0))) return 0;
                    Vk = ql + -8 | 0;
                    ql & a2 + -1 ? (wl = q2[(vl = ql + -4 | 0) >> 2], ul = (-8 & wl) - (ql = (a2 = 15 < (ql = ((a2 + ql | 0) - 1 & 0 - a2) - 8 | 0) - Vk >>> 0 ? ql : a2 + ql | 0) - Vk | 0) | 0, 3 & wl ? (q2[a2 + 4 >> 2] = ul | 1 & q2[a2 + 4 >> 2] | 2, q2[4 + (ul = a2 + ul | 0) >> 2] = 1 | q2[4 + ul >> 2], q2[vl >> 2] = ql | 1 & q2[vl >> 2] | 2, q2[a2 + 4 >> 2] = 1 | q2[a2 + 4 >> 2], za(Vk, ql)) : (Vk = q2[Vk >> 2], q2[a2 + 4 >> 2] = ul, q2[a2 >> 2] = Vk + ql)) : a2 = Vk;
                    3 & (Vk = q2[a2 + 4 >> 2]) && ((ql = -8 & Vk) >>> 0 <= tl + 16 >>> 0 || (q2[a2 + 4 >> 2] = tl | 1 & Vk | 2, Vk = a2 + tl | 0, tl = ql - tl | 0, q2[Vk + 4 >> 2] = 3 | tl, q2[(ql = a2 + ql | 0) + 4 >> 2] = 1 | q2[ql + 4 >> 2], za(Vk, tl)));
                    return a2 + 8 | 0;
                  }(16 < v3 >>> 0 ? v3 : 16, $2);
                }
                if (!v3) return 1;
                q2[a >> 2] = v3, aa2 = 0;
              }
              return aa2;
            }
            function pa2(a) {
              var da3, v3 = 0, $2 = 0, ba2 = 0, ca3 = 0, ea2 = 0, fa2 = 0, ha3 = 0;
              a: if (a) {
                da3 = (ba2 = a + -8 | 0) + (a = -8 & ($2 = q2[a + -4 >> 2])) | 0;
                b: if (!(1 & $2)) {
                  if (!(3 & $2)) break a;
                  if ((ba2 = ba2 - ($2 = q2[ba2 >> 2]) | 0) >>> 0 < t3[2091]) break a;
                  if (a = a + $2 | 0, q2[2092] != (0 | ba2)) if ($2 >>> 0 <= 255) ca3 = q2[ba2 + 8 >> 2], $2 >>>= 3, (0 | (v3 = q2[ba2 + 12 >> 2])) == (0 | ca3) ? (ha3 = q2[2087] & dd($2), q2[8348 >> 2] = ha3) : (q2[ca3 + 12 >> 2] = v3, q2[v3 + 8 >> 2] = ca3);
                  else {
                    if (fa2 = q2[ba2 + 24 >> 2], (0 | ba2) != (0 | ($2 = q2[ba2 + 12 >> 2]))) v3 = q2[ba2 + 8 >> 2], q2[v3 + 12 >> 2] = $2, q2[$2 + 8 >> 2] = v3;
                    else if ((v3 = q2[(ca3 = ba2 + 20 | 0) >> 2]) || (v3 = q2[(ca3 = ba2 + 16 | 0) >> 2])) {
                      for (; ; ) if (ea2 = ca3, !((v3 = q2[(ca3 = ($2 = v3) + 20 | 0) >> 2]) || (ca3 = $2 + 16 | 0, v3 = q2[$2 + 16 >> 2]))) break;
                      q2[ea2 >> 2] = 0;
                    } else $2 = 0;
                    if (fa2) {
                      ca3 = q2[ba2 + 28 >> 2];
                      e: {
                        if (q2[(v3 = 8652 + (ca3 << 2) | 0) >> 2] == (0 | ba2)) {
                          if (q2[v3 >> 2] = $2) break e;
                          ha3 = q2[2088] & dd(ca3), q2[8352 >> 2] = ha3;
                          break b;
                        }
                        if (!(q2[fa2 + (q2[fa2 + 16 >> 2] == (0 | ba2) ? 16 : 20) >> 2] = $2)) break b;
                      }
                      q2[$2 + 24 >> 2] = fa2, (v3 = q2[ba2 + 16 >> 2]) && (q2[$2 + 16 >> 2] = v3, q2[v3 + 24 >> 2] = $2), (v3 = q2[ba2 + 20 >> 2]) && (q2[$2 + 20 >> 2] = v3, q2[v3 + 24 >> 2] = $2);
                    }
                  }
                  else if (3 == (3 & ($2 = q2[4 + da3 >> 2]))) return q2[2089] = a, q2[4 + da3 >> 2] = -2 & $2, q2[ba2 + 4 >> 2] = 1 | a, void (q2[a + ba2 >> 2] = a);
                }
                if (!(da3 >>> 0 <= ba2 >>> 0) && 1 & ($2 = q2[4 + da3 >> 2])) {
                  f: {
                    if (!(2 & $2)) {
                      if (q2[2093] == (0 | da3)) {
                        if (q2[2093] = ba2, a = q2[2090] + a | 0, q2[2090] = a, q2[ba2 + 4 >> 2] = 1 | a, q2[2092] != (0 | ba2)) break a;
                        return q2[2089] = 0, void (q2[2092] = 0);
                      }
                      if (q2[2092] == (0 | da3)) return q2[2092] = ba2, a = q2[2089] + a | 0, q2[2089] = a, q2[ba2 + 4 >> 2] = 1 | a, void (q2[a + ba2 >> 2] = a);
                      a = (-8 & $2) + a | 0;
                      g: if ($2 >>> 0 <= 255) $2 >>>= 3, (0 | (v3 = q2[8 + da3 >> 2])) == (0 | (ca3 = q2[12 + da3 >> 2])) ? (ha3 = q2[2087] & dd($2), q2[8348 >> 2] = ha3) : (q2[v3 + 12 >> 2] = ca3, q2[ca3 + 8 >> 2] = v3);
                      else {
                        if (fa2 = q2[24 + da3 >> 2], (0 | da3) != (0 | ($2 = q2[12 + da3 >> 2]))) v3 = q2[8 + da3 >> 2], q2[v3 + 12 >> 2] = $2, q2[$2 + 8 >> 2] = v3;
                        else if ((v3 = q2[(ca3 = 20 + da3 | 0) >> 2]) || (v3 = q2[(ca3 = 16 + da3 | 0) >> 2])) {
                          for (; ; ) if (ea2 = ca3, !((v3 = q2[(ca3 = ($2 = v3) + 20 | 0) >> 2]) || (ca3 = $2 + 16 | 0, v3 = q2[$2 + 16 >> 2]))) break;
                          q2[ea2 >> 2] = 0;
                        } else $2 = 0;
                        if (fa2) {
                          ca3 = q2[28 + da3 >> 2];
                          j: {
                            if (q2[(v3 = 8652 + (ca3 << 2) | 0) >> 2] == (0 | da3)) {
                              if (q2[v3 >> 2] = $2) break j;
                              ha3 = q2[2088] & dd(ca3), q2[8352 >> 2] = ha3;
                              break g;
                            }
                            if (!(q2[fa2 + (q2[fa2 + 16 >> 2] == (0 | da3) ? 16 : 20) >> 2] = $2)) break g;
                          }
                          q2[$2 + 24 >> 2] = fa2, (v3 = q2[16 + da3 >> 2]) && (q2[$2 + 16 >> 2] = v3, q2[v3 + 24 >> 2] = $2), (v3 = q2[20 + da3 >> 2]) && (q2[$2 + 20 >> 2] = v3, q2[v3 + 24 >> 2] = $2);
                        }
                      }
                      if (q2[ba2 + 4 >> 2] = 1 | a, q2[a + ba2 >> 2] = a, q2[2092] != (0 | ba2)) break f;
                      return void (q2[2089] = a);
                    }
                    q2[4 + da3 >> 2] = -2 & $2, q2[ba2 + 4 >> 2] = 1 | a, q2[a + ba2 >> 2] = a;
                  }
                  if (a >>> 0 <= 255) return $2 = 8388 + ((a >>>= 3) << 3) | 0, a = (v3 = q2[2087]) & (a = 1 << a) ? q2[$2 + 8 >> 2] : (q2[2087] = a | v3, $2), q2[$2 + 8 >> 2] = ba2, q2[a + 12 >> 2] = ba2, q2[ba2 + 12 >> 2] = $2, void (q2[ba2 + 8 >> 2] = a);
                  q2[ba2 + 16 >> 2] = 0, v3 = q2[ba2 + 20 >> 2] = 0, (ca3 = a >>> 8) && (v3 = 31, 16777215 < a >>> 0 || (v3 = ca3, v3 = 28 + ((v3 = ((v3 = (v3 <<= ca3 = ca3 + 1048320 >>> 16 & 8) << (fa2 = v3 + 520192 >>> 16 & 4)) << (ea2 = v3 + 245760 >>> 16 & 2) >>> 15) - (ea2 | ca3 | fa2) | 0) << 1 | a >>> v3 + 21 & 1) | 0)), ea2 = 8652 + ((q2[($2 = ba2) + 28 >> 2] = v3) << 2) | 0;
                  m: if ((ca3 = q2[2088]) & ($2 = 1 << v3)) {
                    ca3 = a << (31 == (0 | v3) ? 0 : 25 - (v3 >>> 1) | 0), $2 = q2[ea2 >> 2];
                    n: {
                      for (; ; ) {
                        if ((-8 & q2[(v3 = $2) + 4 >> 2]) == (0 | a)) break n;
                        if ($2 = ca3 >>> 29, ca3 <<= 1, !($2 = q2[(ea2 = v3 + (4 & $2) | 0) + 16 >> 2])) break;
                      }
                      q2[ea2 + 16 >> 2] = ba2, q2[ba2 + 12 >> 2] = ba2, q2[ba2 + 24 >> 2] = v3, q2[ba2 + 8 >> 2] = ba2;
                      break m;
                    }
                    a = q2[v3 + 8 >> 2], q2[a + 12 >> 2] = ba2, q2[v3 + 8 >> 2] = ba2, q2[ba2 + 24 >> 2] = 0, q2[ba2 + 12 >> 2] = v3, q2[ba2 + 8 >> 2] = a;
                  } else q2[2088] = $2 | ca3, q2[ea2 >> 2] = ba2, q2[ba2 + 12 >> 2] = ba2, q2[ba2 + 24 >> 2] = ea2, q2[ba2 + 8 >> 2] = ba2;
                  if (a = q2[2095] + -1 | 0, !(q2[2095] = a)) {
                    for (ba2 = 8804; ; ) if (ba2 = (a = q2[ba2 >> 2]) + 8 | 0, !a) break;
                    q2[2095] = -1;
                  }
                }
              }
            }
            function qa(a) {
              var sa2, ia3 = 0, ja3 = 0, ka3 = 0, la3 = 0, ma3 = 0, na3 = 0, oa3 = 0, pa3 = 0, qa2 = 0, ra3 = 0, ua2 = 0;
              L2 = sa2 = L2 - 16 | 0;
              a: {
                b: {
                  c: {
                    d: {
                      e: {
                        f: {
                          g: {
                            h: {
                              i: {
                                j: {
                                  k: {
                                    if (a >>> 0 <= 244) {
                                      if (3 & (ia3 = (ma3 = q2[2087]) >>> (a = (na3 = a >>> 0 < 11 ? 16 : a + 11 & -8) >>> 3))) {
                                        a = (ia3 = q2[(la3 = (ja3 = a + (1 & (-1 ^ ia3)) | 0) << 3) + 8396 >> 2]) + 8 | 0, (0 | (ka3 = q2[ia3 + 8 >> 2])) == (0 | (la3 = la3 + 8388 | 0)) ? (ua2 = dd(ja3) & ma3, q2[8348 >> 2] = ua2) : (q2[ka3 + 12 >> 2] = la3, q2[la3 + 8 >> 2] = ka3), q2[ia3 + 4 >> 2] = 3 | (ja3 <<= 3), q2[(ia3 = ia3 + ja3 | 0) + 4 >> 2] = 1 | q2[ia3 + 4 >> 2];
                                        break a;
                                      }
                                      if (na3 >>> 0 <= (pa3 = q2[2089]) >>> 0) break k;
                                      if (ia3) {
                                        ja3 = ia3 = (a = (0 - (a = (0 - (ja3 = 2 << a) | ja3) & ia3 << a) & a) - 1 | 0) >>> 12 & 16, ia3 = q2[(ka3 = (ja3 = ((ja3 = (ja3 |= ia3 = (a >>>= ia3) >>> 5 & 8) | (ia3 = (a >>>= ia3) >>> 2 & 4) | (ia3 = (a >>>= ia3) >>> 1 & 2)) | (ia3 = (a >>>= ia3) >>> 1 & 1)) + (a >>> ia3) | 0) << 3) + 8396 >> 2], (0 | (a = q2[ia3 + 8 >> 2])) == (0 | (ka3 = ka3 + 8388 | 0)) ? (ma3 = dd(ja3) & ma3, q2[2087] = ma3) : (q2[a + 12 >> 2] = ka3, q2[ka3 + 8 >> 2] = a), a = ia3 + 8 | 0, q2[ia3 + 4 >> 2] = 3 | na3, q2[(oa3 = ia3 + na3 | 0) + 4 >> 2] = 1 | (la3 = (ja3 <<= 3) - na3 | 0), q2[ia3 + ja3 >> 2] = la3, pa3 && (ia3 = 8388 + ((ja3 = pa3 >>> 3) << 3) | 0, ka3 = q2[2092], ja3 = (ja3 = 1 << ja3) & ma3 ? q2[ia3 + 8 >> 2] : (q2[2087] = ja3 | ma3, ia3), q2[ia3 + 8 >> 2] = ka3, q2[ja3 + 12 >> 2] = ka3, q2[ka3 + 12 >> 2] = ia3, q2[ka3 + 8 >> 2] = ja3), q2[2092] = oa3, q2[2089] = la3;
                                        break a;
                                      }
                                      if (!(ra3 = q2[2088])) break k;
                                      for (ja3 = ia3 = (a = (ra3 & 0 - ra3) - 1 | 0) >>> 12 & 16, ia3 = q2[8652 + (((ja3 = (ja3 |= ia3 = (a >>>= ia3) >>> 5 & 8) | (ia3 = (a >>>= ia3) >>> 2 & 4) | (ia3 = (a >>>= ia3) >>> 1 & 2)) | (ia3 = (a >>>= ia3) >>> 1 & 1)) + (a >>> ia3) << 2) >> 2], ka3 = (-8 & q2[ia3 + 4 >> 2]) - na3 | 0, ja3 = ia3; ; ) {
                                        if (!(a = (a = q2[ja3 + 16 >> 2]) || q2[ja3 + 20 >> 2])) break;
                                        ka3 = (ja3 = (la3 = (-8 & q2[a + 4 >> 2]) - na3 | 0) >>> 0 < ka3 >>> 0) ? la3 : ka3, ia3 = ja3 ? a : ia3, ja3 = a;
                                      }
                                      if (qa2 = q2[ia3 + 24 >> 2], (0 | (la3 = q2[ia3 + 12 >> 2])) != (0 | ia3)) {
                                        a = q2[ia3 + 8 >> 2], q2[a + 12 >> 2] = la3, q2[la3 + 8 >> 2] = a;
                                        break b;
                                      }
                                      if (!(a = q2[(ja3 = ia3 + 20 | 0) >> 2])) {
                                        if (!(a = q2[ia3 + 16 >> 2])) break j;
                                        ja3 = ia3 + 16 | 0;
                                      }
                                      for (; ; ) if (oa3 = ja3, !((a = q2[(ja3 = (la3 = a) + 20 | 0) >> 2]) || (ja3 = la3 + 16 | 0, a = q2[la3 + 16 >> 2]))) break;
                                      q2[oa3 >> 2] = 0;
                                      break b;
                                    }
                                    if (na3 = -1, !(4294967231 < a >>> 0) && (na3 = -8 & (ia3 = a + 11 | 0), pa3 = q2[2088])) {
                                      ja3 = 0 - na3 | 0, ma3 = 0, (ia3 >>>= 8) && (ma3 = 31, 16777215 < na3 >>> 0 || (ma3 = 28 + ((a = ((ma3 = (ia3 <<= ka3 = ia3 + 1048320 >>> 16 & 8) << (a = ia3 + 520192 >>> 16 & 4)) << (ia3 = ma3 + 245760 >>> 16 & 2) >>> 15) - (ia3 | a | ka3) | 0) << 1 | na3 >>> a + 21 & 1) | 0));
                                      q: {
                                        r: {
                                          if (ka3 = q2[8652 + (ma3 << 2) >> 2]) for (ia3 = na3 << (31 == (0 | ma3) ? 0 : 25 - (ma3 >>> 1) | 0), a = 0; ; ) {
                                            if (!(ja3 >>> 0 <= (oa3 = (-8 & q2[ka3 + 4 >> 2]) - na3 | 0) >>> 0 || (la3 = ka3, ja3 = oa3))) {
                                              ja3 = 0, a = ka3;
                                              break r;
                                            }
                                            if (oa3 = q2[ka3 + 20 >> 2], ka3 = q2[16 + ((ia3 >>> 29 & 4) + ka3 | 0) >> 2], a = !oa3 || (0 | oa3) == (0 | ka3) ? a : oa3, ia3 <<= 0 != (0 | ka3), !ka3) break;
                                          }
                                          else a = 0;
                                          if (!(a | la3)) {
                                            if (!(a = (0 - (a = 2 << ma3) | a) & pa3)) break k;
                                            ka3 = ia3 = (a = (a & 0 - a) - 1 | 0) >>> 12 & 16, a = q2[8652 + (((ka3 = (ka3 |= ia3 = (a >>>= ia3) >>> 5 & 8) | (ia3 = (a >>>= ia3) >>> 2 & 4) | (ia3 = (a >>>= ia3) >>> 1 & 2)) | (ia3 = (a >>>= ia3) >>> 1 & 1)) + (a >>> ia3) << 2) >> 2];
                                          }
                                          if (!a) break q;
                                        }
                                        for (; ; ) if (ja3 = (ia3 = (ka3 = (-8 & q2[a + 4 >> 2]) - na3 | 0) >>> 0 < ja3 >>> 0) ? ka3 : ja3, la3 = ia3 ? a : la3, !(a = (ia3 = q2[a + 16 >> 2]) || q2[a + 20 >> 2])) break;
                                      }
                                      if (!(!la3 | ja3 >>> 0 >= q2[2089] - na3 >>> 0)) {
                                        if (oa3 = q2[la3 + 24 >> 2], (0 | la3) != (0 | (ia3 = q2[la3 + 12 >> 2]))) {
                                          a = q2[la3 + 8 >> 2], q2[a + 12 >> 2] = ia3, q2[ia3 + 8 >> 2] = a;
                                          break c;
                                        }
                                        if (!(a = q2[(ka3 = la3 + 20 | 0) >> 2])) {
                                          if (!(a = q2[la3 + 16 >> 2])) break i;
                                          ka3 = la3 + 16 | 0;
                                        }
                                        for (; ; ) if (ma3 = ka3, !((a = q2[(ka3 = (ia3 = a) + 20 | 0) >> 2]) || (ka3 = ia3 + 16 | 0, a = q2[ia3 + 16 >> 2]))) break;
                                        q2[ma3 >> 2] = 0;
                                        break c;
                                      }
                                    }
                                  }
                                  if (na3 >>> 0 <= (ia3 = q2[2089]) >>> 0) {
                                    a = q2[2092], 16 <= (ja3 = ia3 - na3 | 0) >>> 0 ? (q2[2089] = ja3, q2[2092] = ka3 = a + na3 | 0, q2[ka3 + 4 >> 2] = 1 | ja3, q2[a + ia3 >> 2] = ja3, q2[a + 4 >> 2] = 3 | na3) : (q2[2092] = 0, q2[2089] = 0, q2[a + 4 >> 2] = 3 | ia3, q2[(ia3 = a + ia3 | 0) + 4 >> 2] = 1 | q2[ia3 + 4 >> 2]), a = a + 8 | 0;
                                    break a;
                                  }
                                  if (na3 >>> 0 < (ka3 = q2[2090]) >>> 0) {
                                    q2[2090] = ia3 = ka3 - na3 | 0, a = q2[2093], q2[2093] = ja3 = a + na3 | 0, q2[ja3 + 4 >> 2] = 1 | ia3, q2[a + 4 >> 2] = 3 | na3, a = a + 8 | 0;
                                    break a;
                                  }
                                  if ((ja3 = (ma3 = (ja3 = la3 = na3 + 47 | (a = 0)) + (ia3 = q2[2205] ? q2[2207] : (q2[2208] = -1, q2[2209] = -1, q2[2206] = 4096, q2[2207] = 4096, q2[2205] = 12 + sa2 & -16 ^ 1431655768, q2[2210] = 0, q2[2198] = 0, 4096)) | 0) & (oa3 = 0 - ia3 | 0)) >>> 0 <= na3 >>> 0) break a;
                                  if ((ia3 = q2[2197]) && (qa2 = (pa3 = q2[2195]) + ja3 | 0) >>> 0 <= pa3 >>> 0 | ia3 >>> 0 < qa2 >>> 0) break a;
                                  if (4 & r2[8792]) break f;
                                  v: {
                                    w: {
                                      if (ia3 = q2[2093]) for (a = 8796; ; ) {
                                        if ((pa3 = q2[a >> 2]) + q2[a + 4 >> 2] >>> 0 > ia3 >>> 0 && pa3 >>> 0 <= ia3 >>> 0) break w;
                                        if (!(a = q2[a + 8 >> 2])) break;
                                      }
                                      if (-1 == (0 | (ia3 = ea(0)))) break g;
                                      if (ma3 = ja3, (ma3 = (ka3 = (a = q2[2206]) + -1 | 0) & ia3 ? (ja3 - ia3 | 0) + (ia3 + ka3 & 0 - a) | 0 : ma3) >>> 0 <= na3 >>> 0 | 2147483646 < ma3 >>> 0) break g;
                                      if ((a = q2[2197]) && (oa3 = (ka3 = q2[2195]) + ma3 | 0) >>> 0 <= ka3 >>> 0 | a >>> 0 < oa3 >>> 0) break g;
                                      if ((0 | ia3) != (0 | (a = ea(ma3)))) break v;
                                      break e;
                                    }
                                    if (2147483646 < (ma3 = oa3 & ma3 - ka3) >>> 0) break g;
                                    if ((0 | (ia3 = ea(ma3))) == (q2[a >> 2] + q2[a + 4 >> 2] | 0)) break h;
                                    a = ia3;
                                  }
                                  if (!(na3 + 48 >>> 0 <= ma3 >>> 0 | 2147483646 < ma3 >>> 0 | -1 == (0 | (ia3 = a)))) {
                                    if (2147483646 < (a = (a = q2[2207]) + (la3 - ma3 | 0) & 0 - a) >>> 0) break e;
                                    if (-1 != (0 | ea(a))) {
                                      ma3 = a + ma3 | 0;
                                      break e;
                                    }
                                    ea(0 - ma3 | 0);
                                    break g;
                                  }
                                  if (-1 != (0 | ia3)) break e;
                                  break g;
                                }
                                la3 = 0;
                                break b;
                              }
                              ia3 = 0;
                              break c;
                            }
                            if (-1 != (0 | ia3)) break e;
                          }
                          q2[2198] = 4 | q2[2198];
                        }
                        if (2147483646 < ja3 >>> 0) break d;
                        if (ia3 = ea(ja3), (a = ea(0)) >>> 0 <= ia3 >>> 0 | -1 == (0 | ia3) | -1 == (0 | a)) break d;
                        if ((ma3 = a - ia3 | 0) >>> 0 <= na3 + 40 >>> 0) break d;
                      }
                      a = q2[2195] + ma3 | 0, (q2[2195] = a) >>> 0 > t3[2196] && (q2[2196] = a);
                      x: {
                        y: {
                          z: {
                            if (ja3 = q2[2093]) {
                              for (a = 8796; ; ) {
                                if (((ka3 = q2[a >> 2]) + (la3 = q2[a + 4 >> 2]) | 0) == (0 | ia3)) break z;
                                if (!(a = q2[a + 8 >> 2])) break;
                              }
                              break y;
                            }
                            for ((a = q2[2091]) >>> 0 <= ia3 >>> 0 && a || (q2[2091] = ia3), a = 0, q2[2200] = ma3, q2[2199] = ia3, q2[2095] = -1, q2[2096] = q2[2205], q2[2202] = 0; ; ) if (q2[(ja3 = a << 3) + 8396 >> 2] = ka3 = ja3 + 8388 | 0, q2[ja3 + 8400 >> 2] = ka3, 32 == (0 | (a = a + 1 | 0))) break;
                            q2[2090] = ka3 = (a = ma3 + -40 | 0) - (ja3 = ia3 + 8 & 7 ? -8 - ia3 & 7 : 0) | 0, q2[2093] = ja3 = ia3 + ja3 | 0, q2[ja3 + 4 >> 2] = 1 | ka3, q2[4 + (a + ia3 | 0) >> 2] = 40, q2[2094] = q2[2209];
                            break x;
                          }
                          if (!(8 & r2[a + 12 | 0] | ia3 >>> 0 <= ja3 >>> 0 | ja3 >>> 0 < ka3 >>> 0)) {
                            q2[a + 4 >> 2] = la3 + ma3, q2[2093] = ia3 = (a = ja3 + 8 & 7 ? -8 - ja3 & 7 : 0) + ja3 | 0, ka3 = q2[2090] + ma3 | 0, q2[2090] = a = ka3 - a | 0, q2[ia3 + 4 >> 2] = 1 | a, q2[4 + (ja3 + ka3 | 0) >> 2] = 40, q2[2094] = q2[2209];
                            break x;
                          }
                        }
                        ia3 >>> 0 < (la3 = q2[2091]) >>> 0 && (q2[2091] = ia3, la3 = 0), ka3 = ia3 + ma3 | 0, a = 8796;
                        A: {
                          B: {
                            C: {
                              D: {
                                E: {
                                  F: {
                                    for (; ; ) {
                                      if ((0 | ka3) == q2[a >> 2]) break;
                                      if (!(a = q2[a + 8 >> 2])) break F;
                                    }
                                    if (!(8 & r2[a + 12 | 0])) break E;
                                  }
                                  for (a = 8796; ; ) {
                                    if ((ka3 = q2[a >> 2]) >>> 0 <= ja3 >>> 0 && ja3 >>> 0 < (la3 = ka3 + q2[a + 4 >> 2] | 0) >>> 0) break D;
                                    a = q2[a + 8 >> 2];
                                  }
                                }
                                if (q2[a >> 2] = ia3, q2[a + 4 >> 2] = q2[a + 4 >> 2] + ma3, q2[(qa2 = (ia3 + 8 & 7 ? -8 - ia3 & 7 : 0) + ia3 | 0) + 4 >> 2] = 3 | na3, a = ((ia3 = ka3 + (ka3 + 8 & 7 ? -8 - ka3 & 7 : 0) | 0) - qa2 | 0) - na3 | 0, oa3 = na3 + qa2 | 0, (0 | ia3) == (0 | ja3)) {
                                  q2[2093] = oa3, a = q2[2090] + a | 0, q2[2090] = a, q2[oa3 + 4 >> 2] = 1 | a;
                                  break B;
                                }
                                if (q2[2092] == (0 | ia3)) {
                                  q2[2092] = oa3, a = q2[2089] + a | 0, q2[2089] = a, q2[oa3 + 4 >> 2] = 1 | a, q2[a + oa3 >> 2] = a;
                                  break B;
                                }
                                if (1 == (3 & (ja3 = q2[ia3 + 4 >> 2]))) {
                                  ra3 = -8 & ja3;
                                  G: if (ja3 >>> 0 <= 255) la3 = ja3 >>> 3, ja3 = q2[ia3 + 8 >> 2], (0 | (ka3 = q2[ia3 + 12 >> 2])) == (0 | ja3) ? (ua2 = q2[2087] & dd(la3), q2[8348 >> 2] = ua2) : (q2[ja3 + 12 >> 2] = ka3, q2[ka3 + 8 >> 2] = ja3);
                                  else {
                                    if (pa3 = q2[ia3 + 24 >> 2], (0 | (ma3 = q2[ia3 + 12 >> 2])) != (0 | ia3)) ja3 = q2[ia3 + 8 >> 2], q2[ja3 + 12 >> 2] = ma3, q2[ma3 + 8 >> 2] = ja3;
                                    else if ((na3 = q2[(ka3 = ia3 + 20 | 0) >> 2]) || (na3 = q2[(ka3 = ia3 + 16 | 0) >> 2])) {
                                      for (; ; ) if (ja3 = ka3, !((na3 = q2[(ka3 = (ma3 = na3) + 20 | 0) >> 2]) || (ka3 = ma3 + 16 | 0, na3 = q2[ma3 + 16 >> 2]))) break;
                                      q2[ja3 >> 2] = 0;
                                    } else ma3 = 0;
                                    if (pa3) {
                                      ja3 = q2[ia3 + 28 >> 2];
                                      J: {
                                        if (q2[(ka3 = 8652 + (ja3 << 2) | 0) >> 2] == (0 | ia3)) {
                                          if (q2[ka3 >> 2] = ma3) break J;
                                          ua2 = q2[2088] & dd(ja3), q2[8352 >> 2] = ua2;
                                          break G;
                                        }
                                        if (!(q2[pa3 + (q2[pa3 + 16 >> 2] == (0 | ia3) ? 16 : 20) >> 2] = ma3)) break G;
                                      }
                                      q2[ma3 + 24 >> 2] = pa3, (ja3 = q2[ia3 + 16 >> 2]) && (q2[ma3 + 16 >> 2] = ja3, q2[ja3 + 24 >> 2] = ma3), (ja3 = q2[ia3 + 20 >> 2]) && (q2[ma3 + 20 >> 2] = ja3, q2[ja3 + 24 >> 2] = ma3);
                                    }
                                  }
                                  ia3 = ia3 + ra3 | 0, a = a + ra3 | 0;
                                }
                                if (q2[ia3 + 4 >> 2] = -2 & q2[ia3 + 4 >> 2], q2[oa3 + 4 >> 2] = 1 | a, (q2[a + oa3 >> 2] = a) >>> 0 <= 255) {
                                  a = 8388 + ((ia3 = a >>> 3) << 3) | 0, ia3 = (ja3 = q2[2087]) & (ia3 = 1 << ia3) ? q2[a + 8 >> 2] : (q2[2087] = ia3 | ja3, a), q2[a + 8 >> 2] = oa3, q2[ia3 + 12 >> 2] = oa3, q2[oa3 + 12 >> 2] = a, q2[oa3 + 8 >> 2] = ia3;
                                  break B;
                                }
                                if (ia3 = 0, (ka3 = a >>> 8) && (ia3 = 31, 16777215 < a >>> 0 || (ia3 = 28 + ((ia3 = ((na3 = (ka3 <<= la3 = ka3 + 1048320 >>> 16 & 8) << (ia3 = ka3 + 520192 >>> 16 & 4)) << (ka3 = na3 + 245760 >>> 16 & 2) >>> 15) - (ka3 | ia3 | la3) | 0) << 1 | a >>> ia3 + 21 & 1) | 0)), q2[(ja3 = oa3) + 28 >> 2] = ia3, q2[oa3 + 16 >> 2] = 0, ja3 = 8652 + (ia3 << 2) | (q2[oa3 + 20 >> 2] = 0), (ka3 = q2[2088]) & (la3 = 1 << ia3)) {
                                  for (ka3 = a << (31 == (0 | ia3) ? 0 : 25 - (ia3 >>> 1) | 0), ia3 = q2[ja3 >> 2]; ; ) {
                                    if ((-8 & q2[(ja3 = ia3) + 4 >> 2]) == (0 | a)) break C;
                                    if (ia3 = ka3 >>> 29, ka3 <<= 1, !(ia3 = q2[(la3 = (4 & ia3) + ja3 | 0) + 16 >> 2])) break;
                                  }
                                  q2[la3 + 16 >> 2] = oa3;
                                } else q2[2088] = ka3 | la3, q2[ja3 >> 2] = oa3;
                                q2[oa3 + 24 >> 2] = ja3, q2[oa3 + 12 >> 2] = oa3, q2[oa3 + 8 >> 2] = oa3;
                                break B;
                              }
                              for (q2[2090] = oa3 = (a = ma3 + -40 | 0) - (ka3 = ia3 + 8 & 7 ? -8 - ia3 & 7 : 0) | 0, q2[2093] = ka3 = ia3 + ka3 | 0, q2[ka3 + 4 >> 2] = 1 | oa3, q2[4 + (a + ia3 | 0) >> 2] = 40, q2[2094] = q2[2209], q2[(ka3 = (a = (la3 + (la3 + -39 & 7 ? 39 - la3 & 7 : 0) | 0) - 47 | 0) >>> 0 < ja3 + 16 >>> 0 ? ja3 : a) + 4 >> 2] = 27, a = q2[2202], q2[ka3 + 16 >> 2] = q2[2201], q2[ka3 + 20 >> 2] = a, a = q2[2200], q2[ka3 + 8 >> 2] = q2[2199], q2[ka3 + 12 >> 2] = a, q2[2201] = ka3 + 8, q2[2200] = ma3, q2[2199] = ia3, a = ka3 + 24 | (q2[2202] = 0); ; ) if (q2[a + 4 >> 2] = 7, ia3 = a + 8 | 0, a = a + 4 | 0, !(ia3 >>> 0 < la3 >>> 0)) break;
                              if ((0 | ja3) == (0 | ka3)) break x;
                              if (q2[ka3 + 4 >> 2] = -2 & q2[ka3 + 4 >> 2], q2[ja3 + 4 >> 2] = 1 | (la3 = ka3 - ja3 | 0), (q2[ka3 >> 2] = la3) >>> 0 <= 255) {
                                a = 8388 + ((ia3 = la3 >>> 3) << 3) | 0, ia3 = (ka3 = q2[2087]) & (ia3 = 1 << ia3) ? q2[a + 8 >> 2] : (q2[2087] = ia3 | ka3, a), q2[a + 8 >> 2] = ja3, q2[ia3 + 12 >> 2] = ja3, q2[ja3 + 12 >> 2] = a, q2[ja3 + 8 >> 2] = ia3;
                                break x;
                              }
                              if (q2[ja3 + 16 >> 2] = 0, a = q2[ja3 + 20 >> 2] = 0, (ka3 = la3 >>> 8) && (a = 31, 16777215 < la3 >>> 0 || (a = 28 + ((a = ((oa3 = (ka3 <<= ma3 = ka3 + 1048320 >>> 16 & 8) << (a = ka3 + 520192 >>> 16 & 4)) << (ka3 = oa3 + 245760 >>> 16 & 2) >>> 15) - (ka3 | a | ma3) | 0) << 1 | la3 >>> a + 21 & 1) | 0)), ia3 = 8652 + ((q2[(ia3 = ja3) + 28 >> 2] = a) << 2) | 0, (ka3 = q2[2088]) & (ma3 = 1 << a)) {
                                for (a = la3 << (31 == (0 | a) ? 0 : 25 - (a >>> 1) | 0), ia3 = q2[ia3 >> 2]; ; ) {
                                  if ((0 | la3) == (-8 & q2[(ka3 = ia3) + 4 >> 2])) break A;
                                  if (ia3 = a >>> 29, a <<= 1, !(ia3 = q2[(ma3 = ka3 + (4 & ia3) | 0) + 16 >> 2])) break;
                                }
                                q2[ma3 + 16 >> 2] = ja3, q2[ja3 + 24 >> 2] = ka3;
                              } else q2[2088] = ka3 | ma3, q2[ia3 >> 2] = ja3, q2[ja3 + 24 >> 2] = ia3;
                              q2[ja3 + 12 >> 2] = ja3, q2[ja3 + 8 >> 2] = ja3;
                              break x;
                            }
                            a = q2[ja3 + 8 >> 2], q2[a + 12 >> 2] = oa3, q2[ja3 + 8 >> 2] = oa3, q2[oa3 + 24 >> 2] = 0, q2[oa3 + 12 >> 2] = ja3, q2[oa3 + 8 >> 2] = a;
                          }
                          a = qa2 + 8 | 0;
                          break a;
                        }
                        a = q2[ka3 + 8 >> 2], q2[a + 12 >> 2] = ja3, q2[ka3 + 8 >> 2] = ja3, q2[ja3 + 24 >> 2] = 0, q2[ja3 + 12 >> 2] = ka3, q2[ja3 + 8 >> 2] = a;
                      }
                      if (!((a = q2[2090]) >>> 0 <= na3 >>> 0)) {
                        q2[2090] = ia3 = a - na3 | 0, a = q2[2093], q2[2093] = ja3 = a + na3 | 0, q2[ja3 + 4 >> 2] = 1 | ia3, q2[a + 4 >> 2] = 3 | na3, a = a + 8 | 0;
                        break a;
                      }
                    }
                    q2[2086] = 48, a = 0;
                    break a;
                  }
                  Q: if (oa3) {
                    a = q2[la3 + 28 >> 2];
                    R: {
                      if (q2[(ka3 = 8652 + (a << 2) | 0) >> 2] == (0 | la3)) {
                        if (q2[ka3 >> 2] = ia3) break R;
                        pa3 = dd(a) & pa3, q2[2088] = pa3;
                        break Q;
                      }
                      if (!(q2[oa3 + (q2[oa3 + 16 >> 2] == (0 | la3) ? 16 : 20) >> 2] = ia3)) break Q;
                    }
                    q2[ia3 + 24 >> 2] = oa3, (a = q2[la3 + 16 >> 2]) && (q2[ia3 + 16 >> 2] = a, q2[a + 24 >> 2] = ia3), (a = q2[la3 + 20 >> 2]) && (q2[ia3 + 20 >> 2] = a, q2[a + 24 >> 2] = ia3);
                  }
                  S: if (ja3 >>> 0 <= 15) q2[la3 + 4 >> 2] = 3 | (a = ja3 + na3 | 0), q2[(a = a + la3 | 0) + 4 >> 2] = 1 | q2[a + 4 >> 2];
                  else if (q2[la3 + 4 >> 2] = 3 | na3, q2[(ka3 = la3 + na3 | 0) + 4 >> 2] = 1 | ja3, (q2[ja3 + ka3 >> 2] = ja3) >>> 0 <= 255) a = 8388 + ((ia3 = ja3 >>> 3) << 3) | 0, ia3 = (ja3 = q2[2087]) & (ia3 = 1 << ia3) ? q2[a + 8 >> 2] : (q2[2087] = ia3 | ja3, a), q2[a + 8 >> 2] = ka3, q2[ia3 + 12 >> 2] = ka3, q2[ka3 + 12 >> 2] = a, q2[ka3 + 8 >> 2] = ia3;
                  else {
                    a = 0, (na3 = ja3 >>> 8) && (a = 31, 16777215 < ja3 >>> 0 || (a = 28 + ((a = ((oa3 = (na3 <<= ma3 = na3 + 1048320 >>> 16 & 8) << (a = na3 + 520192 >>> 16 & 4)) << (na3 = oa3 + 245760 >>> 16 & 2) >>> 15) - (na3 | a | ma3) | 0) << 1 | ja3 >>> a + 21 & 1) | 0)), q2[(ia3 = ka3) + 28 >> 2] = a, q2[ka3 + 16 >> 2] = 0, ia3 = 8652 + (a << 2) | (q2[ka3 + 20 >> 2] = 0);
                    V: {
                      if ((na3 = 1 << a) & pa3) {
                        for (a = ja3 << (31 == (0 | a) ? 0 : 25 - (a >>> 1) | 0), na3 = q2[ia3 >> 2]; ; ) {
                          if ((-8 & q2[(ia3 = na3) + 4 >> 2]) == (0 | ja3)) break V;
                          if (na3 = a >>> 29, a <<= 1, !(na3 = q2[(ma3 = (4 & na3) + ia3 | 0) + 16 >> 2])) break;
                        }
                        q2[ma3 + 16 >> 2] = ka3;
                      } else q2[2088] = na3 | pa3, q2[ia3 >> 2] = ka3;
                      q2[ka3 + 24 >> 2] = ia3, q2[ka3 + 12 >> 2] = ka3, q2[ka3 + 8 >> 2] = ka3;
                      break S;
                    }
                    a = q2[ia3 + 8 >> 2], q2[a + 12 >> 2] = ka3, q2[ia3 + 8 >> 2] = ka3, q2[ka3 + 24 >> 2] = 0, q2[ka3 + 12 >> 2] = ia3, q2[ka3 + 8 >> 2] = a;
                  }
                  a = la3 + 8 | 0;
                  break a;
                }
                X: if (qa2) {
                  a = q2[ia3 + 28 >> 2];
                  Y: {
                    if (q2[(ja3 = 8652 + (a << 2) | 0) >> 2] == (0 | ia3)) {
                      if (q2[ja3 >> 2] = la3) break Y;
                      ua2 = dd(a) & ra3, q2[8352 >> 2] = ua2;
                      break X;
                    }
                    if (!(q2[qa2 + (q2[qa2 + 16 >> 2] == (0 | ia3) ? 16 : 20) >> 2] = la3)) break X;
                  }
                  q2[la3 + 24 >> 2] = qa2, (a = q2[ia3 + 16 >> 2]) && (q2[la3 + 16 >> 2] = a, q2[a + 24 >> 2] = la3), (a = q2[ia3 + 20 >> 2]) && (q2[la3 + 20 >> 2] = a, q2[a + 24 >> 2] = la3);
                }
                ka3 >>> 0 <= 15 ? (q2[ia3 + 4 >> 2] = 3 | (a = ka3 + na3 | 0), q2[(a = a + ia3 | 0) + 4 >> 2] = 1 | q2[a + 4 >> 2]) : (q2[ia3 + 4 >> 2] = 3 | na3, q2[(na3 = ia3 + na3 | 0) + 4 >> 2] = 1 | ka3, q2[ka3 + na3 >> 2] = ka3, pa3 && (a = 8388 + ((ja3 = pa3 >>> 3) << 3) | 0, la3 = q2[2092], ja3 = (ja3 = 1 << ja3) & ma3 ? q2[a + 8 >> 2] : (q2[2087] = ja3 | ma3, a), q2[a + 8 >> 2] = la3, q2[ja3 + 12 >> 2] = la3, q2[la3 + 12 >> 2] = a, q2[la3 + 8 >> 2] = ja3), q2[2092] = na3, q2[2089] = ka3), a = ia3 + 8 | 0;
              }
              return L2 = 16 + sa2 | 0, a;
            }
            function ra2(a, va3, wa3, xa3, ya3, za2, Aa3) {
              var Qa, Ta, Ba3, Ca3 = 0, Da2 = 0, Fa2 = 0, Ia2 = 0, Ja = 0, Ka2 = 0, Ma2 = 0, Na2 = 0, Oa2 = 0, Pa = 0, Ra = 0, Sa2 = 0;
              q2[76 + (L2 = Ba3 = L2 - 80 | 0) >> 2] = va3, Ta = 55 + Ba3 | 0, Qa = 56 + Ba3 | 0, va3 = 0;
              a: {
                b: {
                  c: for (; ; ) {
                    (0 | Oa2) < 0 || (Oa2 = (2147483647 - Oa2 | 0) < (0 | va3) ? (q2[2086] = 61, -1) : va3 + Oa2 | 0);
                    e: {
                      f: {
                        g: {
                          h: {
                            i: {
                              j: {
                                k: {
                                  l: {
                                    m: {
                                      n: {
                                        o: {
                                          p: {
                                            q: {
                                              if (Ia2 = q2[76 + Ba3 >> 2], Fa2 = r2[0 | (va3 = Ia2)]) {
                                                for (; ; ) {
                                                  r: {
                                                    s: {
                                                      t: if (Ca3 = 255 & Fa2) {
                                                        if (37 != (0 | Ca3)) break s;
                                                        for (Fa2 = va3; ; ) {
                                                          if (37 != r2[va3 + 1 | 0]) break t;
                                                          if (q2[76 + Ba3 >> 2] = Ca3 = va3 + 2 | 0, Fa2 = Fa2 + 1 | 0, Da2 = r2[va3 + 2 | 0], va3 = Ca3, 37 != (0 | Da2)) break;
                                                        }
                                                      } else Fa2 = va3;
                                                      if (va3 = Fa2 - Ia2 | 0, a && Z2(a, Ia2, va3), va3) continue c;
                                                      Pa = -1, Ja = !ha2(o[q2[76 + (Ca3 = Ba3) >> 2] + (Fa2 = 1) | 0]), va3 = q2[76 + Ba3 >> 2], Ja | 36 != r2[va3 + 2 | 0] || (Pa = o[va3 + 1 | 0] + -48 | 0, Ra = 1, Fa2 = 3), q2[Ca3 + 76 >> 2] = va3 = Fa2 + va3 | 0;
                                                      u: if (31 < (Da2 = (Ma2 = o[(Fa2 = 0) | va3]) + -32 | 0) >>> 0) Ca3 = va3;
                                                      else if (Ca3 = va3, 75913 & (Da2 = 1 << Da2)) for (; ; ) {
                                                        if (q2[76 + Ba3 >> 2] = Ca3 = va3 + 1 | 0, Fa2 |= Da2, 31 < (Da2 = (Ma2 = o[va3 + 1 | 0]) + -32 | 0) >>> 0) break u;
                                                        if (va3 = Ca3, !(75913 & (Da2 = 1 << Da2))) break;
                                                      }
                                                      if (42 == (0 | Ma2)) {
                                                        if (Ja = Ba3, ha2(o[Ca3 + 1 | 0]) && (va3 = q2[76 + Ba3 >> 2], 36 == r2[va3 + 2 | 0])) q2[((o[va3 + 1 | 0] << 2) + ya3 | 0) - 192 >> 2] = 10, Na2 = q2[((o[va3 + 1 | 0] << 3) + xa3 | 0) - 384 >> 2], Ra = 1, va3 = va3 + 3 | 0;
                                                        else {
                                                          if (Ra) break b;
                                                          Na2 = Ra = 0, a && (va3 = q2[wa3 >> 2], q2[wa3 >> 2] = va3 + 4, Na2 = q2[va3 >> 2]), va3 = q2[76 + Ba3 >> 2] + 1 | 0;
                                                        }
                                                        q2[Ja + 76 >> 2] = va3, -1 < (0 | Na2) || (Na2 = 0 - Na2 | 0, Fa2 |= 8192);
                                                      } else {
                                                        if ((0 | (Na2 = Ha(76 + Ba3 | 0))) < 0) break b;
                                                        va3 = q2[76 + Ba3 >> 2];
                                                      }
                                                      if (Da2 = -1, 46 == r2[0 | va3]) if (42 == r2[va3 + 1 | 0]) if (ha2(o[va3 + 2 | 0]) && (va3 = q2[76 + Ba3 >> 2], 36 == r2[va3 + 3 | 0])) q2[((o[va3 + 2 | 0] << 2) + ya3 | 0) - 192 >> 2] = 10, Da2 = q2[((o[va3 + 2 | 0] << 3) + xa3 | 0) - 384 >> 2], q2[76 + Ba3 >> 2] = va3 = va3 + 4 | 0;
                                                      else {
                                                        if (Ra) break b;
                                                        Da2 = a ? (va3 = q2[wa3 >> 2], q2[wa3 >> 2] = va3 + 4, q2[va3 >> 2]) : 0, va3 = q2[76 + Ba3 >> 2] + 2 | 0, q2[76 + Ba3 >> 2] = va3;
                                                      }
                                                      else q2[76 + Ba3 >> 2] = va3 + 1, Da2 = Ha(76 + Ba3 | 0), va3 = q2[76 + Ba3 >> 2];
                                                      for (Ca3 = 0; ; ) {
                                                        if (Sa2 = Ca3, Ka2 = -1, 57 < o[0 | va3] + -65 >>> 0) break a;
                                                        if (q2[76 + Ba3 >> 2] = Ma2 = va3 + 1 | 0, Ca3 = o[0 | va3], va3 = Ma2, !((Ca3 = r2[3295 + (Ca3 + w2(Sa2, 58) | 0) | 0]) + -1 >>> 0 < 8)) break;
                                                      }
                                                      if (!Ca3) break a;
                                                      A: {
                                                        B: {
                                                          C: {
                                                            if (19 == (0 | Ca3)) {
                                                              if ((0 | Pa) <= -1) break C;
                                                              break a;
                                                            }
                                                            if ((0 | Pa) < 0) break B;
                                                            q2[(Pa << 2) + ya3 >> 2] = Ca3, Ca3 = q2[(va3 = (Pa << 3) + xa3 | 0) + 4 >> 2], q2[64 + Ba3 >> 2] = q2[va3 >> 2], q2[68 + Ba3 >> 2] = Ca3;
                                                          }
                                                          if (va3 = 0, a) break A;
                                                          continue c;
                                                        }
                                                        if (!a) break e;
                                                        Ga(Ba3 + 64 | 0, Ca3, wa3, Aa3), Ma2 = q2[76 + Ba3 >> 2];
                                                      }
                                                      if (Ja = -65537 & Fa2, Fa2 = 8192 & Fa2 ? Ja : Fa2, Pa = 3336, Ca3 = Qa, va3 = o[Ma2 + -1 | (Ka2 = 0)], (Ma2 = (va3 = Sa2 && 3 == (15 & va3) ? -33 & va3 : va3) + -88 | 0) >>> 0 <= 32) break r;
                                                      D: {
                                                        E: {
                                                          F: {
                                                            G: {
                                                              if (6 < (Ja = va3 + -65 | 0) >>> 0) {
                                                                if (83 != (0 | va3)) break f;
                                                                if (!Da2) break G;
                                                                Ca3 = q2[64 + Ba3 >> 2];
                                                                break E;
                                                              }
                                                              switch (Ja - 1 | 0) {
                                                                case 1:
                                                                  break F;
                                                                case 0:
                                                                case 2:
                                                                  break f;
                                                                default:
                                                                  break q;
                                                              }
                                                            }
                                                            _(a, 32, Na2, va3 = 0, Fa2);
                                                            break D;
                                                          }
                                                          q2[12 + Ba3 >> 2] = 0, q2[8 + Ba3 >> 2] = q2[64 + Ba3 >> 2], q2[64 + Ba3 >> 2] = 8 + Ba3, Da2 = -1, Ca3 = 8 + Ba3 | 0;
                                                        }
                                                        va3 = 0;
                                                        H: {
                                                          for (; ; ) {
                                                            if (!(Ia2 = q2[Ca3 >> 2])) break H;
                                                            if ((Ja = (0 | (Ia2 = Ea(4 + Ba3 | 0, Ia2))) < 0) | Da2 - va3 >>> 0 < Ia2 >>> 0) break;
                                                            if (Ca3 = Ca3 + 4 | 0, !((va3 = va3 + Ia2 | 0) >>> 0 < Da2 >>> 0)) break H;
                                                          }
                                                          if (Ka2 = -1, Ja) break a;
                                                        }
                                                        if (_(a, 32, Na2, va3, Fa2), va3) for (Da2 = 0, Ca3 = q2[64 + Ba3 >> 2]; ; ) {
                                                          if (!(Ia2 = q2[Ca3 >> 2])) break D;
                                                          if ((0 | va3) < (0 | (Da2 = (Ia2 = Ea(4 + Ba3 | 0, Ia2)) + Da2 | 0))) break D;
                                                          if (Z2(a, 4 + Ba3 | 0, Ia2), Ca3 = Ca3 + 4 | 0, !(Da2 >>> 0 < va3 >>> 0)) break;
                                                        }
                                                        else va3 = 0;
                                                      }
                                                      _(a, 32, Na2, va3, 8192 ^ Fa2), va3 = (0 | va3) < (0 | Na2) ? Na2 : va3;
                                                      continue c;
                                                    }
                                                    q2[76 + Ba3 >> 2] = Ca3 = va3 + 1 | 0, Fa2 = r2[va3 + 1 | 0], va3 = Ca3;
                                                    continue;
                                                  }
                                                  break;
                                                }
                                                switch (Ma2 - 1 | 0) {
                                                  case 28:
                                                    break i;
                                                  case 21:
                                                    break j;
                                                  case 23:
                                                    break l;
                                                  case 22:
                                                    break m;
                                                  case 11:
                                                  case 16:
                                                    break n;
                                                  case 10:
                                                    break o;
                                                  case 26:
                                                    break p;
                                                  case 8:
                                                  case 12:
                                                  case 13:
                                                  case 14:
                                                    break q;
                                                  case 0:
                                                  case 1:
                                                  case 2:
                                                  case 3:
                                                  case 4:
                                                  case 5:
                                                  case 6:
                                                  case 7:
                                                  case 9:
                                                  case 15:
                                                  case 17:
                                                  case 18:
                                                  case 19:
                                                  case 20:
                                                  case 24:
                                                  case 25:
                                                  case 27:
                                                  case 29:
                                                  case 30:
                                                    break f;
                                                  default:
                                                    break k;
                                                }
                                              }
                                              if (Ka2 = Oa2, a) break a;
                                              if (!Ra) break e;
                                              for (va3 = 1; ; ) {
                                                if (a = q2[(va3 << 2) + ya3 >> 2]) {
                                                  if (Ga((va3 << 3) + xa3 | 0, a, wa3, Aa3), 10 != (0 | (va3 = va3 + (Ka2 = 1) | 0))) continue;
                                                  break a;
                                                }
                                                break;
                                              }
                                              if (Ka2 = 1, 9 < va3 >>> 0) break a;
                                              if (Ka2 = -1, q2[(va3 << 2) + ya3 >> 2]) break a;
                                              for (; ; ) if (q2[((va3 = va3 + 1 | 0) << 2) + ya3 >> 2] || 10 == (0 | va3)) break;
                                              Ka2 = va3 >>> 0 < 10 ? -1 : 1;
                                              break a;
                                            }
                                            va3 = 0 | n2[za2](a, v2[64 + Ba3 >> 3], Na2, Da2, Fa2, va3);
                                            continue;
                                          }
                                          Ca3 = (va3 = La(Ia2 = (va3 = q2[64 + Ba3 >> 2]) || 3346, Da2)) || Da2 + Ia2 | 0, Fa2 = Ja, Da2 = va3 ? va3 - Ia2 | 0 : Da2;
                                          break f;
                                        }
                                        o[55 + Ba3 | 0] = q2[64 + Ba3 >> 2], Da2 = 1, Ia2 = Ta, Fa2 = Ja;
                                        break f;
                                      }
                                      if (va3 = Ja = q2[68 + Ba3 >> 2], Ia2 = q2[64 + Ba3 >> 2], (0 | va3) < -1 || (0 | va3) <= -1 && !(4294967295 < Ia2 >>> 0)) {
                                        va3 = 0 - (va3 + (0 < Ia2 >>> 0) | 0) | 0, q2[64 + Ba3 >> 2] = Ia2 = 0 - Ia2 | 0, q2[68 + Ba3 >> 2] = va3, Ka2 = 1, Pa = 3336;
                                        break h;
                                      }
                                      if (2048 & Fa2) {
                                        Ka2 = 1, Pa = 3337;
                                        break h;
                                      }
                                      Pa = (Ka2 = 1 & Fa2) ? 3338 : 3336;
                                      break h;
                                    }
                                    if (Ia2 = function(a2, Il, Rm) {
                                      if (a2 | Il) {
                                        for (; ; ) if (o[0 | (Rm = Rm + -1 | 0)] = 7 & a2 | 48, !((a2 = (7 & Il) << 29 | a2 >>> 3) | (Il >>>= 3))) break;
                                      }
                                      return Rm;
                                    }(q2[64 + Ba3 >> 2], q2[68 + Ba3 >> 2], Qa), !(8 & Fa2)) break g;
                                    Da2 = (0 | (va3 = Qa - Ia2 | 0)) < (0 | Da2) ? Da2 : va3 + 1 | 0;
                                    break g;
                                  }
                                  Da2 = 8 < Da2 >>> 0 ? Da2 : 8, Fa2 |= 8, va3 = 120;
                                }
                                if (Ia2 = function(a2, Il, Rm, Sm) {
                                  if (a2 | Il) {
                                    for (; ; ) if (o[0 | (Rm = Rm + -1 | 0)] = r2[3824 + (15 & a2) | 0] | Sm, !((a2 = (15 & Il) << 28 | a2 >>> 4) | (Il >>>= 4))) break;
                                  }
                                  return Rm;
                                }(q2[64 + Ba3 >> 2], q2[68 + Ba3 >> 2], Qa, 32 & va3), !(8 & Fa2) | !(q2[64 + Ba3 >> 2] | q2[68 + Ba3 >> 2])) break g;
                                Pa = 3336 + (va3 >>> 4) | 0, Ka2 = 2;
                                break g;
                              }
                              if (7 < (Ca3 = 255 & Sa2) >>> (va3 = 0)) continue;
                              I: switch (Ca3 - 1 | 0) {
                                default:
                                case 0:
                                  q2[q2[64 + Ba3 >> 2] >> 2] = Oa2;
                                  continue;
                                case 1:
                                  Ca3 = q2[64 + Ba3 >> 2], q2[Ca3 >> 2] = Oa2, q2[Ca3 + 4 >> 2] = Oa2 >> 31;
                                  continue;
                                case 2:
                                  p2[q2[64 + Ba3 >> 2] >> 1] = Oa2;
                                  continue;
                                case 3:
                                  o[q2[64 + Ba3 >> 2]] = Oa2;
                                  continue;
                                case 5:
                                  q2[q2[64 + Ba3 >> 2] >> 2] = Oa2;
                                  continue;
                                case 4:
                                  continue;
                                case 6:
                                  break I;
                              }
                              Ca3 = q2[64 + Ba3 >> 2], q2[Ca3 >> 2] = Oa2, q2[Ca3 + 4 >> 2] = Oa2 >> 31;
                              continue;
                            }
                            Ia2 = q2[64 + Ba3 >> 2], va3 = q2[68 + Ba3 >> 2], Pa = 3336;
                          }
                          Ia2 = ga(Ia2, va3, Qa);
                        }
                        Fa2 = -1 < (0 | Da2) ? -65537 & Fa2 : Fa2, Da2 = !!((Ja = va3 = q2[68 + Ba3 >> 2]) | (Ma2 = q2[64 + Ba3 >> 2])) | Da2 ? (0 | (va3 = !(Ja | Ma2) + (Qa - Ia2 | 0) | 0)) < (0 | Da2) ? Da2 : va3 : (Ia2 = Qa, 0);
                      }
                      _(a, 32, va3 = (0 | Na2) < (0 | (Ca3 = (Da2 = (0 | Da2) < (0 | (Ja = Ca3 - Ia2 | 0)) ? Ja : Da2) + Ka2 | 0)) ? Ca3 : Na2, Ca3, Fa2), Z2(a, Pa, Ka2), _(a, 48, va3, Ca3, 65536 ^ Fa2), _(a, 48, Da2, Ja, 0), Z2(a, Ia2, Ja), _(a, 32, va3, Ca3, 8192 ^ Fa2);
                      continue;
                    }
                    break;
                  }
                  Ka2 = 0;
                  break a;
                }
                Ka2 = -1;
              }
              return L2 = 80 + Ba3 | 0, Ka2;
            }
            function sa(a) {
              var ya3, va3 = 0, wa3 = 0, xa3 = 0, za2 = 0, xa3 = 4, wa3 = 1439;
              a: if (va3 = r2[0 | a]) {
                for (; ; ) {
                  if ((0 | (ya3 = r2[0 | wa3])) != (0 | va3) || !(xa3 = xa3 + -1 | 0) | !ya3) break;
                  if (wa3 = wa3 + 1 | 0, va3 = r2[a + 1 | 0], a = a + 1 | 0, !va3) break a;
                }
                za2 = va3;
              }
              return (255 & za2) - r2[0 | wa3] | 0;
            }
            function ta2(a, Aa3, Ea2) {
              var La2, Ga2, Ha2 = 0, Ua = 0, Va = 0;
              q2[(L2 = Ga2 = L2 - 240 | 0) >> 2] = a, Ua = 1;
              a: if (!((0 | Aa3) < 2)) for (Ha2 = a; ; ) {
                if (Ha2 = (La2 = Ha2 + -4 | 0) - q2[((Va = Aa3 + -2 | 0) << 2) + Ea2 >> 2] | 0, 0 <= (0 | n2[5](a, Ha2)) && -1 < (0 | n2[5](a, La2))) break a;
                if (a = (Ua << 2) + Ga2 | 0, 0 <= (0 | n2[5](Ha2, La2)) ? (q2[a >> 2] = Ha2, Va = Aa3 + -1 | 0) : Ha2 = q2[a >> 2] = La2, Ua = Ua + 1 | 0, (0 | Va) < 2) break a;
                a = q2[Ga2 >> 2], Aa3 = Va;
              }
              Na(Ga2, Ua), L2 = 240 + Ga2 | 0;
            }
            function ua(a) {
              var Ea2, ab, Aa3 = 0;
              x2(0);
              if (!function(a2) {
                var Vg = 0, Wg = 0;
                q2[a2 + 428 >> 2] && (Wg = q2[a2 + 332 >> 2], Vg = Wg << 2, $(q2[a2 + 460 >> 2], q2[a2 + 436 >> 2], Vg), $(q2[a2 + 464 >> 2], q2[a2 + 440 >> 2], Vg), $(q2[a2 + 468 >> 2], q2[a2 + 448 >> 2], Vg), r2[q2[a2 >> 2] + 4 | 0] < 4 || (Vg = Wg << 4, $(q2[a2 + 472 >> 2], q2[a2 + 452 >> 2], Vg), $(q2[a2 + 476 >> 2], q2[a2 + 456 >> 2], Vg)));
              }(a), !function(a2) {
                var fe = 0, ge = x2(0), he = x2(0), ie = 0, je = x2(0), ke = 0, le = x2(0), me = 0, ne = x2(0);
                if (1 <= (0 | (ie = q2[a2 >> 2]))) {
                  for (fe = q2[a2 + 4 >> 2], me = fe + w2(ie, 52) | 0, a2 = q2[a2 + 12 >> 2]; ; ) if (ge = u2[a2 >> 2], ne = u2[fe + 44 >> 2], ke = q2[fe + 16 >> 2], ge = ke ? (he = ge, ge = u2[fe + 4 >> 2], je = u2[fe + 12 >> 2], he = x2(x2(he - ge) / je), le = x2(C2(he)), ie = x2(y2(le)) < x2(2147483648) ? ~~le : -2147483648, x2(ge + x2(je * x2(he - x2(0 | ie))))) : (je = u2[fe + 4 >> 2], he = u2[fe + 8 >> 2], ge < je ? je : he < ge ? he : ge), ne != ge ? (u2[fe + 44 >> 2] = ge, q2[fe + 48 >> 2] = 1) : q2[fe + 48 >> 2] = 0, ke || (u2[a2 >> 2] = ge), a2 = a2 + 4 | 0, !((fe = fe + 52 | 0) >>> 0 < me >>> 0)) break;
                }
              }(a + 540 | 0), !function(a2) {
                var Rd = 0, Sd = 0, Td = x2(0), Ud = 0, Vd = x2(0), Wd = x2(0), Xd = x2(0), Yd = 0, Zd = x2(0), _d = 0, $d = 0, ae = 0, be = 0, ce = x2(0), de = 0, ee = 0;
                if (1 <= (0 | (Ud = q2[a2 + 540 >> 2]))) for (Yd = q2[a2 + 544 >> 2], de = Yd + w2(Ud, 52) | 0, ee = q2[a2 + 644 >> 2]; ; ) {
                  a: if (!(q2[Yd >> 2] || (0 | (Ud = q2[Yd + 32 >> 2])) < 1)) if (a2 = q2[Yd + 28 >> 2], ae = a2 + w2(Ud, 28) | 0, ce = u2[Yd + 24 >> 2], Xd = u2[Yd + 20 >> 2], Wd = u2[Yd + 44 >> 2], ee) for (; ; ) {
                    Zd = x2($d = 0);
                    h: {
                      i: {
                        j: {
                          if ((0 | (Sd = q2[a2 >> 2])) < 1) Rd = Ud = 0;
                          else if (_d = q2[a2 + 4 >> 2], Vd = u2[_d >> 2], Td = x2(Vd - Xd), 1 == (0 | Sd)) Ud = Wd < x2(Xd + Vd) ^ 1 | Td < Wd ^ 1, Rd = 0;
                          else {
                            if (Wd < Td) {
                              Ud = 1, Rd = 0;
                              break i;
                            }
                            if (Ud = 0, Wd < x2(Xd + Vd)) Rd = 0;
                            else {
                              if (Rd = 1, Td = u2[_d + 4 >> 2], !(Wd < x2(Xd + Td))) for (; ; ) {
                                if ((0 | Sd) == (0 | (Rd = Rd + 1 | 0))) break j;
                                if (Vd = Td, Td = u2[_d + (Rd << 2) >> 2], Wd < x2(Xd + Td)) break;
                              }
                              x2(Td - Xd) < Wd || (Rd = Rd + -1 | 0, (Td = x2(Td - Vd)) < ce) || (Zd = x2(x2(Wd - Vd) / Td));
                            }
                          }
                          if (Ud) break i;
                          if (_d = Sd = 1, q2[a2 + 16 >> 2]) break h;
                          break i;
                        }
                        Rd = Sd + -1 | 0, Ud = 1;
                      }
                      Vd = u2[a2 + 12 >> 2], _d = (Sd = Vd != Zd) & (Zd == x2(0) | Vd == x2(0)) | q2[a2 + 8 >> 2] != (0 | Rd), $d = Ud;
                    }
                    if (q2[a2 + 20 >> 2] = _d, q2[a2 + 24 >> 2] = Sd, u2[a2 + 12 >> 2] = Zd, q2[a2 + 16 >> 2] = $d, q2[a2 + 8 >> 2] = Rd, !((a2 = a2 + 28 | 0) >>> 0 < ae >>> 0)) break;
                  }
                  else {
                    if (!q2[Yd + 48 >> 2]) {
                      for (; ; ) if (q2[a2 + 20 >> 2] = 0, q2[a2 + 24 >> 2] = 0, !((a2 = a2 + 28 | 0) >>> 0 < ae >>> 0)) break a;
                    }
                    for (; ; ) {
                      Zd = x2($d = 0), Rd = q2[(_d = a2) >> 2], Sd = 0;
                      b: {
                        c: {
                          d: {
                            e: if (!((0 | Rd) < 1)) {
                              if (Ud = q2[a2 + 4 >> 2], Vd = u2[Ud >> 2], Td = x2(Vd - Xd), 1 != (0 | Rd)) {
                                if (!(Wd < Td)) {
                                  if (Sd = 0, Wd < x2(Xd + Vd)) break e;
                                  Sd = 1;
                                  f: if (Td = u2[Ud + 4 >> 2], !(Wd < x2(Xd + Td))) {
                                    for (Rd = Rd + -1 | 0; ; ) {
                                      if (Vd = Td, (0 | Rd) == (0 | Sd)) break;
                                      if (Td = u2[Ud + ((Sd = Sd + 1 | 0) << 2) >> 2], Wd < x2(Xd + Td)) break f;
                                    }
                                    Ud = 1;
                                    break c;
                                  }
                                  if (Ud = 0, x2(Td - Xd) < Wd) {
                                    Rd = Sd;
                                    break d;
                                  }
                                  if (Rd = Sd + -1 | 0, (Td = x2(Td - Vd)) < ce) break d;
                                  Zd = x2(x2(Wd - Vd) / Td);
                                  break d;
                                }
                                Ud = 1, Rd = 0;
                                break c;
                              }
                              Sd = Wd < x2(Xd + Vd) ^ 1 | Td < Wd ^ 1;
                            }
                            Ud = Sd, Rd = 0;
                          }
                          if (!Ud && (be = Sd = 1, q2[a2 + 16 >> 2])) break b;
                        }
                        $d = Ud, Vd = u2[a2 + 12 >> 2], be = (Sd = Vd != Zd) & (Zd == x2(0) | Vd == x2(0)) | q2[a2 + 8 >> 2] != (0 | Rd);
                      }
                      if (q2[_d + 20 >> 2] = be, q2[a2 + 24 >> 2] = Sd, u2[a2 + 12 >> 2] = Zd, q2[a2 + 16 >> 2] = $d, q2[a2 + 8 >> 2] = Rd, !((a2 = a2 + 28 | 0) >>> 0 < ae >>> 0)) break;
                    }
                  }
                  if (!((Yd = Yd + 52 | 0) >>> 0 < de >>> 0)) break;
                }
              }(a), !function(a2) {
                var kd = 0, ld = x2(0), md = 0, nd = 0, od = x2(0), pd = 0, qd = x2(0), rd = x2(0), sd = 0, td = 0, ud = 0, vd = 0;
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (0 | (kd = q2[a2 + 540 >> 2])) < 1)) for (pd = q2[a2 + 544 >> 2], ud = pd + w2(kd, 52) | 0, vd = q2[a2 + 644 >> 2]; ; ) {
                  b: if (1 == q2[pd >> 2] && !((0 | (kd = q2[pd + 40 >> 2])) < 1)) if (a2 = q2[pd + 36 >> 2], sd = a2 + w2(kd, 28) | 0, rd = u2[pd + 44 >> 2], vd) for (; ; ) {
                    qd = x2(kd = 0), nd = q2[a2 >> 2];
                    d: if (!((0 | nd) < 2 || (md = q2[a2 + 4 >> 2], ld = u2[md >> 2], rd <= ld))) {
                      kd = 1;
                      e: if (od = u2[md + 4 >> 2], !(rd < od)) {
                        for (; ; ) {
                          if (ld = od, (0 | nd) == (0 | (kd = kd + 1 | 0))) break;
                          if (od = u2[md + (kd << 2) >> 2], rd < od) break e;
                        }
                        kd = nd + -1 | 0;
                        break d;
                      }
                      qd = x2(x2(rd - ld) / x2(od - ld)), kd = kd + -1 | 0;
                    }
                    if (ld = u2[a2 + 16 >> 2], u2[a2 + 16 >> 2] = qd, nd = q2[a2 + 12 >> 2], q2[a2 + 12 >> 2] = kd, md = ld != qd, q2[a2 + 24 >> 2] = md, q2[a2 + 20 >> 2] = md & (qd == x2(0) | ld == x2(0)) | (0 | kd) != (0 | nd), !((a2 = a2 + 28 | 0) >>> 0 < sd >>> 0)) break;
                  }
                  else {
                    if (!q2[pd + 48 >> 2]) {
                      for (; ; ) if (q2[a2 + 20 >> 2] = 0, q2[a2 + 24 >> 2] = 0, !((a2 = a2 + 28 | 0) >>> 0 < sd >>> 0)) break b;
                    }
                    for (; ; ) {
                      qd = x2(nd = 0), td = q2[a2 >> 2];
                      c: if (!((0 | td) < 2 || (md = q2[a2 + 4 >> 2], ld = u2[md >> 2], rd <= ld))) {
                        if (kd = 1, od = u2[md + 4 >> 2], !(rd < od)) for (nd = td + -1 | 0; ; ) {
                          if (ld = od, (0 | kd) == (0 | nd)) break c;
                          if (od = u2[md + ((kd = kd + 1 | 0) << 2) >> 2], rd < od) break;
                        }
                        qd = x2(x2(rd - ld) / x2(od - ld)), nd = kd + -1 | 0;
                      }
                      if (ld = u2[a2 + 16 >> 2], u2[a2 + 16 >> 2] = qd, kd = q2[a2 + 12 >> 2], q2[a2 + 12 >> 2] = nd, md = ld != qd, q2[a2 + 24 >> 2] = md, q2[a2 + 20 >> 2] = md & (qd == x2(0) | ld == x2(0)) | (0 | kd) != (0 | nd), !((a2 = a2 + 28 | 0) >>> 0 < sd >>> 0)) break;
                    }
                  }
                  if (!((pd = pd + 52 | 0) >>> 0 < ud >>> 0)) break;
                }
              }(a), !function(a2) {
                var wd = 0, xd = 0, yd = 0, zd = 0, Ad = 0, Bd = 0, Cd = 0, Dd = x2(0), Ed = 0, Fd = 0, Gd = 0, Hd = 0, Id6 = 0, Jd = 0, Kd = 0, Ld = 0, Md = 0, Nd = 0, Od = 0, Pd = 0, Qd = 0;
                if (1 <= (0 | (xd = q2[a2 + 564 >> 2]))) for (Ad = q2[a2 + 568 >> 2], Pd = Ad + w2(xd, 36) | 0, Nd = q2[a2 + 644 >> 2]; ; ) {
                  yd = zd = xd = 0, Jd = q2[Ad + 4 >> 2];
                  a: {
                    if (!(Bd = (0 | Jd) < 1)) for (Ed = q2[Ad >> 2], a2 = Kd = 0; ; ) {
                      if (wd = q2[Ed + (a2 << 2) >> 2], q2[wd + 16 >> 2]) {
                        wd = 1, Ld = 0;
                        break a;
                      }
                      if (yd = yd || q2[wd + 24 >> 2], xd = xd || q2[wd + 20 >> 2], zd = (u2[wd + 12 >> 2] != x2(0)) + zd | 0, (0 | Jd) == (0 | (a2 = a2 + 1 | 0))) break;
                    }
                    if (wd = 0, (Kd = Nd ? 1 : yd) | (Ld = Nd ? 1 : xd) && (Ed = 1 << zd, q2[Ad + 12 >> 2] = Ed, 31 != (0 | zd))) {
                      for (xd = q2[Ad + 20 >> 2], Od = q2[Ad >> 2], a2 = q2[Ad + 16 >> 2], yd = a2 + (Cd = Ed << 2) | 0, yd = ca2(Fd = a2, 0, 4 + ((Md = -1 ^ a2) + ((a2 = a2 + 4 | 0) >>> 0 < yd >>> 0 ? yd : a2) | 0) & -4), Cd = xd + Cd | 0, a2 = xd; ; ) if (q2[a2 >> 2] = 1065353216, !((a2 = a2 + 4 | 0) >>> 0 < Cd >>> 0)) break;
                      if (!Bd) {
                        if (Bd = 0, Cd = wd = 1, zd) for (; ; ) {
                          if (zd = q2[(Bd << 2) + Od >> 2], Gd = q2[zd + 8 >> 2], Hd = w2(Gd, wd), a2 = 0, (Dd = u2[zd + 12 >> 2]) != x2(0)) {
                            for (q2[yd >> 2] = Hd + q2[yd >> 2], u2[xd >> 2] = x2(x2(1) - Dd) * u2[xd >> 2], Gd = w2(Gd + (a2 = 1) | 0, wd); ; ) if (Dd = u2[zd + 12 >> 2], Qd = q2[(Md = Fd = (Id6 = a2 << 2) + yd | 0) >> 2], Fd = a2 & Cd, q2[Md >> 2] = Qd + (Fd ? Gd : Hd), u2[(Id6 = xd + Id6 | 0) >> 2] = (Fd ? Dd : x2(x2(1) - Dd)) * u2[Id6 >> 2], (0 | Ed) == (0 | (a2 = a2 + 1 | 0))) break;
                            Cd <<= 1;
                          } else for (; ; ) if (q2[(Gd = yd + (a2 << 2) | 0) >> 2] = Hd + q2[Gd >> 2], (0 | Ed) == (0 | (a2 = a2 + 1 | 0))) break;
                          if (wd = w2(q2[zd >> 2], wd), (0 | Jd) == (0 | (Bd = Bd + 1 | 0))) break;
                        }
                        else for (; ; ) {
                          if (zd = q2[(Bd << 2) + Od >> 2], Cd = w2(q2[zd + 8 >> 2], wd), a2 = 0, (Dd = u2[zd + 12 >> 2]) != x2(0)) q2[yd >> 2] = Cd + q2[yd >> 2], u2[xd >> 2] = x2(x2(1) - Dd) * u2[xd >> 2];
                          else for (; ; ) if (q2[(Hd = yd + (a2 << 2) | 0) >> 2] = Cd + q2[Hd >> 2], (0 | Ed) == (0 | (a2 = a2 + 1 | 0))) break;
                          if (wd = w2(q2[zd >> 2], wd), (0 | Jd) == (0 | (Bd = Bd + 1 | 0))) break;
                        }
                        wd = 0;
                      }
                    }
                  }
                  if (q2[Ad + 32 >> 2] = wd, q2[Ad + 24 >> 2] = Ld, q2[Ad + 28 >> 2] = Kd, !((Ad = Ad + 36 | 0) >>> 0 < Pd >>> 0)) break;
                }
              }(a), !function(a2) {
                var Wc = x2(0), Xc = 0, Yc = 0, Zc2 = 0, _c = 0, $c = 0, ad2 = x2(0), bd2 = x2(0), cd = x2(0), dd2 = 0, ed = 0, fd = 0, gd = 0, hd = 0, id = 0, jd = 0;
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (0 | (Xc = q2[a2 + 588 >> 2])) < 1)) for (Zc2 = q2[a2 + 592 >> 2], jd = Zc2 + w2(Xc, 48) | 0, gd = q2[a2 + 644 >> 2]; ; ) {
                  if (a2 = q2[Zc2 >> 2], ed = gd ? 1 : q2[a2 + 20 >> 2], fd = gd ? 1 : q2[a2 + 24 >> 2], ed | fd) {
                    c: {
                      d: {
                        $c = Zc2, _c = q2[a2 + 8 >> 2], Xc = q2[a2 + 12 >> 2], Wc = u2[a2 + 16 >> 2], a2 = (0 | _c) != (0 | Xc);
                        e: {
                          if (Wc != x2(0)) {
                            if (a2 = Xc + 1 | 0, (0 | Xc) == (0 | _c)) {
                              ed = 1, q2[Zc2 + 8 >> 2] = 1, Wc = x2(x2(1) - Wc), fd = 1;
                              break e;
                            }
                            a2 = (0 | a2) == (0 | _c) ? 1 : 2;
                          }
                          if (q2[$c + 8 >> 2] = a2, !fd) break d;
                          a2 = Xc;
                        }
                        u2[Zc2 + 24 >> 2] = Wc, u2[Zc2 + 20 >> 2] = x2(1) - Wc;
                        break c;
                      }
                      fd = 0, a2 = Xc;
                    }
                    ed ? (q2[Zc2 + 12 >> 2] = a2, q2[Zc2 + 16 >> 2] = a2 + 1) : ed = 0;
                  } else ed = fd = 0;
                  g: if ((0 | (hd = q2[Zc2 + 36 >> 2])) < 1) cd = x2(1);
                  else {
                    if (id = q2[Zc2 + 40 >> 2], a2 = 0, cd = x2(1), !gd) for (; ; ) {
                      h: {
                        i: {
                          if (Xc = q2[(a2 << 2) + id >> 2], Yc = q2[Xc >> 2]) {
                            if (!q2[Yc + 48 >> 2]) {
                              Wc = u2[Xc + 16 >> 2];
                              break h;
                            }
                            if ((0 | (_c = q2[Xc + 12 >> 2])) < 1) {
                              Wc = x2(1), u2[Xc + 16 >> 2] = 1;
                              break h;
                            }
                            if (dd2 = q2[Xc + 8 >> 2], 1 != (0 | _c) && (ad2 = u2[Yc + 44 >> 2], $c = q2[Xc + 4 >> 2], bd2 = u2[$c >> 2], !(ad2 <= bd2))) break i;
                            Wc = u2[dd2 >> 2], u2[Xc + 16 >> 2] = Wc;
                            break h;
                          }
                          q2[Xc + 16 >> 2] = 1065353216, Wc = x2(1);
                          break h;
                        }
                        Yc = 1;
                        j: if (Wc = u2[$c + 4 >> 2], !(ad2 < Wc)) {
                          for (; ; ) {
                            if (bd2 = Wc, (0 | _c) == (0 | (Yc = Yc + 1 | 0))) break;
                            if (Wc = u2[$c + (Yc << 2) >> 2], ad2 < Wc) break j;
                          }
                          Wc = u2[(dd2 + (_c << 2) | 0) - 4 >> 2], u2[Xc + 16 >> 2] = Wc;
                          break h;
                        }
                        $c = Xc, Wc = x2(x2(ad2 - bd2) / x2(Wc - bd2)), Wc = x2(x2(Wc * u2[(Xc = dd2 + (Yc << 2) | 0) >> 2]) + x2(u2[Xc + -4 >> 2] * x2(x2(1) - Wc))), u2[$c + 16 >> 2] = Wc;
                      }
                      if (cd = cd < Wc ? cd : Wc, (0 | hd) == (0 | (a2 = a2 + 1 | 0))) break g;
                    }
                    for (; ; ) {
                      Xc = q2[(a2 << 2) + id >> 2], Yc = q2[Xc >> 2], Wc = x2(1);
                      l: if (Yc && (dd2 = q2[Xc + 12 >> 2], Wc = x2(1), !((0 | dd2) < 1)) && (_c = q2[Xc + 8 >> 2], Wc = u2[_c >> 2], 1 != (0 | dd2))) {
                        m: {
                          if (ad2 = u2[Yc + 44 >> 2], $c = q2[Xc + 4 >> 2], bd2 = u2[$c >> 2], ad2 <= bd2) {
                            Wc = u2[_c >> 2];
                            break l;
                          }
                          if (Yc = 1, Wc = u2[$c + 4 >> 2], !(ad2 < Wc)) {
                            for (; ; ) {
                              if (bd2 = Wc, (0 | dd2) == (0 | (Yc = Yc + 1 | 0))) break;
                              if (Wc = u2[$c + (Yc << 2) >> 2], ad2 < Wc) break m;
                            }
                            Wc = u2[(_c + (dd2 << 2) | 0) - 4 >> 2];
                            break l;
                          }
                        }
                        Wc = x2(x2(ad2 - bd2) / x2(Wc - bd2)), Wc = x2(x2(Wc * u2[(Yc = _c + (Yc << 2) | 0) >> 2]) + x2(u2[Yc + -4 >> 2] * x2(x2(1) - Wc)));
                      }
                      if (u2[Xc + 16 >> 2] = Wc, cd = cd < Wc ? cd : Wc, (0 | hd) == (0 | (a2 = a2 + 1 | 0))) break;
                    }
                  }
                  if (q2[Zc2 + 32 >> 2] = fd, q2[Zc2 + 28 >> 2] = ed, u2[Zc2 + 44 >> 2] = cd, !((Zc2 = Zc2 + 48 | 0) >>> 0 < jd >>> 0)) break;
                }
              }(a), 1 <= (0 | (Ea2 = q2[a + 4 >> 2]))) {
                for (Ea2 = (Aa3 = q2[a + 52 >> 2]) + (Ea2 << 2) | 0; ; ) if (ab = u2[Aa3 >> 2], u2[Aa3 >> 2] = ab < x2(0) ? x2(0) : x2(A(ab, x2(1))), !((Aa3 = Aa3 + 4 | 0) >>> 0 < Ea2 >>> 0)) break;
              }
              !function(a2) {
                var De = 0, Ee = 0, Fe = 0, Ge = 0, He = 0;
                if (1 <= (0 | (Ee = q2[a2 + 4 >> 2]))) {
                  for (De = q2[a2 + 8 >> 2], He = De + w2(Ee, 12) | 0, Fe = q2[a2 + 40 >> 2], a2 = Fe; ; ) if (Ee = 0, q2[De + 8 >> 2] && (Ge = q2[De + 4 >> 2], !q2[(Ge << 2) + Fe >> 2] && -1 != (0 | Ge) || (Ee = !q2[q2[De >> 2] + 32 >> 2])), q2[a2 >> 2] = Ee, a2 = a2 + 4 | 0, !((De = De + 12 | 0) >>> 0 < He >>> 0)) break;
                }
              }(a), function(a2) {
                var pg = 0, qg = 0, rg = 0, sg = 0, tg = 0, ug = 0, vg = 0, wg = 0, xg = 0, yg = 0, zg = 0, Ag = 0;
                if (1 <= (0 | (vg = q2[a2 + 4 >> 2]))) for (xg = q2[a2 + 8 >> 2], wg = q2[a2 >> 2], yg = q2[wg + 724 >> 2]; ; ) {
                  if (rg = q2[w2(tg, 12) + xg >> 2], (q2[rg + 28 >> 2] || q2[rg + 24 >> 2]) && (q2[(pg = tg << 2) + q2[a2 + 28 >> 2] >> 2] = q2[rg + 12 >> 2], q2[rg + 24 >> 2]) && !((0 | (sg = q2[rg + 12 >> 2])) < 1)) {
                    for (qg = q2[rg + 16 >> 2], sg = qg + (sg << 2) | 0, zg = q2[pg + yg >> 2], pg = q2[a2 + 36 >> 2] + (ug << 2) | 0, Ag = q2[wg + 976 >> 2]; ; ) if (q2[pg >> 2] = q2[(q2[qg >> 2] + zg << 2) + Ag >> 2], pg = pg + 4 | 0, !((qg = qg + 4 | 0) >>> 0 < sg >>> 0)) break;
                  }
                  if (q2[rg + 28 >> 2] && !((0 | (pg = q2[rg + 12 >> 2])) < 1)) {
                    for (qg = q2[rg + 20 >> 2], sg = qg + (pg << 2) | 0, pg = q2[a2 + 32 >> 2] + (ug << 2) | 0; ; ) if (q2[pg >> 2] = q2[qg >> 2], pg = pg + 4 | 0, !((qg = qg + 4 | 0) >>> 0 < sg >>> 0)) break;
                  }
                  if (ug = q2[rg + 8 >> 2] + ug | 0, (0 | vg) == (0 | (tg = tg + 1 | 0))) break;
                }
              }(a), n2[q2[1808]](a + 12 | 0, q2[a + 36 >> 2], q2[a + 44 >> 2], q2[a + 40 >> 2]), function(a2) {
                var ue = 0, ve = 0, we = 0, xe = 0, ye = 0, ze = 0, Ae = 0, Be = 0, Ce = 0;
                if (1 <= (0 | (we = q2[a2 + 304 >> 2]))) {
                  for (ue = q2[a2 + 308 >> 2], ze = ue + (we << 5) | 0, Ae = q2[a2 + 264 >> 2], Be = q2[a2 + 144 >> 2], Ce = q2[a2 + 40 >> 2], ye = q2[a2 + 312 >> 2], we = ye; ; ) if (xe = we, ve = 0, a2 = ve = !q2[ue + 28 >> 2] || -1 != (0 | (a2 = q2[ue + 4 >> 2])) && (ve = 0, !q2[(a2 << 2) + Ce >> 2]) || -1 != (0 | (a2 = q2[ue + 8 >> 2])) && (ve = 0, !q2[(a2 << 2) + ye >> 2]) ? ve : !q2[q2[ue >> 2] + 32 >> 2], q2[xe >> 2] = a2, (xe = q2[ue + 12 >> 2]) >>> 0 <= 1 ? xe - 1 ? q2[(q2[ue + 16 >> 2] << 2) + Be >> 2] = a2 : q2[(q2[ue + 16 >> 2] << 2) + Ae >> 2] = a2 : Y3(4, 1372, 0), we = we + 4 | 0, !((ue = ue + 32 | 0) >>> 0 < ze >>> 0)) break;
                }
              }(a), function(a2) {
                var Uf = 0, Vf = 0, Wf = 0, Xf = 0, Yf = 0, Zf = 0, _f = 0, $f = 0, ag = 0, bg = 0, cg = 0, dg = 0, eg = 0, fg = 0, gg = 0, hg = 0, ig = 0, jg = 0, kg = 0, lg = 0, mg = 0, ng = 0, og = 0;
                if (Yf = q2[a2 >> 2], 1 <= (0 | ($f = q2[a2 + 56 >> 2]))) {
                  for (ag = q2[a2 + 60 >> 2], bg = q2[Yf + 1052 >> 2], cg = q2[Yf + 784 >> 2]; ; ) {
                    if (Uf = q2[ag + w2(Zf, 24) >> 2], (q2[Uf + 28 >> 2] || q2[Uf + 24 >> 2]) && (q2[(Vf = Zf << 2) + q2[a2 + 80 >> 2] >> 2] = q2[Uf + 12 >> 2], q2[Uf + 24 >> 2]) && !((0 | (Xf = q2[Uf + 12 >> 2])) < 1)) {
                      for (Wf = q2[Uf + 16 >> 2], dg = Wf + (Xf << 2) | 0, eg = q2[Vf + cg >> 2], Vf = (Xf = _f << 2) + q2[a2 + 92 >> 2] | 0, Xf = Xf + q2[a2 + 88 >> 2] | 0; ; ) if (fg = eg + q2[Wf >> 2] << 2, q2[Vf >> 2] = bg + (q2[fg + q2[Yf + 984 >> 2] >> 2] << 2), q2[Xf >> 2] = q2[fg + q2[Yf + 980 >> 2] >> 2], Xf = Xf + 4 | 0, Vf = Vf + 4 | 0, !((Wf = Wf + 4 | 0) >>> 0 < dg >>> 0)) break;
                    }
                    if (q2[Uf + 28 >> 2] && !((0 | (Vf = q2[Uf + 12 >> 2])) < 1)) {
                      for (Wf = q2[Uf + 20 >> 2], Xf = Wf + (Vf << 2) | 0, Vf = q2[a2 + 84 >> 2] + (_f << 2) | 0; ; ) if (q2[Vf >> 2] = q2[Wf >> 2], Vf = Vf + 4 | 0, !((Wf = Wf + 4 | 0) >>> 0 < Xf >>> 0)) break;
                    }
                    if (_f = q2[Uf + 8 >> 2] + _f | 0, (0 | $f) == (0 | (Zf = Zf + 1 | 0))) break;
                  }
                  Yf = q2[a2 >> 2];
                }
                if (!(r2[Yf + 4 | 0] < 4 || (0 | (eg = q2[a2 + 56 >> 2])) < 1)) for (fg = q2[Yf + 792 >> 2], gg = q2[a2 + 60 >> 2], Wf = _f = 0; ; ) {
                  if (Zf = q2[w2(Wf, 24) + gg >> 2], q2[Zf + 24 >> 2] && !((0 | (Uf = q2[Zf + 12 >> 2])) < 1)) {
                    for (Vf = q2[Zf + 16 >> 2], hg = Vf + (Uf << 2) | 0, ig = q2[fg + (Wf << 2) >> 2], Xf = (Uf = _f << 2) + q2[a2 + 96 >> 2] | 0, $f = Uf + q2[a2 + 100 >> 2] | 0, ag = Uf + q2[a2 + 104 >> 2] | 0, bg = Uf + q2[a2 + 108 >> 2] | 0, cg = Uf + q2[a2 + 112 >> 2] | 0, dg = Uf + q2[a2 + 116 >> 2] | 0, jg = q2[Yf + 1308 >> 2], kg = q2[Yf + 1304 >> 2], lg = q2[Yf + 1300 >> 2], mg = q2[Yf + 1296 >> 2], ng = q2[Yf + 1292 >> 2], og = q2[Yf + 1288 >> 2]; ; ) if (Uf = q2[Vf >> 2] + ig << 2, q2[Xf >> 2] = q2[Uf + og >> 2], q2[$f >> 2] = q2[Uf + ng >> 2], q2[ag >> 2] = q2[Uf + mg >> 2], q2[bg >> 2] = q2[Uf + lg >> 2], q2[cg >> 2] = q2[Uf + kg >> 2], q2[dg >> 2] = q2[Uf + jg >> 2], dg = dg + 4 | 0, cg = cg + 4 | 0, bg = bg + 4 | 0, ag = ag + 4 | 0, $f = $f + 4 | 0, Xf = Xf + 4 | 0, !((Vf = Vf + 4 | 0) >>> 0 < hg >>> 0)) break;
                  }
                  if (_f = q2[Zf + 8 >> 2] + _f | 0, (0 | eg) == (0 | (Wf = Wf + 1 | 0))) break;
                }
              }(a), function(a2) {
                var xf = 0, yf = 0, zf = 0, Af = 0, Bf = 0, Cf = 0, Df = 0, Ef = 0, Ff = 0, Gf = 0, Hf = 0, If = 0, Jf = 0, Kf = 0, Lf = 0, Mf = 0, Nf = 0, Of = 0, Pf = 0, Qf = 0, Rf = 0, Sf = 0, Tf = 0;
                if (Tf = q2[a2 + 168 >> 2], zf = q2[a2 >> 2], 1 <= (0 | (Kf = q2[a2 + 164 >> 2]))) for (Mf = q2[zf + 816 >> 2]; ; ) {
                  if (Af = q2[w2(Ef, 12) + Tf >> 2], (q2[Af + 28 >> 2] || q2[Af + 24 >> 2]) && (q2[(Ff = Ef << 2) + q2[a2 + 188 >> 2] >> 2] = q2[Af + 12 >> 2], q2[Af + 24 >> 2])) {
                    if (yf = q2[Af + 16 >> 2], Lf = q2[Ff + Mf >> 2], 1 <= (0 | (xf = q2[Af + 12 >> 2]))) {
                      for (Nf = yf + (xf << 2) | 0, Bf = (xf = Df << 2) + q2[a2 + 200 >> 2] | 0, Gf = xf + q2[a2 + 204 >> 2] | 0, Hf = xf + q2[a2 + 208 >> 2] | 0, If = xf + q2[a2 + 212 >> 2] | 0, Jf = xf + q2[a2 + 196 >> 2] | 0, Of = q2[zf + 996 >> 2], Pf = q2[zf + 1012 >> 2], Qf = q2[zf + 1008 >> 2], Rf = q2[zf + 1004 >> 2], Sf = q2[zf + 1e3 >> 2], xf = yf; ; ) if (Cf = Lf + q2[xf >> 2] << 2, q2[Bf >> 2] = q2[Cf + Sf >> 2], q2[Gf >> 2] = q2[Cf + Rf >> 2], q2[Hf >> 2] = q2[Cf + Qf >> 2], q2[If >> 2] = q2[Cf + Pf >> 2], q2[Jf >> 2] = q2[Cf + Of >> 2], Jf = Jf + 4 | 0, If = If + 4 | 0, Hf = Hf + 4 | 0, Gf = Gf + 4 | 0, Bf = Bf + 4 | 0, !((xf = xf + 4 | 0) >>> 0 < Nf >>> 0)) break;
                    }
                    xf = Lf + q2[yf >> 2] << 2, q2[Ff + q2[a2 + 288 >> 2] >> 2] = q2[xf + q2[zf + 1016 >> 2] >> 2], q2[Ff + q2[a2 + 292 >> 2] >> 2] = q2[xf + q2[zf + 1020 >> 2] >> 2];
                  }
                  if (q2[Af + 28 >> 2] && !((0 | (yf = q2[Af + 12 >> 2])) < 1)) {
                    for (xf = q2[Af + 20 >> 2], yf = xf + (yf << 2) | 0, Bf = q2[a2 + 192 >> 2] + (Df << 2) | 0; ; ) if (q2[Bf >> 2] = q2[xf >> 2], Bf = Bf + 4 | 0, !((xf = xf + 4 | 0) >>> 0 < yf >>> 0)) break;
                  }
                  if (Df = q2[Af + 8 >> 2] + Df | 0, (0 | Kf) == (0 | (Ef = Ef + 1 | 0))) break;
                }
                if (!(r2[zf + 4 | 0] < 4 || (0 | (Ff = q2[a2 + 164 >> 2])) < 1)) for (Lf = q2[zf + 824 >> 2], Df = Af = 0; ; ) {
                  if (Cf = q2[w2(Df, 12) + Tf >> 2], q2[Cf + 24 >> 2] && !((0 | (xf = q2[Cf + 12 >> 2])) < 1)) {
                    for (Bf = q2[Cf + 16 >> 2], Kf = Bf + (xf << 2) | 0, Mf = q2[Lf + (Df << 2) >> 2], Gf = (yf = Af << 2) + q2[a2 + 216 >> 2] | 0, Hf = yf + q2[a2 + 220 >> 2] | 0, If = yf + q2[a2 + 224 >> 2] | 0, Jf = yf + q2[a2 + 228 >> 2] | 0, xf = yf + q2[a2 + 232 >> 2] | 0, Ef = yf + q2[a2 + 236 >> 2] | 0, Nf = q2[zf + 1308 >> 2], Of = q2[zf + 1304 >> 2], Pf = q2[zf + 1300 >> 2], Qf = q2[zf + 1296 >> 2], Rf = q2[zf + 1292 >> 2], Sf = q2[zf + 1288 >> 2]; ; ) if (yf = Mf + q2[Bf >> 2] << 2, q2[Gf >> 2] = q2[yf + Sf >> 2], q2[Hf >> 2] = q2[yf + Rf >> 2], q2[If >> 2] = q2[yf + Qf >> 2], q2[Jf >> 2] = q2[yf + Pf >> 2], q2[xf >> 2] = q2[yf + Of >> 2], q2[Ef >> 2] = q2[yf + Nf >> 2], Ef = Ef + 4 | 0, xf = xf + 4 | 0, Jf = Jf + 4 | 0, If = If + 4 | 0, Hf = Hf + 4 | 0, Gf = Gf + 4 | 0, !((Bf = Bf + 4 | 0) >>> 0 < Kf >>> 0)) break;
                  }
                  if (Af = q2[Cf + 8 >> 2] + Af | 0, (0 | Ff) == (0 | (Df = Df + 1 | 0))) break;
                }
              }(a), function(a2) {
                var qk = 0, rk = 0, sk = 0, tk = 0, uk = 0, vk = 0, wk = 0, xk = 0, yk = 0;
                qk = a2 - -64 | 0, n2[q2[1807]](qk, q2[a2 + 88 >> 2], q2[a2 + 148 >> 2], q2[a2 + 144 >> 2]), n2[q2[1809]](qk, q2[a2 + 92 >> 2], q2[a2 + 152 >> 2], q2[q2[a2 >> 2] + 796 >> 2], 2, q2[a2 + 144 >> 2]);
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (n2[q2[1807]](qk, q2[a2 + 96 >> 2], q2[a2 + 120 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 100 >> 2], q2[a2 + 124 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 104 >> 2], q2[a2 + 128 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 108 >> 2], q2[a2 + 132 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 112 >> 2], q2[a2 + 136 >> 2], q2[a2 + 144 >> 2]), n2[q2[1807]](qk, q2[a2 + 116 >> 2], q2[a2 + 140 >> 2], q2[a2 + 144 >> 2]), (0 | (vk = q2[a2 + 56 >> 2])) < 1))) {
                  for (wk = q2[a2 + 128 >> 2], xk = q2[a2 + 124 >> 2], yk = q2[a2 + 120 >> 2], rk = q2[a2 + 156 >> 2], qk = 0; ; ) if (uk = qk << 2, q2[(sk = tk << 2) + rk >> 2] = q2[uk + yk >> 2], q2[rk + (4 | sk) >> 2] = q2[uk + xk >> 2], q2[rk + (8 | sk) >> 2] = q2[uk + wk >> 2], tk = tk + 4 | 0, (0 | vk) == (0 | (qk = qk + 1 | 0))) break;
                  for (rk = q2[a2 + 160 >> 2], uk = q2[a2 + 140 >> 2], wk = q2[a2 + 136 >> 2], xk = q2[a2 + 132 >> 2], qk = a2 = 0; ; ) if (sk = qk << 2, q2[(tk = a2 << 2) + rk >> 2] = q2[sk + xk >> 2], q2[rk + (4 | tk) >> 2] = q2[sk + wk >> 2], q2[rk + (8 | tk) >> 2] = q2[sk + uk >> 2], a2 = a2 + 4 | 0, (0 | vk) == (0 | (qk = qk + 1 | 0))) break;
                }
              }(a), function(a2) {
                var hk = 0, ik = 0, jk = 0, kk = 0, lk = 0, mk = 0, nk = 0, ok = 0, pk = 0;
                hk = a2 + 172 | 0, n2[q2[1807]](hk, q2[a2 + 196 >> 2], q2[a2 + 268 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 200 >> 2], q2[a2 + 284 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 204 >> 2], q2[a2 + 276 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 208 >> 2], q2[a2 + 280 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 212 >> 2], q2[a2 + 272 >> 2], q2[a2 + 264 >> 2]);
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (n2[q2[1807]](hk, q2[a2 + 216 >> 2], q2[a2 + 240 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 220 >> 2], q2[a2 + 244 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 224 >> 2], q2[a2 + 248 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 228 >> 2], q2[a2 + 252 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 232 >> 2], q2[a2 + 256 >> 2], q2[a2 + 264 >> 2]), n2[q2[1807]](hk, q2[a2 + 236 >> 2], q2[a2 + 260 >> 2], q2[a2 + 264 >> 2]), (0 | (mk = q2[a2 + 164 >> 2])) < 1))) {
                  for (nk = q2[a2 + 248 >> 2], ok = q2[a2 + 244 >> 2], pk = q2[a2 + 240 >> 2], ik = q2[a2 + 296 >> 2], hk = 0; ; ) if (lk = hk << 2, q2[(jk = kk << 2) + ik >> 2] = q2[lk + pk >> 2], q2[ik + (4 | jk) >> 2] = q2[lk + ok >> 2], q2[ik + (8 | jk) >> 2] = q2[lk + nk >> 2], kk = kk + 4 | 0, (0 | mk) == (0 | (hk = hk + 1 | 0))) break;
                  for (ik = q2[a2 + 300 >> 2], lk = q2[a2 + 260 >> 2], nk = q2[a2 + 256 >> 2], ok = q2[a2 + 252 >> 2], hk = a2 = 0; ; ) if (jk = hk << 2, q2[(kk = a2 << 2) + ik >> 2] = q2[jk + ok >> 2], q2[ik + (4 | kk) >> 2] = q2[jk + nk >> 2], q2[ik + (8 | kk) >> 2] = q2[jk + lk >> 2], a2 = a2 + 4 | 0, (0 | mk) == (0 | (hk = hk + 1 | 0))) break;
                }
              }(a), function(a2) {
                var oe = 0, pe = 0, qe = 0, re = 0, se = 0, te = 0;
                if (1 <= (0 | (pe = q2[a2 + 332 >> 2]))) {
                  for (oe = q2[a2 + 336 >> 2], re = oe + w2(pe, 20) | 0, se = q2[a2 + 312 >> 2], te = q2[a2 + 40 >> 2], a2 = q2[a2 + 424 >> 2]; ; ) if (pe = 0, q2[oe + 12 >> 2] && (qe = q2[oe + 4 >> 2], q2[(qe << 2) + te >> 2] || -1 == (0 | qe)) && (qe = q2[oe + 8 >> 2], q2[(qe << 2) + se >> 2] || -1 == (0 | qe)) && (pe = !q2[q2[oe >> 2] + 32 >> 2]), q2[a2 >> 2] = pe, a2 = a2 + 4 | 0, !((oe = oe + 20 | 0) >>> 0 < re >>> 0)) break;
                }
              }(a), function(a2) {
                var $e = 0, af = 0, bf = 0, cf = 0, df = 0, ef = 0, ff = 0, gf = 0, hf = 0, jf = 0, kf = 0, lf = 0, mf = 0, nf = 0, of = 0, pf = 0, qf = 0, rf = 0, sf = 0, tf = 0, uf = 0, vf = 0, wf = 0;
                if (cf = q2[a2 >> 2], 1 <= (0 | (jf = q2[a2 + 332 >> 2]))) {
                  for (kf = q2[a2 + 336 >> 2], lf = q2[cf + 1052 >> 2], mf = q2[cf + 856 >> 2]; ; ) {
                    if ($e = q2[kf + w2(ff, 20) >> 2], (q2[$e + 28 >> 2] || q2[$e + 24 >> 2]) && (q2[(af = ff << 2) + q2[a2 + 356 >> 2] >> 2] = q2[$e + 12 >> 2], q2[$e + 24 >> 2]) && !((0 | (df = q2[$e + 12 >> 2])) < 1)) {
                      for (bf = q2[$e + 16 >> 2], nf = bf + (df << 2) | 0, of = q2[af + mf >> 2], af = (ef = gf << 2) + q2[a2 + 372 >> 2] | 0, df = ef + q2[a2 + 364 >> 2] | 0, ef = ef + q2[a2 + 368 >> 2] | 0; ; ) if (hf = of + q2[bf >> 2] << 2, q2[af >> 2] = lf + (q2[hf + q2[cf + 1040 >> 2] >> 2] << 2), q2[df >> 2] = q2[hf + q2[cf + 1032 >> 2] >> 2], q2[ef >> 2] = q2[hf + q2[cf + 1036 >> 2] >> 2], ef = ef + 4 | 0, df = df + 4 | 0, af = af + 4 | 0, !((bf = bf + 4 | 0) >>> 0 < nf >>> 0)) break;
                    }
                    if (q2[$e + 28 >> 2] && !((0 | (af = q2[$e + 12 >> 2])) < 1)) {
                      for (bf = q2[$e + 20 >> 2], df = bf + (af << 2) | 0, af = q2[a2 + 360 >> 2] + (gf << 2) | 0; ; ) if (q2[af >> 2] = q2[bf >> 2], af = af + 4 | 0, !((bf = bf + 4 | 0) >>> 0 < df >>> 0)) break;
                    }
                    if (gf = q2[$e + 8 >> 2] + gf | 0, (0 | jf) == (0 | (ff = ff + 1 | 0))) break;
                  }
                  cf = q2[a2 >> 2];
                }
                if (!(r2[cf + 4 | 0] < 4 || (0 | (mf = q2[a2 + 332 >> 2])) < 1)) for (nf = q2[cf + 864 >> 2], of = q2[a2 + 336 >> 2], bf = gf = 0; ; ) {
                  if (ff = q2[of + w2(bf, 20) >> 2], q2[ff + 24 >> 2] && !((0 | ($e = q2[ff + 12 >> 2])) < 1)) {
                    for (af = q2[ff + 16 >> 2], pf = af + ($e << 2) | 0, qf = q2[nf + (bf << 2) >> 2], df = ($e = gf << 2) + q2[a2 + 376 >> 2] | 0, ef = $e + q2[a2 + 380 >> 2] | 0, hf = $e + q2[a2 + 384 >> 2] | 0, jf = $e + q2[a2 + 388 >> 2] | 0, kf = $e + q2[a2 + 392 >> 2] | 0, lf = $e + q2[a2 + 396 >> 2] | 0, rf = q2[cf + 1308 >> 2], sf = q2[cf + 1304 >> 2], tf = q2[cf + 1300 >> 2], uf = q2[cf + 1296 >> 2], vf = q2[cf + 1292 >> 2], wf = q2[cf + 1288 >> 2]; ; ) if ($e = q2[af >> 2] + qf << 2, q2[df >> 2] = q2[$e + wf >> 2], q2[ef >> 2] = q2[$e + vf >> 2], q2[hf >> 2] = q2[$e + uf >> 2], q2[jf >> 2] = q2[$e + tf >> 2], q2[kf >> 2] = q2[$e + sf >> 2], q2[lf >> 2] = q2[$e + rf >> 2], lf = lf + 4 | 0, kf = kf + 4 | 0, jf = jf + 4 | 0, hf = hf + 4 | 0, ef = ef + 4 | 0, df = df + 4 | 0, !((af = af + 4 | 0) >>> 0 < pf >>> 0)) break;
                  }
                  if (gf = q2[ff + 8 >> 2] + gf | 0, (0 | mf) == (0 | (bf = bf + 1 | 0))) break;
                }
              }(a), function(a2) {
                var vj = 0, xj = 0, yj = 0, bk = 0, ck = 0, dk = 0, ek = 0, fk = 0, gk = 0;
                vj = a2 + 340 | 0, n2[q2[1807]](vj, q2[a2 + 364 >> 2], q2[a2 + 448 >> 2], q2[a2 + 424 >> 2]), n2[q2[1808]](vj, q2[a2 + 368 >> 2], q2[a2 + 440 >> 2], q2[a2 + 424 >> 2]), n2[q2[1809]](vj, q2[a2 + 372 >> 2], q2[a2 + 444 >> 2], q2[q2[a2 >> 2] + 892 >> 2], 2, q2[a2 + 424 >> 2]);
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (n2[q2[1807]](vj, q2[a2 + 376 >> 2], q2[a2 + 400 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 380 >> 2], q2[a2 + 404 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 384 >> 2], q2[a2 + 408 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 388 >> 2], q2[a2 + 412 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 392 >> 2], q2[a2 + 416 >> 2], q2[a2 + 424 >> 2]), n2[q2[1807]](vj, q2[a2 + 396 >> 2], q2[a2 + 420 >> 2], q2[a2 + 424 >> 2]), (0 | (dk = q2[a2 + 332 >> 2])) < 1))) {
                  for (ek = q2[a2 + 408 >> 2], fk = q2[a2 + 404 >> 2], gk = q2[a2 + 400 >> 2], xj = q2[a2 + 452 >> 2], vj = 0; ; ) if (ck = vj << 2, q2[(yj = bk << 2) + xj >> 2] = q2[ck + gk >> 2], q2[xj + (4 | yj) >> 2] = q2[ck + fk >> 2], q2[xj + (8 | yj) >> 2] = q2[ck + ek >> 2], bk = bk + 4 | 0, (0 | dk) == (0 | (vj = vj + 1 | 0))) break;
                  for (xj = q2[a2 + 456 >> 2], ck = q2[a2 + 420 >> 2], ek = q2[a2 + 416 >> 2], fk = q2[a2 + 412 >> 2], vj = a2 = 0; ; ) if (yj = vj << 2, q2[(bk = a2 << 2) + xj >> 2] = q2[yj + fk >> 2], q2[xj + (4 | bk) >> 2] = q2[yj + ek >> 2], q2[xj + (8 | bk) >> 2] = q2[yj + ck >> 2], a2 = a2 + 4 | 0, (0 | dk) == (0 | (vj = vj + 1 | 0))) break;
                }
              }(a), function(a2) {
                var Pe = 0, Qe = 0, Re = 0, Se = 0, Te = 0, Ue = 0, Ve = 0, We = 0, Xe = 0, Ye = 0, Ze = 0, _e = 0;
                if (1 <= (0 | (Ve = q2[a2 + 500 >> 2]))) for (Xe = q2[a2 + 504 >> 2], We = q2[a2 >> 2], Ye = q2[We + 1252 >> 2]; ; ) {
                  if (Re = q2[w2(Te, 24) + Xe >> 2], (q2[Re + 28 >> 2] || q2[Re + 24 >> 2]) && (q2[(Pe = Te << 2) + q2[a2 + 524 >> 2] >> 2] = q2[Re + 12 >> 2], q2[Re + 24 >> 2]) && !((0 | (Se = q2[Re + 12 >> 2])) < 1)) {
                    for (Qe = q2[Re + 16 >> 2], Se = Qe + (Se << 2) | 0, Ze = q2[Pe + Ye >> 2], Pe = q2[a2 + 532 >> 2] + (Ue << 2) | 0, _e = q2[We + 1284 >> 2]; ; ) if (q2[Pe >> 2] = q2[(q2[Qe >> 2] + Ze << 2) + _e >> 2], Pe = Pe + 4 | 0, !((Qe = Qe + 4 | 0) >>> 0 < Se >>> 0)) break;
                  }
                  if (q2[Re + 28 >> 2] && !((0 | (Pe = q2[Re + 12 >> 2])) < 1)) {
                    for (Qe = q2[Re + 20 >> 2], Se = Qe + (Pe << 2) | 0, Pe = q2[a2 + 528 >> 2] + (Ue << 2) | 0; ; ) if (q2[Pe >> 2] = q2[Qe >> 2], Pe = Pe + 4 | 0, !((Qe = Qe + 4 | 0) >>> 0 < Se >>> 0)) break;
                  }
                  if (Ue = q2[Re + 8 >> 2] + Ue | 0, (0 | Ve) == (0 | (Te = Te + 1 | 0))) break;
                }
              }(a), n2[q2[1807]](a + 508 | 0, q2[a + 532 >> 2], q2[a + 536 >> 2], 0), function(a2) {
                var zk = x2(0), Ak = 0, Bk = 0, Ck = 0, Dk = 0, Ek = 0, Fk = 0, Gk = x2(0), Hk = 0, Ik = 0, Jk = 0;
                L2 = Ek = L2 - 16 | 0, Ck = q2[a2 >> 2];
                if (!(r2[Ck + 4 | 0] < 5 || (0 | (Dk = q2[a2 + 596 >> 2])) < 1)) for (Bk = q2[a2 + 600 >> 2], Hk = Bk + w2(Dk, 12) | 0, Ik = q2[a2 + 44 >> 2], Dk = q2[Ck + 976 >> 2]; ; ) {
                  if (Ck = (q2[Bk >> 2] << 2) + Ik | 0, zk = x2(q2[Ck >> 2]), 1 <= (0 | (Ak = q2[Bk + 4 >> 2]))) {
                    for (a2 = q2[Bk + 8 >> 2], Jk = a2 + w2(Ak, 48) | 0; ; ) if ((Ak = q2[a2 + 8 >> 2]) && ((Fk = Ak + -1 | 0) >>> 0 <= 1 ? (Ak = q2[a2 + 4 >> 2], Gk = u2[Dk + (Ak + q2[a2 + 12 >> 2] << 2) >> 2], zk = x2(Fk - 1 ? zk + x2(u2[a2 + 44 >> 2] * x2(Gk * u2[a2 + 20 >> 2])) : zk + x2(u2[a2 + 44 >> 2] * x2(x2(Gk * u2[a2 + 20 >> 2]) + x2(u2[Dk + (Ak + q2[a2 + 16 >> 2] << 2) >> 2] * u2[a2 + 24 >> 2]))))) : (q2[Ek >> 2] = Ak, Y3(4, 1024, Ek))), !((a2 = a2 + 48 | 0) >>> 0 < Jk >>> 0)) break;
                  }
                  if (zk = (zk = x2(zk + x2(0.0010000000474974513))) < x2(0) ? x2(0) : x2(A(zk, x2(1e3))), a2 = x2(y2(zk)) < x2(2147483648) ? ~~zk : -2147483648, q2[Ck >> 2] = a2, !((Bk = Bk + 12 | 0) >>> 0 < Hk >>> 0)) break;
                }
                L2 = 16 + Ek | 0;
              }(a), function(a2) {
                var ej = 0, gj = 0, ij = 0, jj = 0, kj = 0, lj = x2(0), mj = 0, nj = 0, oj = 0, pj = 0, qj = 0, rj = 0, sj = 0, tj = 0, uj = 0;
                L2 = mj = L2 - 16 | 0, ej = q2[a2 >> 2];
                if (!(r2[ej + 4 | 0] < 4 || (va2(a2, q2[a2 + 604 >> 2], q2[a2 + 608 >> 2], q2[ej + 984 >> 2], q2[a2 + 152 >> 2], q2[ej + 796 >> 2]), gj = q2[a2 >> 2], r2[gj + 4 | 0] < 5))) {
                  if (ij = q2[a2 + 608 >> 2], qj = q2[gj + 992 >> 2], rj = q2[gj + 988 >> 2], 1 <= (0 | (ej = q2[a2 + 604 >> 2]))) {
                    for (sj = w2(ej, 12) + ij | 0, tj = q2[a2 + 148 >> 2], nj = q2[gj + 980 >> 2]; ; ) {
                      if (oj = (q2[ij >> 2] << 2) + tj | 0, kj = q2[oj >> 2], 1 <= (0 | (jj = q2[ij + 4 >> 2]))) {
                        for (ej = q2[ij + 8 >> 2], uj = ej + w2(jj, 48) | 0; ; ) if ((jj = q2[ej + 8 >> 2]) && ((pj = jj + -1 | 0) >>> 0 <= 1 ? (jj = q2[ej + 4 >> 2], lj = u2[(jj + q2[ej + 12 >> 2] << 2) + nj >> 2], kj = (j(x2(pj - 1 ? x2(u2[ej + 44 >> 2] * x2(lj * u2[ej + 20 >> 2])) + (f(0, kj), k()) : x2(u2[ej + 44 >> 2] * x2(x2(lj * u2[ej + 20 >> 2]) + x2(u2[(jj + q2[ej + 16 >> 2] << 2) + nj >> 2] * u2[ej + 24 >> 2]))) + (f(0, kj), k()))), b2[0])) : (q2[mj >> 2] = jj, Y3(4, 1024, mj))), !((ej = ej + 48 | 0) >>> 0 < uj >>> 0)) break;
                      }
                      if (f(0, kj), lj = k(), u2[oj >> 2] = lj < x2(0) ? x2(0) : x2(A(lj, x2(1))), !((ij = ij + 12 | 0) >>> 0 < sj >>> 0)) break;
                    }
                    ij = q2[a2 + 608 >> 2], ej = q2[a2 + 604 >> 2];
                  }
                  fa(ej, ij, rj, q2[gj + 1288 >> 2], q2[gj + 1292 >> 2], q2[gj + 1296 >> 2], q2[a2 + 156 >> 2]), fa(q2[a2 + 604 >> 2], q2[a2 + 608 >> 2], qj, q2[gj + 1300 >> 2], q2[gj + 1304 >> 2], q2[gj + 1308 >> 2], q2[a2 + 160 >> 2]);
                }
                L2 = 16 + mj | 0;
              }(a), function(a2) {
                var si = 0, ti = 0, ui = 0, vi = 0, wi = 0, xi = x2(0), yi = 0, zi = 0, Ai = 0, Bi = 0, Ci = 0, Di = 0, Ei = 0, Fi = 0, Gi = 0;
                L2 = zi = L2 - 80 | 0, wi = q2[a2 >> 2];
                if (!(r2[wi + 4 | 0] < 5)) {
                  if (Ei = q2[wi + 1028 >> 2], Fi = q2[wi + 1024 >> 2], ti = q2[a2 + 616 >> 2], si = q2[a2 + 612 >> 2], ui = ti, !((0 | si) < 1)) {
                    for (Ai = w2(si, 12) + ti | 0, Bi = q2[a2 + 276 >> 2], yi = q2[wi + 1004 >> 2]; ; ) {
                      if (Ci = Bi + (q2[ti >> 2] << 2) | 0, ui = q2[Ci >> 2], 1 <= (0 | (vi = q2[ti + 4 >> 2]))) {
                        for (si = q2[ti + 8 >> 2], Gi = si + w2(vi, 48) | 0; ; ) if ((vi = q2[si + 8 >> 2]) && ((Di = vi + -1 | 0) >>> 0 <= 1 ? (vi = q2[si + 4 >> 2], xi = u2[yi + (vi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Di - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[yi + (vi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[64 + zi >> 2] = vi, Y3(4, 1024, zi + 64 | 0))), !((si = si + 48 | 0) >>> 0 < Gi >>> 0)) break;
                      }
                      if (q2[Ci >> 2] = ui, !((ti = ti + 12 | 0) >>> 0 < Ai >>> 0)) break;
                    }
                    if (ti = q2[a2 + 616 >> 2], si = q2[a2 + 612 >> 2], ui = ti, !((0 | si) < 1)) {
                      for (Ai = w2(si, 12) + ti | 0, Bi = q2[a2 + 280 >> 2], yi = q2[q2[a2 >> 2] + 1008 >> 2]; ; ) {
                        if (Ci = Bi + (q2[ti >> 2] << 2) | 0, ui = q2[Ci >> 2], 1 <= (0 | (vi = q2[ti + 4 >> 2]))) {
                          for (si = q2[ti + 8 >> 2], Gi = si + w2(vi, 48) | 0; ; ) if ((vi = q2[si + 8 >> 2]) && ((Di = vi + -1 | 0) >>> 0 <= 1 ? (vi = q2[si + 4 >> 2], xi = u2[yi + (vi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Di - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[yi + (vi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[48 + zi >> 2] = vi, Y3(4, 1024, 48 + zi | 0))), !((si = si + 48 | 0) >>> 0 < Gi >>> 0)) break;
                        }
                        if (q2[Ci >> 2] = ui, !((ti = ti + 12 | 0) >>> 0 < Ai >>> 0)) break;
                      }
                      if (ti = q2[a2 + 616 >> 2], si = q2[a2 + 612 >> 2], ui = ti, !((0 | si) < 1)) {
                        for (Ai = w2(si, 12) + ti | 0, Bi = q2[a2 + 268 >> 2], yi = q2[q2[a2 >> 2] + 996 >> 2]; ; ) {
                          if (Ci = Bi + (q2[ti >> 2] << 2) | 0, ui = q2[Ci >> 2], 1 <= (0 | (vi = q2[ti + 4 >> 2]))) {
                            for (si = q2[ti + 8 >> 2], Gi = si + w2(vi, 48) | 0; ; ) if ((vi = q2[si + 8 >> 2]) && ((Di = vi + -1 | 0) >>> 0 <= 1 ? (vi = q2[si + 4 >> 2], xi = u2[yi + (vi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Di - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[yi + (vi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[32 + zi >> 2] = vi, Y3(4, 1024, 32 + zi | 0))), !((si = si + 48 | 0) >>> 0 < Gi >>> 0)) break;
                          }
                          if (f(0, ui), xi = k(), u2[Ci >> 2] = xi < x2(0) ? x2(0) : x2(A(xi, x2(1))), !((ti = ti + 12 | 0) >>> 0 < Ai >>> 0)) break;
                        }
                        si = q2[a2 + 612 >> 2], ui = q2[a2 + 616 >> 2];
                      }
                    }
                  }
                  if (fa(si, ui, Fi, q2[wi + 1288 >> 2], q2[wi + 1292 >> 2], q2[wi + 1296 >> 2], q2[a2 + 296 >> 2]), fa(q2[a2 + 612 >> 2], q2[a2 + 616 >> 2], Ei, q2[wi + 1300 >> 2], q2[wi + 1304 >> 2], q2[wi + 1308 >> 2], q2[a2 + 300 >> 2]), !((0 | (si = q2[a2 + 612 >> 2])) < 1)) {
                    for (ti = q2[a2 + 616 >> 2], vi = ti + w2(si, 12) | 0, Ei = q2[a2 + 284 >> 2], wi = q2[q2[a2 >> 2] + 1e3 >> 2]; ; ) {
                      if (Fi = Ei + (q2[ti >> 2] << 2) | 0, ui = q2[Fi >> 2], 1 <= (0 | (yi = q2[ti + 4 >> 2]))) {
                        for (si = q2[ti + 8 >> 2], Ai = si + w2(yi, 48) | 0; ; ) if ((yi = q2[si + 8 >> 2]) && ((Bi = yi + -1 | 0) >>> 0 <= 1 ? (yi = q2[si + 4 >> 2], xi = u2[wi + (yi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Bi - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[wi + (yi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[16 + zi >> 2] = yi, Y3(4, 1024, 16 + zi | 0))), !((si = si + 48 | 0) >>> 0 < Ai >>> 0)) break;
                      }
                      if (f(0, ui), xi = k(), u2[Fi >> 2] = xi < x2(-3600) ? x2(-3600) : x2(A(xi, x2(3600))), !((ti = ti + 12 | 0) >>> 0 < vi >>> 0)) break;
                    }
                    if (!((0 | (si = q2[a2 + 612 >> 2])) < 1)) for (ti = q2[a2 + 616 >> 2], yi = ti + w2(si, 12) | 0, vi = q2[a2 + 272 >> 2], a2 = q2[q2[a2 >> 2] + 1012 >> 2]; ; ) {
                      if (Ei = vi + (q2[ti >> 2] << 2) | 0, ui = q2[Ei >> 2], 1 <= (0 | (wi = q2[ti + 4 >> 2]))) {
                        for (si = q2[ti + 8 >> 2], Fi = si + w2(wi, 48) | 0; ; ) if ((wi = q2[si + 8 >> 2]) && ((Ai = wi + -1 | 0) >>> 0 <= 1 ? (wi = q2[si + 4 >> 2], xi = u2[a2 + (wi + q2[si + 12 >> 2] << 2) >> 2], ui = (j(x2(Ai - 1 ? x2(u2[si + 44 >> 2] * x2(xi * u2[si + 20 >> 2])) + (f(0, ui), k()) : x2(u2[si + 44 >> 2] * x2(x2(xi * u2[si + 20 >> 2]) + x2(u2[a2 + (wi + q2[si + 16 >> 2] << 2) >> 2] * u2[si + 24 >> 2]))) + (f(0, ui), k()))), b2[0])) : (q2[zi >> 2] = wi, Y3(4, 1024, zi))), !((si = si + 48 | 0) >>> 0 < Fi >>> 0)) break;
                      }
                      if (f(0, ui), xi = k(), u2[Ei >> 2] = xi < x2(9999999747378752e-20) ? x2(9999999747378752e-20) : x2(A(xi, x2(100))), !((ti = ti + 12 | 0) >>> 0 < yi >>> 0)) break;
                    }
                  }
                }
                L2 = 80 + zi | 0;
              }(a), function(a2) {
                var Vh = 0, Wh = 0, Xh = 0, Yh = 0, Zh = x2(0), _h = 0, $h = 0, ai = 0, bi = 0, ci = 0, di = 0, ei = 0, fi = x2(0), gi = 0, hi = 0, ii = 0;
                L2 = $h = L2 - 32 | 0, Xh = q2[a2 >> 2];
                if (!(r2[Xh + 4 | 0] < 4 || (va2(a2, q2[a2 + 620 >> 2], q2[a2 + 624 >> 2], q2[Xh + 1040 >> 2], q2[a2 + 444 >> 2], q2[Xh + 892 >> 2]), _h = q2[a2 >> 2], r2[_h + 4 | 0] < 5))) {
                  if (hi = q2[_h + 1048 >> 2], ii = q2[_h + 1044 >> 2], Yh = q2[a2 + 624 >> 2], Vh = q2[a2 + 620 >> 2], Xh = Yh, !((0 | Vh) < 1)) {
                    for (di = w2(Vh, 12) + Yh | 0, ei = q2[a2 + 440 >> 2], ai = q2[_h + 1036 >> 2]; ; ) {
                      if (Xh = ei + (q2[Yh >> 2] << 2) | 0, Zh = x2(q2[Xh >> 2]), 1 <= (0 | (Wh = q2[Yh + 4 >> 2]))) {
                        for (Vh = q2[Yh + 8 >> 2], bi = Vh + w2(Wh, 48) | 0; ; ) if ((Wh = q2[Vh + 8 >> 2]) && ((ci = Wh + -1 | 0) >>> 0 <= 1 ? (Wh = q2[Vh + 4 >> 2], fi = u2[ai + (Wh + q2[Vh + 12 >> 2] << 2) >> 2], Zh = x2(ci - 1 ? Zh + x2(u2[Vh + 44 >> 2] * x2(fi * u2[Vh + 20 >> 2])) : Zh + x2(u2[Vh + 44 >> 2] * x2(x2(fi * u2[Vh + 20 >> 2]) + x2(u2[ai + (Wh + q2[Vh + 16 >> 2] << 2) >> 2] * u2[Vh + 24 >> 2]))))) : (q2[16 + $h >> 2] = Wh, Y3(4, 1024, 16 + $h | 0))), !((Vh = Vh + 48 | 0) >>> 0 < bi >>> 0)) break;
                      }
                      if (Zh = (Zh = x2(Zh + x2(0.0010000000474974513))) < x2(0) ? x2(0) : x2(A(Zh, x2(1e3))), Vh = x2(y2(Zh)) < x2(2147483648) ? ~~Zh : -2147483648, q2[Xh >> 2] = Vh, !((Yh = Yh + 12 | 0) >>> 0 < di >>> 0)) break;
                    }
                    if (Yh = q2[a2 + 624 >> 2], Vh = q2[a2 + 620 >> 2], Xh = Yh, !((0 | Vh) < 1)) {
                      for (di = w2(Vh, 12) + Yh | 0, ei = q2[a2 + 448 >> 2], ai = q2[q2[a2 >> 2] + 1032 >> 2]; ; ) {
                        if (bi = ei + (q2[Yh >> 2] << 2) | 0, Xh = q2[bi >> 2], 1 <= (0 | (Wh = q2[Yh + 4 >> 2]))) {
                          for (Vh = q2[Yh + 8 >> 2], ci = Vh + w2(Wh, 48) | 0; ; ) if ((Wh = q2[Vh + 8 >> 2]) && ((gi = Wh + -1 | 0) >>> 0 <= 1 ? (Wh = q2[Vh + 4 >> 2], Zh = u2[ai + (Wh + q2[Vh + 12 >> 2] << 2) >> 2], Xh = (j(x2(gi - 1 ? x2(u2[Vh + 44 >> 2] * x2(Zh * u2[Vh + 20 >> 2])) + (f(0, Xh), k()) : x2(u2[Vh + 44 >> 2] * x2(x2(Zh * u2[Vh + 20 >> 2]) + x2(u2[ai + (Wh + q2[Vh + 16 >> 2] << 2) >> 2] * u2[Vh + 24 >> 2]))) + (f(0, Xh), k()))), b2[0])) : (q2[$h >> 2] = Wh, Y3(4, 1024, $h))), !((Vh = Vh + 48 | 0) >>> 0 < ci >>> 0)) break;
                        }
                        if (f(0, Xh), Zh = k(), u2[bi >> 2] = Zh < x2(0) ? x2(0) : x2(A(Zh, x2(1))), !((Yh = Yh + 12 | 0) >>> 0 < di >>> 0)) break;
                      }
                      Vh = q2[a2 + 620 >> 2], Xh = q2[a2 + 624 >> 2];
                    }
                  }
                  fa(Vh, Xh, ii, q2[_h + 1288 >> 2], q2[_h + 1292 >> 2], q2[_h + 1296 >> 2], q2[a2 + 452 >> 2]), fa(q2[a2 + 620 >> 2], q2[a2 + 624 >> 2], hi, q2[_h + 1300 >> 2], q2[_h + 1304 >> 2], q2[_h + 1308 >> 2], q2[a2 + 456 >> 2]);
                }
                L2 = 32 + $h | 0;
              }(a), function(a2) {
                var Bg = 0, Cg = 0, Dg = 0, Eg = 0, Fg = x2(0), Gg = 0, Hg = 0, Ig = 0, Jg = 0, Kg = 0, Lg = 0;
                L2 = Gg = L2 - 16 | 0, Cg = q2[a2 >> 2];
                if (!(r2[Cg + 4 | 0] < 5 || (0 | (Eg = q2[a2 + 628 >> 2])) < 1)) for (Dg = q2[a2 + 632 >> 2], Jg = Dg + w2(Eg, 12) | 0, Kg = q2[a2 + 536 >> 2], Eg = q2[Cg + 1284 >> 2]; ; ) {
                  if (Hg = (q2[Dg >> 2] << 2) + Kg | 0, Cg = q2[Hg >> 2], 1 <= (0 | (Bg = q2[Dg + 4 >> 2]))) {
                    for (a2 = q2[Dg + 8 >> 2], Lg = a2 + w2(Bg, 48) | 0; ; ) if ((Bg = q2[a2 + 8 >> 2]) && ((Ig = Bg + -1 | 0) >>> 0 <= 1 ? (Bg = q2[a2 + 4 >> 2], Fg = u2[Eg + (Bg + q2[a2 + 12 >> 2] << 2) >> 2], Cg = (j(x2(Ig - 1 ? x2(u2[a2 + 44 >> 2] * x2(Fg * u2[a2 + 20 >> 2])) + (f(0, Cg), k()) : x2(u2[a2 + 44 >> 2] * x2(x2(Fg * u2[a2 + 20 >> 2]) + x2(u2[Eg + (Bg + q2[a2 + 16 >> 2] << 2) >> 2] * u2[a2 + 24 >> 2]))) + (f(0, Cg), k()))), b2[0])) : (q2[Gg >> 2] = Bg, Y3(4, 1024, Gg))), !((a2 = a2 + 48 | 0) >>> 0 < Lg >>> 0)) break;
                  }
                  if (f(0, Cg), Fg = k(), u2[Hg >> 2] = Fg < x2(0) ? x2(0) : x2(A(Fg, x2(1))), !((Dg = Dg + 12 | 0) >>> 0 < Jg >>> 0)) break;
                }
                L2 = 16 + Gg | 0;
              }(a), function(a2) {
                var mh = 0, Oh = 0, Ph = 0, Qh = 0, Rh = x2(0), Sh = 0, Th = 0;
                if (1 <= (0 | (mh = q2[a2 + 4 >> 2]))) {
                  for (Oh = q2[a2 + 8 >> 2], Th = Oh + w2(mh, 12) | 0, mh = q2[a2 + 40 >> 2], Ph = q2[a2 + 52 >> 2], Qh = q2[a2 + 48 >> 2], a2 = Qh; ; ) if (q2[mh >> 2] && (Rh = u2[Ph >> 2], u2[a2 >> 2] = Rh, -1 != (0 | (Sh = q2[Oh + 4 >> 2]))) && (u2[a2 >> 2] = Rh * u2[(Sh << 2) + Qh >> 2]), a2 = a2 + 4 | 0, Ph = Ph + 4 | 0, mh = mh + 4 | 0, !((Oh = Oh + 12 | 0) >>> 0 < Th >>> 0)) break;
                }
              }(a), function(a2) {
                var ih = 0, jh = 0, kh = 0, lh = 0;
                if (1 <= (0 | (lh = q2[a2 + 304 >> 2]))) {
                  for (ih = q2[a2 + 308 >> 2], jh = q2[a2 + 312 >> 2]; ; ) if (q2[jh >> 2] && n2[q2[ih + 20 >> 2]](a2, kh), jh = jh + 4 | 0, ih = ih + 32 | 0, (0 | lh) == (0 | (kh = kh + 1 | 0))) break;
                }
              }(a), function(a2) {
                var Xg = 0, Yg = 0, Zg = x2(0), _g = x2(0), $g = 0, ah = 0, bh = 0, ch = x2(0), dh = 0, eh = 0, fh = 0, gh = 0, hh = 0;
                if (1 <= (0 | (Xg = q2[a2 + 332 >> 2]))) {
                  for (Yg = q2[a2 + 336 >> 2], eh = Yg + w2(Xg, 20) | 0, fh = q2[a2 + 308 >> 2], dh = q2[a2 + 316 >> 2], hh = q2[a2 + 48 >> 2], Xg = q2[a2 + 448 >> 2], $g = q2[a2 + 444 >> 2], bh = q2[a2 + 424 >> 2]; ; ) if (q2[bh >> 2] && (-1 != (0 | (ah = q2[Yg + 4 >> 2])) && (u2[Xg >> 2] = u2[(ah << 2) + hh >> 2] * u2[Xg >> 2]), -1 != (0 | (ah = q2[Yg + 8 >> 2]))) && (u2[Xg >> 2] = u2[dh + (ah << 2) >> 2] * u2[Xg >> 2], gh = q2[$g >> 2], n2[q2[24 + (fh + (ah << 5) | 0) >> 2]](a2, ah, gh, gh, q2[Yg + 16 >> 2])), $g = $g + 4 | 0, Xg = Xg + 4 | 0, bh = bh + 4 | 0, !((Yg = Yg + 20 | 0) >>> 0 < eh >>> 0)) break;
                }
                if (!(r2[q2[a2 >> 2] + 4 | 0] < 4 || (0 | (Xg = q2[a2 + 332 >> 2])) < 1)) {
                  for ($g = q2[a2 + 336 >> 2], ah = $g + w2(Xg, 20) | 0, eh = q2[a2 + 328 >> 2], fh = q2[a2 + 324 >> 2], Yg = q2[a2 + 452 >> 2], Xg = q2[a2 + 456 >> 2], bh = q2[a2 + 424 >> 2]; ; ) if (q2[bh >> 2] && -1 != (0 | (a2 = q2[$g + 8 >> 2])) && (a2 = (dh = a2 << 4) + fh | 0, Zg = x2(u2[Yg >> 2] * u2[a2 >> 2]), u2[Yg >> 2] = Zg, _g = x2(u2[Yg + 4 >> 2] * u2[a2 + 4 >> 2]), u2[Yg + 4 >> 2] = _g, ch = u2[a2 + 8 >> 2], q2[Yg + 12 >> 2] = 1065353216, u2[Yg + 4 >> 2] = _g < x2(0) ? x2(0) : x2(A(_g, x2(1))), u2[Yg >> 2] = Zg < x2(0) ? x2(0) : x2(A(Zg, x2(1))), Zg = x2(ch * u2[Yg + 8 >> 2]), u2[Yg + 8 >> 2] = Zg < x2(0) ? x2(0) : x2(A(Zg, x2(1))), Zg = u2[Xg >> 2], _g = u2[(a2 = eh + dh | 0) >> 2], Zg = x2(x2(Zg + _g) - x2(Zg * _g)), u2[Xg >> 2] = Zg, _g = u2[Xg + 4 >> 2], ch = u2[a2 + 4 >> 2], _g = x2(x2(_g + ch) - x2(_g * ch)), u2[Xg + 4 >> 2] = _g, ch = u2[a2 + 8 >> 2], q2[Xg + 12 >> 2] = 1065353216, u2[Xg + 4 >> 2] = _g < x2(0) ? x2(0) : x2(A(_g, x2(1))), u2[Xg >> 2] = Zg < x2(0) ? x2(0) : x2(A(Zg, x2(1))), Zg = u2[Xg + 8 >> 2], Zg = x2(x2(ch + Zg) - x2(Zg * ch)), u2[Xg + 8 >> 2] = Zg < x2(0) ? x2(0) : x2(A(Zg, x2(1)))), Xg = Xg + 16 | 0, Yg = Yg + 16 | 0, bh = bh + 4 | 0, !(($g = $g + 20 | 0) >>> 0 < ah >>> 0)) break;
                }
              }(a), function(a2) {
                var Ln = 0, Mn = 0, Nn = 0, On = x2(0), Ko = x2(0), Lo = x2(0), Mo = x2(0), No = x2(0), Oo = 0, Po = 0, Qo = 0, Ro = 0, So = 0, To = 0, Uo = 0, Vo = x2(0), Wo = 0, Xo = 0, Yo = x2(0), Zo = 0, _o = 0;
                if (1 <= (0 | (Oo = q2[a2 + 500 >> 2]))) for (Zo = q2[a2 + 536 >> 2], Po = q2[a2 + 444 >> 2], _o = q2[a2 + 504 >> 2]; ; ) {
                  if (a2 = w2(Nn, 24) + _o | 0, 0 < (0 | (Qo = q2[a2 + 12 >> 2]))) {
                    for (On = u2[(Nn << 2) + Zo >> 2], Ro = q2[a2 + 20 >> 2], So = q2[a2 + 16 >> 2], To = q2[(q2[a2 + 4 >> 2] << 2) + Po >> 2], Uo = q2[(q2[a2 + 8 >> 2] << 2) + Po >> 2], a2 = 0; ; ) if (Vo = u2[((Ln = 1 | a2) << 2) + So >> 2], Mn = s[(a2 << 1) + Ro >> 1] << 3 & 262136, Ko = u2[(Wo = (4 | Mn) + To | 0) >> 2], Ln = s[(Ln << 1) + Ro >> 1] << 3 & 262136, Lo = u2[(Xo = (4 | Ln) + Uo | 0) >> 2], Mo = u2[(Mn = Mn + To | 0) >> 2], Yo = u2[(a2 << 2) + So >> 2], No = u2[(Ln = Ln + Uo | 0) >> 2], u2[Mn >> 2] = Mo + x2(On * x2(Yo * x2(No - Mo))), u2[Wo >> 2] = Ko + x2(On * x2(Yo * x2(Lo - Ko))), u2[Ln >> 2] = No + x2(On * x2(Vo * x2(Mo - No))), u2[Xo >> 2] = Lo + x2(On * x2(Vo * x2(Ko - Lo))), !((0 | (a2 = a2 + 2 | 0)) < (0 | Qo))) break;
                  }
                  if (!((0 | (Nn = Nn + 1 | 0)) < (0 | Oo))) break;
                }
              }(a), n2[q2[1810]](a), function(a2) {
                var Gc = 0, Ic = 0, Jc = 0, Kc = 0, Lc = 0, Mc = 0, Nc = 0, Oc = 0, Pc = 0, Qc = 0, Rc = 0, Sc = 0, Tc = 0, Uc = 0, Vc = 0;
                if (!((0 | (Rc = q2[a2 + 480 >> 2])) < 1)) {
                  for (Sc = q2[a2 + 484 >> 2], Kc = Sc + w2(Rc, 28) | 0, Nc = q2[a2 + 424 >> 2], Oc = q2[a2 + 40 >> 2], Lc = q2[a2 + 44 >> 2], Tc = q2[a2 + 440 >> 2], Gc = Sc; ; ) {
                    if (1 <= (0 | (Mc = q2[Gc + 4 >> 2]))) {
                      for (Qc = Gc + 20 | 0, Pc = q2[Gc + 12 >> 2], Ic = 0; ; ) if (Uc = q2[(Jc = Pc + (Ic << 4) | 0) + 4 >> 2] << 2, Jc = 1 == q2[(Vc = Jc) >> 2], q2[Vc + 12 >> 2] = q2[(q2[(Jc ? Oc : Nc) + Uc >> 2] ? (Jc ? Lc : Tc) + Uc | 0 : Qc) >> 2], !((0 | (Ic = Ic + 1 | 0)) < (0 | Mc))) break;
                    }
                    if (!((Gc = Gc + 28 | 0) >>> 0 < Kc >>> 0)) break;
                  }
                  if (!((0 | Rc) < 1)) for (Tc = q2[a2 + 436 >> 2], Oc = 0; ; ) {
                    if (Kc = w2(Oc, 28) + Sc | 0, !(q2[(Nc = Kc) + 24 >> 2] < 1)) {
                      for (Jc = q2[a2 + 488 >> 2], Ic = 0; ; ) if (q2[Jc + (Ic << 2) >> 2] = -1, Ic = Ic + 1 | 0, Gc = q2[Nc + 24 >> 2], !((0 | Ic) < (0 | Gc))) break;
                      if (!((0 | Gc) < 1)) {
                        for (Gc = q2[a2 + 496 >> 2], Ic = 0; ; ) if (q2[Gc + (Ic << 2) >> 2] = -1, !((0 | (Ic = Ic + 1 | 0)) < q2[Nc + 24 >> 2])) break;
                      }
                    }
                    if (!(q2[Kc + 4 >> 2] < 1)) {
                      for (Lc = q2[a2 + 492 >> 2], Ic = 0; ; ) if (q2[Lc + (Ic << 2) >> 2] = -1, Ic = Ic + 1 | 0, Gc = q2[Kc + 4 >> 2], !((0 | Ic) < (0 | Gc))) break;
                      if (!((0 | Gc) < 1)) {
                        for (Mc = q2[Kc + 12 >> 2], Qc = q2[a2 + 496 >> 2], Ic = 0; ; ) if (Pc = q2[12 + (Mc + (Ic << 4) | 0) >> 2] - q2[Kc + 20 >> 2] << 2, Gc = -1 == (0 | (Gc = q2[(Jc = Pc + Qc | 0) >> 2])) ? Pc + q2[a2 + 488 >> 2] | 0 : Lc + (Gc << 2) | 0, q2[Gc >> 2] = Ic, !((0 | (Ic = (q2[Jc >> 2] = Ic) + 1 | 0)) < q2[Kc + 4 >> 2])) break;
                      }
                    }
                    if (1 <= (0 | (Gc = q2[Nc + 24 >> 2]))) for (Lc = q2[Kc + 8 >> 2], Qc = q2[a2 + 488 >> 2], Mc = 0; ; ) {
                      if (-1 != (0 | (Ic = q2[Qc + (Mc << 2) >> 2]))) {
                        for (Pc = q2[a2 + 492 >> 2], Jc = q2[Kc + 12 >> 2]; ; ) if (Gc = 1 == q2[(Gc = Jc + (Ic << 4) | 0) >> 2] ? (Gc = w2(q2[Gc + 8 >> 2], 28) + Sc | 0, q2[Gc + 8 >> 2] = Lc, q2[Gc >> 2]) : (q2[Tc + (q2[Gc + 4 >> 2] << 2) >> 2] = Lc, 1), Lc = Gc + Lc | 0, Gc = q2[Pc + (Ic << 2) >> 2], !((0 | Ic) < (0 | Gc) && -1 != (0 | (Ic = Gc)))) break;
                        Gc = q2[Nc + 24 >> 2];
                      }
                      if (!((0 | (Mc = Mc + 1 | 0)) < (0 | Gc))) break;
                    }
                    if ((0 | Rc) == (0 | (Oc = Oc + 1 | 0))) break;
                  }
                }
              }(a), function(a2) {
                var Mg = 0, Ng = 0, Og = 0, Pg = 0, Qg = 0, Rg = 0, Sg = x2(0), Tg = 0, Ug = 0;
                Qg = q2[a2 + 332 >> 2];
                if (q2[a2 + 644 >> 2]) {
                  if (!(((q2[a2 + 428 >> 2] = 0) | Qg) < 1)) {
                    for (; ; ) if (Mg = 126, Tg = q2[a2 + 432 >> 2] + Og | 0, !q2[(Ng = Og << 2) + q2[a2 + 424 >> 2] >> 2] | u2[Ng + q2[a2 + 448 >> 2] >> 2] == x2(0) || (Mg = 127), o[0 | Tg] = Mg, (0 | Qg) == (0 | (Og = Og + 1 | 0))) break;
                  }
                } else if (q2[a2 + 428 >> 2]) {
                  if (Mg = r2[q2[a2 >> 2] + 4 | 0], !(((q2[a2 + 428 >> 2] = 0) | Qg) < 1)) {
                    if (4 <= Mg >>> 0) {
                      for (; ; ) if (Sg = u2[(Mg = Og << 2) + q2[a2 + 448 >> 2] >> 2], Pg = q2[Mg + q2[a2 + 424 >> 2] >> 2], Ng = Sg != x2(0) & 0 != (0 | Pg), Tg = q2[a2 + 432 >> 2] + Og | 0, Ng = (0 | Ng) == (1 & o[0 | Tg]) ? Ng : 2 | Ng, Ng = Sg != u2[Mg + q2[a2 + 468 >> 2] >> 2] ? 4 | Ng : Ng, Ng = q2[Mg + q2[a2 + 440 >> 2] >> 2] == q2[Mg + q2[a2 + 464 >> 2] >> 2] ? Ng : 8 | Ng, Mg = q2[Mg + q2[a2 + 436 >> 2] >> 2] == q2[Mg + q2[a2 + 460 >> 2] >> 2] ? Ng : 16 | Ng, Mg = Pg ? 32 | Mg : Mg, Pg = (Ng = Ug << 2) + q2[a2 + 452 >> 2] | 0, Rg = Ng + q2[a2 + 472 >> 2] | 0, (u2[Pg >> 2] != u2[Rg >> 2] | u2[Pg + 4 >> 2] != u2[Rg + 4 >> 2] | (u2[Pg + 8 >> 2] != u2[Rg + 8 >> 2] | u2[Pg + 12 >> 2] != u2[Rg + 12 >> 2]) || (Pg = Ng + q2[a2 + 456 >> 2] | 0, Ng = Ng + q2[a2 + 476 >> 2] | 0, u2[Pg >> 2] != u2[Ng >> 2] | u2[Pg + 4 >> 2] != u2[Ng + 4 >> 2] | u2[Pg + 8 >> 2] != u2[Ng + 8 >> 2]) || u2[Pg + 12 >> 2] != u2[Ng + 12 >> 2]) && (Mg |= 64), o[0 | Tg] = Mg, Ug = Ug + 4 | 0, (0 | Qg) == (0 | (Og = Og + 1 | 0))) break;
                    } else for (; ; ) if (Sg = u2[(Mg = Og << 2) + q2[a2 + 448 >> 2] >> 2], Pg = q2[Mg + q2[a2 + 424 >> 2] >> 2], Ng = Sg != x2(0) & 0 != (0 | Pg), Rg = q2[a2 + 432 >> 2] + Og | 0, Ng = (0 | Ng) == (1 & o[0 | Rg]) ? Ng : 2 | Ng, Ng = Sg != u2[Mg + q2[a2 + 468 >> 2] >> 2] ? 4 | Ng : Ng, Ng = q2[Mg + q2[a2 + 440 >> 2] >> 2] == q2[Mg + q2[a2 + 464 >> 2] >> 2] ? Ng : 8 | Ng, Mg = q2[Mg + q2[a2 + 436 >> 2] >> 2] == q2[Mg + q2[a2 + 460 >> 2] >> 2] ? Ng : 16 | Ng, o[0 | Rg] = Pg ? 32 | Mg : Mg, (0 | Qg) == (0 | (Og = Og + 1 | 0))) break;
                  }
                } else if (!((0 | Qg) < 1)) {
                  for (; ; ) if (!q2[(Mg = Og << 2) + q2[a2 + 424 >> 2] >> 2] | u2[Mg + q2[a2 + 448 >> 2] >> 2] == x2(0) ? (Mg = q2[a2 + 432 >> 2] + Og | 0, o[0 | Mg] = 254 & r2[0 | Mg]) : (Mg = q2[a2 + 432 >> 2] + Og | 0, o[0 | Mg] = 1 | r2[0 | Mg]), (0 | Qg) == (0 | (Og = Og + 1 | 0))) break;
                }
              }(a), q2[a + 644 >> 2] = 0;
            }
            function va2(a, Wa, Xa, Ya, Za, _a) {
              var fb, gb, hb, jb, kb, cb, $a = 0, bb = 0, db = 0, eb = 0, ib = 0;
              if (L2 = cb = L2 - 32 | 0, 1 <= (0 | Wa)) for (kb = w2(Wa, 12) + Xa | 0; ; ) {
                if (!((0 | ($a = q2[Xa + 4 >> 2])) < 1)) {
                  if (fb = (Wa = q2[Xa + 8 >> 2]) + w2($a, 48) | 0, $a = q2[Xa >> 2] << 2, 1 <= (0 | (db = q2[$a + _a >> 2]))) for (db <<= 1, gb = q2[q2[a >> 2] + 1052 >> 2], hb = q2[Za + $a >> 2]; ; ) {
                    b: if ($a = q2[Wa + 8 >> 2]) {
                      c: {
                        if ((bb = $a + -1 | 0) >>> 0 <= 1) {
                          if ($a = (q2[Wa + 4 >> 2] << 2) + Ya | 0, ib = (q2[$a + (q2[Wa + 12 >> 2] << 2) >> 2] << 2) + gb | 0, bb - 1) break c;
                          for (eb = (q2[$a + (q2[Wa + 16 >> 2] << 2) >> 2] << 2) + gb | 0, $a = 0; ; ) if (u2[(jb = (bb = $a << 2) + hb | 0) >> 2] = u2[jb >> 2] + x2(u2[Wa + 44 >> 2] * x2(x2(u2[bb + ib >> 2] * u2[Wa + 20 >> 2]) + x2(u2[bb + eb >> 2] * u2[Wa + 24 >> 2]))), (0 | db) == (0 | ($a = $a + 1 | 0))) break;
                          break b;
                        }
                        q2[cb >> 2] = $a, Y3(4, 1024, cb);
                        break b;
                      }
                      for ($a = 0; ; ) if (u2[(eb = (bb = $a << 2) + hb | 0) >> 2] = u2[eb >> 2] + x2(u2[Wa + 44 >> 2] * x2(u2[bb + ib >> 2] * u2[Wa + 20 >> 2])), (0 | db) == (0 | ($a = $a + 1 | 0))) break;
                    }
                    if (!((Wa = Wa + 48 | 0) >>> 0 < fb >>> 0)) break;
                  }
                  else for (; ; ) if (3 <= ($a = q2[Wa + 8 >> 2]) >>> 0 && (q2[16 + cb >> 2] = $a, Y3(4, 1024, 16 + cb | 0)), !((Wa = Wa + 48 | 0) >>> 0 < fb >>> 0)) break;
                }
                if (!((Xa = Xa + 12 | 0) >>> 0 < kb >>> 0)) break;
              }
              L2 = 32 + cb | 0;
            }
            function wa2(a, Wa, Xa) {
              Wa |= 0, Xa |= 0;
              var Ya;
              L2 = Ya = L2 + -64 | 0;
              a: {
                if (a |= 0) if (Wa) if ((Wa + 15 & -16) != (0 | Wa)) q2[52 + Ya >> 2] = 1522, q2[48 + Ya >> 2] = 2361, Y3(4, 1294, 48 + Ya | 0);
                else {
                  if (Wa = function(a2, Il, Jl) {
                    var $l = 0, am = 0, bm = 0, cm = 0, dm = 0, em = 0, fm = 0, gm = 0, hm = 0, im = 0, jm = 0, km = 0, lm = 0, mm = 0, nm = x2(0), om = 0, pm = 0, qm = 0, rm = 0, sm = 0;
                    if (ca2(16 + (L2 = cm = L2 - 576 | 0) | 0, 0, 560), Fa(a2, 16 + cm | 0, 12 + cm | 0), (dm = q2[12 + cm >> 2]) >>> 0 <= Jl >>> 0) {
                      if (am = ca2(Il, 0, dm), $l = am + q2[16 + cm >> 2] | 0, q2[$l + 8 >> 2] = am + q2[20 + cm >> 2], q2[$l + 40 >> 2] = am + q2[24 + cm >> 2], q2[$l + 44 >> 2] = am + q2[28 + cm >> 2], q2[$l + 48 >> 2] = am + q2[32 + cm >> 2], q2[$l + 52 >> 2] = am + q2[36 + cm >> 2], q2[$l + 16 >> 2] = am + q2[40 + cm >> 2], q2[$l + 24 >> 2] = am + q2[44 + cm >> 2], q2[$l + 28 >> 2] = am + q2[48 + cm >> 2], q2[$l + 32 >> 2] = am + q2[52 + cm >> 2], q2[$l + 36 >> 2] = am + q2[56 + cm >> 2], Il = q2[a2 + 704 >> 2], q2[$l + 308 >> 2] = am + q2[60 + cm >> 2], q2[$l + 312 >> 2] = am + q2[64 + cm >> 2], q2[$l + 316 >> 2] = am + q2[68 + cm >> 2], q2[$l + 320 >> 2] = am + q2[72 + cm >> 2], q2[$l + 324 >> 2] = am + q2[76 + cm >> 2], q2[$l + 328 >> 2] = am + q2[80 + cm >> 2], q2[$l + 60 >> 2] = am + q2[84 + cm >> 2], q2[$l + 144 >> 2] = am + q2[88 + cm >> 2], q2[$l + 148 >> 2] = am + q2[92 + cm >> 2], Jl = am + q2[96 + cm >> 2] | 0, q2[$l + 152 >> 2] = Jl, !((0 | (dm = q2[Il + 8 >> 2])) < 1) && (Il = am + q2[100 + cm >> 2] | 0, q2[Jl >> 2] = Il, 1 != (0 | dm))) {
                        for (Jl = 1; ; ) if (Il = (15 + (q2[q2[a2 + 796 >> 2] + (bm << 2) >> 2] << 3) & -16) + Il | 0, q2[q2[$l + 152 >> 2] + (Jl << 2) >> 2] = Il, (0 | dm) == (0 | (Jl = (bm = Jl) + 1 | 0))) break;
                      }
                      if (q2[$l + 156 >> 2] = am + q2[104 + cm >> 2], q2[$l + 160 >> 2] = am + q2[108 + cm >> 2], q2[$l + 68 >> 2] = am + q2[112 + cm >> 2], q2[$l + 76 >> 2] = am + q2[116 + cm >> 2], q2[$l + 80 >> 2] = am + q2[120 + cm >> 2], q2[$l + 84 >> 2] = am + q2[124 + cm >> 2], q2[$l + 88 >> 2] = am + q2[128 + cm >> 2], q2[$l + 92 >> 2] = am + q2[132 + cm >> 2], q2[$l + 96 >> 2] = am + q2[136 + cm >> 2], q2[$l + 100 >> 2] = am + q2[140 + cm >> 2], q2[$l + 104 >> 2] = am + q2[144 + cm >> 2], q2[$l + 108 >> 2] = am + q2[148 + cm >> 2], q2[$l + 112 >> 2] = am + q2[152 + cm >> 2], q2[$l + 116 >> 2] = am + q2[156 + cm >> 2], q2[$l + 120 >> 2] = am + q2[160 + cm >> 2], q2[$l + 124 >> 2] = am + q2[164 + cm >> 2], q2[$l + 128 >> 2] = am + q2[168 + cm >> 2], q2[$l + 132 >> 2] = am + q2[172 + cm >> 2], q2[$l + 136 >> 2] = am + q2[176 + cm >> 2], q2[$l + 140 >> 2] = am + q2[180 + cm >> 2], q2[$l + 168 >> 2] = am + q2[184 + cm >> 2], q2[$l + 264 >> 2] = am + q2[188 + cm >> 2], q2[$l + 268 >> 2] = am + q2[192 + cm >> 2], q2[$l + 272 >> 2] = am + q2[196 + cm >> 2], q2[$l + 276 >> 2] = am + q2[200 + cm >> 2], q2[$l + 280 >> 2] = am + q2[204 + cm >> 2], q2[$l + 284 >> 2] = am + q2[208 + cm >> 2], q2[$l + 288 >> 2] = am + q2[212 + cm >> 2], q2[$l + 292 >> 2] = am + q2[216 + cm >> 2], q2[$l + 296 >> 2] = am + q2[220 + cm >> 2], q2[$l + 300 >> 2] = am + q2[224 + cm >> 2], q2[$l + 176 >> 2] = am + q2[228 + cm >> 2], q2[$l + 184 >> 2] = am + q2[232 + cm >> 2], q2[$l + 188 >> 2] = am + q2[236 + cm >> 2], q2[$l + 192 >> 2] = am + q2[240 + cm >> 2], q2[$l + 196 >> 2] = am + q2[244 + cm >> 2], q2[$l + 200 >> 2] = am + q2[248 + cm >> 2], q2[$l + 204 >> 2] = am + q2[252 + cm >> 2], q2[$l + 208 >> 2] = am + q2[256 + cm >> 2], q2[$l + 212 >> 2] = am + q2[260 + cm >> 2], q2[$l + 216 >> 2] = am + q2[264 + cm >> 2], q2[$l + 220 >> 2] = am + q2[268 + cm >> 2], q2[$l + 224 >> 2] = am + q2[272 + cm >> 2], q2[$l + 228 >> 2] = am + q2[276 + cm >> 2], q2[$l + 232 >> 2] = am + q2[280 + cm >> 2], q2[$l + 236 >> 2] = am + q2[284 + cm >> 2], q2[$l + 240 >> 2] = am + q2[288 + cm >> 2], q2[$l + 244 >> 2] = am + q2[292 + cm >> 2], q2[$l + 248 >> 2] = am + q2[296 + cm >> 2], q2[$l + 252 >> 2] = am + q2[300 + cm >> 2], q2[$l + 256 >> 2] = am + q2[304 + cm >> 2], q2[$l + 260 >> 2] = am + q2[308 + cm >> 2], Il = q2[a2 + 704 >> 2], q2[$l + 336 >> 2] = am + q2[312 + cm >> 2], q2[$l + 424 >> 2] = am + q2[316 + cm >> 2], q2[$l + 432 >> 2] = am + q2[320 + cm >> 2], q2[$l + 436 >> 2] = am + q2[324 + cm >> 2], q2[$l + 440 >> 2] = am + q2[328 + cm >> 2], Jl = am + q2[332 + cm >> 2] | 0, q2[$l + 444 >> 2] = Jl, !((0 | (dm = q2[Il + 16 >> 2])) < 1) && (bm = am + q2[336 + cm >> 2] | 0, q2[Jl >> 2] = bm, (Jl = 1) != (0 | dm))) {
                        for (Il = 0; ; ) if (bm = (15 + (q2[q2[a2 + 892 >> 2] + (Il << 2) >> 2] << 3) & -16) + bm | 0, q2[q2[$l + 444 >> 2] + (Jl << 2) >> 2] = bm, (0 | dm) == (0 | (Jl = (Il = Jl) + 1 | 0))) break;
                      }
                      if (q2[$l + 448 >> 2] = am + q2[340 + cm >> 2], q2[$l + 452 >> 2] = am + q2[344 + cm >> 2], q2[$l + 456 >> 2] = am + q2[348 + cm >> 2], q2[$l + 460 >> 2] = am + q2[352 + cm >> 2], q2[$l + 464 >> 2] = am + q2[356 + cm >> 2], q2[$l + 468 >> 2] = am + q2[360 + cm >> 2], q2[$l + 472 >> 2] = am + q2[364 + cm >> 2], q2[$l + 476 >> 2] = am + q2[368 + cm >> 2], q2[$l + 344 >> 2] = am + q2[372 + cm >> 2], q2[$l + 352 >> 2] = am + q2[376 + cm >> 2], q2[$l + 356 >> 2] = am + q2[380 + cm >> 2], q2[$l + 360 >> 2] = am + q2[384 + cm >> 2], q2[$l + 364 >> 2] = am + q2[388 + cm >> 2], q2[$l + 368 >> 2] = am + q2[392 + cm >> 2], q2[$l + 372 >> 2] = am + q2[396 + cm >> 2], q2[$l + 376 >> 2] = am + q2[400 + cm >> 2], q2[$l + 380 >> 2] = am + q2[404 + cm >> 2], q2[$l + 384 >> 2] = am + q2[408 + cm >> 2], q2[$l + 388 >> 2] = am + q2[412 + cm >> 2], q2[$l + 392 >> 2] = am + q2[416 + cm >> 2], q2[$l + 396 >> 2] = am + q2[420 + cm >> 2], q2[$l + 400 >> 2] = am + q2[424 + cm >> 2], q2[$l + 404 >> 2] = am + q2[428 + cm >> 2], q2[$l + 408 >> 2] = am + q2[432 + cm >> 2], q2[$l + 412 >> 2] = am + q2[436 + cm >> 2], q2[$l + 416 >> 2] = am + q2[440 + cm >> 2], q2[$l + 420 >> 2] = am + q2[444 + cm >> 2], Il = q2[448 + cm >> 2], Jl = q2[452 + cm >> 2], q2[$l + 552 >> 2] = am + q2[456 + cm >> 2], q2[$l + 548 >> 2] = Jl + am, q2[$l + 544 >> 2] = Il + am, q2[$l + 560 >> 2] = am + q2[460 + cm >> 2], Il = q2[a2 + 704 >> 2], gm = am + q2[464 + cm >> 2] | 0, q2[$l + 568 >> 2] = gm, 1 <= (0 | (fm = q2[Il + 48 >> 2]))) {
                        for (bm = am + q2[468 + cm >> 2] | 0, Il = am + q2[472 + cm >> 2] | 0, em = am + q2[476 + cm >> 2] | 0, hm = q2[a2 + 1072 >> 2], Jl = 0; ; ) if (dm = gm + w2(Jl, 36) | 0, q2[dm + 20 >> 2] = em, q2[dm + 16 >> 2] = Il, q2[dm >> 2] = bm, dm = q2[hm + (Jl << 2) >> 2], bm = (dm << 2) + bm | 0, em = (dm = 1 << dm << 2) + em | 0, Il = Il + dm | 0, (0 | fm) == (0 | (Jl = Jl + 1 | 0))) break;
                      }
                      if (Il = q2[a2 + 704 >> 2], dm = am + q2[516 + cm >> 2] | 0, q2[$l + 484 >> 2] = dm, 1 <= (0 | (Il = q2[Il + 72 >> 2]))) {
                        for (bm = am + q2[520 + cm >> 2] | 0, em = q2[a2 + 1212 >> 2], Jl = 0; ; ) if (q2[12 + (dm + w2(Jl, 28) | 0) >> 2] = bm, bm = (q2[em + (Jl << 2) >> 2] << 4) + bm | 0, (0 | Il) == (0 | (Jl = Jl + 1 | 0))) break;
                      }
                      q2[$l + 488 >> 2] = am + q2[524 + cm >> 2], q2[$l + 492 >> 2] = am + q2[528 + cm >> 2], q2[$l + 496 >> 2] = am + q2[532 + cm >> 2], q2[$l + 504 >> 2] = am + q2[536 + cm >> 2], q2[$l + 536 >> 2] = am + q2[540 + cm >> 2], q2[$l + 512 >> 2] = am + q2[544 + cm >> 2], q2[$l + 520 >> 2] = am + q2[548 + cm >> 2], q2[$l + 524 >> 2] = am + q2[552 + cm >> 2], q2[$l + 528 >> 2] = am + q2[556 + cm >> 2], q2[$l + 532 >> 2] = am + q2[560 + cm >> 2];
                      c: {
                        if (4 <= (fm = r2[a2 + 4 | 0]) >>> 0) {
                          if (q2[$l + 576 >> 2] = am + q2[480 + cm >> 2], q2[$l + 584 >> 2] = am + q2[484 + cm >> 2], Il = q2[a2 + 704 >> 2], Jl = q2[492 + cm >> 2], dm = am + q2[488 + cm >> 2] | 0, q2[$l + 592 >> 2] = dm, 1 <= (0 | (Il = q2[Il + 104 >> 2]))) {
                            for (bm = Jl + am | 0, em = q2[a2 + 1104 >> 2], Jl = 0; ; ) if (q2[40 + (dm + w2(Jl, 48) | 0) >> 2] = bm, bm = (q2[em + (Jl << 2) >> 2] << 2) + bm | 0, (0 | Il) == (0 | (Jl = Jl + 1 | 0))) break;
                          }
                          q2[$l + 608 >> 2] = am + q2[500 + cm >> 2], q2[$l + 624 >> 2] = am + q2[508 + cm >> 2];
                        } else {
                          if (Il = q2[572 + cm >> 2], Jl = q2[568 + cm >> 2], q2[$l + 636 >> 2] = am + q2[564 + cm >> 2], q2[$l + 640 >> 2] = Jl + am, q2[q2[a2 + 704 >> 2] + 20 >> 2] < 1) break c;
                          for (dm = Il + am | 0, gm = 0; ; ) {
                            e: {
                              if ((0 | (bm = q2[(Il = gm << 2) + q2[a2 + 952 >> 2] >> 2])) <= 0) Il = Il + q2[$l + 636 >> 2] | 0;
                              else {
                                for (Jl = q2[Il + q2[a2 + 948 >> 2] >> 2], em = bm + Jl | 0, hm = q2[a2 + 1060 >> 2], bm = 0; ; ) if (bm = q2[hm + (Jl << 2) >> 2] + bm | 0, !((0 | (Jl = Jl + 1 | 0)) < (0 | em))) break;
                                if (Il = Il + q2[$l + 636 >> 2] | 0, Jl = dm, bm) break e;
                              }
                              Jl = bm = 0;
                            }
                            if (q2[Il >> 2] = Jl, dm = (bm << 2) + dm | 0, !((0 | (gm = gm + 1 | 0)) < q2[q2[a2 + 704 >> 2] + 20 >> 2])) break;
                          }
                        }
                        fm >>> 0 < 5 || (q2[$l + 600 >> 2] = am + q2[496 + cm >> 2], q2[$l + 616 >> 2] = am + q2[504 + cm >> 2], q2[$l + 632 >> 2] = am + q2[512 + cm >> 2]);
                      }
                      q2[$l + 644 >> 2] = 1, q2[$l >> 2] = a2, q2[$l + 648 >> 2] = 1 & o[q2[a2 + 708 >> 2] + 20 | 0], am = q2[a2 + 704 >> 2], gm = q2[am + 20 >> 2], q2[$l + 540 >> 2] = gm;
                      g: if (!((0 | gm) < 1)) {
                        if (Il = gm + -1 | 0, hm = q2[a2 + 952 >> 2], im = q2[a2 + 940 >> 2], jm = q2[a2 + 932 >> 2], km = q2[a2 + 936 >> 2], lm = q2[a2 + 924 >> 2], mm = q2[a2 + 928 >> 2], om = q2[$l + 552 >> 2], qm = q2[$l + 544 >> 2], fm >>> 0 < 4) {
                          for (; ; ) if (Jl = qm + w2(Il, 52) | 0, q2[Jl >> 2] = 0, bm = (dm = Il << 2) + mm | 0, q2[Jl + 4 >> 2] = q2[bm >> 2], em = dm + lm | 0, q2[Jl + 8 >> 2] = q2[em >> 2], u2[Jl + 12 >> 2] = u2[em >> 2] - u2[bm >> 2], q2[Jl + 16 >> 2] = q2[dm + km >> 2], bm = dm + jm | 0, q2[Jl + 44 >> 2] = q2[bm >> 2], nm = Aa2(x2(q2[dm + im >> 2])), u2[Jl + 20 >> 2] = nm, u2[Jl + 24 >> 2] = nm * x2(1.5), pm = q2[dm + hm >> 2], q2[Jl + 32 >> 2] = pm, em = 0, em = pm ? q2[$l + 560 >> 2] + w2(q2[dm + q2[a2 + 948 >> 2] >> 2], 28) | 0 : em, q2[Jl + 48 >> 2] = 1, q2[Jl + 28 >> 2] = em, q2[dm + om >> 2] = q2[bm >> 2], Jl = 0 < (0 | Il), Il = Il + -1 | 0, !Jl) break g;
                        }
                        for (pm = q2[a2 + 960 >> 2], sm = q2[a2 + 944 >> 2]; ; ) if (Jl = qm + w2(Il, 52) | 0, bm = Il << 2, q2[Jl >> 2] = q2[bm + sm >> 2], dm = bm + mm | 0, q2[Jl + 4 >> 2] = q2[dm >> 2], em = bm + lm | 0, q2[Jl + 8 >> 2] = q2[em >> 2], u2[Jl + 12 >> 2] = u2[em >> 2] - u2[dm >> 2], q2[Jl + 16 >> 2] = q2[bm + km >> 2], rm = bm + jm | 0, q2[Jl + 44 >> 2] = q2[rm >> 2], nm = Aa2(x2(q2[bm + im >> 2])), u2[Jl + 20 >> 2] = nm, u2[Jl + 24 >> 2] = nm * x2(1.5), em = q2[bm + hm >> 2], q2[Jl + 32 >> 2] = em, q2[Jl + 28 >> 2] = em ? q2[$l + 560 >> 2] + w2(q2[bm + q2[a2 + 948 >> 2] >> 2], 28) | 0 : 0, dm = q2[bm + pm >> 2], dm = (q2[Jl + 40 >> 2] = dm) ? q2[$l + 584 >> 2] + w2(q2[bm + q2[a2 + 956 >> 2] >> 2], 28) | 0 : 0, q2[Jl + 48 >> 2] = 1, q2[Jl + 36 >> 2] = dm, q2[bm + om >> 2] = q2[rm >> 2], Jl = 0 < (0 | Il), Il = Il + -1 | 0, !Jl) break;
                      }
                      if (4 <= fm >>> 0 ? (q2[$l + 548 >> 2] = q2[a2 + 944 >> 2], dm = a2) : (ca2(q2[$l + 548 >> 2], 0, gm << 2), dm = q2[$l >> 2], am = q2[dm + 704 >> 2]), bm = q2[am + 52 >> 2], 1 <= (0 | (q2[$l + 556 >> 2] = bm))) {
                        for (Jl = q2[dm + 1056 >> 2], em = q2[dm + 1192 >> 2], gm = q2[dm + 1060 >> 2], fm = q2[$l + 560 >> 2]; ; ) if (Il = fm + w2(bm = bm + -1 | 0, 28) | 0, hm = bm << 2, q2[Il >> 2] = q2[hm + gm >> 2], hm = q2[Jl + hm >> 2], q2[Il + 24 >> 2] = 1, q2[Il + 16 >> 2] = 0, q2[Il + 20 >> 2] = 1, q2[Il + 8 >> 2] = 0, q2[Il + 12 >> 2] = 0, q2[Il + 4 >> 2] = em + (hm << 2), !(0 < (0 | bm))) break;
                      }
                      if (bm = q2[am + 48 >> 2], 1 <= (0 | (q2[$l + 564 >> 2] = bm))) {
                        for (; ; ) {
                          if (bm = bm + -1 | 0, Il = q2[$l + 568 >> 2] + w2(bm, 36) | 0, em = q2[(am = bm << 2) + q2[dm + 1072 >> 2] >> 2], 1 <= (0 | (q2[Il + 4 >> 2] = em))) {
                            for (Jl = 0; ; ) if (q2[q2[Il >> 2] + (Jl << 2) >> 2] = q2[$l + 560 >> 2] + w2(q2[q2[dm + 1064 >> 2] + (q2[am + q2[dm + 1068 >> 2] >> 2] + Jl << 2) >> 2], 28), (0 | em) == (0 | (Jl = Jl + 1 | 0))) break;
                          }
                          if (q2[Il + 24 >> 2] = 1, q2[Il + 28 >> 2] = 1, q2[Il + 8 >> 2] = 1 << em, !(0 < (0 | bm))) break;
                        }
                        dm = q2[$l >> 2], am = q2[dm + 704 >> 2];
                      }
                      if (Il = q2[am >> 2], (0 | (q2[$l + 4 >> 2] = Il)) < 1) Jl = 0;
                      else {
                        for (hm = q2[dm + 732 >> 2], im = q2[dm + 736 >> 2], jm = q2[dm + 740 >> 2], em = q2[dm + 720 >> 2], km = q2[$l + 52 >> 2], gm = q2[$l + 568 >> 2], lm = q2[$l + 8 >> 2], bm = Il; ; ) if (fm = lm + w2(bm = bm + -1 | 0, 12) | 0, Jl = bm << 2, q2[fm >> 2] = gm + w2(q2[Jl + em >> 2], 36), q2[fm + 4 >> 2] = q2[Jl + jm >> 2], q2[fm + 8 >> 2] = q2[Jl + im >> 2], u2[Jl + km >> 2] = q2[Jl + hm >> 2] ? x2(1) : x2(0), !(0 < (0 | bm))) break;
                        for (fm = q2[$l + 16 >> 2], Jl = 0; ; ) if (bm = q2[8 + (gm + w2(q2[(hm = (Il = Il + -1 | 0) << 2) + em >> 2], 36) | 0) >> 2], q2[fm + hm >> 2] = bm, Jl = Jl + bm | 0, !(0 < (0 | Il))) break;
                        Il = q2[$l + 4 >> 2];
                      }
                      if (q2[$l + 12 >> 2] = Il, q2[$l + 20 >> 2] = Jl, Il = q2[am + 4 >> 2], 1 <= (0 | (q2[$l + 304 >> 2] = Il))) {
                        for (; ; ) if (Il = Il + -1 | 0, Jl = q2[$l + 308 >> 2] + (Il << 5) | 0, bm = Il << 2, q2[Jl >> 2] = q2[$l + 568 >> 2] + w2(q2[bm + q2[dm + 752 >> 2] >> 2], 36), q2[Jl + 4 >> 2] = q2[bm + q2[dm + 764 >> 2] >> 2], q2[Jl + 8 >> 2] = q2[bm + q2[dm + 768 >> 2] >> 2], em = q2[bm + q2[dm + 772 >> 2] >> 2], q2[Jl + 12 >> 2] = em, am = q2[bm + q2[dm + 776 >> 2] >> 2], q2[Jl + 16 >> 2] = am, q2[Jl + 28 >> 2] = q2[bm + q2[dm + 760 >> 2] >> 2], em >>> 0 <= 1 ? em - 1 ? (q2[20 + (q2[$l + 60 >> 2] + w2(am, 24) | 0) >> 2] = Il, q2[Jl + 24 >> 2] = 1, q2[Jl + 20 >> 2] = 2) : (q2[8 + (q2[$l + 168 >> 2] + w2(am, 12) | 0) >> 2] = Il, q2[Jl + 24 >> 2] = 3, q2[Jl + 20 >> 2] = 4) : Y3(4, 1179, 0), !(0 < (0 | Il))) break;
                        dm = q2[$l >> 2], am = q2[dm + 704 >> 2];
                      }
                      bm = q2[am + 8 >> 2], q2[$l + 56 >> 2] = bm;
                      k: if (!((0 | bm) < 1)) {
                        if (Jl = bm + -1 | 0, gm = q2[dm + 796 >> 2], fm = q2[dm + 804 >> 2], hm = q2[dm + 800 >> 2], im = q2[dm + 780 >> 2], jm = q2[$l + 568 >> 2], km = q2[$l + 60 >> 2], r2[dm + 4 | 0] < 2) {
                          for (; ; ) if (Il = km + w2(Jl, 24) | 0, em = Jl << 2, q2[Il >> 2] = jm + w2(q2[em + im >> 2], 36), q2[Il + 4 >> 2] = q2[em + hm >> 2], q2[Il + 8 >> 2] = q2[em + fm >> 2], em = q2[em + gm >> 2], q2[Il + 12 >> 2] = 0, q2[Il + 16 >> 2] = em, Il = 0 < (0 | Jl), Jl = Jl + -1 | 0, !Il) break k;
                        }
                        for (lm = q2[dm + 808 >> 2]; ; ) if (Il = km + w2(Jl, 24) | 0, em = Jl << 2, q2[Il >> 2] = jm + w2(q2[em + im >> 2], 36), q2[Il + 4 >> 2] = q2[em + hm >> 2], q2[Il + 8 >> 2] = q2[em + fm >> 2], q2[Il + 16 >> 2] = q2[em + gm >> 2], q2[Il + 12 >> 2] = q2[em + lm >> 2], Il = 0 < (0 | Jl), Jl = Jl + -1 | 0, !Il) break;
                      }
                      if (Jl = q2[am + 12 >> 2], 1 <= (0 | (q2[$l + 164 >> 2] = Jl))) {
                        for (em = q2[dm + 828 >> 2], gm = q2[dm + 812 >> 2], fm = q2[$l + 568 >> 2], hm = q2[$l + 168 >> 2], Il = Jl; ; ) if (im = hm + w2(Il = Il + -1 | 0, 12) | 0, jm = Il << 2, q2[im >> 2] = fm + w2(q2[jm + gm >> 2], 36), q2[im + 4 >> 2] = q2[em + jm >> 2], !(0 < (0 | Il))) break;
                      }
                      if (((Il = 0) | bm) < 1) em = 0;
                      else {
                        for (gm = q2[$l + 68 >> 2], fm = q2[$l + 60 >> 2], em = 0; ; ) if (Jl = q2[q2[fm + w2(bm = bm + -1 | 0, 24) >> 2] + 8 >> 2], q2[gm + (bm << 2) >> 2] = Jl, em = Jl + em | 0, !(0 < (0 | bm))) break;
                        Jl = q2[$l + 164 >> 2], bm = q2[$l + 56 >> 2];
                      }
                      if (q2[$l + 64 >> 2] = bm, q2[$l + 72 >> 2] = em, bm = $l, 1 <= (0 | Jl)) {
                        for (gm = q2[$l + 176 >> 2], fm = q2[$l + 168 >> 2]; ; ) if (em = q2[q2[fm + w2(Jl = Jl + -1 | 0, 12) >> 2] + 8 >> 2], q2[gm + (Jl << 2) >> 2] = em, Il = Il + em | 0, !(0 < (0 | Jl))) break;
                        Jl = q2[$l + 164 >> 2];
                      }
                      if (q2[bm + 172 >> 2] = Jl, q2[$l + 180 >> 2] = Il, em = q2[am + 16 >> 2], 1 <= (0 | (q2[$l + 332 >> 2] = em))) {
                        for (hm = q2[dm + 872 >> 2], im = q2[dm + 892 >> 2], jm = q2[dm + 880 >> 2], km = q2[dm + 876 >> 2], gm = q2[dm + 852 >> 2], fm = q2[$l + 568 >> 2], lm = q2[$l + 336 >> 2], Il = em; ; ) if (Jl = lm + w2(Il = Il + -1 | 0, 20) | 0, bm = Il << 2, q2[Jl >> 2] = fm + w2(q2[bm + gm >> 2], 36), q2[Jl + 4 >> 2] = q2[bm + km >> 2], q2[Jl + 8 >> 2] = q2[bm + jm >> 2], q2[Jl + 16 >> 2] = q2[bm + im >> 2], q2[Jl + 12 >> 2] = q2[bm + hm >> 2], !(0 < (0 | Il))) break;
                        for (bm = q2[$l + 344 >> 2], Jl = 0; ; ) if (Il = q2[8 + (fm + w2(q2[(hm = (em = em + -1 | 0) << 2) + gm >> 2], 36) | 0) >> 2], q2[bm + hm >> 2] = Il, Jl = Il + Jl | 0, !(0 < (0 | em))) break;
                        if (q2[$l + 348 >> 2] = Jl, em = q2[$l + 332 >> 2], !((0 | (q2[$l + 340 >> 2] = em)) < 1)) {
                          for (Jl = em << 2, bm = q2[$l + 456 >> 2], gm = q2[$l + 452 >> 2]; ; ) if (q2[(fm = (Il = Jl + -4 | 0) << 2) + gm >> 2] = 1065353216, q2[(hm = (Jl <<= 2) + -4 | 0) + gm >> 2] = 1065353216, q2[(im = (Jl = Jl + -12 | 0) + gm | 0) >> 2] = 1065353216, q2[im + 4 >> 2] = 1065353216, q2[bm + fm >> 2] = 0, q2[bm + hm >> 2] = 1065353216, q2[(Jl = Jl + bm | 0) >> 2] = 0, q2[Jl + 4 >> 2] = 0, Jl = Il, !(0 < (0 | (em = em + -1 | 0)))) break;
                        }
                      } else q2[$l + 340 >> 2] = em, q2[$l + 348 >> 2] = 0;
                      if (em = q2[am + 72 >> 2], 1 <= (0 | (q2[$l + 480 >> 2] = em))) for (hm = q2[dm + 1208 >> 2], im = q2[dm + 1224 >> 2], jm = q2[dm + 1220 >> 2], km = q2[dm + 1216 >> 2], lm = q2[dm + 1212 >> 2], mm = q2[$l + 484 >> 2], bm = 0; ; ) {
                        if (Il = mm + w2(bm, 28) | 0, gm = q2[(Jl = bm << 2) + lm >> 2], q2[Il + 4 >> 2] = gm, q2[Il >> 2] = q2[Jl + km >> 2], fm = q2[Jl + jm >> 2], q2[Il + 16 >> 2] = fm, om = q2[Jl + im >> 2], q2[Il + 20 >> 2] = om, q2[Il + 8 >> 2] = 0, q2[Il + 24 >> 2] = 1 + (fm - om | 0), 1 <= (0 | gm)) {
                          for (om = q2[Jl + hm >> 2], qm = q2[Il + 12 >> 2], pm = q2[dm + 1236 >> 2], sm = q2[dm + 1228 >> 2], rm = q2[dm + 1232 >> 2], Jl = 0; ; ) if (fm = Jl + om << 2, q2[(Il = qm + (Jl << 4) | 0) + 4 >> 2] = q2[fm + rm >> 2], q2[Il >> 2] = q2[fm + sm >> 2], fm = q2[fm + pm >> 2], q2[Il + 12 >> 2] = 0, q2[Il + 8 >> 2] = fm, (0 | gm) == (0 | (Jl = Jl + 1 | 0))) break;
                        }
                        if ((0 | em) == (0 | (bm = bm + 1 | 0))) break;
                      }
                      if (Jl = q2[am + 80 >> 2], (0 | (q2[$l + 500 >> 2] = Jl)) < 1) bm = 0;
                      else {
                        for (fm = q2[dm + 1280 >> 2], hm = q2[dm + 1268 >> 2], im = q2[dm + 1276 >> 2], jm = q2[dm + 1272 >> 2], km = q2[dm + 1264 >> 2], lm = q2[dm + 1260 >> 2], em = q2[dm + 1248 >> 2], gm = q2[$l + 568 >> 2], mm = q2[$l + 504 >> 2]; ; ) if (Il = mm + w2(Jl = Jl + -1 | 0, 24) | 0, bm = Jl << 2, q2[Il >> 2] = gm + w2(q2[bm + em >> 2], 36), q2[Il + 4 >> 2] = q2[bm + lm >> 2], q2[Il + 8 >> 2] = q2[bm + km >> 2], q2[Il + 12 >> 2] = q2[bm + jm >> 2], bm = q2[bm + hm >> 2], q2[Il + 20 >> 2] = fm + (bm << 1), q2[Il + 16 >> 2] = im + (bm << 2), !(0 < (0 | Jl))) break;
                        if ((0 | (Jl = q2[$l + 500 >> 2])) < 1) bm = 0;
                        else {
                          for (fm = q2[$l + 512 >> 2], bm = 0; ; ) if (Il = q2[8 + (gm + w2(q2[(hm = (Jl = Jl + -1 | 0) << 2) + em >> 2], 36) | 0) >> 2], q2[fm + hm >> 2] = Il, bm = Il + bm | 0, !(0 < (0 | Jl))) break;
                          Jl = q2[$l + 500 >> 2];
                        }
                      }
                      q2[$l + 508 >> 2] = Jl, q2[$l + 516 >> 2] = bm;
                      o: if (4 <= r2[a2 + 4 | 0]) {
                        if (!((em = r2[dm + 4 | 0]) >>> 0 < 4)) {
                          if (Jl = q2[am + 120 >> 2], 1 <= (0 | (q2[$l + 572 >> 2] = Jl))) {
                            for (fm = q2[dm + 1172 >> 2], hm = q2[$l + 576 >> 2]; ; ) if (am = q2[(Il = (Jl = Jl + -1 | 0) << 2) + fm >> 2], em = (0 | am) < 0 ? am = gm = bm = 0 : (em = q2[Il + q2[dm + 1176 >> 2] >> 2] << 2, bm = em + q2[dm + 1188 >> 2] | 0, gm = q2[Il + q2[dm + 1180 >> 2] >> 2], am = q2[$l + 544 >> 2] + w2(am, 52) | 0, em + q2[dm + 1184 >> 2] | 0), Il = hm + w2(Jl, 20) | 0, q2[Il + 12 >> 2] = gm, q2[Il + 8 >> 2] = bm, q2[Il + 4 >> 2] = em, q2[Il >> 2] = am, !(0 < (0 | Jl))) break;
                            if (dm = q2[$l >> 2], (em = r2[dm + 4 | 0]) >>> 0 < 4) break o;
                          }
                          if (am = q2[dm + 704 >> 2], bm = q2[am + 100 >> 2], 1 <= (0 | (q2[$l + 580 >> 2] = bm))) {
                            for (gm = q2[dm + 1084 >> 2], fm = q2[dm + 1076 >> 2], hm = q2[dm + 1192 >> 2], im = q2[dm + 1080 >> 2], jm = q2[$l + 584 >> 2]; ; ) if (Il = jm + w2(bm = bm + -1 | 0, 28) | 0, Jl = bm << 2, q2[Il >> 2] = q2[Jl + im >> 2], q2[Il + 4 >> 2] = hm + (q2[Jl + fm >> 2] << 2), Jl = q2[Jl + gm >> 2], q2[Il + 20 >> 2] = 1, q2[Il + 24 >> 2] = 1, q2[Il + 12 >> 2] = 0, q2[Il + 16 >> 2] = 0, q2[Il + 8 >> 2] = Jl, !(0 < (0 | bm))) break;
                          }
                          if (bm = q2[am + 104 >> 2], 1 <= (0 | (q2[$l + 588 >> 2] = bm))) {
                            for (; ; ) {
                              if (bm = bm + -1 | 0, Il = q2[$l + 592 >> 2] + w2(bm, 48) | 0, em = bm << 2, q2[Il >> 2] = q2[$l + 584 >> 2] + w2(q2[em + q2[dm + 1088 >> 2] >> 2], 28), Jl = q2[em + q2[dm + 1092 >> 2] >> 2], q2[Il + 28 >> 2] = 1, q2[Il + 32 >> 2] = 1, q2[Il + 8 >> 2] = 0, q2[Il + 4 >> 2] = Jl, am = q2[em + q2[dm + 1104 >> 2] >> 2], 1 <= (0 | (q2[Il + 36 >> 2] = am))) {
                                for (Jl = 0; ; ) if (q2[q2[Il + 40 >> 2] + (Jl << 2) >> 2] = q2[$l + 576 >> 2] + w2(q2[q2[dm + 1168 >> 2] + (q2[em + q2[dm + 1100 >> 2] >> 2] + Jl << 2) >> 2], 20), (0 | am) == (0 | (Jl = Jl + 1 | 0))) break;
                              }
                              if (!(1 <= (0 | bm))) break;
                            }
                            dm = q2[$l >> 2], em = r2[dm + 4 | 0];
                          }
                          if (!(em >>> 0 < 4)) {
                            if (em = q2[a2 + 704 >> 2], Jl = q2[em + 108 >> 2], 1 <= (0 | (q2[$l + 604 >> 2] = Jl))) {
                              for (am = q2[a2 + 1124 >> 2], gm = q2[a2 + 1128 >> 2], fm = q2[a2 + 1120 >> 2], hm = q2[$l + 592 >> 2], im = q2[$l + 608 >> 2]; ; ) if (Il = im + w2(Jl = Jl + -1 | 0, 12) | 0, bm = Jl << 2, q2[Il >> 2] = q2[bm + fm >> 2], q2[Il + 4 >> 2] = q2[bm + gm >> 2], q2[Il + 8 >> 2] = hm + w2(q2[am + bm >> 2], 48), !(0 < (0 | Jl))) break;
                            }
                            if (Jl = q2[em + 112 >> 2], 1 <= (0 | (q2[$l + 620 >> 2] = Jl))) {
                              for (em = q2[a2 + 1148 >> 2], am = q2[a2 + 1152 >> 2], gm = q2[a2 + 1144 >> 2], fm = q2[$l + 592 >> 2], hm = q2[$l + 624 >> 2]; ; ) if (Il = hm + w2(Jl = Jl + -1 | 0, 12) | 0, bm = Jl << 2, q2[Il >> 2] = q2[bm + gm >> 2], q2[Il + 4 >> 2] = q2[am + bm >> 2], q2[Il + 8 >> 2] = fm + w2(q2[bm + em >> 2], 48), !(0 < (0 | Jl))) break;
                            }
                            if (bm = q2[dm + 1192 >> 2], Il = q2[q2[dm + 704 >> 2] + 20 >> 2], q2[$l + 640 >> 2] = q2[dm + 972 >> 2], em = q2[dm + 964 >> 2], q2[$l + 636 >> 2] = em, !((0 | Il) < (Jl = 1)) && (q2[em >> 2] = bm + (q2[q2[dm + 968 >> 2] >> 2] << 2), 1 != (0 | Il))) {
                              for (; ; ) if (q2[(em = Jl << 2) + q2[$l + 636 >> 2] >> 2] = bm + (q2[em + q2[dm + 968 >> 2] >> 2] << 2), (0 | Il) == (0 | (Jl = Jl + 1 | 0))) break;
                            }
                          }
                        }
                      } else if (!(q2[am + 20 >> 2] < 1)) for (am = 0; ; ) {
                        if (bm = q2[(gm = am << 2) + q2[$l + 636 >> 2] >> 2], 1 <= ((Il = 0) | (Jl = q2[gm + q2[dm + 952 >> 2] >> 2]))) for (fm = q2[gm + q2[dm + 948 >> 2] >> 2], im = Jl + fm | 0, jm = q2[dm + 1060 >> 2], km = q2[dm + 1056 >> 2]; ; ) {
                          if (1 <= (0 | (hm = q2[(Jl = fm << 2) + jm >> 2]))) for (em = q2[Jl + km >> 2], lm = hm + em | 0, mm = q2[dm + 1192 >> 2]; ; ) {
                            hm = bm + (Il << 2) | 0, nm = u2[mm + (em << 2) >> 2], Jl = bm;
                            q: {
                              if (0 < (0 | Il)) for (; ; ) {
                                if (u2[Jl >> 2] == nm) break q;
                                if (!((Jl = Jl + 4 | 0) >>> 0 < hm >>> 0)) break;
                              }
                              u2[hm >> 2] = nm, Il = Il + 1 | 0;
                            }
                            if (!((0 | (em = em + 1 | 0)) < (0 | lm))) break;
                          }
                          if (!((0 | (fm = fm + 1 | 0)) < (0 | im))) break;
                        }
                        if (!function(a3, Sm) {
                          var un = 0, xn = 0, yn = 0, Jn = 0, Kn = 0;
                          q2[8 + (L2 = un = L2 - 208 | 0) >> 2] = 1, q2[12 + un >> 2] = 0;
                          a: if (Kn = Sm << 2) {
                            for (q2[16 + un >> 2] = 4, q2[20 + un >> 2] = 4, Jn = Sm = 4, xn = 2; ; ) if (Sm = (Jn + 4 | 0) + (yn = Sm) | 0, q2[(16 + un | 0) + (xn << 2) >> 2] = Sm, xn = xn + 1 | 0, Jn = yn, !(Sm >>> 0 < Kn >>> 0)) break;
                            if ((yn = (a3 + Kn | 0) - 4 | 0) >>> 0 <= a3 >>> 0) Sm = xn = 1;
                            else for (Sm = xn = 1; ; ) if (Sm = 3 == (3 & xn) ? (ta2(a3, Sm, 16 + un | 0), ma2(8 + un | 0, 2), Sm + 2 | 0) : (t3[(16 + un | 0) + ((Jn = Sm + -1 | 0) << 2) >> 2] >= yn - a3 >>> 0 ? la2(a3, 8 + un | 0, Sm, 0, 16 + un | 0) : ta2(a3, Sm, 16 + un | 0), 1 == (0 | Sm) ? (ka2(8 + un | 0, 1), 0) : (ka2(8 + un | 0, Jn), 1)), xn = 1 | q2[8 + un >> 2], q2[8 + un >> 2] = xn, !((a3 = a3 + 4 | 0) >>> 0 < yn >>> 0)) break;
                            for (la2(a3, 8 + un | 0, Sm, 0, 16 + un | 0); ; ) {
                              e: {
                                f: {
                                  g: {
                                    if (!(1 != (0 | Sm) | 1 != (0 | xn))) {
                                      if (q2[12 + un >> 2]) break g;
                                      break a;
                                    }
                                    if (1 < (0 | Sm)) break f;
                                  }
                                  yn = Oa(8 + un | 0), ma2(8 + un | 0, yn), xn = q2[8 + un >> 2], Sm = Sm + yn | 0;
                                  break e;
                                }
                                ka2(8 + un | 0, 2), q2[8 + un >> 2] = 7 ^ q2[8 + un >> 2], ma2(8 + un | 0, 1), la2((Jn = a3 + -4 | 0) - q2[(16 + un | 0) + ((yn = Sm + -2 | 0) << 2) >> 2] | 0, 8 + un | 0, Sm + -1 | 0, 1, 16 + un | 0), ka2(8 + un | 0, 1), xn = 1 | q2[8 + un >> 2], q2[8 + un >> 2] = xn, la2(Jn, 8 + un | 0, yn, 1, 16 + un | 0), Sm = yn;
                              }
                              a3 = a3 + -4 | 0;
                            }
                          }
                          L2 = 208 + un | 0;
                        }(bm, Il), q2[gm + q2[$l + 640 >> 2] >> 2] = Il, !((0 | (am = am + 1 | 0)) < q2[q2[dm + 704 >> 2] + 20 >> 2])) break;
                      }
                      if (!(r2[a2 + 4 | 0] < 5 | r2[q2[$l >> 2] + 4 | 0] < 4)) {
                        if (Il = q2[a2 + 704 >> 2], Jl = q2[Il + 128 >> 2], 1 <= (0 | (q2[$l + 596 >> 2] = Jl))) {
                          for (em = q2[a2 + 1112 >> 2], am = q2[a2 + 1116 >> 2], gm = q2[a2 + 1108 >> 2], fm = q2[$l + 592 >> 2], hm = q2[$l + 600 >> 2]; ; ) if (dm = hm + w2(Jl = Jl + -1 | 0, 12) | 0, bm = Jl << 2, q2[dm >> 2] = q2[bm + gm >> 2], q2[dm + 4 >> 2] = q2[am + bm >> 2], q2[dm + 8 >> 2] = fm + w2(q2[bm + em >> 2], 48), !(0 < (0 | Jl))) break;
                        }
                        if (Jl = q2[Il + 132 >> 2], 1 <= (0 | (q2[$l + 612 >> 2] = Jl))) {
                          for (em = q2[a2 + 1136 >> 2], am = q2[a2 + 1140 >> 2], gm = q2[a2 + 1132 >> 2], fm = q2[$l + 592 >> 2], hm = q2[$l + 616 >> 2]; ; ) if (dm = hm + w2(Jl = Jl + -1 | 0, 12) | 0, bm = Jl << 2, q2[dm >> 2] = q2[bm + gm >> 2], q2[dm + 4 >> 2] = q2[am + bm >> 2], q2[dm + 8 >> 2] = fm + w2(q2[bm + em >> 2], 48), !(0 < (0 | Jl))) break;
                        }
                        if (Jl = q2[Il + 136 >> 2], !((0 | (q2[$l + 628 >> 2] = Jl)) < 1)) {
                          for (dm = q2[a2 + 1160 >> 2], bm = q2[a2 + 1164 >> 2], em = q2[a2 + 1156 >> 2], am = q2[$l + 592 >> 2], gm = q2[$l + 632 >> 2]; ; ) if (a2 = gm + w2(Jl = Jl + -1 | 0, 12) | 0, Il = Jl << 2, q2[a2 >> 2] = q2[Il + em >> 2], q2[a2 + 4 >> 2] = q2[Il + bm >> 2], q2[a2 + 8 >> 2] = am + w2(q2[Il + dm >> 2], 48), !(0 < (0 | Jl))) break;
                        }
                      }
                      ua($l);
                    }
                    return L2 = 576 + cm | 0, $l;
                  }(a, Wa, Xa)) break a;
                  q2[36 + Ya >> 2] = 2209, q2[32 + Ya >> 2] = 2361, Y3(4, 1294, 32 + Ya | 0);
                }
                else q2[20 + Ya >> 2] = 1444, q2[16 + Ya >> 2] = 2361, Y3(4, 1294, 16 + Ya | 0);
                else q2[4 + Ya >> 2] = 2132, q2[Ya >> 2] = 2361, Y3(4, 1294, Ya);
                Wa = 0;
              }
              return L2 = Ya + 64 | 0, 0 | Wa;
            }
            function xa2(a) {
              var Wa;
              return L2 = Wa = L2 - 16 | 0, a = (a |= 0) ? function(a2) {
                var Il = 0;
                return ca2(16 + (L2 = Il = L2 - 576 | 0) | 0, 0, 560), Fa(a2, 16 + Il | 0, 12 + Il | 0), L2 = 576 + Il | 0, q2[12 + Il >> 2];
              }(a) : (q2[4 + Wa >> 2] = 2132, q2[Wa >> 2] = 2343, Y3(4, 1294, Wa), 0), L2 = 16 + Wa | 0, 0 | a;
            }
            function ya2(a) {
              var Xa = r2[a + 4 | 0];
              X3(q2[a + 704 >> 2], 4, 64), da2(q2[a + 708 >> 2], 4), da2(q2[a + 708 >> 2] + 4 | 0, 4), da2(q2[a + 708 >> 2] + 8 | 0, 4), da2(q2[a + 708 >> 2] + 12 | 0, 4), da2(q2[a + 708 >> 2] + 16 | 0, 4), da2(q2[a + 708 >> 2] + 20 | 0, 1), X3(q2[a + 720 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 724 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 728 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 732 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 736 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 740 >> 2], 4, q2[q2[a + 704 >> 2] >> 2]), X3(q2[a + 752 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 756 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 760 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 764 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 768 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 772 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 776 >> 2], 4, q2[q2[a + 704 >> 2] + 4 >> 2]), X3(q2[a + 780 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 784 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 788 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 796 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 800 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 804 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 812 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 816 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 820 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 828 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 852 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 856 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 860 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 868 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 872 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 876 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 880 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 884 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 888 >> 2], 1, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 892 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 896 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 900 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 904 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 908 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 912 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 924 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 928 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 932 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 936 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 940 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 948 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 952 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 976 >> 2], 4, q2[q2[a + 704 >> 2] + 24 >> 2]), X3(q2[a + 980 >> 2], 4, q2[q2[a + 704 >> 2] + 28 >> 2]), X3(q2[a + 984 >> 2], 4, q2[q2[a + 704 >> 2] + 28 >> 2]), X3(q2[a + 996 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1e3 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1004 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1008 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1012 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1016 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1020 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1032 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1036 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1040 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1052 >> 2], 4, q2[q2[a + 704 >> 2] + 40 >> 2]), X3(q2[a + 1064 >> 2], 4, q2[q2[a + 704 >> 2] + 44 >> 2]), X3(q2[a + 1068 >> 2], 4, q2[q2[a + 704 >> 2] + 48 >> 2]), X3(q2[a + 1072 >> 2], 4, q2[q2[a + 704 >> 2] + 48 >> 2]), X3(q2[a + 1056 >> 2], 4, q2[q2[a + 704 >> 2] + 52 >> 2]), X3(q2[a + 1060 >> 2], 4, q2[q2[a + 704 >> 2] + 52 >> 2]), X3(q2[a + 1192 >> 2], 4, q2[q2[a + 704 >> 2] + 56 >> 2]), X3(q2[a + 1196 >> 2], 4, q2[q2[a + 704 >> 2] + 60 >> 2]), X3(q2[a + 1200 >> 2], 2, q2[q2[a + 704 >> 2] + 64 >> 2]), X3(q2[a + 1204 >> 2], 4, q2[q2[a + 704 >> 2] + 68 >> 2]), X3(q2[a + 1208 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1212 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1216 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1220 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1224 >> 2], 4, q2[q2[a + 704 >> 2] + 72 >> 2]), X3(q2[a + 1228 >> 2], 4, q2[q2[a + 704 >> 2] + 76 >> 2]), X3(q2[a + 1232 >> 2], 4, q2[q2[a + 704 >> 2] + 76 >> 2]), X3(q2[a + 1236 >> 2], 4, q2[q2[a + 704 >> 2] + 76 >> 2]), X3(q2[a + 1248 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1252 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1256 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1260 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1264 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1268 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1272 >> 2], 4, q2[q2[a + 704 >> 2] + 80 >> 2]), X3(q2[a + 1276 >> 2], 4, q2[q2[a + 704 >> 2] + 84 >> 2]), X3(q2[a + 1280 >> 2], 2, q2[q2[a + 704 >> 2] + 84 >> 2]), X3(q2[a + 1284 >> 2], 4, q2[q2[a + 704 >> 2] + 88 >> 2]), Xa >>> 0 < 2 || (X3(q2[a + 808 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), Xa >>> 0 < 4) || (X3(q2[a + 968 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 972 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 792 >> 2], 4, q2[q2[a + 704 >> 2] + 8 >> 2]), X3(q2[a + 824 >> 2], 4, q2[q2[a + 704 >> 2] + 12 >> 2]), X3(q2[a + 864 >> 2], 4, q2[q2[a + 704 >> 2] + 16 >> 2]), X3(q2[a + 1288 >> 2], 4, q2[q2[a + 704 >> 2] + 92 >> 2]), X3(q2[a + 1292 >> 2], 4, q2[q2[a + 704 >> 2] + 92 >> 2]), X3(q2[a + 1296 >> 2], 4, q2[q2[a + 704 >> 2] + 92 >> 2]), X3(q2[a + 1300 >> 2], 4, q2[q2[a + 704 >> 2] + 96 >> 2]), X3(q2[a + 1304 >> 2], 4, q2[q2[a + 704 >> 2] + 96 >> 2]), X3(q2[a + 1308 >> 2], 4, q2[q2[a + 704 >> 2] + 96 >> 2]), X3(q2[a + 944 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 956 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 960 >> 2], 4, q2[q2[a + 704 >> 2] + 20 >> 2]), X3(q2[a + 1076 >> 2], 4, q2[q2[a + 704 >> 2] + 100 >> 2]), X3(q2[a + 1080 >> 2], 4, q2[q2[a + 704 >> 2] + 100 >> 2]), X3(q2[a + 1084 >> 2], 4, q2[q2[a + 704 >> 2] + 100 >> 2]), X3(q2[a + 1088 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1092 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1096 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1100 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1104 >> 2], 4, q2[q2[a + 704 >> 2] + 104 >> 2]), X3(q2[a + 1120 >> 2], 4, q2[q2[a + 704 >> 2] + 108 >> 2]), X3(q2[a + 1124 >> 2], 4, q2[q2[a + 704 >> 2] + 108 >> 2]), X3(q2[a + 1128 >> 2], 4, q2[q2[a + 704 >> 2] + 108 >> 2]), X3(q2[a + 1144 >> 2], 4, q2[q2[a + 704 >> 2] + 112 >> 2]), X3(q2[a + 1148 >> 2], 4, q2[q2[a + 704 >> 2] + 112 >> 2]), X3(q2[a + 1152 >> 2], 4, q2[q2[a + 704 >> 2] + 112 >> 2]), X3(q2[a + 1168 >> 2], 4, q2[q2[a + 704 >> 2] + 116 >> 2]), X3(q2[a + 1172 >> 2], 4, q2[q2[a + 704 >> 2] + 120 >> 2]), X3(q2[a + 1176 >> 2], 4, q2[q2[a + 704 >> 2] + 120 >> 2]), X3(q2[a + 1180 >> 2], 4, q2[q2[a + 704 >> 2] + 120 >> 2]), X3(q2[a + 1184 >> 2], 4, q2[q2[a + 704 >> 2] + 124 >> 2]), X3(q2[a + 1188 >> 2], 4, q2[q2[a + 704 >> 2] + 124 >> 2]), 4 != (0 | Xa) && (X3(q2[a + 988 >> 2], 4, q2[q2[a + 704 >> 2] + 28 >> 2]), X3(q2[a + 992 >> 2], 4, q2[q2[a + 704 >> 2] + 28 >> 2]), X3(q2[a + 1024 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1028 >> 2], 4, q2[q2[a + 704 >> 2] + 32 >> 2]), X3(q2[a + 1044 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1048 >> 2], 4, q2[q2[a + 704 >> 2] + 36 >> 2]), X3(q2[a + 1108 >> 2], 4, q2[q2[a + 704 >> 2] + 128 >> 2]), X3(q2[a + 1112 >> 2], 4, q2[q2[a + 704 >> 2] + 128 >> 2]), X3(q2[a + 1116 >> 2], 4, q2[q2[a + 704 >> 2] + 128 >> 2]), X3(q2[a + 1132 >> 2], 4, q2[q2[a + 704 >> 2] + 132 >> 2]), X3(q2[a + 1136 >> 2], 4, q2[q2[a + 704 >> 2] + 132 >> 2]), X3(q2[a + 1140 >> 2], 4, q2[q2[a + 704 >> 2] + 132 >> 2]), X3(q2[a + 1156 >> 2], 4, q2[q2[a + 704 >> 2] + 136 >> 2]), X3(q2[a + 1160 >> 2], 4, q2[q2[a + 704 >> 2] + 136 >> 2]), X3(q2[a + 1164 >> 2], 4, q2[q2[a + 704 >> 2] + 136 >> 2])));
            }
            function za(a, Za) {
              var _a = 0, lb = 0, mb = 0, ob = 0, pb = 0, rb = 0, nb = a + Za | 0;
              a: {
                b: if (!(1 & (_a = q2[a + 4 >> 2]))) {
                  if (!(3 & _a)) break a;
                  if (Za = (_a = q2[a >> 2]) + Za | 0, (0 | (a = a - _a | 0)) != q2[2092]) if (_a >>> 0 <= 255) mb = _a >>> 3, _a = q2[a + 8 >> 2], (0 | (lb = q2[a + 12 >> 2])) == (0 | _a) ? (rb = q2[2087] & dd(mb), q2[8348 >> 2] = rb) : (q2[_a + 12 >> 2] = lb, q2[lb + 8 >> 2] = _a);
                  else {
                    if (pb = q2[a + 24 >> 2], (0 | (_a = q2[a + 12 >> 2])) != (0 | a)) lb = q2[a + 8 >> 2], q2[lb + 12 >> 2] = _a, q2[_a + 8 >> 2] = lb;
                    else if ((mb = q2[(lb = a + 20 | 0) >> 2]) || (mb = q2[(lb = a + 16 | 0) >> 2])) {
                      for (; ; ) if (ob = lb, !((mb = q2[(lb = (_a = mb) + 20 | 0) >> 2]) || (lb = _a + 16 | 0, mb = q2[_a + 16 >> 2]))) break;
                      q2[ob >> 2] = 0;
                    } else _a = 0;
                    if (pb) {
                      lb = q2[a + 28 >> 2];
                      e: {
                        if (q2[(mb = 8652 + (lb << 2) | 0) >> 2] == (0 | a)) {
                          if (q2[mb >> 2] = _a) break e;
                          rb = q2[2088] & dd(lb), q2[8352 >> 2] = rb;
                          break b;
                        }
                        if (!(q2[pb + (q2[pb + 16 >> 2] == (0 | a) ? 16 : 20) >> 2] = _a)) break b;
                      }
                      q2[_a + 24 >> 2] = pb, (lb = q2[a + 16 >> 2]) && (q2[_a + 16 >> 2] = lb, q2[lb + 24 >> 2] = _a), (lb = q2[a + 20 >> 2]) && (q2[_a + 20 >> 2] = lb, q2[lb + 24 >> 2] = _a);
                    }
                  }
                  else if (3 == (3 & (_a = q2[4 + nb >> 2]))) return q2[2089] = Za, q2[4 + nb >> 2] = -2 & _a, q2[a + 4 >> 2] = 1 | Za, void (q2[nb >> 2] = Za);
                }
                f: {
                  if (!(2 & (_a = q2[4 + nb >> 2]))) {
                    if (q2[2093] == (0 | nb)) {
                      if (q2[2093] = a, Za = q2[2090] + Za | 0, q2[2090] = Za, q2[a + 4 >> 2] = 1 | Za, q2[2092] != (0 | a)) break a;
                      return q2[2089] = 0, void (q2[2092] = 0);
                    }
                    if (q2[2092] == (0 | nb)) return q2[2092] = a, Za = q2[2089] + Za | 0, q2[2089] = Za, q2[a + 4 >> 2] = 1 | Za, void (q2[a + Za >> 2] = Za);
                    Za = (-8 & _a) + Za | 0;
                    g: if (_a >>> 0 <= 255) mb = _a >>> 3, _a = q2[8 + nb >> 2], (0 | (lb = q2[12 + nb >> 2])) == (0 | _a) ? (rb = q2[2087] & dd(mb), q2[8348 >> 2] = rb) : (q2[_a + 12 >> 2] = lb, q2[lb + 8 >> 2] = _a);
                    else {
                      if (pb = q2[24 + nb >> 2], (0 | nb) != (0 | (_a = q2[12 + nb >> 2]))) lb = q2[8 + nb >> 2], q2[lb + 12 >> 2] = _a, q2[_a + 8 >> 2] = lb;
                      else if ((mb = q2[(lb = 20 + nb | 0) >> 2]) || (mb = q2[(lb = 16 + nb | 0) >> 2])) {
                        for (; ; ) if (ob = lb, !((mb = q2[(lb = (_a = mb) + 20 | 0) >> 2]) || (lb = _a + 16 | 0, mb = q2[_a + 16 >> 2]))) break;
                        q2[ob >> 2] = 0;
                      } else _a = 0;
                      if (pb) {
                        lb = q2[28 + nb >> 2];
                        j: {
                          if (q2[(mb = 8652 + (lb << 2) | 0) >> 2] == (0 | nb)) {
                            if (q2[mb >> 2] = _a) break j;
                            rb = q2[2088] & dd(lb), q2[8352 >> 2] = rb;
                            break g;
                          }
                          if (!(q2[pb + (q2[pb + 16 >> 2] == (0 | nb) ? 16 : 20) >> 2] = _a)) break g;
                        }
                        q2[_a + 24 >> 2] = pb, (lb = q2[16 + nb >> 2]) && (q2[_a + 16 >> 2] = lb, q2[lb + 24 >> 2] = _a), (lb = q2[20 + nb >> 2]) && (q2[_a + 20 >> 2] = lb, q2[lb + 24 >> 2] = _a);
                      }
                    }
                    if (q2[a + 4 >> 2] = 1 | Za, q2[a + Za >> 2] = Za, q2[2092] != (0 | a)) break f;
                    return void (q2[2089] = Za);
                  }
                  q2[4 + nb >> 2] = -2 & _a, q2[a + 4 >> 2] = 1 | Za, q2[a + Za >> 2] = Za;
                }
                if (Za >>> 0 <= 255) return Za = 8388 + ((_a = Za >>> 3) << 3) | 0, _a = (lb = q2[2087]) & (_a = 1 << _a) ? q2[Za + 8 >> 2] : (q2[2087] = _a | lb, Za), q2[Za + 8 >> 2] = a, q2[_a + 12 >> 2] = a, q2[a + 12 >> 2] = Za, void (q2[a + 8 >> 2] = _a);
                q2[a + 16 >> 2] = 0, _a = q2[a + 20 >> 2] = 0, (mb = Za >>> 8) && (_a = 31, 16777215 < Za >>> 0 || (_a = 28 + ((_a = ((nb = (mb <<= ob = mb + 1048320 >>> 16 & 8) << (_a = mb + 520192 >>> 16 & 4)) << (mb = 245760 + nb >>> 16 & 2) >>> 15) - (mb | _a | ob) | 0) << 1 | Za >>> _a + 21 & 1) | 0)), mb = 8652 + ((q2[(lb = a) + 28 >> 2] = _a) << 2) | 0;
                m: {
                  if ((lb = q2[2088]) & (ob = 1 << _a)) {
                    for (lb = Za << (31 == (0 | _a) ? 0 : 25 - (_a >>> 1) | 0), _a = q2[mb >> 2]; ; ) {
                      if ((-8 & q2[(mb = _a) + 4 >> 2]) == (0 | Za)) break m;
                      if (_a = lb >>> 29, lb <<= 1, !(_a = q2[(ob = mb + (4 & _a) | 0) + 16 >> 2])) break;
                    }
                    q2[ob + 16 >> 2] = a;
                  } else q2[2088] = lb | ob, q2[mb >> 2] = a;
                  return q2[a + 24 >> 2] = mb, q2[a + 12 >> 2] = a, void (q2[a + 8 >> 2] = a);
                }
                Za = q2[mb + 8 >> 2], q2[Za + 12 >> 2] = a, q2[mb + 8 >> 2] = a, q2[a + 24 >> 2] = 0, q2[a + 12 >> 2] = mb, q2[a + 8 >> 2] = Za;
              }
            }
            function Aa2(a) {
              var vb, xb, yb, Ab, Bb, Cb, Za = x2(0), sb = x2(0), tb = 0, ub = 0, wb = (x2(0), x2(0)), zb = (x2(0), x2(0), 0);
              x2(0), x2(0);
              a: {
                b: {
                  if (j(a), ub = 2147483647 & (tb = b2[0])) {
                    if (!(ub >>> 0 < 2139095041)) return x2(x2(0.10000000149011612) + a);
                    if (1065353216 == (0 | ub)) return x2(-1 < (0 | tb) ? 0.10000000149011612 : 10);
                    if (2139095040 == (0 | ub)) return x2(-1 < (0 | tb) ? 0 : -a);
                    if (1073741824 == (0 | tb)) return x2(0.010000000707805157);
                    if (1056964608 == (0 | tb)) return x2(0.3162277638912201);
                    if (1291845633 <= ub >>> 0) return x2((0 | tb) < 0 ? H2 : 0);
                    if (vb = u2[1701], wb = x2(x2(1.600000023841858) - vb), xb = x2(x2(1) / x2(vb + x2(1.600000023841858))), f(0, -4096 & (j(sb = x2(wb * xb)), b2[0])), Za = k(), yb = x2(Za * Za), Bb = u2[1705], vb = x2(xb * x2(x2(wb - x2((Ab = Za) * x2(3.099609375))) - x2(Za * x2(x2(1.600000023841858) - x2(x2(3.099609375) - vb))))), xb = x2(x2(sb + Za) * vb), Za = x2(sb * sb), wb = x2(xb + x2(x2(Za * Za) * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(0.20697501301765442)) + x2(0.23066075146198273))) + x2(0.2727281153202057))) + x2(0.3333333432674408))) + x2(0.4285714328289032))) + x2(0.6000000238418579)))), f(0, -4096 & (j(x2(x2(yb + x2(3)) + wb)), b2[0])), Za = k(), xb = x2(Ab * Za), sb = x2(x2(vb * Za) + x2(sb * x2(wb - x2(x2(Za + x2(-3)) - yb)))), f(0, -4096 & (j(x2(xb + sb)), b2[0])), Za = k(), vb = x2(Za * x2(0.9619140625)), yb = x2(u2[1703] + x2(x2(x2(sb - x2(Za - xb)) * x2(0.9617967009544373)) + x2(Za * x2(-11736857413779944e-20)))), f(0, -4096 & (j(x2(x2(Bb + x2(vb + yb)) + x2(-4))), b2[0])), sb = k(), f(0, -4096 & tb), wb = k(), Za = x2(sb * wb), a = x2(x2(x2(yb - x2(x2(x2(sb - x2(-4)) - Bb) - vb)) * a) + x2(x2(a - wb) * sb)), j(sb = x2(Za + a)), 1124073473 <= (0 | (tb = b2[0]))) break b;
                    d: {
                      if ((ub = 1124073472) == (0 | tb)) {
                        if (x2(a + x2(4299566569443414e-23)) > x2(sb - Za)) break b;
                      } else {
                        if (ub = 2147483647 & tb, !(a <= x2(sb - Za) ^ 1 | -1021968384 != (0 | tb)) | 1125515265 <= ub >>> 0) break a;
                        if (ub >>> 0 < 1056964609) break d;
                      }
                      zb = (8388607 & (ub = (8388608 >>> (ub >>> 23) - 126) + tb | 0) | 8388608) >>> 150 - (Cb = ub >>> 23 & 255), zb = (0 | tb) < 0 ? 0 - zb | 0 : zb, Za = x2(Za - (f(0, ub & -8388608 >> Cb - 127), k())), j(x2(a + Za)), tb = b2[0];
                    }
                    f(0, -32768 & tb), sb = k(), vb = x2(sb * x2(0.693145751953125)), sb = x2(x2(sb * x2(14286065379565116e-22)) + x2(x2(a - x2(sb - Za)) * x2(0.6931471824645996))), a = x2(vb + sb), Za = x2(a * a), Za = x2(a - x2(Za * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(x2(Za * x2(4138136944220605e-23)) + x2(-16533901998627698e-22))) + x2(661375597701408e-19))) + x2(-0.0027777778450399637))) + x2(0.1666666716337204)))), Ab = x2(x2(a * Za) / x2(Za + x2(-2))), Za = x2(sb - x2(a - vb)), a = (0 | (tb = 0 | (j(a = x2(x2(a - x2(Ab - x2(Za + x2(a * Za)))) + x2(1))), b2[0] + (zb << 23)))) <= 8388607 ? function(a2, Vk) {
                      var zl = 0;
                      128 <= (0 | Vk) ? (a2 = x2(a2 * x2(17014118346046923e22)), Vk = (0 | (zl = Vk + -127 | 0)) < 128 ? zl : (a2 = x2(a2 * x2(17014118346046923e22)), ((0 | Vk) < 381 ? Vk : 381) + -254 | 0)) : -127 < (0 | Vk) || (a2 = x2(a2 * x2(11754943508222875e-54)), Vk = -127 < (0 | (zl = Vk + 126 | 0)) ? zl : (a2 = x2(a2 * x2(11754943508222875e-54)), (-378 < (0 | Vk) ? Vk : -378) + 252 | 0));
                      return x2(a2 * (f(0, 1065353216 + (Vk << 23) | 0), k()));
                    }(a, zb) : (f(0, tb), k()), a = x2(x2(1) * a);
                  } else a = x2(1);
                  return a;
                }
                return x2(H2);
              }
              return x2(0);
            }
            function Ba2(a, Db) {
              var Jb, Eb = 0, Fb = 0, Gb = 0, Hb = 0, Ib = x2(0);
              if (j(Db), !((Gb = 2147483647 & (Eb = b2[0])) >>> 0 <= 2139095040 && (j(a), (Fb = 2147483647 & (Hb = b2[0])) >>> 0 < 2139095041))) return x2(a + Db);
              if (1065353216 == (0 | Eb)) return Ca2(a);
              Eb = (Jb = Eb >>> 30 & 2) | Hb >>> 31;
              b: {
                c: {
                  d: {
                    e: {
                      if (!Fb) {
                        f: switch (Eb - 2 | 0) {
                          case 0:
                            break e;
                          case 1:
                            break f;
                          default:
                            break d;
                        }
                        return x2(-3.1415927410125732);
                      }
                      if (2139095040 != (0 | Gb)) {
                        if (!Gb | !(Fb >>> 0 <= Gb + 218103808 >>> 0 && 2139095040 != (0 | Fb))) break b;
                        if (a = Ib = Fb + 218103808 >>> 0 < Gb >>> 0 && (Ib = x2(0), Jb) ? Ib : Ca2(x2(y2(x2(a / Db)))), Eb >>> 0 <= 2) {
                          h: switch (Eb - 1 | 0) {
                            case 0:
                              return x2(-a);
                            case 1:
                              break h;
                            default:
                              break d;
                          }
                          return x2(x2(3.1415927410125732) - x2(a + x2(8742277657347586e-23)));
                        }
                        return x2(x2(a + x2(8742277657347586e-23)) + x2(-3.1415927410125732));
                      }
                      if (2139095040 == (0 | Fb)) break c;
                      return u2[6784 + (Eb << 2) >> 2];
                    }
                    a = x2(3.1415927410125732);
                  }
                  return a;
                }
                return u2[6768 + (Eb << 2) >> 2];
              }
              return x2((0 | Hb) < 0 ? -1.5707963705062866 : 1.5707963705062866);
            }
            function Ca2(a) {
              var Kb, Nb, Ob, Db = 0, Lb = (x2(0), 0), Mb = 0;
              x2(0), x2(0);
              j(a);
              a: {
                if (1283457024 <= (Db = 2147483647 & (Mb = b2[0])) >>> 0) {
                  if (2139095040 < Db >>> 0) break a;
                  return x2((0 | Mb) < 0 ? -1.570796251296997 : 1.570796251296997);
                }
                b: {
                  if (Db >>> 0 <= 1054867455) {
                    if (Lb = -1, 964689920 <= Db >>> 0) break b;
                    break a;
                  }
                  a = x2(y2(a)), Db >>> 0 <= 1066926079 ? Lb = Db >>> 0 <= 1060110335 ? (a = x2(x2(x2(a + a) + x2(-1)) / x2(a + x2(2))), 0) : (a = x2(x2(a + x2(-1)) / x2(a + x2(1))), 1) : Lb = Db >>> 0 <= 1075576831 ? (a = x2(x2(a + x2(-1.5)) / x2(x2(a * x2(1.5)) + x2(1))), 2) : (a = x2(x2(-1) / a), 3);
                }
                if (Db = Lb, Nb = x2(a * a), Kb = x2(Nb * Nb), Ob = x2(Kb * x2(x2(Kb * x2(-0.106480173766613)) + x2(-0.19999158382415771))), Kb = x2(Nb * x2(x2(Kb * x2(x2(Kb * x2(0.06168760731816292)) + x2(0.14253635704517365))) + x2(0.333333283662796))), (0 | Db) <= -1) return x2(a - x2(a * x2(Ob + Kb)));
                a = x2(u2[6736 + (Db <<= 2) >> 2] - x2(x2(x2(a * x2(Ob + Kb)) - u2[6752 + Db >> 2]) - a)), a = (0 | Mb) < 0 ? x2(-a) : a;
              }
              return a;
            }
            function Da(a, Pb) {
              var Ub, Sb, Qb = 0, Rb = 0, Tb = 0;
              return L2 = Sb = L2 - 16 | 0, j(a), (Qb = 2147483647 & (Tb = b2[0])) >>> 0 <= 1305022426 ? (v2[Pb >> 3] = (Ub = +a) + -1.5707963109016418 * (Rb = 0.6366197723675814 * Ub + 6755399441055744 - 6755399441055744) + -15893254773528196e-24 * Rb, Qb = y2(Rb) < 2147483648 ? ~~Rb : -2147483648) : 2139095040 <= Qb >>> 0 ? (v2[Pb >> 3] = x2(a - a), Qb = 0) : (Ub = Qb, v2[8 + Sb >> 3] = (f(0, Ub - ((Qb = (Qb >>> 23) - 150 | 0) << 23) | 0), k()), Qb = function(a2, Il, Jl) {
                var Kl = 0, Ll = 0, Ml = 0, Nl = 0, Ol = 0, Pl = 0, Ql = 0, Rl = 0, Sl = 0, Tl = 0, Ul = 0, Vl = 0, Wl = 0, Xl = 0, Yl = 0, Zl = 0, _l = 0;
                if (L2 = Nl = L2 - 560 | 0, Rl = (Ll = Jl) + w2(Wl = 0 < (0 | (Jl = (Jl + -3 | 0) / 24 | 0)) ? Jl : 0, -24) | 0, 0 <= (0 | (Sl = q2[972]))) {
                  for (Ll = Sl + 1 | 0, Jl = Wl; ; ) if (v2[(320 + Nl | 0) + (Ml << 3) >> 3] = (0 | Jl) < 0 ? 0 : +q2[3904 + (Jl << 2) >> 2], Jl = Jl + 1 | 0, (0 | Ll) == (0 | (Ml = Ml + 1 | 0))) break;
                }
                Pl = Rl + -24 | 0, Ll = 0;
                for (; ; ) {
                  for (Kl = Jl = 0; ; ) if (Kl += v2[(Jl << 3) + a2 >> 3] * v2[(320 + Nl | 0) + (Ll - Jl << 3) >> 3], 1 == (0 | (Jl = Jl + 1 | 0))) break;
                  if (v2[(Ll << 3) + Nl >> 3] = Kl, Jl = (0 | Ll) < (0 | Sl), Ll = Ll + 1 | 0, !Jl) break;
                }
                _l = 23 - Pl | 0, Xl = 24 - Pl | 0, Ll = Sl;
                a: {
                  for (; ; ) {
                    if (Kl = v2[(Ll << 3) + Nl >> 3], !(Ul = ((Jl = 0) | (Ml = Ll)) < 1)) {
                      for (; ; ) if (Ql = (480 + Nl | 0) + (Jl << 2) | 0, Tl = Kl, Ol = y2(Kl *= 5960464477539063e-23) < 2147483648 ? ~~Kl : -2147483648, Ol = y2(Tl += -16777216 * (Kl = 0 | Ol)) < 2147483648 ? ~~Tl : -2147483648, q2[Ql >> 2] = Ol, Kl = v2[((Ml = Ml + -1 | 0) << 3) + Nl >> 3] + Kl, (0 | Ll) == (0 | (Jl = Jl + 1 | 0))) break;
                    }
                    Kl = ja2(Kl, Pl), Kl += -8 * C2(0.125 * Kl), Ql = y2(Kl) < 2147483648 ? ~~Kl : -2147483648, Kl -= 0 | Ql;
                    e: {
                      f: {
                        g: {
                          if (Yl = (0 | Pl) < 1) {
                            if (Pl) break g;
                            Ol = q2[476 + ((Ll << 2) + Nl | 0) >> 2] >> 23;
                          } else Ol = q2[(Ml = (Ll << 2) + Nl | 0) + 476 >> 2], Vl = Ml, Ml = Ol - ((Jl = Ol >> Xl) << Xl) | 0, q2[Vl + 476 >> 2] = Ml, Ql = Jl + Ql | 0, Ol = Ml >> _l;
                          if ((0 | Ol) < 1) break e;
                          break f;
                        }
                        if (Ol = 2, !(0.5 <= Kl)) {
                          Ol = 0;
                          break e;
                        }
                      }
                      if (Ml = Jl = 0, !Ul) for (; ; ) {
                        Ul = q2[(Zl = (480 + Nl | 0) + (Jl << 2) | 0) >> 2], Vl = 16777215;
                        i: {
                          j: {
                            if (!Ml) {
                              if (!Ul) break j;
                              Vl = 16777216, Ml = 1;
                            }
                            q2[Zl >> 2] = Vl - Ul;
                            break i;
                          }
                          Ml = 0;
                        }
                        if ((0 | Ll) == (0 | (Jl = Jl + 1 | 0))) break;
                      }
                      Yl || 1 < (Jl = Pl + -1 | 0) >>> 0 || (q2[(Jl = (Ll << 2) + Nl | 0) + 476 >> 2] = Jl - 1 ? 8388607 & q2[Jl + 476 >> 2] : 4194303 & q2[Jl + 476 >> 2]), Ql = Ql + 1 | 0, 2 == (0 | Ol) && (Kl = 1 - Kl, Ol = 2, Ml) && (Kl -= ja2(1, Pl));
                    }
                    if (0 != Kl) break;
                    if (!(((Ml = 0) | (Jl = Ll)) <= (0 | Sl))) {
                      for (; ; ) if (Ml = q2[(480 + Nl | 0) + ((Jl = Jl + -1 | 0) << 2) >> 2] | Ml, !((0 | Sl) < (0 | Jl))) break;
                      if (Ml) {
                        for (Rl = Pl; ; ) if (Rl = Rl + -24 | 0, q2[(480 + Nl | 0) + ((Ll = Ll + -1 | 0) << 2) >> 2]) break;
                        break a;
                      }
                    }
                    for (Jl = 1; ; ) if (Jl = (Ml = Jl) + 1 | 0, q2[(480 + Nl | 0) + (Sl - Ml << 2) >> 2]) break;
                    for (Ml = Ll + Ml | 0; ; ) {
                      for (Ll = Ql = Ll + 1 | 0, v2[(320 + Nl | 0) + (Ql << 3) >> 3] = q2[3904 + (Wl + Ll << 2) >> 2], Kl = Jl = 0; ; ) if (Kl += v2[(Jl << 3) + a2 >> 3] * v2[(320 + Nl | 0) + (Ql - Jl << 3) >> 3], 1 == (0 | (Jl = Jl + 1 | 0))) break;
                      if (v2[(Ll << 3) + Nl >> 3] = Kl, !((0 | Ll) < (0 | Ml))) break;
                    }
                    Ll = Ml;
                  }
                  16777216 <= (Kl = ja2(Kl, 0 - Pl | 0)) ? (a2 = (480 + Nl | 0) + (Ll << 2) | 0, Tl = Kl, Jl = y2(Kl *= 5960464477539063e-23) < 2147483648 ? ~~Kl : -2147483648, Ml = y2(Kl = Tl + -16777216 * (0 | Jl)) < 2147483648 ? ~~Kl : -2147483648, q2[a2 >> 2] = Ml, Ll = Ll + 1 | 0) : (Jl = y2(Kl) < 2147483648 ? ~~Kl : -2147483648, Rl = Pl), q2[(480 + Nl | 0) + (Ll << 2) >> 2] = Jl;
                }
                Kl = ja2(1, Rl);
                if (!((0 | Ll) <= -1)) {
                  for (Jl = Ll; ; ) if (v2[(Jl << 3) + Nl >> 3] = Kl * +q2[(480 + Nl | 0) + (Jl << 2) >> 2], Kl *= 5960464477539063e-23, a2 = 0 < (0 | Jl), Jl = Jl + -1 | 0, !a2) break;
                  if (!((0 | Ll) <= -1)) for (Jl = Ll; ; ) {
                    for (Pl = Ll - (a2 = Jl) | 0, Jl = Kl = 0; ; ) if (Kl += v2[6672 + (Jl << 3) >> 3] * v2[(a2 + Jl << 3) + Nl >> 3], (0 | Sl) <= (0 | Jl) || (Rl = Jl >>> 0 < Pl >>> 0, Jl = Jl + 1 | 0, !Rl)) break;
                    if (v2[(160 + Nl | 0) + (Pl << 3) >> 3] = Kl, Jl = a2 + -1 | 0, !(0 < (0 | a2))) break;
                  }
                }
                if (0 <= (Ll | (Kl = 0))) {
                  for (; ; ) if (Kl += v2[(160 + Nl | 0) + (Ll << 3) >> 3], a2 = 0 < (0 | Ll), Ll = Ll + -1 | 0, !a2) break;
                }
                return v2[Il >> 3] = Ol ? -Kl : Kl, L2 = 560 + Nl | 0, 7 & Ql;
              }(8 + Sb | 0, Sb, Qb), Rb = v2[Sb >> 3], (0 | Tb) <= -1 ? (v2[Pb >> 3] = -Rb, Qb = 0 - Qb | 0) : v2[Pb >> 3] = Rb), L2 = 16 + Sb | 0, Qb;
            }
            function Ea(a, Pb) {
              return a ? function(a2, Il) {
                a: {
                  if (a2) {
                    if (Il >>> 0 <= 127) break a;
                    if (q2[q2[1789] >> 2]) {
                      if (Il >>> 0 <= 2047) return o[a2 + 1 | 0] = 63 & Il | 128, o[0 | a2] = Il >>> 6 | 192, 2;
                      if (!(57344 != (-8192 & Il) && 55296 <= Il >>> 0)) return o[a2 + 2 | 0] = 63 & Il | 128, o[0 | a2] = Il >>> 12 | 224, o[a2 + 1 | 0] = Il >>> 6 & 63 | 128, 3;
                      if (Il + -65536 >>> 0 <= 1048575) return o[a2 + 3 | 0] = 63 & Il | 128, o[0 | a2] = Il >>> 18 | 240, o[a2 + 2 | 0] = Il >>> 6 & 63 | 128, o[a2 + 1 | 0] = Il >>> 12 & 63 | 128, 4;
                    } else if (57216 == (-128 & Il)) break a;
                    q2[2086] = 25, a2 = -1;
                  } else a2 = 1;
                  return a2;
                }
                return o[0 | a2] = Il, 1;
              }(a, Pb) : 0;
            }
            function Fa(a, Pb, Wb) {
              var fc, gc, Xb = 0, Yb = 0, Zb = 0, _b = 0, $b = 0, ac = 0, bc = 0, cc = 0, dc = 0, ec = r2[a + 4 | 0];
              if (q2[Pb >> 2] = 652, Yb = q2[a + 704 >> 2], 1 <= (0 | (_b = q2[Yb >> 2]))) {
                for ($b = q2[a + 720 >> 2], bc = q2[a + 1072 >> 2]; ; ) if (Zb = (1 << q2[bc + (q2[$b + (Xb << 2) >> 2] << 2) >> 2]) + Zb | 0, (0 | _b) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = Zb << 2;
              }
              if (q2[Pb + 4 >> 2] = w2(_b, 12), q2[Pb + 8 >> 2] = q2[Yb >> 2] << 2, q2[Pb + 12 >> 2] = q2[Yb >> 2] << 2, q2[Pb + 16 >> 2] = q2[Yb >> 2] << 2, q2[Pb + 20 >> 2] = q2[Yb >> 2] << 2, Zb = q2[Yb >> 2], q2[Pb + 28 >> 2] = Xb, q2[Pb + 24 >> 2] = Zb << 2, Zb = q2[Yb >> 2], q2[Pb + 40 >> 2] = Xb, q2[Pb + 36 >> 2] = Xb, q2[Pb + 32 >> 2] = Zb << 2, q2[Pb + 44 >> 2] = q2[Yb + 4 >> 2] << 5, q2[Pb + 48 >> 2] = q2[Yb + 4 >> 2] << 2, q2[Pb + 52 >> 2] = q2[Yb + 4 >> 2] << 2, q2[Pb + 56 >> 2] = q2[Yb + 4 >> 2] << 2, q2[Pb + 60 >> 2] = q2[Yb + 4 >> 2] << 4, q2[Pb + 64 >> 2] = q2[Yb + 4 >> 2] << 4, 1 <= ((Xb = 0) | (_b = q2[Yb + 8 >> 2]))) {
                for ($b = q2[a + 780 >> 2], bc = q2[a + 1072 >> 2], dc = q2[a + 796 >> 2], Zb = 0; ; ) if (ac = (15 + (q2[(cc = Xb << 2) + dc >> 2] << 3) & -16) + ac | 0, Zb = (1 << q2[bc + (q2[$b + cc >> 2] << 2) >> 2]) + Zb | 0, (0 | _b) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = Zb << 2;
              }
              if (q2[Pb + 68 >> 2] = w2(_b, 24), q2[Pb + 72 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 76 >> 2] = q2[Yb + 8 >> 2] << 2, Zb = q2[Yb + 8 >> 2], q2[Pb + 84 >> 2] = ac, q2[Pb + 80 >> 2] = Zb << 2, q2[Pb + 88 >> 2] = q2[Yb + 8 >> 2] << 4, q2[Pb + 92 >> 2] = q2[Yb + 8 >> 2] << 4, Zb = q2[Yb + 8 >> 2], q2[Pb + 100 >> 2] = Xb, q2[Pb + 96 >> 2] = Zb << 2, Zb = q2[Yb + 8 >> 2], q2[Pb + 140 >> 2] = Xb, q2[Pb + 136 >> 2] = Xb, q2[Pb + 132 >> 2] = Xb, q2[Pb + 128 >> 2] = Xb, q2[Pb + 124 >> 2] = Xb, q2[Pb + 120 >> 2] = Xb, q2[Pb + 116 >> 2] = Xb, q2[Pb + 112 >> 2] = Xb, q2[Pb + 108 >> 2] = Xb, q2[Pb + 104 >> 2] = Zb << 2, q2[Pb + 144 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 148 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 152 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 156 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 160 >> 2] = q2[Yb + 8 >> 2] << 2, q2[Pb + 164 >> 2] = q2[Yb + 8 >> 2] << 2, 1 <= ((Xb = ac = 0) | (_b = q2[Yb + 12 >> 2]))) {
                for ($b = q2[a + 812 >> 2], bc = q2[a + 1072 >> 2], Zb = 0; ; ) if (Zb = (1 << q2[bc + (q2[$b + (Xb << 2) >> 2] << 2) >> 2]) + Zb | 0, (0 | _b) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = Zb << 2;
              }
              if (q2[Pb + 168 >> 2] = w2(_b, 12), q2[Pb + 172 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 176 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 180 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 184 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 188 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 192 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 196 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 200 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 204 >> 2] = q2[Yb + 12 >> 2] << 4, q2[Pb + 208 >> 2] = q2[Yb + 12 >> 2] << 4, Zb = q2[Yb + 12 >> 2], q2[Pb + 216 >> 2] = Xb, q2[Pb + 212 >> 2] = Zb << 2, Zb = q2[Yb + 12 >> 2], q2[Pb + 268 >> 2] = Xb, q2[Pb + 264 >> 2] = Xb, q2[Pb + 260 >> 2] = Xb, q2[Pb + 256 >> 2] = Xb, q2[Pb + 252 >> 2] = Xb, q2[Pb + 248 >> 2] = Xb, q2[Pb + 244 >> 2] = Xb, q2[Pb + 240 >> 2] = Xb, q2[Pb + 236 >> 2] = Xb, q2[Pb + 232 >> 2] = Xb, q2[Pb + 228 >> 2] = Xb, q2[Pb + 224 >> 2] = Xb, q2[Pb + 220 >> 2] = Zb << 2, q2[Pb + 272 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 276 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 280 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 284 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 288 >> 2] = q2[Yb + 12 >> 2] << 2, q2[Pb + 292 >> 2] = q2[Yb + 12 >> 2] << 2, 1 <= ((Xb = 0) | (Zb = q2[Yb + 16 >> 2]))) {
                for ($b = q2[a + 852 >> 2], bc = q2[a + 1072 >> 2], dc = q2[a + 892 >> 2], _b = 0; ; ) if (ac = (15 + (q2[(cc = Xb << 2) + dc >> 2] << 3) & -16) + ac | 0, _b = (1 << q2[bc + (q2[$b + cc >> 2] << 2) >> 2]) + _b | 0, (0 | Zb) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = _b << 2;
              }
              if (q2[Pb + 296 >> 2] = w2(Zb, 20), q2[Pb + 300 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 304 >> 2] = q2[Yb + 16 >> 2], q2[Pb + 308 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 312 >> 2] = q2[Yb + 16 >> 2] << 2, Zb = q2[Yb + 16 >> 2], q2[Pb + 320 >> 2] = ac, q2[Pb + 316 >> 2] = Zb << 2, q2[Pb + 324 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 328 >> 2] = q2[Yb + 16 >> 2] << 4, q2[Pb + 332 >> 2] = q2[Yb + 16 >> 2] << 4, q2[Pb + 336 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 340 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 344 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 348 >> 2] = q2[Yb + 16 >> 2] << 4, q2[Pb + 352 >> 2] = q2[Yb + 16 >> 2] << 4, Zb = q2[Yb + 16 >> 2], q2[Pb + 360 >> 2] = Xb, q2[Pb + 356 >> 2] = Zb << 2, Zb = q2[Yb + 16 >> 2], q2[Pb + 404 >> 2] = Xb, q2[Pb + 400 >> 2] = Xb, q2[Pb + 396 >> 2] = Xb, q2[Pb + 392 >> 2] = Xb, q2[Pb + 388 >> 2] = Xb, q2[Pb + 384 >> 2] = Xb, q2[Pb + 380 >> 2] = Xb, q2[Pb + 376 >> 2] = Xb, q2[Pb + 372 >> 2] = Xb, q2[Pb + 368 >> 2] = Xb, q2[Pb + 364 >> 2] = Zb << 2, q2[Pb + 408 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 412 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 416 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 420 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 424 >> 2] = q2[Yb + 16 >> 2] << 2, q2[Pb + 428 >> 2] = q2[Yb + 16 >> 2] << 2, $b = q2[a + 704 >> 2], q2[Pb + 432 >> 2] = w2(q2[$b + 20 >> 2], 52), q2[Pb + 436 >> 2] = ec >>> (Xb = _b = 0) <= 3 ? q2[$b + 20 >> 2] << 2 : 0, q2[Pb + 440 >> 2] = q2[$b + 20 >> 2] << 2, q2[Pb + 444 >> 2] = w2(q2[$b + 52 >> 2], 28), 1 <= (0 | (Yb = q2[$b + 48 >> 2]))) {
                for (Zb = q2[a + 1072 >> 2], ac = 0; ; ) if (ac = (bc = q2[Zb + (Xb << 2) >> 2]) + ac | 0, _b = (1 << bc) + _b | 0, (0 | Yb) == (0 | (Xb = Xb + 1 | 0))) break;
                Xb = _b << 2, _b = ac << 2;
              }
              if (q2[Pb + 460 >> 2] = Xb, q2[Pb + 456 >> 2] = Xb, q2[Pb + 452 >> 2] = _b, q2[Pb + 448 >> 2] = w2(Yb, 36), q2[Pb + 500 >> 2] = w2(q2[$b + 72 >> 2], 28), 1 <= ((ac = Xb = Zb = 0) | (bc = q2[$b + 72 >> 2]))) {
                for (dc = q2[a + 1224 >> 2], cc = q2[a + 1220 >> 2], gc = q2[a + 1212 >> 2], _b = 0; ; ) if (_b = (0 | (fc = q2[(Yb = ac << 2) + cc >> 2] - q2[Yb + dc >> 2] | 0)) < (0 | _b) ? _b : 1 + fc | 0, Xb = (0 | Xb) < (0 | (Yb = q2[Yb + gc >> 2])) ? Yb : Xb, (0 | bc) == (0 | (ac = ac + 1 | 0))) break;
                ac = Xb << 2, Xb = _b << 2;
              }
              if (Yb = q2[$b + 76 >> 2], q2[Pb + 516 >> 2] = Xb, q2[Pb + 512 >> 2] = ac, q2[Pb + 508 >> 2] = Xb, q2[Pb + 504 >> 2] = Yb << 4, 1 <= (0 | (Yb = q2[$b + 80 >> 2]))) {
                for (Zb = q2[a + 1248 >> 2], ac = q2[a + 1072 >> 2], _b = Xb = 0; ; ) if (_b = (1 << q2[ac + (q2[Zb + (Xb << 2) >> 2] << 2) >> 2]) + _b | 0, (0 | Yb) == (0 | (Xb = Xb + 1 | 0))) break;
                Zb = _b << 2;
              }
              if (q2[Pb + 520 >> 2] = w2(Yb, 24), q2[Pb + 524 >> 2] = q2[$b + 80 >> 2] << 2, Yb = q2[$b + 80 >> 2], q2[Pb + 532 >> 2] = Zb, q2[Pb + 528 >> 2] = Yb << 2, Yb = q2[$b + 80 >> 2], q2[Pb + 544 >> 2] = Zb, q2[Pb + 540 >> 2] = Zb, q2[Pb + 536 >> 2] = Yb << 2, Yb = Pb, 4 <= ec >>> 0) {
                if (q2[Pb + 464 >> 2] = w2(q2[$b + 120 >> 2], 20), q2[Pb + 468 >> 2] = w2(q2[$b + 100 >> 2], 28), Zb = Pb, 1 <= ((Xb = ac = 0) | (bc = q2[$b + 104 >> 2]))) {
                  for (a = q2[a + 1104 >> 2], _b = 0; ; ) if (_b = q2[a + (Xb << 2) >> 2] + _b | 0, (0 | bc) == (0 | (Xb = Xb + 1 | 0))) break;
                  a = _b << 2;
                } else a = 0;
                q2[Zb + 476 >> 2] = a, q2[Pb + 472 >> 2] = w2(bc, 48), q2[Pb + 484 >> 2] = w2(q2[$b + 108 >> 2], 12), a = q2[$b + 112 >> 2], q2[Pb + 552 >> 2] = 0, q2[Pb + 492 >> 2] = w2(a, 12), a = 0;
              } else {
                if ((0 | (ac = q2[$b + 20 >> 2])) < 1) _b = 0;
                else for (bc = q2[a + 1060 >> 2], dc = q2[a + 952 >> 2], a = q2[a + 948 >> 2], Zb = _b = 0; ; ) {
                  if (1 <= (0 | (cc = q2[(Xb = Zb << 2) + dc >> 2]))) {
                    for (cc = (Xb = bc + (q2[a + Xb >> 2] << 2) | 0) + (cc << 2) | 0; ; ) if (_b = q2[Xb >> 2] + _b | 0, !((Xb = Xb + 4 | 0) >>> 0 < cc >>> 0)) break;
                  }
                  if ((0 | ac) == (0 | (Zb = Zb + 1 | 0))) break;
                }
                q2[Pb + 552 >> 2] = ac << 2, ac = q2[$b + 20 >> 2] << 2, a = _b << 2;
              }
              for (q2[Yb + 556 >> 2] = a, q2[Pb + 548 >> 2] = ac, 4 < ec >>> 0 && (q2[Pb + 480 >> 2] = w2(q2[$b + 128 >> 2], 12), q2[Pb + 488 >> 2] = w2(q2[$b + 132 >> 2], 12), q2[Pb + 496 >> 2] = w2(q2[$b + 136 >> 2], 12)), Xb = _b = 0; ; ) if (Xb = ((Yb = q2[(a = (_b << 2) + Pb | 0) >> 2]) + 15 & -16) + (q2[a >> 2] = Xb) | 0, 140 == (0 | (_b = _b + 1 | 0))) break;
              q2[Wb >> 2] = Xb;
            }
            function Ga(a, Pb, Wb, hc) {
              a: {
                if (!(20 < Pb >>> 0 || 9 < (Pb = Pb + -9 | 0) >>> 0)) {
                  c: switch (Pb - 1 | 0) {
                    default:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, void (q2[a >> 2] = q2[Pb >> 2]);
                    case 0:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, Pb = q2[Pb >> 2], q2[a >> 2] = Pb, void (q2[a + 4 >> 2] = Pb >> 31);
                    case 1:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, q2[a >> 2] = q2[Pb >> 2], void (q2[a + 4 >> 2] = 0);
                    case 3:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, Pb = p2[Pb >> 1], q2[a >> 2] = Pb, void (q2[a + 4 >> 2] = Pb >> 31);
                    case 4:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, q2[a >> 2] = s[Pb >> 1], void (q2[a + 4 >> 2] = 0);
                    case 5:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, Pb = o[0 | Pb], q2[a >> 2] = Pb, void (q2[a + 4 >> 2] = Pb >> 31);
                    case 6:
                      return Pb = q2[Wb >> 2], q2[Wb >> 2] = Pb + 4, q2[a >> 2] = r2[0 | Pb], void (q2[a + 4 >> 2] = 0);
                    case 2:
                    case 7:
                      break a;
                    case 8:
                      break c;
                  }
                  n2[hc](a, Wb);
                }
                return;
              }
              Pb = q2[Wb >> 2] + 7 & -8, q2[Wb >> 2] = Pb + 8, Wb = q2[Pb + 4 >> 2], q2[a >> 2] = q2[Pb >> 2], q2[a + 4 >> 2] = Wb;
            }
            function Ha(a) {
              var Pb, hc, Wb = 0;
              if (ha2(o[q2[a >> 2]])) {
                for (; ; ) if (Pb = q2[a >> 2], hc = o[0 | Pb], q2[a >> 2] = Pb + 1, Wb = (w2(Wb, 10) + hc | 0) - 48 | 0, !ha2(o[Pb + 1 | 0])) break;
              }
              return Wb;
            }
            function Ia(a, ic, jc, kc, lc) {
              var oc, mc;
              q2[204 + (L2 = mc = L2 - 208 | 0) >> 2] = jc, ca2(160 + mc | (jc = 0), 0, 40), q2[200 + mc >> 2] = q2[204 + mc >> 2], (0 | ra2(0, ic, 200 + mc | 0, 80 + mc | 0, 160 + mc | 0, kc, lc)) < 0 || (jc = 0 <= q2[a + 76 >> 2] ? 1 : jc, jc = q2[a >> 2], o[a + 74 | 0] <= 0 && (q2[a >> 2] = -33 & jc), oc = 32 & jc, q2[a + 48 >> 2] ? ra2(a, ic, 200 + mc | 0, 80 + mc | 0, 160 + mc | 0, kc, lc) : (q2[a + 48 >> 2] = 80, q2[a + 16 >> 2] = 80 + mc, q2[a + 28 >> 2] = mc, q2[a + 20 >> 2] = mc, jc = q2[a + 44 >> 2], ra2(a, ic, 200 + (q2[a + 44 >> 2] = mc) | 0, 80 + mc | 0, 160 + mc | 0, kc, lc), jc && (n2[q2[a + 36 >> 2]](a, 0, 0), q2[a + 48 >> 2] = 0, q2[a + 44 >> 2] = jc, q2[a + 28 >> 2] = 0, q2[a + 16 >> 2] = 0, q2[a + 20 >> 2] = 0)), q2[a >> 2] = q2[a >> 2] | oc), L2 = 208 + mc | 0;
            }
            function Ka(a, ic, pc) {
              var rc, qc;
              $(8 + (L2 = qc = L2 - 160 | 0) | 0, 3192, 144), q2[52 + qc >> 2] = a, q2[28 + qc >> 2] = a, q2[56 + qc >> 2] = rc = (rc = -2 - a | 0) >>> 0 < 256 ? rc : 256, q2[36 + qc >> 2] = a = a + rc | 0, q2[24 + qc >> 2] = a, Ia(8 + qc | 0, ic, pc, 11, 12), rc && (a = q2[28 + qc >> 2], o[a - ((0 | a) == q2[24 + qc >> 2]) | 0] = 0), L2 = 160 + qc | 0;
            }
            function La(a, ic) {
              var sc, tc, pc = 0, pc = 0 != (0 | ic);
              a: {
                b: {
                  c: {
                    d: if (!(!ic | !(3 & a))) for (; ; ) {
                      if (!r2[0 | a]) break c;
                      if (a = a + 1 | 0, pc = 0 != (0 | (ic = ic + -1 | 0)), !ic) break d;
                      if (!(3 & a)) break;
                    }
                    if (!pc) break b;
                  }
                  if (!r2[0 | a]) break a;
                  e: {
                    if (4 <= ic >>> 0) {
                      for (pc = (pc = ic + -4 | 0) - (sc = -4 & pc) | 0, sc = 4 + (a + sc | 0) | 0; ; ) {
                        if ((-1 ^ (tc = q2[a >> 2])) & tc + -16843009 & -2139062144) break e;
                        if (a = a + 4 | 0, !(3 < (ic = ic + -4 | 0) >>> 0)) break;
                      }
                      ic = pc, a = sc;
                    }
                    if (!ic) break b;
                  }
                  for (; ; ) {
                    if (!r2[0 | a]) break a;
                    if (a = a + 1 | 0, !(ic = ic + -1 | 0)) break;
                  }
                }
                return 0;
              }
              return a;
            }
            function Ma(a) {
              var uc, ic = 0;
              if (!a) return 32;
              if (!(1 & a)) {
                for (; ; ) if (ic = ic + 1 | 0, uc = 2 & a, a >>>= 1, uc) break;
              }
              return ic;
            }
            function Na(a, vc) {
              var zc, Ac, Bc, yc, wc = 0, xc = 0, xc = 4;
              L2 = yc = L2 - 256 | 0;
              a: if (!((0 | vc) < 2)) for (wc = q2[(Bc = (vc << 2) + a | 0) >> 2] = yc; ; ) {
                for ($(wc, q2[a >> 2], zc = xc >>> 0 < 256 ? xc : 256), wc = 0; ; ) if ($(q2[(Ac = (wc << 2) + a | 0) >> 2], q2[((wc = wc + 1 | 0) << 2) + a >> 2], zc), q2[Ac >> 2] = q2[Ac >> 2] + zc, (0 | vc) == (0 | wc)) break;
                if (!(xc = xc - zc | 0)) break a;
                wc = q2[Bc >> 2];
              }
              L2 = 256 + yc | 0;
            }
            function Oa(a) {
              var vc;
              return (vc = Ma(q2[a >> 2] + -1 | 0)) || ((a = Ma(q2[a + 4 >> 2])) ? a + 32 | 0 : 0);
            }
            function Sa(a) {
              var Hc;
              q2[(L2 = Hc = L2 - 16 | 0) >> 2] = a, function(a2, Il) {
                var Jl = 0;
                q2[12 + (L2 = Jl = L2 - 16 | 0) >> 2] = Il, Ia(a2, 1432, Il, 0, 0), L2 = 16 + Jl | 0;
              }(q2[970], Hc), L2 = 16 + Hc | 0;
            }
            function Cc(a, Il, Jl, tm) {
              var zm, wm, um = 0, vm = 0, xm = 0, ym = 0;
              return L2 = wm = L2 - 32 | 0, um = (ym = um = 2147483647 & tm) + -1006698496 | 0, vm = um = (zm = vm = xm = Jl) >>> 0 < 0 ? um + 1 | 0 : um, um = ym + -1140785152 | 0, (0 | (um = xm >>> 0 < 0 ? um + 1 | 0 : um)) == (0 | vm) & zm >>> 0 < xm >>> 0 | vm >>> 0 < um >>> 0 ? (um = tm << 4 | Jl >>> 28, Jl = Jl << 4 | Il >>> 28, 134217728 == (0 | (xm = Il &= 268435455)) & 1 <= a >>> 0 | 134217728 < Il >>> 0 ? (um = um + 1073741824 | 0, (a = Jl + 1 | 0) >>> 0 < 1 && (um = um + 1 | 0), vm = a) : (um = um - (((vm = Jl) >>> 0 < 0) + -1073741824 | 0) | 0, a | 134217728 ^ xm || ((a = vm + (1 & vm) | 0) >>> 0 < vm >>> 0 && (um = um + 1 | 0), vm = a))) : (!xm & 2147418112 == (0 | ym) ? !(a | Il) : 2147418112 == (0 | ym) & xm >>> 0 < 0 | ym >>> 0 < 2147418112) ? (um = 2146435072, 1140785151 == ((vm = 0) | ym) & 4294967295 < xm >>> 0 | 1140785151 < ym >>> 0 || (xm = ym >>> 16) >>> (um = 0) < 15249 || (function(a2, Il2, Jl2, tm2, Bm, Cm) {
                var Hm = 0, Im = 0, Jm = 0, Km = 0;
                a: if (64 & Cm) Il2 = 31 & (Jl2 = Cm + -64 | 0), Il2 = 32 <= (63 & Jl2) >>> 0 ? (Jl2 = 0, Bm >>> Il2) : (Jl2 = Bm >>> Il2, ((1 << Il2) - 1 & Bm) << 32 - Il2 | tm2 >>> Il2), Bm = tm2 = 0;
                else {
                  if (!Cm) break a;
                  Im = Bm, Jm = tm2, Hm = 31 & (Km = 64 - Cm | 0), Km = 32 <= (63 & Km) >>> 0 ? (Im = Jm << Hm, 0) : (Im = (1 << Hm) - 1 & Jm >>> 32 - Hm | Im << Hm, Jm << Hm), Jm = Il2, Il2 = 31 & (Hm = Cm), Il2 = 32 <= (63 & Hm) >>> 0 ? (Hm = 0, Jl2 >>> Il2) : (Hm = Jl2 >>> Il2, ((1 << Il2) - 1 & Jl2) << 32 - Il2 | Jm >>> Il2), Il2 |= Km, Jl2 = Hm | Im, Hm = tm2, tm2 = 31 & Cm, tm2 = 32 <= (63 & Cm) >>> 0 ? (Im = 0, Bm >>> tm2) : (Im = Bm >>> tm2, ((1 << tm2) - 1 & Bm) << 32 - tm2 | Hm >>> tm2), Bm = Im;
                }
                q2[a2 >> 2] = Il2, q2[a2 + 4 >> 2] = Jl2, q2[a2 + 8 >> 2] = tm2, q2[a2 + 12 >> 2] = Bm;
              }(wm, a, Il, Jl, um = 65535 & tm | 65536, 15361 - xm | 0), function(a2, Il2, Jl2, tm2, Bm, Cm) {
                var Dm = 0, Em = 0, Fm = 0, Gm = 0;
                64 & Cm ? (tm2 = Il2, Il2 = 31 & (Bm = Cm + -64 | 0), 32 <= (63 & Bm) >>> 0 ? (Bm = tm2 << Il2, tm2 = 0) : (Bm = (1 << Il2) - 1 & tm2 >>> 32 - Il2 | Jl2 << Il2, tm2 <<= Il2), Jl2 = Il2 = 0) : Cm && (Dm = tm2, tm2 = 31 & (Fm = Cm), Gm = 32 <= (63 & Cm) >>> 0 ? (Em = Dm << tm2, 0) : (Em = (1 << tm2) - 1 & Dm >>> 32 - tm2 | Bm << tm2, Dm << tm2), tm2 = Jl2, Dm = Il2, Bm = 31 & (Cm = 64 - Cm | 0), 32 <= (63 & Cm) >>> 0 ? (Cm = 0, tm2 >>>= Bm) : (Cm = tm2 >>> Bm, tm2 = ((1 << Bm) - 1 & tm2) << 32 - Bm | Dm >>> Bm), tm2 |= Gm, Bm = Cm | Em, Cm = Il2, Il2 = 31 & Fm, Il2 = 32 <= (63 & Fm) >>> 0 ? (Em = Cm << Il2, 0) : (Em = (1 << Il2) - 1 & Cm >>> 32 - Il2 | Jl2 << Il2, Cm << Il2), Jl2 = Em);
                q2[a2 >> 2] = Il2, q2[a2 + 4 >> 2] = Jl2, q2[a2 + 8 >> 2] = tm2, q2[a2 + 12 >> 2] = Bm;
              }(16 + wm | 0, a, Il, Jl, um, xm + -15233 | 0), Jl = q2[4 + wm >> 2], a = q2[8 + wm >> 2], um = q2[12 + wm >> 2] << 4 | a >>> 28, vm = a << 4 | Jl >>> 28, 134217728 == (0 | (Jl = a = 268435455 & Jl)) & 1 <= (Il = q2[wm >> 2] | (0 != (q2[16 + wm >> 2] | q2[24 + wm >> 2]) | 0 != (q2[20 + wm >> 2] | q2[28 + wm >> 2]))) >>> 0 | 134217728 < a >>> 0 ? ((a = vm + 1 | 0) >>> 0 < 1 && (um = um + 1 | 0), vm = a) : Il | 134217728 ^ Jl || ((a = vm + (1 & vm) | 0) >>> 0 < vm >>> 0 && (um = um + 1 | 0), vm = a))) : (vm = Jl << 4 | Il >>> 28, um = 524287 & (um = tm << 4 | Jl >>> 28) | 2146959360), L2 = 32 + wm | 0, f(0, 0 | vm), f(1, -2147483648 & tm | um), +g();
            }
            function Zc(a, $o) {
              a = 0 | a, $o = 0 | $o, b2[0] = a, b2[1] = $o;
            }
            function ad(a, $o, ap) {
              return function(a2, $o2, ap2) {
                var ep, cp, bp, dp, fp = w2(cp = ap2 >>> 16, bp = a2 >>> 16);
                return a2 = (65535 & (bp = ((ep = w2(dp = 65535 & ap2, a2 &= 65535)) >>> 16) + w2(bp, dp) | 0)) + w2(a2, cp) | 0, M2 = ((fp + w2($o2, ap2) | 0) + (bp >>> 16) | 0) + (a2 >>> 16) | 0, 65535 & ep | a2 << 16;
              }(a, $o, ap);
            }
            function bd(a, $o, ap) {
              return function(a2, $o2, ap2) {
                var np, gp = 0, hp = 0, ip = 0, jp = 0, kp = 0, lp = 0, mp = 0, op = 0;
                a: {
                  b: {
                    c: {
                      d: {
                        e: {
                          if (!(hp = $o2)) return Zc(($o2 = a2) - w2(a2 = (a2 >>> 0) / (ap2 >>> 0) | 0, ap2) | 0, 0), M2 = 0, a2;
                          if (gp = ap2) {
                            if (!((jp = gp + -1 | 0) & gp)) break e;
                            kp = 0 - (jp = (z2(gp) + 33 | 0) - z2(hp) | 0) | 0;
                            break c;
                          }
                          if (!a2) return Zc(0, hp - w2(a2 = (hp >>> 0) / 0 | 0, 0) | 0), M2 = 0, a2;
                          if ((gp = 32 - z2(hp) | 0) >>> 0 < 31) break d;
                          break b;
                        }
                        if (Zc(a2 & jp, 0), 1 == (0 | gp)) break a;
                        return ap2 = 31 & (gp = gp ? 31 - z2(gp + -1 ^ gp) | 0 : 32), a2 = 32 <= (63 & gp) >>> 0 ? (hp = 0, $o2 >>> ap2) : (hp = $o2 >>> ap2, ((1 << ap2) - 1 & $o2) << 32 - ap2 | a2 >>> ap2), M2 = hp, a2;
                      }
                      jp = gp + 1 | 0, kp = 63 - gp | 0;
                    }
                    if (gp = $o2, ip = 31 & (hp = 63 & jp), ip = 32 <= hp >>> 0 ? (hp = 0, gp >>> ip) : (hp = gp >>> ip, ((1 << ip) - 1 & gp) << 32 - ip | a2 >>> ip), gp = 31 & (kp &= 63), 32 <= kp >>> 0 ? ($o2 = a2 << gp, a2 = 0) : ($o2 = (1 << gp) - 1 & a2 >>> 32 - gp | $o2 << gp, a2 <<= gp), jp) {
                      for ((kp = ap2 + (gp = -1) | 0) >>> 0 < 4294967295 && (gp = 0); ; ) if (ip = (mp = lp = ip << 1 | $o2 >>> 31) - (np = ap2 & (lp = gp - ((hp = hp << 1 | ip >>> 31) + (kp >>> 0 < lp >>> 0) | 0) >> 31)) | 0, hp = hp - (mp >>> 0 < np >>> 0) | 0, $o2 = $o2 << 1 | a2 >>> 31, a2 = op | a2 << 1, op = lp &= 1, !(jp = jp + -1 | 0)) break;
                    }
                    return Zc(ip, hp), M2 = $o2 << 1 | a2 >>> 31, lp | a2 << 1;
                  }
                  Zc(a2, $o2), $o2 = a2 = 0;
                }
                return M2 = $o2, a2;
              }(a, $o, ap);
            }
            function dd(a) {
              var pp;
              return (-1 >>> (pp = 31 & a) & -2) << pp | (-1 << (a = 0 - a & 31) & -2) >>> a;
            }
            function N2() {
              return buffer2.byteLength / 65536 | 0;
            }
          }(H, I, J) };
        }
        l2 = null, b.wasmBinary && (F = b.wasmBinary);
        var WebAssembly = {}, F = [];
        "object" != typeof WebAssembly && E("no native wasm support detected");
        var I, J = new function(a) {
          var c = Array(16);
          return c.grow = function() {
            17 <= c.length && B("Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH."), c.push(null);
          }, c.set = function(a2, e) {
            c[a2] = e;
          }, c.get = function(a2) {
            return c[a2];
          }, c;
        }(), K = false;
        function assert(a, c) {
          a || B("Assertion failed: " + c);
        }
        var buffer, M, L, N, ha = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function ia(a, c, d) {
          var e = c + d;
          for (d = c; a[d] && !(e <= d); ) ++d;
          if (16 < d - c && a.subarray && ha) return ha.decode(a.subarray(c, d));
          for (e = ""; c < d; ) {
            var g, m, f = a[c++];
            128 & f ? (g = 63 & a[c++], 192 == (224 & f) ? e += String.fromCharCode((31 & f) << 6 | g) : (m = 63 & a[c++], (f = 224 == (240 & f) ? (15 & f) << 12 | g << 6 | m : (7 & f) << 18 | g << 12 | m << 6 | 63 & a[c++]) < 65536 ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | 1023 & f)))) : e += String.fromCharCode(f);
          }
          return e;
        }
        function ja(a, c) {
          return a ? ia(L, a, c) : "";
        }
        function ka(a) {
          return 0 < a % 65536 && (a += 65536 - a % 65536), a;
        }
        function la(a) {
          buffer = a, b.HEAP8 = M = new Int8Array(a), b.HEAP16 = new Int16Array(a), b.HEAP32 = N = new Int32Array(a), b.HEAPU8 = L = new Uint8Array(a), b.HEAPU16 = new Uint16Array(a), b.HEAPU32 = new Uint32Array(a), b.HEAPF32 = new Float32Array(a), b.HEAPF64 = new Float64Array(a);
        }
        "undefined" != typeof TextDecoder && new TextDecoder("utf-16le");
        var G = b.TOTAL_MEMORY || 16777216;
        function O(a) {
          for (; 0 < a.length; ) {
            var d, c = a.shift();
            "function" == typeof c ? c() : "number" == typeof (d = c.ea) ? void 0 === c.da ? b.dynCall_v(d) : b.dynCall_vi(d, c.da) : d(void 0 === c.da ? null : c.da);
          }
        }
        (I = b.wasmMemory || new function() {
          return { buffer: new ArrayBuffer(G / 65536 * 65536), grow: function(a) {
            return ca(a);
          } };
        }()) && (buffer = I.buffer), G = buffer.byteLength, la(buffer), N[2216] = 5251936;
        var ra, ma = [], na = [], oa = [], pa = [];
        Math.imul && -5 === Math.imul(4294967295, 5) || (Math.imul = function(a, c) {
          var d = 65535 & a, e = 65535 & c;
          return d * e + ((a >>> 16) * e + d * (c >>> 16) << 16) | 0;
        }), Math.fround || (ra = new Float32Array(1), Math.fround = function(a) {
          return ra[0] = a, ra[0];
        }), Math.clz32 || (Math.clz32 = function(a) {
          var c = 32, d = a >> 16;
          return d && (c -= 16, a = d), (d = a >> 8) && (c -= 8, a = d), (d = a >> 4) && (c -= 4, a = d), (d = a >> 2) && (c -= 2, a = d), a >> 1 ? c - 2 : c - a;
        }), Math.trunc || (Math.trunc = function(a) {
          return a < 0 ? Math.ceil(a) : Math.floor(a);
        });
        var P = 0, Q = null, U = null;
        function B(a) {
          throw b.onAbort && b.onAbort(a), D(a), E(a), K = true, "abort(" + a + "). Build with -s ASSERTIONS=1 for more info.";
        }
        b.preloadedImages = {}, b.preloadedAudios = {};
        var V = "data:application/octet-stream;base64,";
        function W(a) {
          return String.prototype.startsWith ? a.startsWith(V) : 0 === a.indexOf(V);
        }
        var X2 = "_em_module.wasm";
        function ta() {
          try {
            if (F) return new Uint8Array(F);
            var a = z(X2);
            if (a) return a;
            if (w) return w(X2);
            throw "both async and sync fetching of the wasm failed";
          } catch (c) {
            B(c);
          }
        }
        W(X2) || (t2 = X2, X2 = b.locateFile ? b.locateFile(t2, u) : u + t2), na.push({ ea: function() {
          va();
        } });
        var wa = [null, [], []], xa = false;
        function C(a) {
          for (var c = [], d = 0; d < a.length; d++) {
            var e = a[d];
            255 < e && (xa && assert(false, "Character code " + e + " (" + String.fromCharCode(e) + ")  at offset " + d + " not in 0x00-0xFF."), e &= 255), c.push(String.fromCharCode(e));
          }
          return c.join("");
        }
        var ya = "function" == typeof atob ? atob : function(a) {
          var c = "", d = 0;
          a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), m = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++)), e = e << 2 | f >> 4, f = (15 & f) << 4 | g >> 2, h = (3 & g) << 6 | m;
          } while (c += String.fromCharCode(e), 64 !== g && (c += String.fromCharCode(f)), 64 !== m && (c += String.fromCharCode(h)), d < a.length);
          return c;
        };
        function z(a) {
          if (W(a)) {
            if (a = a.slice(V.length), "boolean" == typeof r && r) {
              try {
                var c = Buffer.from(a, "base64");
              } catch (g) {
                c = new Buffer(a, "base64");
              }
              var d = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else try {
              for (var e = ya(a), f = new Uint8Array(e.length), c = 0; c < e.length; ++c) f[c] = e.charCodeAt(c);
              d = f;
            } catch (g) {
              throw Error("Converting base64 string to bytes failed.");
            }
            return d;
          }
        }
        var Y2, H = { a: function(a, c, d) {
          L.set(L.subarray(c, c + d), a);
        }, b: function(a) {
          if (2147418112 < a) return false;
          for (var c = Math.max(M.length, 16777216); c < a; ) c = c <= 536870912 ? ka(2 * c) : Math.min(ka((3 * c + 2147483648) / 4), 2147418112);
          a: {
            try {
              I.grow(c - buffer.byteLength + 65535 >> 16), la(I.buffer);
              var d = 1;
              break a;
            } catch (e) {
            }
            d = void 0;
          }
          return !!d;
        }, c: function(a, c, d, e) {
          try {
            for (var f = 0, g = 0; g < d; g++) {
              for (var m = N[c + 8 * g >> 2], h = N[c + (8 * g + 4) >> 2], A = 0; A < h; A++) {
                var R = L[m + A], S = wa[a];
                0 === R || 10 === R ? ((1 === a ? D : E)(ia(S, 0)), S.length = 0) : S.push(R);
              }
              f += h;
            }
            return N[e >> 2] = f, 0;
          } catch (T) {
            return "undefined" != typeof FS && T instanceof FS.fa || B(T), T.ga;
          }
        }, memory: I, table: J }, u = function() {
          function a(a2) {
            b.asm = a2.exports, P--, b.monitorRunDependencies && b.monitorRunDependencies(P), 0 == P && (null !== Q && (clearInterval(Q), Q = null), U) && (a2 = U, U = null, a2());
          }
          function c(c2) {
            a(c2.instance);
          }
          function d(a2) {
            return (F || !p && !q || "function" != typeof fetch ? new Promise(function(a3) {
              a3(ta());
            }) : fetch(X2, { credentials: "same-origin" }).then(function(a3) {
              if (a3.ok) return a3.arrayBuffer();
              throw "failed to load wasm binary file at '" + X2 + "'";
            }).catch(ta)).then(function() {
              return { then: function(a3) {
                a3({ instance: new da() });
              } };
            }).then(a2, function(a3) {
              E("failed to asynchronously prepare wasm: " + a3), B(a3);
            });
          }
          var e = { env: H, wasi_unstable: H };
          if (P++, b.monitorRunDependencies && b.monitorRunDependencies(P), b.instantiateWasm) try {
            return b.instantiateWasm(e, a);
          } catch (f) {
            return E("Module.instantiateWasm callback failed with error: " + f), false;
          }
          return F || "function" != typeof WebAssembly.instantiateStreaming || W(X2) || "function" != typeof fetch ? d(c) : fetch(X2, { credentials: "same-origin" }).then(function(a2) {
            return WebAssembly.instantiateStreaming(a2, e).then(c, function(a3) {
              E("wasm streaming compile failed: " + a3), E("falling back to ArrayBuffer instantiation"), d(c);
            });
          }), {};
        }(), va = (b.asm = u, b.___wasm_call_ctors = function() {
          return b.asm.d.apply(null, arguments);
        }), Aa = (b._csmGetVersion = function() {
          return b.asm.e.apply(null, arguments);
        }, b._csmGetLatestMocVersion = function() {
          return b.asm.f.apply(null, arguments);
        }, b._csmGetMocVersion = function() {
          return b.asm.g.apply(null, arguments);
        }, b._csmHasMocConsistency = function() {
          return b.asm.h.apply(null, arguments);
        }, b._csmSetLogFunction = function() {
          return b.asm.i.apply(null, arguments);
        }, b._csmReviveMocInPlace = function() {
          return b.asm.j.apply(null, arguments);
        }, b._csmReadCanvasInfo = function() {
          return b.asm.k.apply(null, arguments);
        }, b._csmGetSizeofModel = function() {
          return b.asm.l.apply(null, arguments);
        }, b._csmInitializeModelInPlace = function() {
          return b.asm.m.apply(null, arguments);
        }, b._csmUpdateModel = function() {
          return b.asm.n.apply(null, arguments);
        }, b._csmGetParameterCount = function() {
          return b.asm.o.apply(null, arguments);
        }, b._csmGetParameterIds = function() {
          return b.asm.p.apply(null, arguments);
        }, b._csmGetParameterTypes = function() {
          return b.asm.q.apply(null, arguments);
        }, b._csmGetParameterMinimumValues = function() {
          return b.asm.r.apply(null, arguments);
        }, b._csmGetParameterMaximumValues = function() {
          return b.asm.s.apply(null, arguments);
        }, b._csmGetParameterDefaultValues = function() {
          return b.asm.t.apply(null, arguments);
        }, b._csmGetParameterValues = function() {
          return b.asm.u.apply(null, arguments);
        }, b._csmGetPartCount = function() {
          return b.asm.v.apply(null, arguments);
        }, b._csmGetPartIds = function() {
          return b.asm.w.apply(null, arguments);
        }, b._csmGetPartOpacities = function() {
          return b.asm.x.apply(null, arguments);
        }, b._csmGetPartParentPartIndices = function() {
          return b.asm.y.apply(null, arguments);
        }, b._csmGetDrawableCount = function() {
          return b.asm.z.apply(null, arguments);
        }, b._csmGetDrawableIds = function() {
          return b.asm.A.apply(null, arguments);
        }, b._csmGetDrawableConstantFlags = function() {
          return b.asm.B.apply(null, arguments);
        }, b._csmGetDrawableDynamicFlags = function() {
          return b.asm.C.apply(null, arguments);
        }, b._csmGetDrawableTextureIndices = function() {
          return b.asm.D.apply(null, arguments);
        }, b._csmGetDrawableDrawOrders = function() {
          return b.asm.E.apply(null, arguments);
        }, b._csmGetDrawableRenderOrders = function() {
          return b.asm.F.apply(null, arguments);
        }, b._csmGetDrawableOpacities = function() {
          return b.asm.G.apply(null, arguments);
        }, b._csmGetDrawableMaskCounts = function() {
          return b.asm.H.apply(null, arguments);
        }, b._csmGetDrawableMasks = function() {
          return b.asm.I.apply(null, arguments);
        }, b._csmGetDrawableVertexCounts = function() {
          return b.asm.J.apply(null, arguments);
        }, b._csmGetDrawableVertexPositions = function() {
          return b.asm.K.apply(null, arguments);
        }, b._csmGetDrawableVertexUvs = function() {
          return b.asm.L.apply(null, arguments);
        }, b._csmGetDrawableIndexCounts = function() {
          return b.asm.M.apply(null, arguments);
        }, b._csmGetDrawableIndices = function() {
          return b.asm.N.apply(null, arguments);
        }, b._csmGetDrawableMultiplyColors = function() {
          return b.asm.O.apply(null, arguments);
        }, b._csmGetDrawableScreenColors = function() {
          return b.asm.P.apply(null, arguments);
        }, b._csmGetDrawableParentPartIndices = function() {
          return b.asm.Q.apply(null, arguments);
        }, b._csmResetDrawableDynamicFlags = function() {
          return b.asm.R.apply(null, arguments);
        }, b._csmGetParameterKeyCounts = function() {
          return b.asm.S.apply(null, arguments);
        }, b._csmGetParameterKeyValues = function() {
          return b.asm.T.apply(null, arguments);
        }, b._csmMallocMoc = function() {
          return b.asm.U.apply(null, arguments);
        }, b._csmMallocModelAndInitialize = function() {
          return b.asm.V.apply(null, arguments);
        }, b._csmMalloc = function() {
          return b.asm.W.apply(null, arguments);
        }, b._csmFree = function() {
          return b.asm.X.apply(null, arguments);
        }, b._csmInitializeAmountOfMemory = function() {
          return b.asm.Y.apply(null, arguments);
        }, b.stackSave = function() {
          return b.asm.Z.apply(null, arguments);
        }), Ba = b.stackAlloc = function() {
          return b.asm._.apply(null, arguments);
        }, Ca = b.stackRestore = function() {
          return b.asm.$.apply(null, arguments);
        }, ca = b.__growWasmMemory = function() {
          return b.asm.aa.apply(null, arguments);
        };
        function Z() {
          function a() {
            if (!Y2 && (Y2 = true, !K)) {
              if (O(na), O(oa), b.onRuntimeInitialized && b.onRuntimeInitialized(), b.postRun) for ("function" == typeof b.postRun && (b.postRun = [b.postRun]); b.postRun.length; ) {
                var a2 = b.postRun.shift();
                pa.unshift(a2);
              }
              O(pa);
            }
          }
          if (!(0 < P)) {
            if (b.preRun) for ("function" == typeof b.preRun && (b.preRun = [b.preRun]); b.preRun.length; ) !function() {
              var a2 = b.preRun.shift();
              ma.unshift(a2);
            }();
            O(ma), 0 < P || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                b.setStatus("");
              }, 1), a();
            }, 1)) : a());
          }
        }
        if (b.dynCall_vi = function() {
          return b.asm.ba.apply(null, arguments);
        }, b.asm = u, b.ccall = function(a, c, d, e) {
          var f = { string: function(a2) {
            var c2 = 0;
            if (null != a2 && 0 !== a2) {
              var d2 = 1 + (a2.length << 2), e2 = c2 = Ba(d2), f2 = L;
              if (0 < d2) {
                for (var d2 = e2 + d2 - 1, g2 = 0; g2 < a2.length; ++g2) {
                  var k = a2.charCodeAt(g2);
                  if ((k = 55296 <= k && k <= 57343 ? 65536 + ((1023 & k) << 10) | 1023 & a2.charCodeAt(++g2) : k) <= 127) {
                    if (d2 <= e2) break;
                    f2[e2++] = k;
                  } else {
                    if (k <= 2047) {
                      if (d2 <= e2 + 1) break;
                      f2[e2++] = 192 | k >> 6;
                    } else {
                      if (k <= 65535) {
                        if (d2 <= e2 + 2) break;
                        f2[e2++] = 224 | k >> 12;
                      } else {
                        if (d2 <= e2 + 3) break;
                        f2[e2++] = 240 | k >> 18, f2[e2++] = 128 | k >> 12 & 63;
                      }
                      f2[e2++] = 128 | k >> 6 & 63;
                    }
                    f2[e2++] = 128 | 63 & k;
                  }
                }
                f2[e2] = 0;
              }
            }
            return c2;
          }, array: function(a2) {
            var c2 = Ba(a2.length);
            return M.set(a2, c2), c2;
          } }, g = function(a2) {
            var c2 = b["_" + a2];
            return assert(c2, "Cannot call unknown function " + a2 + ", make sure it is exported"), c2;
          }(a), m = [];
          if (a = 0, e) for (var h = 0; h < e.length; h++) {
            var A = f[d[h]];
            A ? (0 === a && (a = Aa()), m[h] = A(e[h])) : m[h] = e[h];
          }
          return d = function(a2) {
            return "string" === c ? ja(a2) : "boolean" === c ? !!a2 : a2;
          }(d = g.apply(null, m)), 0 !== a && Ca(a), d;
        }, b.UTF8ToString = ja, b.addFunction = function(a, c) {
          var d = J.length;
          try {
            J.grow(1);
          } catch (e) {
            if (!e instanceof RangeError) throw e;
            throw "Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.";
          }
          try {
            J.set(d, a);
          } catch (e) {
            if (!e instanceof TypeError) throw e;
            assert(void 0 !== c, "Missing signature argument to addFunction"), J.set(d, a);
          }
          return d;
        }, b.then = function(a) {
          var c;
          return Y2 ? a(b) : (c = b.onRuntimeInitialized, b.onRuntimeInitialized = function() {
            c && c(), a(b);
          }), b;
        }, U = function Da() {
          Y2 || Z(), Y2 || (U = Da);
        }, b.run = Z, b.preInit) for ("function" == typeof b.preInit && (b.preInit = [b.preInit]); 0 < b.preInit.length; ) b.preInit.pop()();
        return Z(), _em_module2;
      };
    }();
    "object" == typeof exports && "object" == typeof module ? module.exports = _em_module : "function" == typeof define && define.amd ? define([], function() {
      return _em_module;
    }) : "object" == typeof exports && (exports._em_module = _em_module);
    var _em = _em_module();
  })(Live2DCubismCore2 || (Live2DCubismCore2 = {}));
  if (typeof globalThis !== "undefined") {
    globalThis.Live2DCubismCore = Live2DCubismCore2;
  } else if (typeof window !== "undefined") {
    window.Live2DCubismCore = Live2DCubismCore2;
  }

  // prebuild.js
  var Browser = {
    isDomPresent: true,
    navigator,
    window,
    document,
    ajax: function(url) {
      const xhr = new XMLHttpRequest();
      xhr.open("GET", url, false);
      if (xhr.overrideMimeType) {
        xhr.overrideMimeType("text/plain");
      }
      xhr.setRequestHeader("If-Modified-Since", "Fri, 01 Jan 1960 00:00:00 GMT");
      xhr.send(null);
      if (xhr.status !== 200 && xhr.status !== 0) {
        throw new Error("XMLHttpRequest failed, status code " + xhr.status);
      }
      return xhr.responseText;
    }
  };
  window.Processing = src_default(Browser);
})();
